CAN-include\can_interface.h

|Node:ERROR Text: #pragma once

#include <stdint.h>

#include <algorithm>
#include <array>
#include <chrono>
#include <functional>
#include <vector>

#include "virtualTimer.h"

#ifdef ARDUINO
#include <Arduino.h>
#endif

class CANMessage
{
public:
    CANMessage(uint16_t id, uint8_t len, std::array<uint8_t, 8> data) : id_{id}, len_{len}, data_{data} {}

    uint16_t id_;
    uint8_t len_;
    std::array<uint8_t, 8> data_;
};

class ICANSignal
{
public:
    enum class ByteOrder
    {
        kBigEndian,
        kLittleEndian
    };
    virtual void EncodeSignal(uint64_t *buffer) = 0;
    virtual void DecodeSignal(uint64_t *buffer) = 0;
};

template <class T>
constexpr typename std::enable_if<std::is_unsigned<T>::value, T>::type bswap(T i, T j = 0u, std::size_t n = 0u)
{
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1);
}

constexpr uint8_t CANSignal_generate_position(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
{
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
               ? position
               : position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */);
    /*
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            return position;
        }
        else
        {
            uint8_t bits_in_last_byte{8 - (position % 8)};
            if (length - bits_in_last_byte < 0)
            {
                return position;
            }
            else
            {
                uint8_t full_bytes = (length - bits_in_last_byte) / 8;
                uint8_t remaining_bits = (length - bits_in_last_byte) % 8;
                position -=
                    (8 * (remaining_bits == 0 ? full_bytes : full_bytes + 1)) + (8 - remaining_bits) -
       bits_in_last_byte;
            }

            return position;
        } */
}

// Generates a mask of which bits in the message correspond to a specific signal
constexpr uint64_t CANSignal_generate_mask(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
{
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian)
               ? (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
               : (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))));
}

template <typename SignalType>
class ITypedCANSignal : public ICANSignal
{
public:
    SignalType &value_ref() { return signal_; }

    void operator=(const SignalType &signal) { signal_ = signal; }

    operator SignalType() const { return signal_; }

protected:
    SignalType signal_;
};

// Needed so compiler knows these template classes exist
template class ITypedCANSignal<uint8_t>;
template class ITypedCANSignal<uint16_t>;
template class ITypedCANSignal<uint32_t>;
template class ITypedCANSignal<int8_t>;
template class ITypedCANSignal<int16_t>;
template class ITypedCANSignal<int32_t>;
template class ITypedCANSignal<float>;

static constexpr int kCANTemplateFloatDenominator{1 << 16};  // 2^16
constexpr int CANTemplateConvertFloat(float value) { return value * kCANTemplateFloatDenominator; }
constexpr float CANTemplateGetFloat(int value) { return static_cast<float>(value) / kCANTemplateFloatDenominator; }

template <bool signed_raw>
struct GetCANRawType;

template <>
struct GetCANRawType<true>
{
    using type = int64_t;
};

template <>
struct GetCANRawType<false>
{
    using type = uint64_t;
};

/**
 * @brief A class for decoding and encoding CAN signals. Note: only works with little endian signals on a little endian
 * architecture, and you must manually ensure consistency with the DBC
 *
 * @tparam SignalType The type of variable in the application to be encoded/decoded
 * @tparam position The position of the first bit of the signal in the message
 * @tparam length The length of the signal in the message
 * @tparam factor The factor to multiply the raw signal by (gotten using CANTemplateConvertFloat(float value))
 * @tparam offset The offset added to the raw signal (gotten using CANTemplateConvertFloat(float value))
 * @tparam signed_raw Whether or not the signal is signed
 * @tparam byte_order The order of bytes in the signal (big endian or little endian). Do not change this from the
 * default (little endian) if you aren't sure you need to.
 * @tparam mask This is calculated for you by default
 * @tparam unity_factor This is calculated for you by default
 */
template <typename SignalType,
          uint8_t input_position,
          uint8_t length,
          int factor,
          int offset,
          bool signed_raw = false,
          ICANSignal::ByteOrder byte_order = ICANSignal::ByteOrder::kLittleEndian,
          uint8_t position = CANSignal_generate_position(input_position, length, byte_order),
          uint64_t mask = CANSignal_generate_mask(position, length, byte_order),
          bool unity_factor = factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type;

public:
    CANSignal()
    {
        static_assert(factor != 0, "The integer representation of the factor for a CAN signal must not be 0");
    }

    void EncodeSignal(uint64_t *buffer) override { InternalEncodeSignal(buffer); }

    template <bool unity_factor_ = unity_factor, typename std::enable_if<unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
    {
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            *buffer |= (static_cast<underlying_type>(this->signal_) << position) & mask;
        }
        else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }

    template <bool unity_factor_ = unity_factor, typename std::enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
    {
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            *buffer |= (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask;
        }
        else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }

    void DecodeSignal(uint64_t *buffer) override { InternalDecodeSignal(buffer); }

    template <bool unity_factor_ = unity_factor, typename std::enable_if<unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
    {
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length));
        }
        else
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length));
        }
    }

    template <bool unity_factor_ = unity_factor, typename std::enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
    {
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
        else
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
    }

    void operator=(const SignalType &signal) { ITypedCANSignal<SignalType>::operator=(signal); }
};

// Macros for making signed and unsigned CAN signals, default little-endian
#define MakeEndianUnsignedCANSignal(SignalType, position, length, factor, offset, byte_order) \
    CANSignal<SignalType,                                                                     \
              position,                                                                       \
              length,                                                                         \
              CANTemplateConvertFloat(factor),                                                \
              CANTemplateConvertFloat(offset),                                                \
              false,                                                                          \
              byte_order>
#define MakeEndianSignedCANSignal(SignalType, position, length, factor, offset, byte_order) \
    CANSignal<SignalType,                                                                   \
              position,                                                                     \
              length,                                                                       \
              CANTemplateConvertFloat(factor),                                              \
              CANTemplateConvertFloat(offset),                                              \
              true,                                                                         \
              byte_order>
#define MakeUnsignedCANSignal(SignalType, position, length, factor, offset) \
    MakeEndianUnsignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)
#define MakeSignedCANSignal(SignalType, position, length, factor, offset) \
    MakeEndianSignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)

class ICANTXMessage
{
public:
    virtual uint16_t GetID() = 0;
    virtual VirtualTimer &GetTransmitTimer() = 0;
    virtual void EncodeSignals() = 0;
    virtual void EncodeAndSend() = 0;
};

class ICANRXMessage
{
public:
    virtual uint16_t GetID() = 0;
    virtual void DecodeSignals(CANMessage message) = 0;
};

class ICAN
{
public:
    enum class BaudRate
    {
        kBaud1M = 1000000,
        kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
    };

    virtual void Initialize(BaudRate baud);

    virtual bool SendMessage(CANMessage &msg) = 0;

    virtual void RegisterRXMessage(ICANRXMessage &msg) = 0;

    virtual void Tick() = 0;
};

/**
 * @brief A class for storing signals in a message that sends every period
 */
template <size_t num_signals>
class CANTXMessage : public ICANTXMessage
{
public:
    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_{id, length, std::array<uint8_t, 8>()},
          transmit_timer_{period, [this]() { this->EncodeAndSend(); }, VirtualTimer::Type::kRepeating},
          signals_{&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }

    void EncodeAndSend() override
    {
        EncodeSignals();
        can_interface_.SendMessage(message_);
    }

    uint16_t GetID() { return message_.id_; }

    VirtualTimer &GetTransmitTimer() { return transmit_timer_; }

    void Enable() { transmit_timer_.Enable(); }
    void Disable() { transmit_timer_.Disable(); }

private:
    ICAN &can_interface_;
    CANMessage message_;
    VirtualTimer transmit_timer_;
    std::array<ICANSignal *, num_signals> signals_;

    void EncodeSignals()
    {
        uint8_t temp_raw[8]{0};
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
        std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
    }
};

/**
 * @brief A class for storing signals that get updated every time a matching message is received
 */
template <size_t num_signals>
class CANRXMessage : public ICANRXMessage
{
public:
    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : can_interface_{can_interface},
          id_{id},
          get_millis_{get_millis},
          callback_function_{callback_function},
          signals_{&signal_1, &signals...}
    {
        static_assert(sizeof...(signals) == num_signals - 1, "Wrong number of signals passed into CANRXMessage.");
        can_interface_.RegisterRXMessage(*this);
    }

    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, get_millis, nullptr, signal_1, signals...}
    {
    }

// If compiling for Arduino, automatically uses millis() instead of requiring a std::function<uint32_t(void)> to get the
// current time
#ifdef ARDUINO
    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, callback_function, signal_1, signals...}
    {
    }

    template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, nullptr, signal_1, signals...}
    {
    }
#endif

    uint16_t GetID() { return id_; }

    void DecodeSignals(CANMessage message)
    {
        uint64_t temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data());
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->DecodeSignal(&temp_raw);
        }

        // DecodeSignals is called only on message received
        if (callback_function_)
        {
            callback_function_();
        }

        last_receive_time_ = get_millis_();
    }

    uint32_t GetLastReceiveTime() { return last_receive_time_; }
    uint32_t GetTimeSinceLastReceive() { return get_millis_() - last_receive_time_; }

private:
    ICAN &can_interface_;
    uint16_t id_;
    // A function to get the current time in millis on the current platform
    std::function<uint32_t(void)> get_millis_;

    // The callback function should be a very short function that will get called every time a new message is received.
    std::function<void(void)> callback_function_;

    std::array<ICANSignal *, num_signals> signals_;

    uint64_t raw_message;

    uint32_t last_receive_time_ = 0;
};
|—Node:preproc_call Text: #pragma once

|——Node:preproc_directive Text: #pragma
|——Node:preproc_arg Text: once
|—Node:preproc_include Text: #include <stdint.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <stdint.h>
|—Node:preproc_include Text: #include <algorithm>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <algorithm>
|—Node:preproc_include Text: #include <array>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <array>
|—Node:preproc_include Text: #include <chrono>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <chrono>
|—Node:preproc_include Text: #include <functional>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <functional>
|—Node:preproc_include Text: #include <vector>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <vector>
|—Node:preproc_include Text: #include "virtualTimer.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "virtualTimer.h"
|———Node:" Text: "
|———Node:string_content Text: virtualTimer.h
|———Node:" Text: "
|—Node:preproc_ifdef Text: #ifdef ARDUINO
#include <Arduino.h>
#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: ARDUINO
|——Node:preproc_include Text: #include <Arduino.h>

|———Node:#include Text: #include
|———Node:system_lib_string Text: <Arduino.h>
|——Node:#endif Text: #endif
|—Node:function_definition Text: class CANMessage
{
public:
    CANMessage(uint16_t id, uint8_t len, std::array<uint8_t, 8> data) : id_{id}, len_{len}, data_{data} {}

    uint16_t id_;
    uint8_t len_;
    std::array<uint8_t, 8> data_;
}
|——Node:type_identifier Text: class
|——Node:identifier Text: CANMessage
|——Node:compound_statement Text: {
public:
    CANMessage(uint16_t id, uint8_t len, std::array<uint8_t, 8> data) : id_{id}, len_{len}, data_{data} {}

    uint16_t id_;
    uint8_t len_;
    std::array<uint8_t, 8> data_;
}
|———Node:{ Text: {
|———Node:labeled_statement Text: public:
    CANMessage(uint16_t id, uint8_t len, std::array<uint8_t, 8> data) : id_{id}, len_{len}, data_{data} {}

    uint16_t id_;
|————Node:statement_identifier Text: public
|————Node:: Text: :
|————Node:declaration Text: CANMessage(uint16_t id, uint8_t len, std::array<uint8_t, 8> data) : id_{id}, len_{len}, data_{data} {}

    uint16_t id_;
|—————Node:macro_type_specifier Text: CANMessage(uint16_t
|——————Node:identifier Text: CANMessage
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: 
|—————Node:identifier Text: id
|—————Node:, Text: ,
|—————Node:identifier Text: uint8_t
|—————Node:ERROR Text: len
|——————Node:identifier Text: len
|—————Node:, Text: ,
|—————Node:ERROR Text: std::
|——————Node:identifier Text: std
|——————Node:: Text: :
|——————Node:: Text: :
|—————Node:identifier Text: array
|—————Node:ERROR Text: <uint8_t
|——————Node:< Text: <
|——————Node:primitive_type Text: uint8_t
|—————Node:, Text: ,
|—————Node:ERROR Text: 8> data) : id_{
|——————Node:number_literal Text: 8
|——————Node:> Text: >
|——————Node:identifier Text: data
|——————Node:) Text: )
|——————Node:: Text: :
|——————Node:identifier Text: id_
|——————Node:{ Text: {
|—————Node:identifier Text: id
|—————Node:ERROR Text: }, len_{len}
|——————Node:} Text: }
|——————Node:, Text: ,
|——————Node:identifier Text: len_
|——————Node:{ Text: {
|——————Node:identifier Text: len
|——————Node:} Text: }
|—————Node:, Text: ,
|—————Node:ERROR Text: data_{data} {}

    uint16_t
|——————Node:identifier Text: data_
|——————Node:{ Text: {
|——————Node:identifier Text: data
|——————Node:} Text: }
|——————Node:{ Text: {
|——————Node:} Text: }
|——————Node:primitive_type Text: uint16_t
|—————Node:identifier Text: id_
|—————Node:; Text: ;
|———Node:declaration Text: uint8_t len_;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: len_
|————Node:; Text: ;
|———Node:labeled_statement Text: std::array<uint8_t, 8> data_;
|————Node:statement_identifier Text: std
|————Node:: Text: :
|————Node:ERROR Text: :
|—————Node:: Text: :
|————Node:expression_statement Text: array<uint8_t, 8> data_;
|—————Node:comma_expression Text: array<uint8_t, 8> data_
|——————Node:binary_expression Text: array<uint8_t
|———————Node:identifier Text: array
|———————Node:< Text: <
|———————Node:identifier Text: uint8_t
|——————Node:, Text: ,
|——————Node:binary_expression Text: 8> data_
|———————Node:number_literal Text: 8
|———————Node:> Text: >
|———————Node:identifier Text: data_
|—————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:function_definition Text: class ICANSignal
{
public:
    enum class ByteOrder
    {
        kBigEndian,
        kLittleEndian
    };
    virtual void EncodeSignal(uint64_t *buffer) = 0;
    virtual void DecodeSignal(uint64_t *buffer) = 0;
};

template <class T>
constexpr typename std::enable_if<std::is_unsigned<T>::value, T>::type bswap(T i, T j = 0u, std::size_t n = 0u)
{
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1);
}
|——Node:type_identifier Text: class
|——Node:identifier Text: ICANSignal
|——Node:compound_statement Text: {
public:
    enum class ByteOrder
    {
        kBigEndian,
        kLittleEndian
    };
    virtual void EncodeSignal(uint64_t *buffer) = 0;
    virtual void DecodeSignal(uint64_t *buffer) = 0;
};

template <class T>
constexpr typename std::enable_if<std::is_unsigned<T>::value, T>::type bswap(T i, T j = 0u, std::size_t n = 0u)
{
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1);
}
|———Node:{ Text: {
|———Node:labeled_statement Text: public:
    enum class ByteOrder
    {
        kBigEndian,
        kLittleEndian
    };
    virtual void EncodeSignal(uint64_t *buffer) = 0;
    virtual void DecodeSignal(uint64_t *buffer) = 0;
}
|————Node:statement_identifier Text: public
|————Node:: Text: :
|————Node:ERROR Text: enum class ByteOrder
|—————Node:enum_specifier Text: enum class
|——————Node:enum Text: enum
|——————Node:type_identifier Text: class
|—————Node:identifier Text: ByteOrder
|————Node:compound_statement Text: {
        kBigEndian,
        kLittleEndian
    };
    virtual void EncodeSignal(uint64_t *buffer) = 0;
    virtual void DecodeSignal(uint64_t *buffer) = 0;
}
|—————Node:{ Text: {
|—————Node:expression_statement Text: kBigEndian,
        kLittleEndian
    };
|——————Node:comma_expression Text: kBigEndian,
        kLittleEndian
|———————Node:identifier Text: kBigEndian
|———————Node:, Text: ,
|———————Node:identifier Text: kLittleEndian
|——————Node:ERROR Text: }
|———————Node:} Text: }
|——————Node:; Text: ;
|—————Node:declaration Text: virtual void EncodeSignal(uint64_t *buffer) = 0;
|——————Node:type_identifier Text: virtual
|——————Node:ERROR Text: void
|———————Node:identifier Text: void
|——————Node:init_declarator Text: EncodeSignal(uint64_t *buffer) = 0
|———————Node:function_declarator Text: EncodeSignal(uint64_t *buffer)
|————————Node:identifier Text: EncodeSignal
|————————Node:parameter_list Text: (uint64_t *buffer)
|—————————Node:( Text: (
|—————————Node:parameter_declaration Text: uint64_t *buffer
|——————————Node:primitive_type Text: uint64_t
|——————————Node:pointer_declarator Text: *buffer
|———————————Node:* Text: *
|———————————Node:identifier Text: buffer
|—————————Node:) Text: )
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:declaration Text: virtual void DecodeSignal(uint64_t *buffer) = 0;
|——————Node:type_identifier Text: virtual
|——————Node:ERROR Text: void
|———————Node:identifier Text: void
|——————Node:init_declarator Text: DecodeSignal(uint64_t *buffer) = 0
|———————Node:function_declarator Text: DecodeSignal(uint64_t *buffer)
|————————Node:identifier Text: DecodeSignal
|————————Node:parameter_list Text: (uint64_t *buffer)
|—————————Node:( Text: (
|—————————Node:parameter_declaration Text: uint64_t *buffer
|——————————Node:primitive_type Text: uint64_t
|——————————Node:pointer_declarator Text: *buffer
|———————————Node:* Text: *
|———————————Node:identifier Text: buffer
|—————————Node:) Text: )
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ;
|————Node:; Text: ;
|———Node:expression_statement Text: template <class T>
constexpr
|————Node:binary_expression Text: template <class T>
constexpr
|—————Node:binary_expression Text: template <class
|——————Node:identifier Text: template
|——————Node:< Text: <
|——————Node:identifier Text: class
|—————Node:ERROR Text: T
|——————Node:identifier Text: T
|—————Node:> Text: >
|—————Node:identifier Text: constexpr
|————Node:; Text: 
|———Node:declaration Text: typename std::enable_if<std::is_unsigned<T>::value, T>::type bswap(T i, T j = 0u, std::size_t n = 0u)
{
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1);
|————Node:type_identifier Text: typename
|————Node:ERROR Text: std::enable_if<std::is_unsigned<T>::
|—————Node:identifier Text: std
|—————Node:: Text: :
|—————Node:: Text: :
|—————Node:identifier Text: enable_if
|—————Node:< Text: <
|—————Node:identifier Text: std
|—————Node:: Text: :
|—————Node:: Text: :
|—————Node:identifier Text: is_unsigned
|—————Node:< Text: <
|—————Node:identifier Text: T
|—————Node:> Text: >
|—————Node:: Text: :
|—————Node:: Text: :
|————Node:identifier Text: value
|————Node:, Text: ,
|————Node:ERROR Text: T>::type
|—————Node:identifier Text: T
|—————Node:> Text: >
|—————Node:: Text: :
|—————Node:: Text: :
|—————Node:identifier Text: type
|————Node:init_declarator Text: bswap(T i, T j = 0u
|—————Node:function_declarator Text: bswap(T i, T j
|——————Node:identifier Text: bswap
|——————Node:parameter_list Text: (T i, T j
|———————Node:( Text: (
|———————Node:parameter_declaration Text: T i
|————————Node:type_identifier Text: T
|————————Node:identifier Text: i
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: T j
|————————Node:type_identifier Text: T
|————————Node:identifier Text: j
|———————Node:) Text: 
|—————Node:= Text: =
|—————Node:number_literal Text: 0u
|————Node:, Text: ,
|————Node:init_declarator Text: std::size_t n = 0u)
{
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1)
|—————Node:identifier Text: std
|—————Node:ERROR Text: ::size_t n
|——————Node:: Text: :
|——————Node:: Text: :
|——————Node:primitive_type Text: size_t
|——————Node:identifier Text: n
|—————Node:= Text: =
|—————Node:ERROR Text: 0u)
|——————Node:number_literal Text: 0u
|——————Node:) Text: )
|—————Node:initializer_list Text: {
    return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1)
|——————Node:{ Text: {
|——————Node:conditional_expression Text: return n == sizeof(T) ? j : bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1)
|———————Node:binary_expression Text: return n == sizeof(T)
|————————Node:identifier Text: return
|————————Node:ERROR Text: n
|—————————Node:identifier Text: n
|————————Node:== Text: ==
|————————Node:sizeof_expression Text: sizeof(T)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (T)
|——————————Node:( Text: (
|——————————Node:identifier Text: T
|——————————Node:) Text: )
|———————Node:? Text: ?
|———————Node:identifier Text: j
|———————Node:: Text: :
|———————Node:binary_expression Text: bswap<T>(i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1)
|————————Node:binary_expression Text: bswap<T
|—————————Node:identifier Text: bswap
|—————————Node:< Text: <
|—————————Node:identifier Text: T
|————————Node:> Text: >
|————————Node:parenthesized_expression Text: (i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1)
|—————————Node:( Text: (
|—————————Node:comma_expression Text: i >> 8, (j << 8) | (i & (T)(unsigned char)(-1)), n + 1
|——————————Node:binary_expression Text: i >> 8
|———————————Node:identifier Text: i
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 8
|——————————Node:, Text: ,
|——————————Node:comma_expression Text: (j << 8) | (i & (T)(unsigned char)(-1)), n + 1
|———————————Node:binary_expression Text: (j << 8) | (i & (T)(unsigned char)(-1))
|————————————Node:parenthesized_expression Text: (j << 8)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: j << 8
|——————————————Node:identifier Text: j
|——————————————Node:<< Text: <<
|——————————————Node:number_literal Text: 8
|—————————————Node:) Text: )
|————————————Node:| Text: |
|————————————Node:parenthesized_expression Text: (i & (T)(unsigned char)(-1))
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: i & (T)(unsigned char)(-1)
|——————————————Node:identifier Text: i
|——————————————Node:& Text: &
|——————————————Node:cast_expression Text: (T)(unsigned char)(-1)
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: T
|————————————————Node:type_identifier Text: T
|———————————————Node:) Text: )
|———————————————Node:cast_expression Text: (unsigned char)(-1)
|————————————————Node:( Text: (
|————————————————Node:type_descriptor Text: unsigned char
|—————————————————Node:sized_type_specifier Text: unsigned char
|——————————————————Node:unsigned Text: unsigned
|——————————————————Node:primitive_type Text: char
|————————————————Node:) Text: )
|————————————————Node:parenthesized_expression Text: (-1)
|—————————————————Node:( Text: (
|—————————————————Node:number_literal Text: -1
|—————————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:, Text: ,
|———————————Node:binary_expression Text: n + 1
|————————————Node:identifier Text: n
|————————————Node:+ Text: +
|————————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:} Text: 
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: constexpr uint8_t CANSignal_generate_position(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
{
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
               ? position
               : position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */);
    /*
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            return position;
        }
        else
        {
            uint8_t bits_in_last_byte{8 - (position % 8)};
            if (length - bits_in_last_byte < 0)
            {
                return position;
            }
            else
            {
                uint8_t full_bytes = (length - bits_in_last_byte) / 8;
                uint8_t remaining_bits = (length - bits_in_last_byte) % 8;
                position -=
                    (8 * (remaining_bits == 0 ? full_bytes : full_bytes + 1)) + (8 - remaining_bits) -
       bits_in_last_byte;
            }

            return position;
        } */
}
|——Node:type_qualifier Text: constexpr
|———Node:constexpr Text: constexpr
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANSignal_generate_position(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
|———Node:identifier Text: CANSignal_generate_position
|———Node:parameter_list Text: (uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t position
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: position
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t length
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: length
|————Node:, Text: ,
|————Node:parameter_declaration Text: ICANSignal::ByteOrder byte_order
|—————Node:type_identifier Text: ICANSignal
|—————Node:ERROR Text: ::ByteOrder
|——————Node:: Text: :
|——————Node:: Text: :
|——————Node:identifier Text: ByteOrder
|—————Node:identifier Text: byte_order
|————Node:) Text: )
|——Node:compound_statement Text: {
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
               ? position
               : position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */);
    /*
        if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            return position;
        }
        else
        {
            uint8_t bits_in_last_byte{8 - (position % 8)};
            if (length - bits_in_last_byte < 0)
            {
                return position;
            }
            else
            {
                uint8_t full_bytes = (length - bits_in_last_byte) / 8;
                uint8_t remaining_bits = (length - bits_in_last_byte) % 8;
                position -=
                    (8 * (remaining_bits == 0 ? full_bytes : full_bytes + 1)) + (8 - remaining_bits) -
       bits_in_last_byte;
            }

            return position;
        } */
}
|———Node:{ Text: {
|———Node:return_statement Text: return (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
               ? position
               : position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */);
|————Node:return Text: return
|————Node:conditional_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
               ? position
               : position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */)
|—————Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0))
|——————Node:( Text: (
|——————Node:binary_expression Text: byte_order == ICANSignal::ByteOrder::kLittleEndian
            || (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0)
|———————Node:binary_expression Text: byte_order == ICANSignal
|————————Node:identifier Text: byte_order
|————————Node:== Text: ==
|————————Node:identifier Text: ICANSignal
|———————Node:ERROR Text: ::ByteOrder::kLittleEndian
|————————Node:: Text: :
|————————Node:: Text: :
|————————Node:identifier Text: ByteOrder
|————————Node:: Text: :
|————————Node:: Text: :
|————————Node:identifier Text: kLittleEndian
|———————Node:|| Text: ||
|———————Node:parenthesized_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */ < 0)
|————————Node:( Text: (
|————————Node:binary_expression Text: length - (8 - (position % 8)) /* bits_in_last_byte */ < 0
|—————————Node:binary_expression Text: length - (8 - (position % 8))
|——————————Node:identifier Text: length
|——————————Node:- Text: -
|——————————Node:parenthesized_expression Text: (8 - (position % 8))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 8 - (position % 8)
|————————————Node:number_literal Text: 8
|————————————Node:- Text: -
|————————————Node:parenthesized_expression Text: (position % 8)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: position % 8
|——————————————Node:identifier Text: position
|——————————————Node:% Text: %
|——————————————Node:number_literal Text: 8
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:comment
|—————————Node:< Text: <
|—————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:) Text: )
|—————Node:? Text: ?
|—————Node:identifier Text: position
|—————Node:: Text: :
|—————Node:binary_expression Text: position
                     - ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */)
|——————Node:identifier Text: position
|——————Node:- Text: -
|——————Node:parenthesized_expression Text: ((8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8)) /* bits_in_last_byte */)
|———————Node:( Text: (
|———————Node:binary_expression Text: (8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
                        - (8 - (position % 8))
|————————Node:binary_expression Text: (8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
                        + (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
|—————————Node:parenthesized_expression Text: (8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 8
                         * (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1)
|———————————Node:number_literal Text: 8
|———————————Node:* Text: *
|———————————Node:parenthesized_expression Text: (((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1)
|————————————Node:( Text: (
|————————————Node:conditional_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
                                ? ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */
                                : ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1
|—————————————Node:binary_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */ == 0
|——————————————Node:parenthesized_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */) % 8
|————————————————Node:parenthesized_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: length - (8 - (position % 8))
|——————————————————Node:identifier Text: length
|——————————————————Node:- Text: -
|——————————————————Node:parenthesized_expression Text: (8 - (position % 8))
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: 8 - (position % 8)
|————————————————————Node:number_literal Text: 8
|————————————————————Node:- Text: -
|————————————————————Node:parenthesized_expression Text: (position % 8)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: position % 8
|——————————————————————Node:identifier Text: position
|——————————————————————Node:% Text: %
|——————————————————————Node:number_literal Text: 8
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|—————————————————Node:comment
|—————————————————Node:) Text: )
|————————————————Node:% Text: %
|————————————————Node:number_literal Text: 8
|———————————————Node:) Text: )
|——————————————Node:comment
|——————————————Node:== Text: ==
|——————————————Node:number_literal Text: 0
|—————————————Node:? Text: ?
|—————————————Node:parenthesized_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */) / 8
|———————————————Node:parenthesized_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: length - (8 - (position % 8))
|—————————————————Node:identifier Text: length
|—————————————————Node:- Text: -
|—————————————————Node:parenthesized_expression Text: (8 - (position % 8))
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: 8 - (position % 8)
|———————————————————Node:number_literal Text: 8
|———————————————————Node:- Text: -
|———————————————————Node:parenthesized_expression Text: (position % 8)
|————————————————————Node:( Text: (
|————————————————————Node:binary_expression Text: position % 8
|—————————————————————Node:identifier Text: position
|—————————————————————Node:% Text: %
|—————————————————————Node:number_literal Text: 8
|————————————————————Node:) Text: )
|——————————————————Node:) Text: )
|————————————————Node:comment
|————————————————Node:) Text: )
|———————————————Node:/ Text: /
|———————————————Node:number_literal Text: 8
|——————————————Node:) Text: )
|—————————————Node:comment
|—————————————Node:: Text: :
|—————————————Node:binary_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8) /* full_bytes */ + 1
|——————————————Node:parenthesized_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) / 8)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */) / 8
|————————————————Node:parenthesized_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: length - (8 - (position % 8))
|——————————————————Node:identifier Text: length
|——————————————————Node:- Text: -
|——————————————————Node:parenthesized_expression Text: (8 - (position % 8))
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: 8 - (position % 8)
|————————————————————Node:number_literal Text: 8
|————————————————————Node:- Text: -
|————————————————————Node:parenthesized_expression Text: (position % 8)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: position % 8
|——————————————————————Node:identifier Text: position
|——————————————————————Node:% Text: %
|——————————————————————Node:number_literal Text: 8
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|—————————————————Node:comment
|—————————————————Node:) Text: )
|————————————————Node:/ Text: /
|————————————————Node:number_literal Text: 8
|———————————————Node:) Text: )
|——————————————Node:comment
|——————————————Node:+ Text: +
|——————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:parenthesized_expression Text: (8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8) /* remaining_bits */)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 8 - ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8)
|———————————Node:number_literal Text: 8
|———————————Node:- Text: -
|———————————Node:parenthesized_expression Text: ((length - (8 - (position % 8)) /* bits_in_last_byte */) % 8)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */) % 8
|—————————————Node:parenthesized_expression Text: (length - (8 - (position % 8)) /* bits_in_last_byte */)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: length - (8 - (position % 8))
|———————————————Node:identifier Text: length
|———————————————Node:- Text: -
|———————————————Node:parenthesized_expression Text: (8 - (position % 8))
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 8 - (position % 8)
|—————————————————Node:number_literal Text: 8
|—————————————————Node:- Text: -
|—————————————————Node:parenthesized_expression Text: (position % 8)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: position % 8
|———————————————————Node:identifier Text: position
|———————————————————Node:% Text: %
|———————————————————Node:number_literal Text: 8
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:comment
|——————————————Node:) Text: )
|—————————————Node:% Text: %
|—————————————Node:number_literal Text: 8
|————————————Node:) Text: )
|——————————Node:comment
|——————————Node:) Text: )
|————————Node:- Text: -
|————————Node:parenthesized_expression Text: (8 - (position % 8))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 8 - (position % 8)
|——————————Node:number_literal Text: 8
|——————————Node:- Text: -
|——————————Node:parenthesized_expression Text: (position % 8)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: position % 8
|————————————Node:identifier Text: position
|————————————Node:% Text: %
|————————————Node:number_literal Text: 8
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:comment
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: constexpr uint64_t CANSignal_generate_mask(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
{
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian)
               ? (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
               : (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))));
}
|——Node:type_qualifier Text: constexpr
|———Node:constexpr Text: constexpr
|——Node:primitive_type Text: uint64_t
|——Node:function_declarator Text: CANSignal_generate_mask(uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
|———Node:identifier Text: CANSignal_generate_mask
|———Node:parameter_list Text: (uint8_t position, uint8_t length, ICANSignal::ByteOrder byte_order)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t position
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: position
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t length
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: length
|————Node:, Text: ,
|————Node:parameter_declaration Text: ICANSignal::ByteOrder byte_order
|—————Node:type_identifier Text: ICANSignal
|—————Node:ERROR Text: ::ByteOrder
|——————Node:: Text: :
|——————Node:: Text: :
|——————Node:identifier Text: ByteOrder
|—————Node:identifier Text: byte_order
|————Node:) Text: )
|——Node:compound_statement Text: {
    return (byte_order == ICANSignal::ByteOrder::kLittleEndian)
               ? (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
               : (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))));
}
|———Node:{ Text: {
|———Node:return_statement Text: return (byte_order == ICANSignal::ByteOrder::kLittleEndian)
               ? (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
               : (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))));
|————Node:return Text: return
|————Node:conditional_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
               ? (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
               : (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))))
|—————Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
|——————Node:( Text: (
|——————Node:binary_expression Text: byte_order == ICANSignal
|———————Node:identifier Text: byte_order
|———————Node:== Text: ==
|———————Node:identifier Text: ICANSignal
|——————Node:ERROR Text: ::ByteOrder::kLittleEndian
|———————Node:: Text: :
|———————Node:: Text: :
|———————Node:identifier Text: ByteOrder
|———————Node:: Text: :
|———————Node:: Text: :
|———————Node:identifier Text: kLittleEndian
|——————Node:) Text: )
|—————Node:? Text: ?
|—————Node:parenthesized_expression Text: (0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position)))
|——————Node:( Text: (
|——————Node:binary_expression Text: 0xFFFFFFFFFFFFFFFFull << (64 - length) >> (64 - (length + position))
|———————Node:binary_expression Text: 0xFFFFFFFFFFFFFFFFull << (64 - length)
|————————Node:number_literal Text: 0xFFFFFFFFFFFFFFFFull
|————————Node:<< Text: <<
|————————Node:parenthesized_expression Text: (64 - length)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 64 - length
|——————————Node:number_literal Text: 64
|——————————Node:- Text: -
|——————————Node:identifier Text: length
|—————————Node:) Text: )
|———————Node:>> Text: >>
|———————Node:parenthesized_expression Text: (64 - (length + position))
|————————Node:( Text: (
|————————Node:binary_expression Text: 64 - (length + position)
|—————————Node:number_literal Text: 64
|—————————Node:- Text: -
|—————————Node:parenthesized_expression Text: (length + position)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: length + position
|———————————Node:identifier Text: length
|———————————Node:+ Text: +
|———————————Node:identifier Text: position
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:) Text: )
|—————Node:: Text: :
|—————Node:parenthesized_expression Text: (bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))))
|——————Node:( Text: (
|——————Node:call_expression Text: bswap((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position))))
|———————Node:identifier Text: bswap
|———————Node:argument_list Text: ((uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position))))
|————————Node:( Text: (
|————————Node:cast_expression Text: (uint64_t)(0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint64_t
|——————————Node:primitive_type Text: uint64_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position)))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 0xFFFFFFFFFFFFFFFFull >> (64 - length) << (64 - (length + position))
|———————————Node:binary_expression Text: 0xFFFFFFFFFFFFFFFFull >> (64 - length)
|————————————Node:number_literal Text: 0xFFFFFFFFFFFFFFFFull
|————————————Node:>> Text: >>
|————————————Node:parenthesized_expression Text: (64 - length)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 64 - length
|——————————————Node:number_literal Text: 64
|——————————————Node:- Text: -
|——————————————Node:identifier Text: length
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:parenthesized_expression Text: (64 - (length + position))
|————————————Node:( Text: (
|————————————Node:binary_expression Text: 64 - (length + position)
|—————————————Node:number_literal Text: 64
|—————————————Node:- Text: -
|—————————————Node:parenthesized_expression Text: (length + position)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: length + position
|———————————————Node:identifier Text: length
|———————————————Node:+ Text: +
|———————————————Node:identifier Text: position
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:ERROR Text: template <typename SignalType>
class ITypedCANSignal : public ICANSignal
|——Node:binary_expression Text: template <typename SignalType>
class ITypedCANSignal : public
|———Node:binary_expression Text: template <typename SignalType
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: typename
|—————Node:identifier Text: typename
|————Node:identifier Text: SignalType
|———Node:> Text: >
|———Node:ERROR Text: class ITypedCANSignal :
|————Node:identifier Text: class
|————Node:identifier Text: ITypedCANSignal
|————Node:: Text: :
|———Node:identifier Text: public
|——Node:identifier Text: ICANSignal
|—Node:compound_statement Text: {
public:
    SignalType &value_ref() { return signal_; }

    void operator=(const SignalType &signal) { signal_ = signal; }

    operator SignalType() const { return signal_; }

protected:
    SignalType signal_;
}
|——Node:{ Text: {
|——Node:labeled_statement Text: public:
    SignalType &value_ref()
|———Node:statement_identifier Text: public
|———Node:: Text: :
|———Node:expression_statement Text: SignalType &value_ref()
|————Node:binary_expression Text: SignalType &value_ref()
|—————Node:identifier Text: SignalType
|—————Node:& Text: &
|—————Node:call_expression Text: value_ref()
|——————Node:identifier Text: value_ref
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: 
|——Node:compound_statement Text: { return signal_; }
|———Node:{ Text: {
|———Node:return_statement Text: return signal_;
|————Node:return Text: return
|————Node:identifier Text: signal_
|————Node:; Text: ;
|———Node:} Text: }
|——Node:declaration Text: void operator=(const SignalType &signal)
|———Node:primitive_type Text: void
|———Node:init_declarator Text: operator=(const SignalType &signal)
|————Node:identifier Text: operator
|————Node:= Text: =
|————Node:parenthesized_expression Text: (const SignalType &signal)
|—————Node:( Text: (
|—————Node:ERROR Text: const SignalType
|——————Node:type_descriptor Text: const SignalType
|———————Node:type_qualifier Text: const
|————————Node:const Text: const
|———————Node:type_identifier Text: SignalType
|—————Node:pointer_expression Text: &signal
|——————Node:& Text: &
|——————Node:identifier Text: signal
|—————Node:) Text: )
|———Node:; Text: 
|——Node:compound_statement Text: { signal_ = signal; }
|———Node:{ Text: {
|———Node:expression_statement Text: signal_ = signal;
|————Node:assignment_expression Text: signal_ = signal
|—————Node:identifier Text: signal_
|—————Node:= Text: =
|—————Node:identifier Text: signal
|————Node:; Text: ;
|———Node:} Text: }
|——Node:ERROR Text: operator SignalType() const
|———Node:type_identifier Text: operator
|———Node:function_declarator Text: SignalType()
|————Node:identifier Text: SignalType
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: { return signal_; }
|———Node:{ Text: {
|———Node:return_statement Text: return signal_;
|————Node:return Text: return
|————Node:identifier Text: signal_
|————Node:; Text: ;
|———Node:} Text: }
|——Node:labeled_statement Text: protected:
    SignalType signal_;
|———Node:statement_identifier Text: protected
|———Node:: Text: :
|———Node:declaration Text: SignalType signal_;
|————Node:type_identifier Text: SignalType
|————Node:identifier Text: signal_
|————Node:; Text: ;
|——Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:comment
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<uint8_t>
|——Node:binary_expression Text: ITypedCANSignal<uint8_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: uint8_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<uint16_t>
|——Node:binary_expression Text: ITypedCANSignal<uint16_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: uint16_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<uint32_t>
|——Node:binary_expression Text: ITypedCANSignal<uint32_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: uint32_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<int8_t>
|——Node:binary_expression Text: ITypedCANSignal<int8_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: int8_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<int16_t>
|——Node:binary_expression Text: ITypedCANSignal<int16_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: int16_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<int32_t>
|——Node:binary_expression Text: ITypedCANSignal<int32_t
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: int32_t
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:declaration Text: template class
|——Node:type_identifier Text: template
|——Node:identifier Text: class
|——Node:; Text: 
|—Node:ERROR Text: ITypedCANSignal<float>
|——Node:binary_expression Text: ITypedCANSignal<float
|———Node:identifier Text: ITypedCANSignal
|———Node:< Text: <
|———Node:identifier Text: float
|——Node:> Text: >
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:storage_class_specifier Text: static
|——Node:static Text: static
|—Node:type_qualifier Text: constexpr
|——Node:constexpr Text: constexpr
|—Node:primitive_type Text: int
|—Node:identifier Text: kCANTemplateFloatDenominator
|—Node:{ Text: {
|—Node:expression_statement Text: 1 << 16};
|——Node:binary_expression Text: 1 << 16
|———Node:number_literal Text: 1
|———Node:<< Text: <<
|———Node:number_literal Text: 16
|——Node:ERROR Text: }
|———Node:} Text: }
|——Node:; Text: ;
|—Node:comment
|—Node:function_definition Text: constexpr int CANTemplateConvertFloat(float value) { return value * kCANTemplateFloatDenominator; }
|——Node:type_qualifier Text: constexpr
|———Node:constexpr Text: constexpr
|——Node:primitive_type Text: int
|——Node:function_declarator Text: CANTemplateConvertFloat(float value)
|———Node:identifier Text: CANTemplateConvertFloat
|———Node:parameter_list Text: (float value)
|————Node:( Text: (
|————Node:parameter_declaration Text: float value
|—————Node:primitive_type Text: float
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: { return value * kCANTemplateFloatDenominator; }
|———Node:{ Text: {
|———Node:return_statement Text: return value * kCANTemplateFloatDenominator;
|————Node:return Text: return
|————Node:binary_expression Text: value * kCANTemplateFloatDenominator
|—————Node:identifier Text: value
|—————Node:* Text: *
|—————Node:identifier Text: kCANTemplateFloatDenominator
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: constexpr float CANTemplateGetFloat(int value) { return static_cast<float>(value) / kCANTemplateFloatDenominator; }
|——Node:type_qualifier Text: constexpr
|———Node:constexpr Text: constexpr
|——Node:primitive_type Text: float
|——Node:function_declarator Text: CANTemplateGetFloat(int value)
|———Node:identifier Text: CANTemplateGetFloat
|———Node:parameter_list Text: (int value)
|————Node:( Text: (
|————Node:parameter_declaration Text: int value
|—————Node:primitive_type Text: int
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: { return static_cast<float>(value) / kCANTemplateFloatDenominator; }
|———Node:{ Text: {
|———Node:return_statement Text: return static_cast<float>(value) / kCANTemplateFloatDenominator;
|————Node:return Text: return
|————Node:binary_expression Text: static_cast<float>(value) / kCANTemplateFloatDenominator
|—————Node:binary_expression Text: static_cast<float
|——————Node:identifier Text: static_cast
|——————Node:< Text: <
|——————Node:identifier Text: float
|—————Node:> Text: >
|—————Node:binary_expression Text: (value) / kCANTemplateFloatDenominator
|——————Node:parenthesized_expression Text: (value)
|———————Node:( Text: (
|———————Node:identifier Text: value
|———————Node:) Text: )
|——————Node:/ Text: /
|——————Node:identifier Text: kCANTemplateFloatDenominator
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: template <bool signed_raw>
struct GetCANRawType;
|——Node:binary_expression Text: template <bool signed_raw>
struct GetCANRawType
|———Node:binary_expression Text: template <bool signed_raw
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:identifier Text: signed_raw
|———Node:> Text: >
|———Node:ERROR Text: struct
|————Node:identifier Text: struct
|———Node:identifier Text: GetCANRawType
|——Node:; Text: ;
|—Node:ERROR Text: template <>
struct GetCANRawType<true>
|——Node:identifier Text: template
|——Node:< Text: <
|——Node:> Text: >
|——Node:struct_specifier Text: struct GetCANRawType
|———Node:struct Text: struct
|———Node:type_identifier Text: GetCANRawType
|——Node:< Text: <
|——Node:true Text: true
|——Node:> Text: >
|—Node:compound_statement Text: {
    using type = int64_t;
}
|——Node:{ Text: {
|——Node:declaration Text: using type = int64_t;
|———Node:type_identifier Text: using
|———Node:init_declarator Text: type = int64_t
|————Node:identifier Text: type
|————Node:= Text: =
|————Node:identifier Text: int64_t
|———Node:; Text: ;
|——Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:ERROR Text: template <>
struct GetCANRawType<false>
|——Node:identifier Text: template
|——Node:< Text: <
|——Node:> Text: >
|——Node:struct_specifier Text: struct GetCANRawType
|———Node:struct Text: struct
|———Node:type_identifier Text: GetCANRawType
|——Node:< Text: <
|——Node:false Text: false
|——Node:> Text: >
|—Node:compound_statement Text: {
    using type = uint64_t;
}
|——Node:{ Text: {
|——Node:declaration Text: using type = uint64_t;
|———Node:type_identifier Text: using
|———Node:init_declarator Text: type = uint64_t
|————Node:identifier Text: type
|————Node:= Text: =
|————Node:identifier Text: uint64_t
|———Node:; Text: ;
|——Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:comment
|—Node:ERROR Text: template <typename SignalType,
          uint8_t input_position,
          uint8_t length,
          int factor,
          int offset,
          bool signed_raw = false,
          ICANSignal::ByteOrder byte_order = ICANSignal::ByteOrder::kLittleEndian,
          uint8_t
|——Node:comma_expression Text: template <typename SignalType,
          uint8_t input_position,
          uint8_t length,
          int factor,
          int offset,
          bool signed_raw = false,
          ICANSignal
|———Node:binary_expression Text: template <typename SignalType
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: typename
|—————Node:identifier Text: typename
|————Node:identifier Text: SignalType
|———Node:, Text: ,
|———Node:ERROR Text: uint8_t
|————Node:identifier Text: uint8_t
|———Node:comma_expression Text: input_position,
          uint8_t length,
          int factor,
          int offset,
          bool signed_raw = false,
          ICANSignal
|————Node:identifier Text: input_position
|————Node:, Text: ,
|————Node:comma_expression Text: uint8_t length,
          int factor,
          int offset,
          bool signed_raw = false,
          ICANSignal
|—————Node:identifier Text: uint8_t
|—————Node:ERROR Text: length
|——————Node:identifier Text: length
|—————Node:, Text: ,
|—————Node:ERROR Text: int
|——————Node:identifier Text: int
|—————Node:comma_expression Text: factor,
          int offset,
          bool signed_raw = false,
          ICANSignal
|——————Node:identifier Text: factor
|——————Node:, Text: ,
|——————Node:ERROR Text: int
|———————Node:identifier Text: int
|——————Node:comma_expression Text: offset,
          bool signed_raw = false,
          ICANSignal
|———————Node:identifier Text: offset
|———————Node:, Text: ,
|———————Node:ERROR Text: bool
|————————Node:identifier Text: bool
|———————Node:comma_expression Text: signed_raw = false,
          ICANSignal
|————————Node:assignment_expression Text: signed_raw = false
|—————————Node:identifier Text: signed_raw
|—————————Node:= Text: =
|—————————Node:false Text: false
|————————Node:, Text: ,
|————————Node:identifier Text: ICANSignal
|——Node:: Text: :
|——Node:: Text: :
|——Node:identifier Text: ByteOrder
|——Node:identifier Text: byte_order
|——Node:= Text: =
|——Node:identifier Text: ICANSignal
|——Node:: Text: :
|——Node:: Text: :
|——Node:identifier Text: ByteOrder
|——Node:: Text: :
|——Node:: Text: :
|——Node:identifier Text: kLittleEndian
|——Node:, Text: ,
|——Node:primitive_type Text: uint8_t
|—Node:expression_statement Text: position = CANSignal_generate_position(input_position, length, byte_order),
          uint64_t mask = CANSignal_generate_mask(position, length, byte_order),
          bool unity_factor = factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type;
|——Node:comma_expression Text: position = CANSignal_generate_position(input_position, length, byte_order),
          uint64_t mask = CANSignal_generate_mask(position, length, byte_order),
          bool unity_factor = factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|———Node:assignment_expression Text: position = CANSignal_generate_position(input_position, length, byte_order)
|————Node:identifier Text: position
|————Node:= Text: =
|————Node:call_expression Text: CANSignal_generate_position(input_position, length, byte_order)
|—————Node:identifier Text: CANSignal_generate_position
|—————Node:argument_list Text: (input_position, length, byte_order)
|——————Node:( Text: (
|——————Node:identifier Text: input_position
|——————Node:, Text: ,
|——————Node:identifier Text: length
|——————Node:, Text: ,
|——————Node:identifier Text: byte_order
|——————Node:) Text: )
|———Node:, Text: ,
|———Node:comma_expression Text: uint64_t mask = CANSignal_generate_mask(position, length, byte_order),
          bool unity_factor = factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|————Node:assignment_expression Text: uint64_t mask = CANSignal_generate_mask(position, length, byte_order)
|—————Node:identifier Text: uint64_t
|—————Node:ERROR Text: mask
|——————Node:identifier Text: mask
|—————Node:= Text: =
|—————Node:call_expression Text: CANSignal_generate_mask(position, length, byte_order)
|——————Node:identifier Text: CANSignal_generate_mask
|——————Node:argument_list Text: (position, length, byte_order)
|———————Node:( Text: (
|———————Node:identifier Text: position
|———————Node:, Text: ,
|———————Node:identifier Text: length
|———————Node:, Text: ,
|———————Node:identifier Text: byte_order
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:assignment_expression Text: unity_factor = factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|—————Node:identifier Text: unity_factor
|—————Node:= Text: =
|—————Node:binary_expression Text: factor == CANTemplateConvertFloat(1)
                              && offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|——————Node:binary_expression Text: factor == CANTemplateConvertFloat(1)
|———————Node:identifier Text: factor
|———————Node:== Text: ==
|———————Node:call_expression Text: CANTemplateConvertFloat(1)
|————————Node:identifier Text: CANTemplateConvertFloat
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:binary_expression Text: offset == 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|———————Node:identifier Text: offset
|———————Node:== Text: ==
|———————Node:binary_expression Text: 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType>
{
    using underlying_type = typename GetCANRawType<signed_raw>::type
|————————Node:binary_expression Text: 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class CANSignal : public ITypedCANSignal<SignalType
|—————————Node:binary_expression Text: 0>  // unity_factor is used for increased precision on unity-factor 64-bit
                                               // signals by getting rid of floating point error
class
|——————————Node:number_literal Text: 0
|——————————Node:> Text: >
|——————————Node:comment
|——————————Node:comment
|——————————Node:identifier Text: class
|—————————Node:ERROR Text: CANSignal : public ITypedCANSignal
|——————————Node:identifier Text: CANSignal
|——————————Node:: Text: :
|——————————Node:identifier Text: public
|——————————Node:identifier Text: ITypedCANSignal
|—————————Node:< Text: <
|—————————Node:identifier Text: SignalType
|————————Node:> Text: >
|————————Node:ERROR Text: {
    using
|—————————Node:{ Text: {
|—————————Node:identifier Text: using
|————————Node:assignment_expression Text: underlying_type = typename GetCANRawType<signed_raw>::type
|—————————Node:identifier Text: underlying_type
|—————————Node:= Text: =
|—————————Node:ERROR Text: typename
|——————————Node:identifier Text: typename
|—————————Node:binary_expression Text: GetCANRawType<signed_raw>::type
|——————————Node:binary_expression Text: GetCANRawType<signed_raw
|———————————Node:identifier Text: GetCANRawType
|———————————Node:< Text: <
|———————————Node:identifier Text: signed_raw
|——————————Node:> Text: >
|——————————Node:ERROR Text: ::
|———————————Node:: Text: :
|———————————Node:: Text: :
|——————————Node:identifier Text: type
|——Node:; Text: ;
|—Node:labeled_statement Text: public:
    CANSignal()
|——Node:statement_identifier Text: public
|——Node:: Text: :
|——Node:expression_statement Text: CANSignal()
|———Node:call_expression Text: CANSignal()
|————Node:identifier Text: CANSignal
|————Node:argument_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:; Text: 
|—Node:compound_statement Text: {
        static_assert(factor != 0, "The integer representation of the factor for a CAN signal must not be 0");
    }
|——Node:{ Text: {
|——Node:expression_statement Text: static_assert(factor != 0, "The integer representation of the factor for a CAN signal must not be 0");
|———Node:call_expression Text: static_assert(factor != 0, "The integer representation of the factor for a CAN signal must not be 0")
|————Node:identifier Text: static_assert
|————Node:argument_list Text: (factor != 0, "The integer representation of the factor for a CAN signal must not be 0")
|—————Node:( Text: (
|—————Node:binary_expression Text: factor != 0
|——————Node:identifier Text: factor
|——————Node:!= Text: !=
|——————Node:number_literal Text: 0
|—————Node:, Text: ,
|—————Node:string_literal Text: "The integer representation of the factor for a CAN signal must not be 0"
|——————Node:" Text: "
|——————Node:string_content Text: The integer representation of the factor for a CAN signal must not be 0
|——————Node:" Text: "
|—————Node:) Text: )
|———Node:; Text: ;
|——Node:} Text: }
|—Node:function_definition Text: void EncodeSignal(uint64_t *buffer) override { InternalEncodeSignal(buffer); }
|——Node:primitive_type Text: void
|——Node:function_declarator Text: EncodeSignal(uint64_t *buffer) override
|———Node:identifier Text: EncodeSignal
|———Node:parameter_list Text: (uint64_t *buffer)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint64_t *buffer
|—————Node:primitive_type Text: uint64_t
|—————Node:pointer_declarator Text: *buffer
|——————Node:* Text: *
|——————Node:identifier Text: buffer
|————Node:) Text: )
|———Node:identifier Text: override
|——Node:compound_statement Text: { InternalEncodeSignal(buffer); }
|———Node:{ Text: {
|———Node:expression_statement Text: InternalEncodeSignal(buffer);
|————Node:call_expression Text: InternalEncodeSignal(buffer)
|—————Node:identifier Text: InternalEncodeSignal
|—————Node:argument_list Text: (buffer)
|——————Node:( Text: (
|——————Node:identifier Text: buffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: template <bool unity_factor_ = unity_factor, typename
|——Node:comma_expression Text: template <bool unity_factor_ = unity_factor, typename
|———Node:binary_expression Text: template <bool unity_factor_ = unity_factor
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:assignment_expression Text: unity_factor_ = unity_factor
|—————Node:identifier Text: unity_factor_
|—————Node:= Text: =
|—————Node:identifier Text: unity_factor
|———Node:, Text: ,
|———Node:identifier Text: typename
|——Node:; Text: 
|—Node:identifier Text: std
|—Node:: Text: :
|—Node:ERROR Text: :enable_if<unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|——Node:: Text: :
|——Node:comma_expression Text: enable_if<unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|———Node:binary_expression Text: enable_if<unity_factor_
|————Node:identifier Text: enable_if
|————Node:< Text: <
|————Node:identifier Text: unity_factor_
|———Node:, Text: ,
|———Node:binary_expression Text: void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|————Node:binary_expression Text: void>::type * = nullptr
|—————Node:identifier Text: void
|—————Node:> Text: >
|—————Node:ERROR Text: ::
|——————Node:: Text: :
|——————Node:: Text: :
|—————Node:binary_expression Text: type * = nullptr
|——————Node:identifier Text: type
|——————Node:* Text: *
|——————Node:ERROR Text: =
|———————Node:= Text: =
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|————Node:> Text: >
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:call_expression Text: InternalEncodeSignal(uint64_t *buffer)
|—————Node:identifier Text: InternalEncodeSignal
|—————Node:argument_list Text: (uint64_t *buffer)
|——————Node:( Text: (
|——————Node:binary_expression Text: uint64_t *buffer
|———————Node:identifier Text: uint64_t
|———————Node:* Text: *
|———————Node:identifier Text: buffer
|——————Node:) Text: )
|—Node:{ Text: {
|—Node:if_statement Text: if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            *buffer |= (static_cast<underlying_type>(this->signal_) << position) & mask;
        }
        else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|——Node:if Text: if
|——Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
|———Node:( Text: (
|———Node:binary_expression Text: byte_order == ICANSignal
|————Node:identifier Text: byte_order
|————Node:== Text: ==
|————Node:identifier Text: ICANSignal
|———Node:ERROR Text: ::ByteOrder::kLittleEndian
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: ByteOrder
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: kLittleEndian
|———Node:) Text: )
|——Node:compound_statement Text: {
            *buffer |= (static_cast<underlying_type>(this->signal_) << position) & mask;
        }
|———Node:{ Text: {
|———Node:expression_statement Text: *buffer |= (static_cast<underlying_type>(this->signal_) << position) & mask;
|————Node:assignment_expression Text: *buffer |= (static_cast<underlying_type>(this->signal_) << position) & mask
|—————Node:pointer_expression Text: *buffer
|——————Node:* Text: *
|——————Node:identifier Text: buffer
|—————Node:|= Text: |=
|—————Node:binary_expression Text: (static_cast<underlying_type>(this->signal_) << position) & mask
|——————Node:parenthesized_expression Text: (static_cast<underlying_type>(this->signal_) << position)
|———————Node:( Text: (
|———————Node:binary_expression Text: static_cast<underlying_type>(this->signal_) << position
|————————Node:binary_expression Text: static_cast<underlying_type
|—————————Node:identifier Text: static_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: underlying_type
|————————Node:> Text: >
|————————Node:binary_expression Text: (this->signal_) << position
|—————————Node:parenthesized_expression Text: (this->signal_)
|——————————Node:( Text: (
|——————————Node:field_expression Text: this->signal_
|———————————Node:identifier Text: this
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: signal_
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:identifier Text: position
|———————Node:) Text: )
|——————Node:& Text: &
|——————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:} Text: }
|——Node:else_clause Text: else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|———Node:else Text: else
|———Node:compound_statement Text: {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|————Node:{ Text: {
|————Node:function_definition Text: uint8_t temp_reversed_buffer[8]{0}
|—————Node:primitive_type Text: uint8_t
|—————Node:array_declarator Text: temp_reversed_buffer[8]
|——————Node:identifier Text: temp_reversed_buffer
|——————Node:[ Text: [
|——————Node:number_literal Text: 8
|——————Node:] Text: ]
|—————Node:compound_statement Text: {0}
|——————Node:{ Text: {
|——————Node:ERROR Text: 0
|———————Node:number_literal Text: 0
|——————Node:} Text: }
|————Node:expression_statement Text: ;
|—————Node:; Text: ;
|————Node:function_definition Text: void *temp_reversed_buffer_ptr{
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *temp_reversed_buffer_ptr
|——————Node:* Text: *
|——————Node:identifier Text: temp_reversed_buffer_ptr
|—————Node:compound_statement Text: {
                temp_reversed_buffer};  // intermediate as void* to get rid of strict aliasing compiler warnings
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
|——————Node:{ Text: {
|——————Node:type_identifier Text: temp_reversed_buffer
|——————Node:ERROR Text: }
|———————Node:} Text: }
|——————Node:; Text: ;
|——————Node:comment
|——————Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)));
|———————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)))
|————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|—————————Node:pointer_expression Text: *reinterpret_cast
|——————————Node:* Text: *
|——————————Node:identifier Text: reinterpret_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: underlying_type
|————————Node:ERROR Text: *
|—————————Node:* Text: *
|————————Node:> Text: >
|————————Node:assignment_expression Text: (temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(this->signal_) << (64 - (position + length)))
|—————————Node:parenthesized_expression Text: (temp_reversed_buffer_ptr)
|——————————Node:( Text: (
|——————————Node:identifier Text: temp_reversed_buffer_ptr
|——————————Node:) Text: )
|—————————Node:|= Text: |=
|—————————Node:parenthesized_expression Text: (static_cast<underlying_type>(this->signal_) << (64 - (position + length)))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: static_cast<underlying_type>(this->signal_) << (64 - (position + length))
|———————————Node:binary_expression Text: static_cast<underlying_type
|————————————Node:identifier Text: static_cast
|————————————Node:< Text: <
|————————————Node:identifier Text: underlying_type
|———————————Node:> Text: >
|———————————Node:binary_expression Text: (this->signal_) << (64 - (position + length))
|————————————Node:parenthesized_expression Text: (this->signal_)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: this->signal_
|——————————————Node:identifier Text: this
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: signal_
|—————————————Node:) Text: )
|————————————Node:<< Text: <<
|————————————Node:parenthesized_expression Text: (64 - (position + length))
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 64 - (position + length)
|——————————————Node:number_literal Text: 64
|——————————————Node:- Text: -
|——————————————Node:parenthesized_expression Text: (position + length)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: position + length
|————————————————Node:identifier Text: position
|————————————————Node:+ Text: +
|————————————————Node:identifier Text: length
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:labeled_statement Text: std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
|———————Node:statement_identifier Text: std
|———————Node:: Text: :
|———————Node:ERROR Text: :
|————————Node:: Text: :
|———————Node:labeled_statement Text: reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
|————————Node:statement_identifier Text: reverse
|————————Node:ERROR Text: (std::begin(temp_reversed_buffer), std:
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: std
|——————————Node:type_identifier Text: std
|—————————Node:: Text: :
|—————————Node:: Text: :
|—————————Node:comma_expression Text: begin(temp_reversed_buffer), std
|——————————Node:call_expression Text: begin(temp_reversed_buffer)
|———————————Node:identifier Text: begin
|———————————Node:argument_list Text: (temp_reversed_buffer)
|————————————Node:( Text: (
|————————————Node:identifier Text: temp_reversed_buffer
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: std
|—————————Node:: Text: :
|————————Node:: Text: :
|————————Node:expression_statement Text: end(temp_reversed_buffer));
|—————————Node:call_expression Text: end(temp_reversed_buffer)
|——————————Node:identifier Text: end
|——————————Node:argument_list Text: (temp_reversed_buffer)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_reversed_buffer
|———————————Node:) Text: )
|—————————Node:ERROR Text: )
|——————————Node:) Text: )
|—————————Node:; Text: ;
|——————Node:expression_statement Text: *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
|———————Node:assignment_expression Text: *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask
|————————Node:pointer_expression Text: *buffer
|—————————Node:* Text: *
|—————————Node:identifier Text: buffer
|————————Node:|= Text: |=
|————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask
|—————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr)
|——————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|———————————Node:pointer_expression Text: *reinterpret_cast
|————————————Node:* Text: *
|————————————Node:identifier Text: reinterpret_cast
|———————————Node:< Text: <
|———————————Node:identifier Text: underlying_type
|——————————Node:ERROR Text: *
|———————————Node:* Text: *
|——————————Node:> Text: >
|——————————Node:parenthesized_expression Text: (temp_reversed_buffer_ptr)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_reversed_buffer_ptr
|———————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:identifier Text: mask
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|—Node:expression_statement Text: template <bool unity_factor_ = unity_factor, typename
|——Node:comma_expression Text: template <bool unity_factor_ = unity_factor, typename
|———Node:binary_expression Text: template <bool unity_factor_ = unity_factor
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:assignment_expression Text: unity_factor_ = unity_factor
|—————Node:identifier Text: unity_factor_
|—————Node:= Text: =
|—————Node:identifier Text: unity_factor
|———Node:, Text: ,
|———Node:identifier Text: typename
|——Node:; Text: 
|—Node:identifier Text: std
|—Node:: Text: :
|—Node:ERROR Text: :enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|——Node:: Text: :
|——Node:comma_expression Text: enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|———Node:binary_expression Text: enable_if<!unity_factor_
|————Node:identifier Text: enable_if
|————Node:< Text: <
|————Node:unary_expression Text: !unity_factor_
|—————Node:! Text: !
|—————Node:identifier Text: unity_factor_
|———Node:, Text: ,
|———Node:binary_expression Text: void>::type * = nullptr>
    void InternalEncodeSignal(uint64_t *buffer)
|————Node:binary_expression Text: void>::type * = nullptr
|—————Node:identifier Text: void
|—————Node:> Text: >
|—————Node:ERROR Text: ::
|——————Node:: Text: :
|——————Node:: Text: :
|—————Node:binary_expression Text: type * = nullptr
|——————Node:identifier Text: type
|——————Node:* Text: *
|——————Node:ERROR Text: =
|———————Node:= Text: =
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|————Node:> Text: >
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:call_expression Text: InternalEncodeSignal(uint64_t *buffer)
|—————Node:identifier Text: InternalEncodeSignal
|—————Node:argument_list Text: (uint64_t *buffer)
|——————Node:( Text: (
|——————Node:binary_expression Text: uint64_t *buffer
|———————Node:identifier Text: uint64_t
|———————Node:* Text: *
|———————Node:identifier Text: buffer
|——————Node:) Text: )
|—Node:{ Text: {
|—Node:if_statement Text: if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            *buffer |= (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask;
        }
        else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|——Node:if Text: if
|——Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
|———Node:( Text: (
|———Node:binary_expression Text: byte_order == ICANSignal
|————Node:identifier Text: byte_order
|————Node:== Text: ==
|————Node:identifier Text: ICANSignal
|———Node:ERROR Text: ::ByteOrder::kLittleEndian
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: ByteOrder
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: kLittleEndian
|———Node:) Text: )
|——Node:compound_statement Text: {
            *buffer |= (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask;
        }
|———Node:{ Text: {
|———Node:expression_statement Text: *buffer |= (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask;
|————Node:assignment_expression Text: *buffer |= (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask
|—————Node:pointer_expression Text: *buffer
|——————Node:* Text: *
|——————Node:identifier Text: buffer
|—————Node:|= Text: |=
|—————Node:binary_expression Text: (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
                       & mask
|——————Node:parenthesized_expression Text: (static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position)
|———————Node:( Text: (
|———————Node:binary_expression Text: static_cast<underlying_type>(
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position
|————————Node:binary_expression Text: static_cast<underlying_type
|—————————Node:identifier Text: static_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: underlying_type
|————————Node:> Text: >
|————————Node:binary_expression Text: (
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                        << position
|—————————Node:parenthesized_expression Text: (
                            ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
|——————————Node:( Text: (
|——————————Node:parenthesized_expression Text: ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)
|————————————Node:parenthesized_expression Text: (this->signal_ - CANTemplateGetFloat(offset))
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: this->signal_ - CANTemplateGetFloat(offset)
|——————————————Node:field_expression Text: this->signal_
|———————————————Node:identifier Text: this
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: signal_
|——————————————Node:- Text: -
|——————————————Node:call_expression Text: CANTemplateGetFloat(offset)
|———————————————Node:identifier Text: CANTemplateGetFloat
|———————————————Node:argument_list Text: (offset)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: offset
|————————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:/ Text: /
|————————————Node:call_expression Text: CANTemplateGetFloat(factor)
|—————————————Node:identifier Text: CANTemplateGetFloat
|—————————————Node:argument_list Text: (factor)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: factor
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:identifier Text: position
|———————Node:) Text: )
|——————Node:& Text: &
|——————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:} Text: }
|——Node:else_clause Text: else
        {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|———Node:else Text: else
|———Node:compound_statement Text: {
            uint8_t temp_reversed_buffer[8]{0};
            void *temp_reversed_buffer_ptr{temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
    }
|————Node:{ Text: {
|————Node:function_definition Text: uint8_t temp_reversed_buffer[8]{0}
|—————Node:primitive_type Text: uint8_t
|—————Node:array_declarator Text: temp_reversed_buffer[8]
|——————Node:identifier Text: temp_reversed_buffer
|——————Node:[ Text: [
|——————Node:number_literal Text: 8
|——————Node:] Text: ]
|—————Node:compound_statement Text: {0}
|——————Node:{ Text: {
|——————Node:ERROR Text: 0
|———————Node:number_literal Text: 0
|——————Node:} Text: }
|————Node:expression_statement Text: ;
|—————Node:; Text: ;
|————Node:function_definition Text: void *temp_reversed_buffer_ptr{temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *temp_reversed_buffer_ptr
|——————Node:* Text: *
|——————Node:identifier Text: temp_reversed_buffer_ptr
|—————Node:compound_statement Text: {temp_reversed_buffer};
            *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
            std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
            *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
        }
|——————Node:{ Text: {
|——————Node:type_identifier Text: temp_reversed_buffer
|——————Node:ERROR Text: }
|———————Node:} Text: }
|——————Node:; Text: ;
|——————Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)));
|———————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)))
|————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|—————————Node:pointer_expression Text: *reinterpret_cast
|——————————Node:* Text: *
|——————————Node:identifier Text: reinterpret_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: underlying_type
|————————Node:ERROR Text: *
|—————————Node:* Text: *
|————————Node:> Text: >
|————————Node:assignment_expression Text: (temp_reversed_buffer_ptr) |=
                (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)))
|—————————Node:parenthesized_expression Text: (temp_reversed_buffer_ptr)
|——————————Node:( Text: (
|——————————Node:identifier Text: temp_reversed_buffer_ptr
|——————————Node:) Text: )
|—————————Node:|= Text: |=
|—————————Node:parenthesized_expression Text: (static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length)))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: static_cast<underlying_type>(
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length))
|———————————Node:binary_expression Text: static_cast<underlying_type
|————————————Node:identifier Text: static_cast
|————————————Node:< Text: <
|————————————Node:identifier Text: underlying_type
|———————————Node:> Text: >
|———————————Node:binary_expression Text: (
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
                 << (64 - (position + length))
|————————————Node:parenthesized_expression Text: (
                     ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)))
|—————————————Node:( Text: (
|—————————————Node:parenthesized_expression Text: ((this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor))
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (this->signal_ - CANTemplateGetFloat(offset)) / CANTemplateGetFloat(factor)
|———————————————Node:parenthesized_expression Text: (this->signal_ - CANTemplateGetFloat(offset))
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: this->signal_ - CANTemplateGetFloat(offset)
|—————————————————Node:field_expression Text: this->signal_
|——————————————————Node:identifier Text: this
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: signal_
|—————————————————Node:- Text: -
|—————————————————Node:call_expression Text: CANTemplateGetFloat(offset)
|——————————————————Node:identifier Text: CANTemplateGetFloat
|——————————————————Node:argument_list Text: (offset)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: offset
|———————————————————Node:) Text: )
|————————————————Node:) Text: )
|———————————————Node:/ Text: /
|———————————————Node:call_expression Text: CANTemplateGetFloat(factor)
|————————————————Node:identifier Text: CANTemplateGetFloat
|————————————————Node:argument_list Text: (factor)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: factor
|—————————————————Node:) Text: )
|——————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:<< Text: <<
|————————————Node:parenthesized_expression Text: (64 - (position + length))
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 64 - (position + length)
|——————————————Node:number_literal Text: 64
|——————————————Node:- Text: -
|——————————————Node:parenthesized_expression Text: (position + length)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: position + length
|————————————————Node:identifier Text: position
|————————————————Node:+ Text: +
|————————————————Node:identifier Text: length
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:labeled_statement Text: std::reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
|———————Node:statement_identifier Text: std
|———————Node:: Text: :
|———————Node:ERROR Text: :
|————————Node:: Text: :
|———————Node:labeled_statement Text: reverse(std::begin(temp_reversed_buffer), std::end(temp_reversed_buffer));
|————————Node:statement_identifier Text: reverse
|————————Node:ERROR Text: (std::begin(temp_reversed_buffer), std:
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: std
|——————————Node:type_identifier Text: std
|—————————Node:: Text: :
|—————————Node:: Text: :
|—————————Node:comma_expression Text: begin(temp_reversed_buffer), std
|——————————Node:call_expression Text: begin(temp_reversed_buffer)
|———————————Node:identifier Text: begin
|———————————Node:argument_list Text: (temp_reversed_buffer)
|————————————Node:( Text: (
|————————————Node:identifier Text: temp_reversed_buffer
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: std
|—————————Node:: Text: :
|————————Node:: Text: :
|————————Node:expression_statement Text: end(temp_reversed_buffer));
|—————————Node:call_expression Text: end(temp_reversed_buffer)
|——————————Node:identifier Text: end
|——————————Node:argument_list Text: (temp_reversed_buffer)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_reversed_buffer
|———————————Node:) Text: )
|—————————Node:ERROR Text: )
|——————————Node:) Text: )
|—————————Node:; Text: ;
|——————Node:expression_statement Text: *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask;
|———————Node:assignment_expression Text: *buffer |= *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask
|————————Node:pointer_expression Text: *buffer
|—————————Node:* Text: *
|—————————Node:identifier Text: buffer
|————————Node:|= Text: |=
|————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr) & mask
|—————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_reversed_buffer_ptr)
|——————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|———————————Node:pointer_expression Text: *reinterpret_cast
|————————————Node:* Text: *
|————————————Node:identifier Text: reinterpret_cast
|———————————Node:< Text: <
|———————————Node:identifier Text: underlying_type
|——————————Node:ERROR Text: *
|———————————Node:* Text: *
|——————————Node:> Text: >
|——————————Node:parenthesized_expression Text: (temp_reversed_buffer_ptr)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_reversed_buffer_ptr
|———————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:identifier Text: mask
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|—Node:function_definition Text: void DecodeSignal(uint64_t *buffer) override { InternalDecodeSignal(buffer); }
|——Node:primitive_type Text: void
|——Node:function_declarator Text: DecodeSignal(uint64_t *buffer) override
|———Node:identifier Text: DecodeSignal
|———Node:parameter_list Text: (uint64_t *buffer)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint64_t *buffer
|—————Node:primitive_type Text: uint64_t
|—————Node:pointer_declarator Text: *buffer
|——————Node:* Text: *
|——————Node:identifier Text: buffer
|————Node:) Text: )
|———Node:identifier Text: override
|——Node:compound_statement Text: { InternalDecodeSignal(buffer); }
|———Node:{ Text: {
|———Node:expression_statement Text: InternalDecodeSignal(buffer);
|————Node:call_expression Text: InternalDecodeSignal(buffer)
|—————Node:identifier Text: InternalDecodeSignal
|—————Node:argument_list Text: (buffer)
|——————Node:( Text: (
|——————Node:identifier Text: buffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: template <bool unity_factor_ = unity_factor, typename
|——Node:comma_expression Text: template <bool unity_factor_ = unity_factor, typename
|———Node:binary_expression Text: template <bool unity_factor_ = unity_factor
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:assignment_expression Text: unity_factor_ = unity_factor
|—————Node:identifier Text: unity_factor_
|—————Node:= Text: =
|—————Node:identifier Text: unity_factor
|———Node:, Text: ,
|———Node:identifier Text: typename
|——Node:; Text: 
|—Node:identifier Text: std
|—Node:: Text: :
|—Node:ERROR Text: :enable_if<unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|——Node:: Text: :
|——Node:comma_expression Text: enable_if<unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|———Node:binary_expression Text: enable_if<unity_factor_
|————Node:identifier Text: enable_if
|————Node:< Text: <
|————Node:identifier Text: unity_factor_
|———Node:, Text: ,
|———Node:binary_expression Text: void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|————Node:binary_expression Text: void>::type * = nullptr
|—————Node:identifier Text: void
|—————Node:> Text: >
|—————Node:ERROR Text: ::
|——————Node:: Text: :
|——————Node:: Text: :
|—————Node:binary_expression Text: type * = nullptr
|——————Node:identifier Text: type
|——————Node:* Text: *
|——————Node:ERROR Text: =
|———————Node:= Text: =
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|————Node:> Text: >
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:call_expression Text: InternalDecodeSignal(uint64_t *buffer)
|—————Node:identifier Text: InternalDecodeSignal
|—————Node:argument_list Text: (uint64_t *buffer)
|——————Node:( Text: (
|——————Node:binary_expression Text: uint64_t *buffer
|———————Node:identifier Text: uint64_t
|———————Node:* Text: *
|———————Node:identifier Text: buffer
|——————Node:) Text: )
|—Node:{ Text: {
|—Node:if Text: if
|—Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
|——Node:( Text: (
|——Node:binary_expression Text: byte_order == ICANSignal
|———Node:identifier Text: byte_order
|———Node:== Text: ==
|———Node:identifier Text: ICANSignal
|——Node:ERROR Text: ::ByteOrder::kLittleEndian
|———Node:: Text: :
|———Node:: Text: :
|———Node:identifier Text: ByteOrder
|———Node:: Text: :
|———Node:: Text: :
|———Node:identifier Text: kLittleEndian
|——Node:) Text: )
|—Node:{ Text: {
|—Node:function_definition Text: uint8_t temp_buffer[8]{0}
|——Node:primitive_type Text: uint8_t
|——Node:array_declarator Text: temp_buffer[8]
|———Node:identifier Text: temp_buffer
|———Node:[ Text: [
|———Node:number_literal Text: 8
|———Node:] Text: ]
|——Node:compound_statement Text: {0}
|———Node:{ Text: {
|———Node:ERROR Text: 0
|————Node:number_literal Text: 0
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:function_definition Text: void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length));
        }
|——Node:primitive_type Text: void
|——Node:pointer_declarator Text: *temp_buffer_ptr
|———Node:* Text: *
|———Node:identifier Text: temp_buffer_ptr
|——Node:compound_statement Text: {temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length));
        }
|———Node:{ Text: {
|———Node:type_identifier Text: temp_buffer
|———Node:ERROR Text: }
|————Node:} Text: }
|———Node:; Text: ;
|———Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
|————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask
|—————Node:binary_expression Text: *reinterpret_cast<underlying_type
|——————Node:pointer_expression Text: *reinterpret_cast
|———————Node:* Text: *
|———————Node:identifier Text: reinterpret_cast
|——————Node:< Text: <
|——————Node:identifier Text: underlying_type
|—————Node:ERROR Text: *
|——————Node:* Text: *
|—————Node:> Text: >
|—————Node:assignment_expression Text: (temp_buffer_ptr) = *buffer & mask
|——————Node:parenthesized_expression Text: (temp_buffer_ptr)
|———————Node:( Text: (
|———————Node:identifier Text: temp_buffer_ptr
|———————Node:) Text: )
|——————Node:= Text: =
|——————Node:binary_expression Text: *buffer & mask
|———————Node:pointer_expression Text: *buffer
|————————Node:* Text: *
|————————Node:identifier Text: buffer
|———————Node:& Text: &
|———————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:expression_statement Text: this->signal_ = static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length));
|————Node:assignment_expression Text: this->signal_ = static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length))
|—————Node:field_expression Text: this->signal_
|——————Node:identifier Text: this
|——————Node:-> Text: ->
|——————Node:field_identifier Text: signal_
|—————Node:= Text: =
|—————Node:binary_expression Text: static_cast<SignalType>(
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length))
|——————Node:binary_expression Text: static_cast<SignalType
|———————Node:identifier Text: static_cast
|———————Node:< Text: <
|———————Node:identifier Text: SignalType
|——————Node:> Text: >
|——————Node:parenthesized_expression Text: (
                (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length))
|———————Node:( Text: (
|———————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length)) >> (64 - length)
|————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
|—————————Node:parenthesized_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr)
|———————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|————————————Node:pointer_expression Text: *reinterpret_cast
|—————————————Node:* Text: *
|—————————————Node:identifier Text: reinterpret_cast
|————————————Node:< Text: <
|————————————Node:identifier Text: underlying_type
|———————————Node:ERROR Text: *
|————————————Node:* Text: *
|———————————Node:> Text: >
|———————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|————————————Node:( Text: (
|————————————Node:identifier Text: temp_buffer_ptr
|————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:parenthesized_expression Text: (64 - (position + length))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 64 - (position + length)
|———————————Node:number_literal Text: 64
|———————————Node:- Text: -
|———————————Node:parenthesized_expression Text: (position + length)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: position + length
|—————————————Node:identifier Text: position
|—————————————Node:+ Text: +
|—————————————Node:identifier Text: length
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:>> Text: >>
|————————Node:parenthesized_expression Text: (64 - length)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 64 - length
|——————————Node:number_literal Text: 64
|——————————Node:- Text: -
|——————————Node:identifier Text: length
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:type_identifier Text: else
|—Node:; Text: 
|—Node:compound_statement Text: {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length));
        }
    }
|——Node:{ Text: {
|——Node:function_definition Text: uint8_t temp_buffer[8]{0}
|———Node:primitive_type Text: uint8_t
|———Node:array_declarator Text: temp_buffer[8]
|————Node:identifier Text: temp_buffer
|————Node:[ Text: [
|————Node:number_literal Text: 8
|————Node:] Text: ]
|———Node:compound_statement Text: {0}
|————Node:{ Text: {
|————Node:ERROR Text: 0
|—————Node:number_literal Text: 0
|————Node:} Text: }
|——Node:expression_statement Text: ;
|———Node:; Text: ;
|——Node:function_definition Text: void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length));
        }
|———Node:primitive_type Text: void
|———Node:pointer_declarator Text: *temp_buffer_ptr
|————Node:* Text: *
|————Node:identifier Text: temp_buffer_ptr
|———Node:compound_statement Text: {temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length));
        }
|————Node:{ Text: {
|————Node:type_identifier Text: temp_buffer
|————Node:ERROR Text: }
|—————Node:} Text: }
|————Node:; Text: ;
|————Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
|—————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask
|——————Node:binary_expression Text: *reinterpret_cast<underlying_type
|———————Node:pointer_expression Text: *reinterpret_cast
|————————Node:* Text: *
|————————Node:identifier Text: reinterpret_cast
|———————Node:< Text: <
|———————Node:identifier Text: underlying_type
|——————Node:ERROR Text: *
|———————Node:* Text: *
|——————Node:> Text: >
|——————Node:assignment_expression Text: (temp_buffer_ptr) = *buffer & mask
|———————Node:parenthesized_expression Text: (temp_buffer_ptr)
|————————Node:( Text: (
|————————Node:identifier Text: temp_buffer_ptr
|————————Node:) Text: )
|———————Node:= Text: =
|———————Node:binary_expression Text: *buffer & mask
|————————Node:pointer_expression Text: *buffer
|—————————Node:* Text: *
|—————————Node:identifier Text: buffer
|————————Node:& Text: &
|————————Node:identifier Text: mask
|—————Node:; Text: ;
|————Node:labeled_statement Text: std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
|—————Node:statement_identifier Text: std
|—————Node:: Text: :
|—————Node:ERROR Text: :
|——————Node:: Text: :
|—————Node:labeled_statement Text: reverse(std::begin(temp_buffer), std::end(temp_buffer));
|——————Node:statement_identifier Text: reverse
|——————Node:ERROR Text: (std::begin(temp_buffer), std:
|———————Node:( Text: (
|———————Node:type_descriptor Text: std
|————————Node:type_identifier Text: std
|———————Node:: Text: :
|———————Node:: Text: :
|———————Node:comma_expression Text: begin(temp_buffer), std
|————————Node:call_expression Text: begin(temp_buffer)
|—————————Node:identifier Text: begin
|—————————Node:argument_list Text: (temp_buffer)
|——————————Node:( Text: (
|——————————Node:identifier Text: temp_buffer
|——————————Node:) Text: )
|————————Node:, Text: ,
|————————Node:identifier Text: std
|———————Node:: Text: :
|——————Node:: Text: :
|——————Node:expression_statement Text: end(temp_buffer));
|———————Node:call_expression Text: end(temp_buffer)
|————————Node:identifier Text: end
|————————Node:argument_list Text: (temp_buffer)
|—————————Node:( Text: (
|—————————Node:identifier Text: temp_buffer
|—————————Node:) Text: )
|———————Node:ERROR Text: )
|————————Node:) Text: )
|———————Node:; Text: ;
|————Node:expression_statement Text: this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length));
|—————Node:assignment_expression Text: this->signal_ = static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length))
|——————Node:field_expression Text: this->signal_
|———————Node:identifier Text: this
|———————Node:-> Text: ->
|———————Node:field_identifier Text: signal_
|——————Node:= Text: =
|——————Node:binary_expression Text: static_cast<SignalType>((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length))
|———————Node:binary_expression Text: static_cast<SignalType
|————————Node:identifier Text: static_cast
|————————Node:< Text: <
|————————Node:identifier Text: SignalType
|———————Node:> Text: >
|———————Node:parenthesized_expression Text: ((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length))
|————————Node:( Text: (
|————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
                                                    >> (64 - length)
|—————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
|——————————Node:parenthesized_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr)
|————————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|—————————————Node:pointer_expression Text: *reinterpret_cast
|——————————————Node:* Text: *
|——————————————Node:identifier Text: reinterpret_cast
|—————————————Node:< Text: <
|—————————————Node:identifier Text: underlying_type
|————————————Node:ERROR Text: *
|—————————————Node:* Text: *
|————————————Node:> Text: >
|————————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: temp_buffer_ptr
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:identifier Text: position
|—————————Node:>> Text: >>
|—————————Node:parenthesized_expression Text: (64 - length)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 64 - length
|———————————Node:number_literal Text: 64
|———————————Node:- Text: -
|———————————Node:identifier Text: length
|——————————Node:) Text: )
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:} Text: }
|—Node:expression_statement Text: template <bool unity_factor_ = unity_factor, typename
|——Node:comma_expression Text: template <bool unity_factor_ = unity_factor, typename
|———Node:binary_expression Text: template <bool unity_factor_ = unity_factor
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: bool
|—————Node:identifier Text: bool
|————Node:assignment_expression Text: unity_factor_ = unity_factor
|—————Node:identifier Text: unity_factor_
|—————Node:= Text: =
|—————Node:identifier Text: unity_factor
|———Node:, Text: ,
|———Node:identifier Text: typename
|——Node:; Text: 
|—Node:identifier Text: std
|—Node:: Text: :
|—Node:ERROR Text: :enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|——Node:: Text: :
|——Node:comma_expression Text: enable_if<!unity_factor_, void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|———Node:binary_expression Text: enable_if<!unity_factor_
|————Node:identifier Text: enable_if
|————Node:< Text: <
|————Node:unary_expression Text: !unity_factor_
|—————Node:! Text: !
|—————Node:identifier Text: unity_factor_
|———Node:, Text: ,
|———Node:binary_expression Text: void>::type * = nullptr>
    void InternalDecodeSignal(uint64_t *buffer)
|————Node:binary_expression Text: void>::type * = nullptr
|—————Node:identifier Text: void
|—————Node:> Text: >
|—————Node:ERROR Text: ::
|——————Node:: Text: :
|——————Node:: Text: :
|—————Node:binary_expression Text: type * = nullptr
|——————Node:identifier Text: type
|——————Node:* Text: *
|——————Node:ERROR Text: =
|———————Node:= Text: =
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|————Node:> Text: >
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:call_expression Text: InternalDecodeSignal(uint64_t *buffer)
|—————Node:identifier Text: InternalDecodeSignal
|—————Node:argument_list Text: (uint64_t *buffer)
|——————Node:( Text: (
|——————Node:binary_expression Text: uint64_t *buffer
|———————Node:identifier Text: uint64_t
|———————Node:* Text: *
|———————Node:identifier Text: buffer
|——————Node:) Text: )
|—Node:{ Text: {
|—Node:if_statement Text: if (byte_order == ICANSignal::ByteOrder::kLittleEndian)
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
        else
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
    }

    void operator=(const SignalType &signal) { ITypedCANSignal<SignalType>::operator=(signal); }
}
|——Node:if Text: if
|——Node:parenthesized_expression Text: (byte_order == ICANSignal::ByteOrder::kLittleEndian)
|———Node:( Text: (
|———Node:binary_expression Text: byte_order == ICANSignal
|————Node:identifier Text: byte_order
|————Node:== Text: ==
|————Node:identifier Text: ICANSignal
|———Node:ERROR Text: ::ByteOrder::kLittleEndian
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: ByteOrder
|————Node:: Text: :
|————Node:: Text: :
|————Node:identifier Text: kLittleEndian
|———Node:) Text: )
|——Node:compound_statement Text: {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
        else
        {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
    }

    void operator=(const SignalType &signal) { ITypedCANSignal<SignalType>::operator=(signal); }
}
|———Node:{ Text: {
|———Node:function_definition Text: uint8_t temp_buffer[8]{0}
|————Node:primitive_type Text: uint8_t
|————Node:array_declarator Text: temp_buffer[8]
|—————Node:identifier Text: temp_buffer
|—————Node:[ Text: [
|—————Node:number_literal Text: 8
|—————Node:] Text: ]
|————Node:compound_statement Text: {0}
|—————Node:{ Text: {
|—————Node:ERROR Text: 0
|——————Node:number_literal Text: 0
|—————Node:} Text: }
|———Node:expression_statement Text: ;
|————Node:; Text: ;
|———Node:function_definition Text: void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
|————Node:primitive_type Text: void
|————Node:pointer_declarator Text: *temp_buffer_ptr
|—————Node:* Text: *
|—————Node:identifier Text: temp_buffer_ptr
|————Node:compound_statement Text: {temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
|—————Node:{ Text: {
|—————Node:type_identifier Text: temp_buffer
|—————Node:ERROR Text: }
|——————Node:} Text: }
|—————Node:; Text: ;
|—————Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
|——————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask
|———————Node:binary_expression Text: *reinterpret_cast<underlying_type
|————————Node:pointer_expression Text: *reinterpret_cast
|—————————Node:* Text: *
|—————————Node:identifier Text: reinterpret_cast
|————————Node:< Text: <
|————————Node:identifier Text: underlying_type
|———————Node:ERROR Text: *
|————————Node:* Text: *
|———————Node:> Text: >
|———————Node:assignment_expression Text: (temp_buffer_ptr) = *buffer & mask
|————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|—————————Node:( Text: (
|—————————Node:identifier Text: temp_buffer_ptr
|—————————Node:) Text: )
|————————Node:= Text: =
|————————Node:binary_expression Text: *buffer & mask
|—————————Node:pointer_expression Text: *buffer
|——————————Node:* Text: *
|——————————Node:identifier Text: buffer
|—————————Node:& Text: &
|—————————Node:identifier Text: mask
|——————Node:; Text: ;
|—————Node:expression_statement Text: this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
|——————Node:assignment_expression Text: this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|———————Node:field_expression Text: this->signal_
|————————Node:identifier Text: this
|————————Node:-> Text: ->
|————————Node:field_identifier Text: signal_
|———————Node:= Text: =
|———————Node:binary_expression Text: static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|————————Node:binary_expression Text: static_cast<SignalType
|—————————Node:identifier Text: static_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: SignalType
|————————Node:> Text: >
|————————Node:parenthesized_expression Text: (
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset)
|——————————Node:parenthesized_expression Text: (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
                 * CANTemplateGetFloat(factor)
|————————————Node:parenthesized_expression Text: ((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length))
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
                  >> (64 - length)
|——————————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << (64 - (position + length))
|———————————————Node:parenthesized_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr))
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr)
|—————————————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|——————————————————Node:pointer_expression Text: *reinterpret_cast
|———————————————————Node:* Text: *
|———————————————————Node:identifier Text: reinterpret_cast
|——————————————————Node:< Text: <
|——————————————————Node:identifier Text: underlying_type
|—————————————————Node:ERROR Text: *
|——————————————————Node:* Text: *
|—————————————————Node:> Text: >
|—————————————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: temp_buffer_ptr
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|———————————————Node:<< Text: <<
|———————————————Node:parenthesized_expression Text: (64 - (position + length))
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 64 - (position + length)
|—————————————————Node:number_literal Text: 64
|—————————————————Node:- Text: -
|—————————————————Node:parenthesized_expression Text: (position + length)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: position + length
|———————————————————Node:identifier Text: position
|———————————————————Node:+ Text: +
|———————————————————Node:identifier Text: length
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:>> Text: >>
|——————————————Node:parenthesized_expression Text: (64 - length)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: 64 - length
|————————————————Node:number_literal Text: 64
|————————————————Node:- Text: -
|————————————————Node:identifier Text: length
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:* Text: *
|————————————Node:call_expression Text: CANTemplateGetFloat(factor)
|—————————————Node:identifier Text: CANTemplateGetFloat
|—————————————Node:argument_list Text: (factor)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: factor
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:call_expression Text: CANTemplateGetFloat(offset)
|———————————Node:identifier Text: CANTemplateGetFloat
|———————————Node:argument_list Text: (offset)
|————————————Node:( Text: (
|————————————Node:identifier Text: offset
|————————————Node:) Text: )
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:type_identifier Text: else
|———Node:; Text: 
|———Node:compound_statement Text: {
            uint8_t temp_buffer[8]{0};
            void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
    }
|————Node:{ Text: {
|————Node:function_definition Text: uint8_t temp_buffer[8]{0}
|—————Node:primitive_type Text: uint8_t
|—————Node:array_declarator Text: temp_buffer[8]
|——————Node:identifier Text: temp_buffer
|——————Node:[ Text: [
|——————Node:number_literal Text: 8
|——————Node:] Text: ]
|—————Node:compound_statement Text: {0}
|——————Node:{ Text: {
|——————Node:ERROR Text: 0
|———————Node:number_literal Text: 0
|——————Node:} Text: }
|————Node:expression_statement Text: ;
|—————Node:; Text: ;
|————Node:function_definition Text: void *temp_buffer_ptr{temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *temp_buffer_ptr
|——————Node:* Text: *
|——————Node:identifier Text: temp_buffer_ptr
|—————Node:compound_statement Text: {temp_buffer};
            *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
            std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
            this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
        }
|——————Node:{ Text: {
|——————Node:type_identifier Text: temp_buffer
|——————Node:ERROR Text: }
|———————Node:} Text: }
|——————Node:; Text: ;
|——————Node:expression_statement Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask;
|———————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr) = *buffer & mask
|————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|—————————Node:pointer_expression Text: *reinterpret_cast
|——————————Node:* Text: *
|——————————Node:identifier Text: reinterpret_cast
|—————————Node:< Text: <
|—————————Node:identifier Text: underlying_type
|————————Node:ERROR Text: *
|—————————Node:* Text: *
|————————Node:> Text: >
|————————Node:assignment_expression Text: (temp_buffer_ptr) = *buffer & mask
|—————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|——————————Node:( Text: (
|——————————Node:identifier Text: temp_buffer_ptr
|——————————Node:) Text: )
|—————————Node:= Text: =
|—————————Node:binary_expression Text: *buffer & mask
|——————————Node:pointer_expression Text: *buffer
|———————————Node:* Text: *
|———————————Node:identifier Text: buffer
|——————————Node:& Text: &
|——————————Node:identifier Text: mask
|———————Node:; Text: ;
|——————Node:labeled_statement Text: std::reverse(std::begin(temp_buffer), std::end(temp_buffer));
|———————Node:statement_identifier Text: std
|———————Node:: Text: :
|———————Node:ERROR Text: :
|————————Node:: Text: :
|———————Node:labeled_statement Text: reverse(std::begin(temp_buffer), std::end(temp_buffer));
|————————Node:statement_identifier Text: reverse
|————————Node:ERROR Text: (std::begin(temp_buffer), std:
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: std
|——————————Node:type_identifier Text: std
|—————————Node:: Text: :
|—————————Node:: Text: :
|—————————Node:comma_expression Text: begin(temp_buffer), std
|——————————Node:call_expression Text: begin(temp_buffer)
|———————————Node:identifier Text: begin
|———————————Node:argument_list Text: (temp_buffer)
|————————————Node:( Text: (
|————————————Node:identifier Text: temp_buffer
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: std
|—————————Node:: Text: :
|————————Node:: Text: :
|————————Node:expression_statement Text: end(temp_buffer));
|—————————Node:call_expression Text: end(temp_buffer)
|——————————Node:identifier Text: end
|——————————Node:argument_list Text: (temp_buffer)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_buffer
|———————————Node:) Text: )
|—————————Node:ERROR Text: )
|——————————Node:) Text: )
|—————————Node:; Text: ;
|——————Node:expression_statement Text: this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset));
|———————Node:assignment_expression Text: this->signal_ = static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|————————Node:field_expression Text: this->signal_
|—————————Node:identifier Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: signal_
|————————Node:= Text: =
|————————Node:binary_expression Text: static_cast<SignalType>(
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|—————————Node:binary_expression Text: static_cast<SignalType
|——————————Node:identifier Text: static_cast
|——————————Node:< Text: <
|——————————Node:identifier Text: SignalType
|—————————Node:> Text: >
|—————————Node:parenthesized_expression Text: (
                (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
                + CANTemplateGetFloat(offset)
|———————————Node:parenthesized_expression Text: (((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor))
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
                 * CANTemplateGetFloat(factor)
|—————————————Node:parenthesized_expression Text: ((*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length))
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position >> (64 - length)
|———————————————Node:binary_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr)) << position
|————————————————Node:parenthesized_expression Text: (*reinterpret_cast<underlying_type *>(temp_buffer_ptr))
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: *reinterpret_cast<underlying_type *>(temp_buffer_ptr)
|——————————————————Node:binary_expression Text: *reinterpret_cast<underlying_type
|———————————————————Node:pointer_expression Text: *reinterpret_cast
|————————————————————Node:* Text: *
|————————————————————Node:identifier Text: reinterpret_cast
|———————————————————Node:< Text: <
|———————————————————Node:identifier Text: underlying_type
|——————————————————Node:ERROR Text: *
|———————————————————Node:* Text: *
|——————————————————Node:> Text: >
|——————————————————Node:parenthesized_expression Text: (temp_buffer_ptr)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: temp_buffer_ptr
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|————————————————Node:<< Text: <<
|————————————————Node:identifier Text: position
|———————————————Node:>> Text: >>
|———————————————Node:parenthesized_expression Text: (64 - length)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 64 - length
|—————————————————Node:number_literal Text: 64
|—————————————————Node:- Text: -
|—————————————————Node:identifier Text: length
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|—————————————Node:* Text: *
|—————————————Node:call_expression Text: CANTemplateGetFloat(factor)
|——————————————Node:identifier Text: CANTemplateGetFloat
|——————————————Node:argument_list Text: (factor)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: factor
|———————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:+ Text: +
|———————————Node:call_expression Text: CANTemplateGetFloat(offset)
|————————————Node:identifier Text: CANTemplateGetFloat
|————————————Node:argument_list Text: (offset)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: offset
|—————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|———Node:declaration Text: void operator=(const SignalType &signal)
|————Node:primitive_type Text: void
|————Node:init_declarator Text: operator=(const SignalType &signal)
|—————Node:identifier Text: operator
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (const SignalType &signal)
|——————Node:( Text: (
|——————Node:ERROR Text: const SignalType
|———————Node:type_descriptor Text: const SignalType
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:type_identifier Text: SignalType
|——————Node:pointer_expression Text: &signal
|———————Node:& Text: &
|———————Node:identifier Text: signal
|——————Node:) Text: )
|————Node:; Text: 
|———Node:compound_statement Text: { ITypedCANSignal<SignalType>::operator=(signal); }
|————Node:{ Text: {
|————Node:expression_statement Text: ITypedCANSignal<SignalType>::operator=(signal);
|—————Node:binary_expression Text: ITypedCANSignal<SignalType>::operator=(signal)
|——————Node:binary_expression Text: ITypedCANSignal<SignalType
|———————Node:identifier Text: ITypedCANSignal
|———————Node:< Text: <
|———————Node:identifier Text: SignalType
|——————Node:> Text: >
|——————Node:ERROR Text: ::
|———————Node:: Text: :
|———————Node:: Text: :
|——————Node:assignment_expression Text: operator=(signal)
|———————Node:identifier Text: operator
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: (signal)
|————————Node:( Text: (
|————————Node:identifier Text: signal
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:comment
|—Node:preproc_function_def Text: #define MakeEndianUnsignedCANSignal(SignalType, position, length, factor, offset, byte_order) \
    CANSignal<SignalType,                                                                     \
              position,                                                                       \
              length,                                                                         \
              CANTemplateConvertFloat(factor),                                                \
              CANTemplateConvertFloat(offset),                                                \
              false,                                                                          \
              byte_order>

|——Node:#define Text: #define
|——Node:identifier Text: MakeEndianUnsignedCANSignal
|——Node:preproc_params Text: (SignalType, position, length, factor, offset, byte_order)
|———Node:( Text: (
|———Node:identifier Text: SignalType
|———Node:, Text: ,
|———Node:identifier Text: position
|———Node:, Text: ,
|———Node:identifier Text: length
|———Node:, Text: ,
|———Node:identifier Text: factor
|———Node:, Text: ,
|———Node:identifier Text: offset
|———Node:, Text: ,
|———Node:identifier Text: byte_order
|———Node:) Text: )
|——Node:preproc_arg Text: CANSignal<SignalType,                                                                     \
              position,                                                                       \
              length,                                                                         \
              CANTemplateConvertFloat(factor),                                                \
              CANTemplateConvertFloat(offset),                                                \
              false,                                                                          \
              byte_order>
|—Node:preproc_function_def Text: #define MakeEndianSignedCANSignal(SignalType, position, length, factor, offset, byte_order) \
    CANSignal<SignalType,                                                                   \
              position,                                                                     \
              length,                                                                       \
              CANTemplateConvertFloat(factor),                                              \
              CANTemplateConvertFloat(offset),                                              \
              true,                                                                         \
              byte_order>

|——Node:#define Text: #define
|——Node:identifier Text: MakeEndianSignedCANSignal
|——Node:preproc_params Text: (SignalType, position, length, factor, offset, byte_order)
|———Node:( Text: (
|———Node:identifier Text: SignalType
|———Node:, Text: ,
|———Node:identifier Text: position
|———Node:, Text: ,
|———Node:identifier Text: length
|———Node:, Text: ,
|———Node:identifier Text: factor
|———Node:, Text: ,
|———Node:identifier Text: offset
|———Node:, Text: ,
|———Node:identifier Text: byte_order
|———Node:) Text: )
|——Node:preproc_arg Text: CANSignal<SignalType,                                                                   \
              position,                                                                     \
              length,                                                                       \
              CANTemplateConvertFloat(factor),                                              \
              CANTemplateConvertFloat(offset),                                              \
              true,                                                                         \
              byte_order>
|—Node:preproc_function_def Text: #define MakeUnsignedCANSignal(SignalType, position, length, factor, offset) \
    MakeEndianUnsignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)

|——Node:#define Text: #define
|——Node:identifier Text: MakeUnsignedCANSignal
|——Node:preproc_params Text: (SignalType, position, length, factor, offset)
|———Node:( Text: (
|———Node:identifier Text: SignalType
|———Node:, Text: ,
|———Node:identifier Text: position
|———Node:, Text: ,
|———Node:identifier Text: length
|———Node:, Text: ,
|———Node:identifier Text: factor
|———Node:, Text: ,
|———Node:identifier Text: offset
|———Node:) Text: )
|——Node:preproc_arg Text: MakeEndianUnsignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)
|—Node:preproc_function_def Text: #define MakeSignedCANSignal(SignalType, position, length, factor, offset) \
    MakeEndianSignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)

|——Node:#define Text: #define
|——Node:identifier Text: MakeSignedCANSignal
|——Node:preproc_params Text: (SignalType, position, length, factor, offset)
|———Node:( Text: (
|———Node:identifier Text: SignalType
|———Node:, Text: ,
|———Node:identifier Text: position
|———Node:, Text: ,
|———Node:identifier Text: length
|———Node:, Text: ,
|———Node:identifier Text: factor
|———Node:, Text: ,
|———Node:identifier Text: offset
|———Node:) Text: )
|——Node:preproc_arg Text: MakeEndianSignedCANSignal(SignalType, position, length, factor, offset, ICANSignal::ByteOrder::kLittleEndian)
|—Node:function_definition Text: class ICANTXMessage
{
public:
    virtual uint16_t GetID() = 0;
    virtual VirtualTimer &GetTransmitTimer() = 0;
    virtual void EncodeSignals() = 0;
    virtual void EncodeAndSend() = 0;
}
|——Node:type_identifier Text: class
|——Node:identifier Text: ICANTXMessage
|——Node:compound_statement Text: {
public:
    virtual uint16_t GetID() = 0;
    virtual VirtualTimer &GetTransmitTimer() = 0;
    virtual void EncodeSignals() = 0;
    virtual void EncodeAndSend() = 0;
}
|———Node:{ Text: {
|———Node:labeled_statement Text: public:
    virtual uint16_t GetID() = 0;
|————Node:statement_identifier Text: public
|————Node:: Text: :
|————Node:declaration Text: virtual uint16_t GetID() = 0;
|—————Node:type_identifier Text: virtual
|—————Node:ERROR Text: uint16_t
|——————Node:identifier Text: uint16_t
|—————Node:init_declarator Text: GetID() = 0
|——————Node:function_declarator Text: GetID()
|———————Node:identifier Text: GetID
|———————Node:parameter_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:declaration Text: virtual VirtualTimer
|————Node:type_identifier Text: virtual
|————Node:identifier Text: VirtualTimer
|————Node:; Text: 
|———Node:expression_statement Text: &GetTransmitTimer() = 0;
|————Node:assignment_expression Text: &GetTransmitTimer() = 0
|—————Node:pointer_expression Text: &GetTransmitTimer()
|——————Node:& Text: &
|——————Node:call_expression Text: GetTransmitTimer()
|———————Node:identifier Text: GetTransmitTimer
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: virtual void EncodeSignals() = 0;
|————Node:type_identifier Text: virtual
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:init_declarator Text: EncodeSignals() = 0
|—————Node:function_declarator Text: EncodeSignals()
|——————Node:identifier Text: EncodeSignals
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: virtual void EncodeAndSend() = 0;
|————Node:type_identifier Text: virtual
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:init_declarator Text: EncodeAndSend() = 0
|—————Node:function_declarator Text: EncodeAndSend()
|——————Node:identifier Text: EncodeAndSend
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:function_definition Text: class ICANRXMessage
{
public:
    virtual uint16_t GetID() = 0;
    virtual void DecodeSignals(CANMessage message) = 0;
}
|——Node:type_identifier Text: class
|——Node:identifier Text: ICANRXMessage
|——Node:compound_statement Text: {
public:
    virtual uint16_t GetID() = 0;
    virtual void DecodeSignals(CANMessage message) = 0;
}
|———Node:{ Text: {
|———Node:labeled_statement Text: public:
    virtual uint16_t GetID() = 0;
|————Node:statement_identifier Text: public
|————Node:: Text: :
|————Node:declaration Text: virtual uint16_t GetID() = 0;
|—————Node:type_identifier Text: virtual
|—————Node:ERROR Text: uint16_t
|——————Node:identifier Text: uint16_t
|—————Node:init_declarator Text: GetID() = 0
|——————Node:function_declarator Text: GetID()
|———————Node:identifier Text: GetID
|———————Node:parameter_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:declaration Text: virtual void DecodeSignals(CANMessage message) = 0;
|————Node:type_identifier Text: virtual
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:init_declarator Text: DecodeSignals(CANMessage message) = 0
|—————Node:function_declarator Text: DecodeSignals(CANMessage message)
|——————Node:identifier Text: DecodeSignals
|——————Node:parameter_list Text: (CANMessage message)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: CANMessage message
|————————Node:type_identifier Text: CANMessage
|————————Node:identifier Text: message
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:type_identifier Text: class
|—Node:identifier Text: ICAN
|—Node:{ Text: {
|—Node:labeled_statement Text: public:
    enum class BaudRate
    {
        kBaud1M = 1000000,
        kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
    };

    virtual void Initialize(BaudRate baud);

    virtual bool SendMessage(CANMessage &msg) = 0;

    virtual void RegisterRXMessage(ICANRXMessage &msg) = 0;

    virtual void Tick() = 0;
}
|——Node:statement_identifier Text: public
|——Node:: Text: :
|——Node:ERROR Text: enum class BaudRate
|———Node:enum_specifier Text: enum class
|————Node:enum Text: enum
|————Node:type_identifier Text: class
|———Node:identifier Text: BaudRate
|——Node:compound_statement Text: {
        kBaud1M = 1000000,
        kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
    };

    virtual void Initialize(BaudRate baud);

    virtual bool SendMessage(CANMessage &msg) = 0;

    virtual void RegisterRXMessage(ICANRXMessage &msg) = 0;

    virtual void Tick() = 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: kBaud1M = 1000000,
        kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
    };
|————Node:comma_expression Text: kBaud1M = 1000000,
        kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
|—————Node:assignment_expression Text: kBaud1M = 1000000
|——————Node:identifier Text: kBaud1M
|——————Node:= Text: =
|——————Node:number_literal Text: 1000000
|—————Node:, Text: ,
|—————Node:comma_expression Text: kBaud500K = 500000,
        kBaud250K = 250000,
        kBaud125k = 125000
|——————Node:assignment_expression Text: kBaud500K = 500000
|———————Node:identifier Text: kBaud500K
|———————Node:= Text: =
|———————Node:number_literal Text: 500000
|——————Node:, Text: ,
|——————Node:comma_expression Text: kBaud250K = 250000,
        kBaud125k = 125000
|———————Node:assignment_expression Text: kBaud250K = 250000
|————————Node:identifier Text: kBaud250K
|————————Node:= Text: =
|————————Node:number_literal Text: 250000
|———————Node:, Text: ,
|———————Node:assignment_expression Text: kBaud125k = 125000
|————————Node:identifier Text: kBaud125k
|————————Node:= Text: =
|————————Node:number_literal Text: 125000
|————Node:ERROR Text: }
|—————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: virtual void Initialize(BaudRate baud);
|————Node:type_identifier Text: virtual
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:function_declarator Text: Initialize(BaudRate baud)
|—————Node:identifier Text: Initialize
|—————Node:parameter_list Text: (BaudRate baud)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: BaudRate baud
|———————Node:type_identifier Text: BaudRate
|———————Node:identifier Text: baud
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: virtual bool
|————Node:type_identifier Text: virtual
|————Node:identifier Text: bool
|————Node:; Text: 
|———Node:expression_statement Text: SendMessage(CANMessage &msg) = 0;
|————Node:assignment_expression Text: SendMessage(CANMessage &msg) = 0
|—————Node:call_expression Text: SendMessage(CANMessage &msg)
|——————Node:identifier Text: SendMessage
|——————Node:argument_list Text: (CANMessage &msg)
|———————Node:( Text: (
|———————Node:binary_expression Text: CANMessage &msg
|————————Node:identifier Text: CANMessage
|————————Node:& Text: &
|————————Node:identifier Text: msg
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: virtual void
|————Node:type_identifier Text: virtual
|————Node:identifier Text: void
|————Node:; Text: 
|———Node:expression_statement Text: RegisterRXMessage(ICANRXMessage &msg) = 0;
|————Node:assignment_expression Text: RegisterRXMessage(ICANRXMessage &msg) = 0
|—————Node:call_expression Text: RegisterRXMessage(ICANRXMessage &msg)
|——————Node:identifier Text: RegisterRXMessage
|——————Node:argument_list Text: (ICANRXMessage &msg)
|———————Node:( Text: (
|———————Node:binary_expression Text: ICANRXMessage &msg
|————————Node:identifier Text: ICANRXMessage
|————————Node:& Text: &
|————————Node:identifier Text: msg
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: virtual void Tick() = 0;
|————Node:type_identifier Text: virtual
|————Node:ERROR Text: void
|—————Node:identifier Text: void
|————Node:init_declarator Text: Tick() = 0
|—————Node:function_declarator Text: Tick()
|——————Node:identifier Text: Tick
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:comment
|—Node:expression_statement Text: template <size_t num_signals>
class
|——Node:binary_expression Text: template <size_t num_signals>
class
|———Node:binary_expression Text: template <size_t num_signals
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: size_t
|—————Node:identifier Text: size_t
|————Node:identifier Text: num_signals
|———Node:> Text: >
|———Node:identifier Text: class
|——Node:; Text: 
|—Node:labeled_statement Text: CANTXMessage : public ICANTXMessage
{
public:
    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_{id, length, std::array<uint8_t, 8>()},
          transmit_timer_{period, [this]() { this->EncodeAndSend(); }, VirtualTimer::Type::kRepeating},
          signals_{&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }

    void EncodeAndSend() override
    {
        EncodeSignals();
        can_interface_.SendMessage(message_);
    }

    uint16_t GetID() { return message_.id_; }

    VirtualTimer &GetTransmitTimer() { return transmit_timer_; }

    void Enable() { transmit_timer_.Enable(); }
    void Disable() { transmit_timer_.Disable(); }

private:
    ICAN &can_interface_;
    CANMessage message_;
    VirtualTimer transmit_timer_;
    std::array<ICANSignal *, num_signals> signals_;

    void EncodeSignals()
    {
        uint8_t temp_raw[8]{0};
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
        std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
    }
}
|——Node:statement_identifier Text: CANTXMessage
|——Node:: Text: :
|——Node:ERROR Text: public ICANTXMessage
|———Node:type_identifier Text: public
|———Node:identifier Text: ICANTXMessage
|——Node:compound_statement Text: {
public:
    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_{id, length, std::array<uint8_t, 8>()},
          transmit_timer_{period, [this]() { this->EncodeAndSend(); }, VirtualTimer::Type::kRepeating},
          signals_{&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }

    void EncodeAndSend() override
    {
        EncodeSignals();
        can_interface_.SendMessage(message_);
    }

    uint16_t GetID() { return message_.id_; }

    VirtualTimer &GetTransmitTimer() { return transmit_timer_; }

    void Enable() { transmit_timer_.Enable(); }
    void Disable() { transmit_timer_.Disable(); }

private:
    ICAN &can_interface_;
    CANMessage message_;
    VirtualTimer transmit_timer_;
    std::array<ICANSignal *, num_signals> signals_;

    void EncodeSignals()
    {
        uint8_t temp_raw[8]{0};
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
        std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
    }
}
|———Node:{ Text: {
|———Node:labeled_statement Text: public:
    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_
|————Node:statement_identifier Text: public
|————Node:: Text: :
|————Node:expression_statement Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_
|—————Node:comma_expression Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
        : can_interface_{can_interface},
          message_
|——————Node:binary_expression Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
|———————Node:binary_expression Text: template <typename
|————————Node:identifier Text: template
|————————Node:< Text: <
|————————Node:identifier Text: typename
|———————Node:ERROR Text: ... Ts
|————————Node:... Text: ...
|————————Node:identifier Text: Ts
|———————Node:> Text: >
|———————Node:comment
|———————Node:call_expression Text: CANTXMessage(ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
|————————Node:identifier Text: CANTXMessage
|————————Node:argument_list Text: (ICAN &can_interface, uint16_t id, uint8_t length, uint32_t period, Ts &...signals)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ICAN &can_interface
|——————————Node:identifier Text: ICAN
|——————————Node:& Text: &
|——————————Node:identifier Text: can_interface
|—————————Node:, Text: ,
|—————————Node:identifier Text: uint16_t
|—————————Node:ERROR Text: id
|——————————Node:identifier Text: id
|—————————Node:, Text: ,
|—————————Node:identifier Text: uint8_t
|—————————Node:ERROR Text: length
|——————————Node:identifier Text: length
|—————————Node:, Text: ,
|—————————Node:identifier Text: uint32_t
|—————————Node:ERROR Text: period
|——————————Node:identifier Text: period
|—————————Node:, Text: ,
|—————————Node:field_expression Text: Ts &...signals
|——————————Node:identifier Text: Ts
|——————————Node:ERROR Text: &..
|———————————Node:& Text: &
|———————————Node:. Text: .
|———————————Node:. Text: .
|——————————Node:. Text: .
|——————————Node:field_identifier Text: signals
|—————————Node:) Text: )
|——————Node:ERROR Text: : can_interface_{can_interface}
|———————Node:: Text: :
|———————Node:identifier Text: can_interface_
|———————Node:{ Text: {
|———————Node:identifier Text: can_interface
|———————Node:} Text: }
|——————Node:, Text: ,
|——————Node:identifier Text: message_
|—————Node:; Text: 
|———Node:compound_statement Text: {id, length, std::array<uint8_t, 8>()}
|————Node:{ Text: {
|————Node:ERROR Text: id, length, std::array<uint8_t, 8>()
|—————Node:comma_expression Text: id, length, std
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:comma_expression Text: length, std
|———————Node:identifier Text: length
|———————Node:, Text: ,
|———————Node:identifier Text: std
|—————Node:: Text: :
|—————Node:: Text: :
|—————Node:binary_expression Text: array<uint8_t
|——————Node:identifier Text: array
|——————Node:< Text: <
|——————Node:identifier Text: uint8_t
|—————Node:, Text: ,
|—————Node:number_literal Text: 8
|—————Node:> Text: >
|—————Node:( Text: (
|—————Node:) Text: )
|————Node:} Text: }
|———Node:ERROR Text: ,
          transmit_timer_{period, [this]()
|————Node:, Text: ,
|————Node:type_identifier Text: transmit_timer_
|————Node:ERROR Text: {
|—————Node:{ Text: {
|————Node:identifier Text: period
|————Node:, Text: ,
|————Node:function_declarator Text:  [this]()
|—————Node:array_declarator Text:  [this]
|——————Node:identifier Text: 
|——————Node:[ Text: [
|——————Node:identifier Text: this
|——————Node:] Text: ]
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|———Node:compound_statement Text: { this->EncodeAndSend(); }
|————Node:{ Text: {
|————Node:expression_statement Text: this->EncodeAndSend();
|—————Node:call_expression Text: this->EncodeAndSend()
|——————Node:field_expression Text: this->EncodeAndSend
|———————Node:identifier Text: this
|———————Node:-> Text: ->
|———————Node:field_identifier Text: EncodeAndSend
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|———Node:ERROR Text: ,
|————Node:, Text: ,
|———Node:labeled_statement Text: VirtualTimer::Type::kRepeating},
          signals_{&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }
|————Node:statement_identifier Text: VirtualTimer
|————Node:: Text: :
|————Node:ERROR Text: :
|—————Node:: Text: :
|————Node:labeled_statement Text: Type::kRepeating},
          signals_{&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }
|—————Node:statement_identifier Text: Type
|—————Node:: Text: :
|—————Node:ERROR Text: :kRepeating},
          signals_
|——————Node:: Text: :
|——————Node:comma_expression Text: kRepeating},
          signals_
|———————Node:identifier Text: kRepeating
|———————Node:ERROR Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:identifier Text: signals_
|—————Node:compound_statement Text: {&signals...}
    {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }

    template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
    }
|——————Node:{ Text: {
|——————Node:ERROR Text: &signals...}
|———————Node:pointer_expression Text: &signals
|————————Node:& Text: &
|————————Node:identifier Text: signals
|———————Node:... Text: ...
|———————Node:} Text: }
|——————Node:compound_statement Text: {
        static_assert(sizeof...(signals) == num_signals, "Wrong number of signals passed into CANTXMessage.");
    }
|———————Node:{ Text: {
|———————Node:ERROR Text: static_assert(sizeof...(signals) == num_signals,
|————————Node:macro_type_specifier Text: static_assert(sizeof...(signals)
|—————————Node:identifier Text: static_assert
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: sizeof
|——————————Node:type_identifier Text: sizeof
|—————————Node:ERROR Text: ...(signals
|——————————Node:... Text: ...
|——————————Node:( Text: (
|——————————Node:identifier Text: signals
|—————————Node:) Text: )
|————————Node:ERROR Text: ==
|—————————Node:== Text: ==
|————————Node:identifier Text: num_signals
|————————Node:, Text: ,
|———————Node:expression_statement Text: "Wrong number of signals passed into CANTXMessage.");
|————————Node:string_literal Text: "Wrong number of signals passed into CANTXMessage."
|—————————Node:" Text: "
|—————————Node:string_content Text: Wrong number of signals passed into CANTXMessage.
|—————————Node:" Text: "
|————————Node:ERROR Text: )
|—————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:expression_statement Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_);
|———————Node:comma_expression Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
        : CANTXMessage(can_interface, id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_)
|————————Node:binary_expression Text: template <typename... Ts>
    /**
     * @brief Construct a new CANTXMessage object and automatically adds it to a VirtualTimerGroup
     *
     * @param can_interface The ICAN object the message will be transmitted on
     * @param id The ID of the CAN message
     * @param length The length in bytes of the message
     * @param period The transmit period in ms of the message
     * @param start_time The time in ms to start transmitting the message
     * @param timer_group A timer group to add the transmit timer to
     * @param signals The ICANSignals contained in the message
     */
    CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
|—————————Node:binary_expression Text: template <typename
|——————————Node:identifier Text: template
|——————————Node:< Text: <
|——————————Node:identifier Text: typename
|—————————Node:ERROR Text: ... Ts
|——————————Node:... Text: ...
|——————————Node:identifier Text: Ts
|—————————Node:> Text: >
|—————————Node:comment
|—————————Node:call_expression Text: CANTXMessage(ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
|——————————Node:identifier Text: CANTXMessage
|——————————Node:argument_list Text: (ICAN &can_interface,
                 uint16_t id,
                 uint8_t length,
                 uint32_t period,
                 VirtualTimerGroup &timer_group,
                 Ts &...signals)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ICAN &can_interface
|————————————Node:identifier Text: ICAN
|————————————Node:& Text: &
|————————————Node:identifier Text: can_interface
|———————————Node:, Text: ,
|———————————Node:identifier Text: uint16_t
|———————————Node:ERROR Text: id
|————————————Node:identifier Text: id
|———————————Node:, Text: ,
|———————————Node:identifier Text: uint8_t
|———————————Node:ERROR Text: length
|————————————Node:identifier Text: length
|———————————Node:, Text: ,
|———————————Node:identifier Text: uint32_t
|———————————Node:ERROR Text: period
|————————————Node:identifier Text: period
|———————————Node:, Text: ,
|———————————Node:binary_expression Text: VirtualTimerGroup &timer_group
|————————————Node:identifier Text: VirtualTimerGroup
|————————————Node:& Text: &
|————————————Node:identifier Text: timer_group
|———————————Node:, Text: ,
|———————————Node:field_expression Text: Ts &...signals
|————————————Node:identifier Text: Ts
|————————————Node:ERROR Text: &..
|—————————————Node:& Text: &
|—————————————Node:. Text: .
|—————————————Node:. Text: .
|————————————Node:. Text: .
|————————————Node:field_identifier Text: signals
|———————————Node:) Text: )
|————————Node:ERROR Text: : CANTXMessage(can_interface
|—————————Node:: Text: :
|—————————Node:identifier Text: CANTXMessage
|—————————Node:( Text: (
|—————————Node:identifier Text: can_interface
|————————Node:, Text: ,
|————————Node:comma_expression Text: id, length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_)
|—————————Node:identifier Text: id
|—————————Node:, Text: ,
|—————————Node:comma_expression Text: length, period, signals...)
    {
        timer_group.AddTimer(transmit_timer_)
|——————————Node:identifier Text: length
|——————————Node:, Text: ,
|——————————Node:comma_expression Text: period, signals...)
    {
        timer_group.AddTimer(transmit_timer_)
|———————————Node:identifier Text: period
|———————————Node:, Text: ,
|———————————Node:ERROR Text: signals...)
    {
|————————————Node:identifier Text: signals
|————————————Node:... Text: ...
|————————————Node:) Text: )
|————————————Node:{ Text: {
|———————————Node:call_expression Text: timer_group.AddTimer(transmit_timer_)
|————————————Node:field_expression Text: timer_group.AddTimer
|—————————————Node:identifier Text: timer_group
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: AddTimer
|————————————Node:argument_list Text: (transmit_timer_)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: transmit_timer_
|—————————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:function_definition Text: void EncodeAndSend() override
    {
        EncodeSignals();
        can_interface_.SendMessage(message_);
    }
|————Node:primitive_type Text: void
|————Node:function_declarator Text: EncodeAndSend() override
|—————Node:identifier Text: EncodeAndSend
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|—————Node:identifier Text: override
|————Node:compound_statement Text: {
        EncodeSignals();
        can_interface_.SendMessage(message_);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: EncodeSignals();
|——————Node:call_expression Text: EncodeSignals()
|———————Node:identifier Text: EncodeSignals
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: can_interface_.SendMessage(message_);
|——————Node:call_expression Text: can_interface_.SendMessage(message_)
|———————Node:field_expression Text: can_interface_.SendMessage
|————————Node:identifier Text: can_interface_
|————————Node:. Text: .
|————————Node:field_identifier Text: SendMessage
|———————Node:argument_list Text: (message_)
|————————Node:( Text: (
|————————Node:identifier Text: message_
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:function_definition Text: uint16_t GetID() { return message_.id_; }
|————Node:primitive_type Text: uint16_t
|————Node:function_declarator Text: GetID()
|—————Node:identifier Text: GetID
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:compound_statement Text: { return message_.id_; }
|—————Node:{ Text: {
|—————Node:return_statement Text: return message_.id_;
|——————Node:return Text: return
|——————Node:field_expression Text: message_.id_
|———————Node:identifier Text: message_
|———————Node:. Text: .
|———————Node:field_identifier Text: id_
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: VirtualTimer &GetTransmitTimer()
|————Node:binary_expression Text: VirtualTimer &GetTransmitTimer()
|—————Node:identifier Text: VirtualTimer
|—————Node:& Text: &
|—————Node:call_expression Text: GetTransmitTimer()
|——————Node:identifier Text: GetTransmitTimer
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: 
|———Node:compound_statement Text: { return transmit_timer_; }
|————Node:{ Text: {
|————Node:return_statement Text: return transmit_timer_;
|—————Node:return Text: return
|—————Node:identifier Text: transmit_timer_
|—————Node:; Text: ;
|————Node:} Text: }
|———Node:function_definition Text: void Enable() { transmit_timer_.Enable(); }
|————Node:primitive_type Text: void
|————Node:function_declarator Text: Enable()
|—————Node:identifier Text: Enable
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:compound_statement Text: { transmit_timer_.Enable(); }
|—————Node:{ Text: {
|—————Node:expression_statement Text: transmit_timer_.Enable();
|——————Node:call_expression Text: transmit_timer_.Enable()
|———————Node:field_expression Text: transmit_timer_.Enable
|————————Node:identifier Text: transmit_timer_
|————————Node:. Text: .
|————————Node:field_identifier Text: Enable
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:function_definition Text: void Disable() { transmit_timer_.Disable(); }
|————Node:primitive_type Text: void
|————Node:function_declarator Text: Disable()
|—————Node:identifier Text: Disable
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:compound_statement Text: { transmit_timer_.Disable(); }
|—————Node:{ Text: {
|—————Node:expression_statement Text: transmit_timer_.Disable();
|——————Node:call_expression Text: transmit_timer_.Disable()
|———————Node:field_expression Text: transmit_timer_.Disable
|————————Node:identifier Text: transmit_timer_
|————————Node:. Text: .
|————————Node:field_identifier Text: Disable
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:labeled_statement Text: private:
    ICAN &can_interface_;
|————Node:statement_identifier Text: private
|————Node:: Text: :
|————Node:expression_statement Text: ICAN &can_interface_;
|—————Node:binary_expression Text: ICAN &can_interface_
|——————Node:identifier Text: ICAN
|——————Node:& Text: &
|——————Node:identifier Text: can_interface_
|—————Node:; Text: ;
|———Node:declaration Text: CANMessage message_;
|————Node:type_identifier Text: CANMessage
|————Node:identifier Text: message_
|————Node:; Text: ;
|———Node:declaration Text: VirtualTimer transmit_timer_;
|————Node:type_identifier Text: VirtualTimer
|————Node:identifier Text: transmit_timer_
|————Node:; Text: ;
|———Node:labeled_statement Text: std::array<ICANSignal *, num_signals> signals_;
|————Node:statement_identifier Text: std
|————Node:: Text: :
|————Node:ERROR Text: :
|—————Node:: Text: :
|————Node:expression_statement Text: array<ICANSignal *, num_signals> signals_;
|—————Node:binary_expression Text: array<ICANSignal *, num_signals> signals_
|——————Node:binary_expression Text: array<ICANSignal *, num_signals
|———————Node:identifier Text: array
|———————Node:< Text: <
|———————Node:binary_expression Text: ICANSignal *, num_signals
|————————Node:identifier Text: ICANSignal
|————————Node:* Text: *
|————————Node:ERROR Text: ,
|—————————Node:, Text: ,
|————————Node:identifier Text: num_signals
|——————Node:> Text: >
|——————Node:identifier Text: signals_
|—————Node:; Text: ;
|———Node:function_definition Text: void EncodeSignals()
    {
        uint8_t temp_raw[8]{0};
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
        std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
    }
|————Node:primitive_type Text: void
|————Node:function_declarator Text: EncodeSignals()
|—————Node:identifier Text: EncodeSignals
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:compound_statement Text: {
        uint8_t temp_raw[8]{0};
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
        std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
    }
|—————Node:{ Text: {
|—————Node:function_definition Text: uint8_t temp_raw[8]{0}
|——————Node:primitive_type Text: uint8_t
|——————Node:array_declarator Text: temp_raw[8]
|———————Node:identifier Text: temp_raw
|———————Node:[ Text: [
|———————Node:number_literal Text: 8
|———————Node:] Text: ]
|——————Node:compound_statement Text: {0}
|———————Node:{ Text: {
|———————Node:ERROR Text: 0
|————————Node:number_literal Text: 0
|———————Node:} Text: }
|—————Node:expression_statement Text: ;
|——————Node:; Text: ;
|—————Node:for_statement Text: for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: uint8_t i = 0;
|———————Node:primitive_type Text: uint8_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < num_signals
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: num_signals
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw));
|————————Node:call_expression Text: signals_[i]->EncodeSignal(reinterpret_cast<uint64_t *>(temp_raw))
|—————————Node:field_expression Text: signals_[i]->EncodeSignal
|——————————Node:subscript_expression Text: signals_[i]
|———————————Node:identifier Text: signals_
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: EncodeSignal
|—————————Node:argument_list Text: (reinterpret_cast<uint64_t *>(temp_raw))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: reinterpret_cast<uint64_t *>(temp_raw)
|———————————Node:binary_expression Text: reinterpret_cast<uint64_t
|————————————Node:identifier Text: reinterpret_cast
|————————————Node:< Text: <
|————————————Node:identifier Text: uint64_t
|———————————Node:ERROR Text: *
|————————————Node:* Text: *
|———————————Node:> Text: >
|———————————Node:parenthesized_expression Text: (temp_raw)
|————————————Node:( Text: (
|————————————Node:identifier Text: temp_raw
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:labeled_statement Text: std::copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
|——————Node:statement_identifier Text: std
|——————Node:: Text: :
|——————Node:ERROR Text: :
|———————Node:: Text: :
|——————Node:labeled_statement Text: copy(std::begin(temp_raw), std::end(temp_raw), message_.data_.begin());
|———————Node:statement_identifier Text: copy
|———————Node:ERROR Text: (std::begin(temp_raw), std:
|————————Node:( Text: (
|————————Node:type_descriptor Text: std
|—————————Node:type_identifier Text: std
|————————Node:: Text: :
|————————Node:: Text: :
|————————Node:comma_expression Text: begin(temp_raw), std
|—————————Node:call_expression Text: begin(temp_raw)
|——————————Node:identifier Text: begin
|——————————Node:argument_list Text: (temp_raw)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_raw
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: std
|————————Node:: Text: :
|———————Node:: Text: :
|———————Node:expression_statement Text: end(temp_raw), message_.data_.begin());
|————————Node:comma_expression Text: end(temp_raw), message_.data_.begin()
|—————————Node:call_expression Text: end(temp_raw)
|——————————Node:identifier Text: end
|——————————Node:argument_list Text: (temp_raw)
|———————————Node:( Text: (
|———————————Node:identifier Text: temp_raw
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: message_.data_.begin()
|——————————Node:field_expression Text: message_.data_.begin
|———————————Node:field_expression Text: message_.data_
|————————————Node:identifier Text: message_
|————————————Node:. Text: .
|————————————Node:field_identifier Text: data_
|———————————Node:. Text: .
|———————————Node:field_identifier Text: begin
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:ERROR Text: )
|—————————Node:) Text: )
|————————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:comment
|—Node:expression_statement Text: template <size_t num_signals>
class
|——Node:binary_expression Text: template <size_t num_signals>
class
|———Node:binary_expression Text: template <size_t num_signals
|————Node:identifier Text: template
|————Node:< Text: <
|————Node:ERROR Text: size_t
|—————Node:identifier Text: size_t
|————Node:identifier Text: num_signals
|———Node:> Text: >
|———Node:identifier Text: class
|——Node:; Text: 
|—Node:identifier Text: CANRXMessage
|—Node:: Text: :
|—Node:ERROR Text: public ICANRXMessage
|——Node:type_identifier Text: public
|——Node:identifier Text: ICANRXMessage
|—Node:{ Text: {
|—Node:labeled_statement Text: public:
    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : can_interface_{can_interface},
          id_
|——Node:statement_identifier Text: public
|——Node:: Text: :
|——Node:expression_statement Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : can_interface_{can_interface},
          id_
|———Node:comma_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : can_interface_{can_interface},
          id_
|————Node:binary_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|—————Node:binary_expression Text: template <typename
|——————Node:identifier Text: template
|——————Node:< Text: <
|——————Node:identifier Text: typename
|—————Node:ERROR Text: ... Ts
|——————Node:... Text: ...
|——————Node:identifier Text: Ts
|—————Node:> Text: >
|—————Node:call_expression Text: CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|——————Node:identifier Text: CANRXMessage
|——————Node:argument_list Text: (ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|———————Node:( Text: (
|———————Node:binary_expression Text: ICAN &can_interface
|————————Node:identifier Text: ICAN
|————————Node:& Text: &
|————————Node:identifier Text: can_interface
|———————Node:, Text: ,
|———————Node:identifier Text: uint16_t
|———————Node:ERROR Text: id
|————————Node:identifier Text: id
|———————Node:, Text: ,
|———————Node:ERROR Text: std::
|————————Node:identifier Text: std
|————————Node:: Text: :
|————————Node:: Text: :
|———————Node:binary_expression Text: function<uint32_t(void)> get_millis
|————————Node:binary_expression Text: function<uint32_t(void)
|—————————Node:identifier Text: function
|—————————Node:< Text: <
|—————————Node:call_expression Text: uint32_t(void)
|——————————Node:identifier Text: uint32_t
|——————————Node:argument_list Text: (void)
|———————————Node:( Text: (
|———————————Node:identifier Text: void
|———————————Node:) Text: )
|————————Node:> Text: >
|————————Node:identifier Text: get_millis
|———————Node:, Text: ,
|———————Node:ERROR Text: std::
|————————Node:identifier Text: std
|————————Node:: Text: :
|————————Node:: Text: :
|———————Node:binary_expression Text: function<void(void)> callback_function
|————————Node:binary_expression Text: function<void(void)
|—————————Node:identifier Text: function
|—————————Node:< Text: <
|—————————Node:call_expression Text: void(void)
|——————————Node:identifier Text: void
|——————————Node:argument_list Text: (void)
|———————————Node:( Text: (
|———————————Node:identifier Text: void
|———————————Node:) Text: )
|————————Node:> Text: >
|————————Node:identifier Text: callback_function
|———————Node:, Text: ,
|———————Node:binary_expression Text: ICANSignal &signal_1
|————————Node:identifier Text: ICANSignal
|————————Node:& Text: &
|————————Node:identifier Text: signal_1
|———————Node:, Text: ,
|———————Node:field_expression Text: Ts &...signals
|————————Node:identifier Text: Ts
|————————Node:ERROR Text: &..
|—————————Node:& Text: &
|—————————Node:. Text: .
|—————————Node:. Text: .
|————————Node:. Text: .
|————————Node:field_identifier Text: signals
|———————Node:) Text: )
|————Node:ERROR Text: : can_interface_{can_interface}
|—————Node:: Text: :
|—————Node:identifier Text: can_interface_
|—————Node:{ Text: {
|—————Node:identifier Text: can_interface
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:identifier Text: id_
|———Node:; Text: 
|—Node:{ Text: {
|—Node:expression_statement Text: id},
          get_millis_
|——Node:comma_expression Text: id},
          get_millis_
|———Node:identifier Text: id
|———Node:ERROR Text: }
|————Node:} Text: }
|———Node:, Text: ,
|———Node:identifier Text: get_millis_
|——Node:; Text: 
|—Node:{ Text: {
|—Node:expression_statement Text: get_millis},
          callback_function_
|——Node:comma_expression Text: get_millis},
          callback_function_
|———Node:identifier Text: get_millis
|———Node:ERROR Text: }
|————Node:} Text: }
|———Node:, Text: ,
|———Node:identifier Text: callback_function_
|——Node:; Text: 
|—Node:compound_statement Text: {callback_function},
          signals_{&signal_1, &signals...}
    {
        static_assert(sizeof...(signals) == num_signals - 1, "Wrong number of signals passed into CANRXMessage.");
        can_interface_.RegisterRXMessage(*this);
    }

    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, get_millis, nullptr, signal_1, signals...}
    {
    }

// If compiling for Arduino, automatically uses millis() instead of requiring a std::function<uint32_t(void)> to get the
// current time
#ifdef ARDUINO
    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, callback_function, signal_1, signals...}
    {
    }

    template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, nullptr, signal_1, signals...}
    {
    }
#endif

    uint16_t GetID() { return id_; }

    void DecodeSignals(CANMessage message)
    {
        uint64_t temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data());
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->DecodeSignal(&temp_raw);
        }

        // DecodeSignals is called only on message received
        if (callback_function_)
        {
            callback_function_();
        }

        last_receive_time_ = get_millis_();
    }

    uint32_t GetLastReceiveTime() { return last_receive_time_; }
    uint32_t GetTimeSinceLastReceive() { return get_millis_() - last_receive_time_; }

private:
    ICAN &can_interface_;
    uint16_t id_;
    // A function to get the current time in millis on the current platform
    std::function<uint32_t(void)> get_millis_;

    // The callback function should be a very short function that will get called every time a new message is received.
    std::function<void(void)> callback_function_;

    std::array<ICANSignal *, num_signals> signals_;

    uint64_t raw_message;

    uint32_t last_receive_time_ = 0;
}
|——Node:{ Text: {
|——Node:ERROR Text: callback_function},
          signals_{&signal_1, &signals...}
|———Node:comma_expression Text: callback_function},
          signals_{&signal_1, &signals
|————Node:identifier Text: callback_function
|————Node:ERROR Text: }
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:comma_expression Text: signals_{&signal_1, &signals
|—————Node:binary_expression Text: signals_{&signal_1
|——————Node:identifier Text: signals_
|——————Node:ERROR Text: {
|———————Node:{ Text: {
|——————Node:& Text: &
|——————Node:identifier Text: signal_1
|—————Node:, Text: ,
|—————Node:pointer_expression Text: &signals
|——————Node:& Text: &
|——————Node:identifier Text: signals
|———Node:... Text: ...
|———Node:} Text: }
|——Node:compound_statement Text: {
        static_assert(sizeof...(signals) == num_signals - 1, "Wrong number of signals passed into CANRXMessage.");
        can_interface_.RegisterRXMessage(*this);
    }
|———Node:{ Text: {
|———Node:declaration Text: static_assert(sizeof...(signals) == num_signals
|————Node:macro_type_specifier Text: static_assert(sizeof...(signals)
|—————Node:identifier Text: static_assert
|—————Node:( Text: (
|—————Node:type_descriptor Text: sizeof
|——————Node:type_identifier Text: sizeof
|—————Node:ERROR Text: ...(signals
|——————Node:... Text: ...
|——————Node:( Text: (
|——————Node:identifier Text: signals
|—————Node:) Text: )
|————Node:ERROR Text: ==
|—————Node:== Text: ==
|————Node:identifier Text: num_signals
|————Node:; Text: 
|———Node:expression_statement Text: - 1, "Wrong number of signals passed into CANRXMessage.");
|————Node:comma_expression Text: - 1, "Wrong number of signals passed into CANRXMessage."
|—————Node:unary_expression Text: - 1
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|—————Node:, Text: ,
|—————Node:string_literal Text: "Wrong number of signals passed into CANRXMessage."
|——————Node:" Text: "
|——————Node:string_content Text: Wrong number of signals passed into CANRXMessage.
|——————Node:" Text: "
|————Node:ERROR Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: can_interface_.RegisterRXMessage(*this);
|————Node:call_expression Text: can_interface_.RegisterRXMessage(*this)
|—————Node:field_expression Text: can_interface_.RegisterRXMessage
|——————Node:identifier Text: can_interface_
|——————Node:. Text: .
|——————Node:field_identifier Text: RegisterRXMessage
|—————Node:argument_list Text: (*this)
|——————Node:( Text: (
|——————Node:pointer_expression Text: *this
|———————Node:* Text: *
|———————Node:identifier Text: this
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|——Node:ERROR Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, get_millis, nullptr, signal_1, signals...}
|———Node:comma_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, get_millis, nullptr, signal_1, signals
|————Node:binary_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
|—————Node:binary_expression Text: template <typename
|——————Node:identifier Text: template
|——————Node:< Text: <
|——————Node:identifier Text: typename
|—————Node:ERROR Text: ... Ts
|——————Node:... Text: ...
|——————Node:identifier Text: Ts
|—————Node:> Text: >
|—————Node:call_expression Text: CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
|——————Node:identifier Text: CANRXMessage
|——————Node:argument_list Text: (ICAN &can_interface,
                 uint16_t id,
                 std::function<uint32_t(void)> get_millis,
                 ICANSignal &signal_1,
                 Ts &...signals)
|———————Node:( Text: (
|———————Node:binary_expression Text: ICAN &can_interface
|————————Node:identifier Text: ICAN
|————————Node:& Text: &
|————————Node:identifier Text: can_interface
|———————Node:, Text: ,
|———————Node:identifier Text: uint16_t
|———————Node:ERROR Text: id
|————————Node:identifier Text: id
|———————Node:, Text: ,
|———————Node:ERROR Text: std::
|————————Node:identifier Text: std
|————————Node:: Text: :
|————————Node:: Text: :
|———————Node:binary_expression Text: function<uint32_t(void)> get_millis
|————————Node:binary_expression Text: function<uint32_t(void)
|—————————Node:identifier Text: function
|—————————Node:< Text: <
|—————————Node:call_expression Text: uint32_t(void)
|——————————Node:identifier Text: uint32_t
|——————————Node:argument_list Text: (void)
|———————————Node:( Text: (
|———————————Node:identifier Text: void
|———————————Node:) Text: )
|————————Node:> Text: >
|————————Node:identifier Text: get_millis
|———————Node:, Text: ,
|———————Node:binary_expression Text: ICANSignal &signal_1
|————————Node:identifier Text: ICANSignal
|————————Node:& Text: &
|————————Node:identifier Text: signal_1
|———————Node:, Text: ,
|———————Node:field_expression Text: Ts &...signals
|————————Node:identifier Text: Ts
|————————Node:ERROR Text: &..
|—————————Node:& Text: &
|—————————Node:. Text: .
|—————————Node:. Text: .
|————————Node:. Text: .
|————————Node:field_identifier Text: signals
|———————Node:) Text: )
|————Node:ERROR Text: : CANRXMessage{can_interface
|—————Node:: Text: :
|—————Node:identifier Text: CANRXMessage
|—————Node:{ Text: {
|—————Node:identifier Text: can_interface
|————Node:, Text: ,
|————Node:comma_expression Text: id, get_millis, nullptr, signal_1, signals
|—————Node:identifier Text: id
|—————Node:, Text: ,
|—————Node:comma_expression Text: get_millis, nullptr, signal_1, signals
|——————Node:identifier Text: get_millis
|——————Node:, Text: ,
|——————Node:comma_expression Text: nullptr, signal_1, signals
|———————Node:null Text: nullptr
|————————Node:nullptr Text: nullptr
|———————Node:, Text: ,
|———————Node:comma_expression Text: signal_1, signals
|————————Node:identifier Text: signal_1
|————————Node:, Text: ,
|————————Node:identifier Text: signals
|———Node:... Text: ...
|———Node:} Text: }
|——Node:compound_statement Text: {
    }
|———Node:{ Text: {
|———Node:} Text: }
|——Node:comment
|——Node:comment
|——Node:preproc_ifdef Text: #ifdef ARDUINO
    template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, callback_function, signal_1, signals...}
    {
    }

    template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis(); }, nullptr, signal_1, signals...}
    {
    }
#endif
|———Node:#ifdef Text: #ifdef
|———Node:identifier Text: ARDUINO
|———Node:expression_statement Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis();
|————Node:comma_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis()
|—————Node:binary_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|——————Node:binary_expression Text: template <typename
|———————Node:identifier Text: template
|———————Node:< Text: <
|———————Node:identifier Text: typename
|——————Node:ERROR Text: ... Ts
|———————Node:... Text: ...
|———————Node:identifier Text: Ts
|——————Node:> Text: >
|——————Node:call_expression Text: CANRXMessage(ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|———————Node:identifier Text: CANRXMessage
|———————Node:argument_list Text: (ICAN &can_interface,
                 uint16_t id,
                 std::function<void(void)> callback_function,
                 ICANSignal &signal_1,
                 Ts &...signals)
|————————Node:( Text: (
|————————Node:binary_expression Text: ICAN &can_interface
|—————————Node:identifier Text: ICAN
|—————————Node:& Text: &
|—————————Node:identifier Text: can_interface
|————————Node:, Text: ,
|————————Node:identifier Text: uint16_t
|————————Node:ERROR Text: id
|—————————Node:identifier Text: id
|————————Node:, Text: ,
|————————Node:ERROR Text: std::
|—————————Node:identifier Text: std
|—————————Node:: Text: :
|—————————Node:: Text: :
|————————Node:binary_expression Text: function<void(void)> callback_function
|—————————Node:binary_expression Text: function<void(void)
|——————————Node:identifier Text: function
|——————————Node:< Text: <
|——————————Node:call_expression Text: void(void)
|———————————Node:identifier Text: void
|———————————Node:argument_list Text: (void)
|————————————Node:( Text: (
|————————————Node:identifier Text: void
|————————————Node:) Text: )
|—————————Node:> Text: >
|—————————Node:identifier Text: callback_function
|————————Node:, Text: ,
|————————Node:binary_expression Text: ICANSignal &signal_1
|—————————Node:identifier Text: ICANSignal
|—————————Node:& Text: &
|—————————Node:identifier Text: signal_1
|————————Node:, Text: ,
|————————Node:field_expression Text: Ts &...signals
|—————————Node:identifier Text: Ts
|—————————Node:ERROR Text: &..
|——————————Node:& Text: &
|——————————Node:. Text: .
|——————————Node:. Text: .
|—————————Node:. Text: .
|—————————Node:field_identifier Text: signals
|————————Node:) Text: )
|—————Node:ERROR Text: : CANRXMessage{can_interface
|——————Node:: Text: :
|——————Node:identifier Text: CANRXMessage
|——————Node:{ Text: {
|——————Node:identifier Text: can_interface
|—————Node:, Text: ,
|—————Node:comma_expression Text: id, []() { return millis()
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:ERROR Text: []() { return
|———————Node:[ Text: [
|———————Node:] Text: ]
|———————Node:( Text: (
|———————Node:) Text: )
|———————Node:{ Text: {
|———————Node:return Text: return
|——————Node:call_expression Text: millis()
|———————Node:identifier Text: millis
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|————Node:; Text: ;
|———Node:ERROR Text: }, callback_function, signal_1, signals...}
|————Node:} Text: }
|————Node:, Text: ,
|————Node:comma_expression Text: callback_function, signal_1, signals
|—————Node:identifier Text: callback_function
|—————Node:, Text: ,
|—————Node:comma_expression Text: signal_1, signals
|——————Node:identifier Text: signal_1
|——————Node:, Text: ,
|——————Node:identifier Text: signals
|————Node:... Text: ...
|————Node:} Text: }
|———Node:compound_statement Text: {
    }
|————Node:{ Text: {
|————Node:} Text: }
|———Node:expression_statement Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis();
|————Node:comma_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
        : CANRXMessage{can_interface, id, []() { return millis()
|—————Node:binary_expression Text: template <typename... Ts>
    CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
|——————Node:binary_expression Text: template <typename
|———————Node:identifier Text: template
|———————Node:< Text: <
|———————Node:identifier Text: typename
|——————Node:ERROR Text: ... Ts
|———————Node:... Text: ...
|———————Node:identifier Text: Ts
|——————Node:> Text: >
|——————Node:call_expression Text: CANRXMessage(ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
|———————Node:identifier Text: CANRXMessage
|———————Node:argument_list Text: (ICAN &can_interface, uint16_t id, ICANSignal &signal_1, Ts &...signals)
|————————Node:( Text: (
|————————Node:binary_expression Text: ICAN &can_interface
|—————————Node:identifier Text: ICAN
|—————————Node:& Text: &
|—————————Node:identifier Text: can_interface
|————————Node:, Text: ,
|————————Node:identifier Text: uint16_t
|————————Node:ERROR Text: id
|—————————Node:identifier Text: id
|————————Node:, Text: ,
|————————Node:binary_expression Text: ICANSignal &signal_1
|—————————Node:identifier Text: ICANSignal
|—————————Node:& Text: &
|—————————Node:identifier Text: signal_1
|————————Node:, Text: ,
|————————Node:field_expression Text: Ts &...signals
|—————————Node:identifier Text: Ts
|—————————Node:ERROR Text: &..
|——————————Node:& Text: &
|——————————Node:. Text: .
|——————————Node:. Text: .
|—————————Node:. Text: .
|—————————Node:field_identifier Text: signals
|————————Node:) Text: )
|—————Node:ERROR Text: : CANRXMessage{can_interface
|——————Node:: Text: :
|——————Node:identifier Text: CANRXMessage
|——————Node:{ Text: {
|——————Node:identifier Text: can_interface
|—————Node:, Text: ,
|—————Node:comma_expression Text: id, []() { return millis()
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:ERROR Text: []() { return
|———————Node:[ Text: [
|———————Node:] Text: ]
|———————Node:( Text: (
|———————Node:) Text: )
|———————Node:{ Text: {
|———————Node:return Text: return
|——————Node:call_expression Text: millis()
|———————Node:identifier Text: millis
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|————Node:; Text: ;
|———Node:ERROR Text: }, nullptr, signal_1, signals...}
|————Node:} Text: }
|————Node:, Text: ,
|————Node:comma_expression Text: nullptr, signal_1, signals
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:, Text: ,
|—————Node:comma_expression Text: signal_1, signals
|——————Node:identifier Text: signal_1
|——————Node:, Text: ,
|——————Node:identifier Text: signals
|————Node:... Text: ...
|————Node:} Text: }
|———Node:compound_statement Text: {
    }
|————Node:{ Text: {
|————Node:} Text: }
|———Node:#endif Text: #endif
|——Node:function_definition Text: uint16_t GetID() { return id_; }
|———Node:primitive_type Text: uint16_t
|———Node:function_declarator Text: GetID()
|————Node:identifier Text: GetID
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: { return id_; }
|————Node:{ Text: {
|————Node:return_statement Text: return id_;
|—————Node:return Text: return
|—————Node:identifier Text: id_
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void DecodeSignals(CANMessage message)
    {
        uint64_t temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data());
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->DecodeSignal(&temp_raw);
        }

        // DecodeSignals is called only on message received
        if (callback_function_)
        {
            callback_function_();
        }

        last_receive_time_ = get_millis_();
    }
|———Node:primitive_type Text: void
|———Node:function_declarator Text: DecodeSignals(CANMessage message)
|————Node:identifier Text: DecodeSignals
|————Node:parameter_list Text: (CANMessage message)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: CANMessage message
|——————Node:type_identifier Text: CANMessage
|——————Node:identifier Text: message
|—————Node:) Text: )
|———Node:compound_statement Text: {
        uint64_t temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data());
        for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->DecodeSignal(&temp_raw);
        }

        // DecodeSignals is called only on message received
        if (callback_function_)
        {
            callback_function_();
        }

        last_receive_time_ = get_millis_();
    }
|————Node:{ Text: {
|————Node:declaration Text: uint64_t temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data());
|—————Node:primitive_type Text: uint64_t
|—————Node:init_declarator Text: temp_raw = *reinterpret_cast<uint64_t *>(message.data_.data())
|——————Node:identifier Text: temp_raw
|——————Node:= Text: =
|——————Node:binary_expression Text: *reinterpret_cast<uint64_t *>(message.data_.data())
|———————Node:binary_expression Text: *reinterpret_cast<uint64_t
|————————Node:pointer_expression Text: *reinterpret_cast
|—————————Node:* Text: *
|—————————Node:identifier Text: reinterpret_cast
|————————Node:< Text: <
|————————Node:identifier Text: uint64_t
|———————Node:ERROR Text: *
|————————Node:* Text: *
|———————Node:> Text: >
|———————Node:parenthesized_expression Text: (message.data_.data())
|————————Node:( Text: (
|————————Node:call_expression Text: message.data_.data()
|—————————Node:field_expression Text: message.data_.data
|——————————Node:field_expression Text: message.data_
|———————————Node:identifier Text: message
|———————————Node:. Text: .
|———————————Node:field_identifier Text: data_
|——————————Node:. Text: .
|——————————Node:field_identifier Text: data
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:for_statement Text: for (uint8_t i = 0; i < num_signals; i++)
        {
            signals_[i]->DecodeSignal(&temp_raw);
        }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: uint8_t i = 0;
|——————Node:primitive_type Text: uint8_t
|——————Node:init_declarator Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: i < num_signals
|——————Node:identifier Text: i
|——————Node:< Text: <
|——————Node:identifier Text: num_signals
|—————Node:; Text: ;
|—————Node:update_expression Text: i++
|——————Node:identifier Text: i
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
            signals_[i]->DecodeSignal(&temp_raw);
        }
|——————Node:{ Text: {
|——————Node:expression_statement Text: signals_[i]->DecodeSignal(&temp_raw);
|———————Node:call_expression Text: signals_[i]->DecodeSignal(&temp_raw)
|————————Node:field_expression Text: signals_[i]->DecodeSignal
|—————————Node:subscript_expression Text: signals_[i]
|——————————Node:identifier Text: signals_
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: DecodeSignal
|————————Node:argument_list Text: (&temp_raw)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &temp_raw
|——————————Node:& Text: &
|——————————Node:identifier Text: temp_raw
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment
|————Node:if_statement Text: if (callback_function_)
        {
            callback_function_();
        }
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (callback_function_)
|——————Node:( Text: (
|——————Node:identifier Text: callback_function_
|——————Node:) Text: )
|—————Node:compound_statement Text: {
            callback_function_();
        }
|——————Node:{ Text: {
|——————Node:expression_statement Text: callback_function_();
|———————Node:call_expression Text: callback_function_()
|————————Node:identifier Text: callback_function_
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:expression_statement Text: last_receive_time_ = get_millis_();
|—————Node:assignment_expression Text: last_receive_time_ = get_millis_()
|——————Node:identifier Text: last_receive_time_
|——————Node:= Text: =
|——————Node:call_expression Text: get_millis_()
|———————Node:identifier Text: get_millis_
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: uint32_t GetLastReceiveTime() { return last_receive_time_; }
|———Node:primitive_type Text: uint32_t
|———Node:function_declarator Text: GetLastReceiveTime()
|————Node:identifier Text: GetLastReceiveTime
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: { return last_receive_time_; }
|————Node:{ Text: {
|————Node:return_statement Text: return last_receive_time_;
|—————Node:return Text: return
|—————Node:identifier Text: last_receive_time_
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: uint32_t GetTimeSinceLastReceive() { return get_millis_() - last_receive_time_; }
|———Node:primitive_type Text: uint32_t
|———Node:function_declarator Text: GetTimeSinceLastReceive()
|————Node:identifier Text: GetTimeSinceLastReceive
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: { return get_millis_() - last_receive_time_; }
|————Node:{ Text: {
|————Node:return_statement Text: return get_millis_() - last_receive_time_;
|—————Node:return Text: return
|—————Node:binary_expression Text: get_millis_() - last_receive_time_
|——————Node:call_expression Text: get_millis_()
|———————Node:identifier Text: get_millis_
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:- Text: -
|——————Node:identifier Text: last_receive_time_
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:labeled_statement Text: private:
    ICAN &can_interface_;
|———Node:statement_identifier Text: private
|———Node:: Text: :
|———Node:expression_statement Text: ICAN &can_interface_;
|————Node:binary_expression Text: ICAN &can_interface_
|—————Node:identifier Text: ICAN
|—————Node:& Text: &
|—————Node:identifier Text: can_interface_
|————Node:; Text: ;
|——Node:declaration Text: uint16_t id_;
|———Node:primitive_type Text: uint16_t
|———Node:identifier Text: id_
|———Node:; Text: ;
|——Node:comment
|——Node:labeled_statement Text: std::function<uint32_t(void)> get_millis_;
|———Node:statement_identifier Text: std
|———Node:: Text: :
|———Node:ERROR Text: :
|————Node:: Text: :
|———Node:expression_statement Text: function<uint32_t(void)> get_millis_;
|————Node:binary_expression Text: function<uint32_t(void)> get_millis_
|—————Node:binary_expression Text: function<uint32_t(void)
|——————Node:identifier Text: function
|——————Node:< Text: <
|——————Node:call_expression Text: uint32_t(void)
|———————Node:identifier Text: uint32_t
|———————Node:argument_list Text: (void)
|————————Node:( Text: (
|————————Node:identifier Text: void
|————————Node:) Text: )
|—————Node:> Text: >
|—————Node:identifier Text: get_millis_
|————Node:; Text: ;
|——Node:comment
|——Node:labeled_statement Text: std::function<void(void)> callback_function_;
|———Node:statement_identifier Text: std
|———Node:: Text: :
|———Node:ERROR Text: :
|————Node:: Text: :
|———Node:expression_statement Text: function<void(void)> callback_function_;
|————Node:binary_expression Text: function<void(void)> callback_function_
|—————Node:binary_expression Text: function<void(void)
|——————Node:identifier Text: function
|——————Node:< Text: <
|——————Node:call_expression Text: void(void)
|———————Node:identifier Text: void
|———————Node:argument_list Text: (void)
|————————Node:( Text: (
|————————Node:identifier Text: void
|————————Node:) Text: )
|—————Node:> Text: >
|—————Node:identifier Text: callback_function_
|————Node:; Text: ;
|——Node:labeled_statement Text: std::array<ICANSignal *, num_signals> signals_;
|———Node:statement_identifier Text: std
|———Node:: Text: :
|———Node:ERROR Text: :
|————Node:: Text: :
|———Node:expression_statement Text: array<ICANSignal *, num_signals> signals_;
|————Node:binary_expression Text: array<ICANSignal *, num_signals> signals_
|—————Node:binary_expression Text: array<ICANSignal *, num_signals
|——————Node:identifier Text: array
|——————Node:< Text: <
|——————Node:binary_expression Text: ICANSignal *, num_signals
|———————Node:identifier Text: ICANSignal
|———————Node:* Text: *
|———————Node:ERROR Text: ,
|————————Node:, Text: ,
|———————Node:identifier Text: num_signals
|—————Node:> Text: >
|—————Node:identifier Text: signals_
|————Node:; Text: ;
|——Node:declaration Text: uint64_t raw_message;
|———Node:primitive_type Text: uint64_t
|———Node:identifier Text: raw_message
|———Node:; Text: ;
|——Node:declaration Text: uint32_t last_receive_time_ = 0;
|———Node:primitive_type Text: uint32_t
|———Node:init_declarator Text: last_receive_time_ = 0
|————Node:identifier Text: last_receive_time_
|————Node:= Text: =
|————Node:number_literal Text: 0
|———Node:; Text: ;
|——Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
