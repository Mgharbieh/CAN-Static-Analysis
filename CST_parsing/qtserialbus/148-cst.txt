qtserialbus-src\serialbus\qmodbusrtuserialslave_p.h

|Node:translation_unit
|—Node:comment
|—Node:preproc_ifdef Text: #ifndef QMODBUSRTUSERIALSLAVE_P_H
#define QMODBUSRTUSERIALSLAVE_P_H

#include "qmodbusrtuserialslave.h"
#include "qmodbusserver_p.h"

#include <QtCore/qdebug.h>
#include <QtCore/qloggingcategory.h>
#include <QtSerialPort/qserialport.h>

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API. It exists purely as an
// implementation detail. This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

QT_BEGIN_NAMESPACE

Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS)
Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS_LOW)

class QModbusRtuSerialSlavePrivate : public QModbusServerPrivate
{
    Q_DECLARE_PUBLIC(QModbusRtuSerialSlave)

public:
    QModbusRtuSerialSlavePrivate()
    {
    }

    ~QModbusRtuSerialSlavePrivate()
    {
    }

    void setupSerialPort()
    {
        Q_Q(QModbusRtuSerialSlave);

        m_serialPort = new QSerialPort(q);
        m_serialPort->setBaudRate(QSerialPort::Baud9600);
        m_serialPort->setParity(QSerialPort::NoParity);
        m_serialPort->setDataBits(QSerialPort::Data8);
        m_serialPort->setStopBits(QSerialPort::OneStop);

        QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]() {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        });

        using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
        QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });

        QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]() {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        });
    }

    void handleErrorOccurred(QSerialPort::SerialPortError);
    void serialPortReadyRead();
    void aboutToClose();

    QSerialPort *m_serialPort;
    bool m_processesBroadcast = false;
};

QT_END_NAMESPACE

#endif
|——Node:#ifndef Text: #ifndef
|——Node:identifier Text: QMODBUSRTUSERIALSLAVE_P_H
|——Node:preproc_def Text: #define QMODBUSRTUSERIALSLAVE_P_H

|———Node:#define Text: #define
|———Node:identifier Text: QMODBUSRTUSERIALSLAVE_P_H
|——Node:preproc_include Text: #include "qmodbusrtuserialslave.h"

|———Node:#include Text: #include
|———Node:string_literal Text: "qmodbusrtuserialslave.h"
|————Node:" Text: "
|————Node:string_content Text: qmodbusrtuserialslave.h
|————Node:" Text: "
|——Node:preproc_include Text: #include "qmodbusserver_p.h"

|———Node:#include Text: #include
|———Node:string_literal Text: "qmodbusserver_p.h"
|————Node:" Text: "
|————Node:string_content Text: qmodbusserver_p.h
|————Node:" Text: "
|——Node:preproc_include Text: #include <QtCore/qdebug.h>

|———Node:#include Text: #include
|———Node:system_lib_string Text: <QtCore/qdebug.h>
|——Node:preproc_include Text: #include <QtCore/qloggingcategory.h>

|———Node:#include Text: #include
|———Node:system_lib_string Text: <QtCore/qloggingcategory.h>
|——Node:preproc_include Text: #include <QtSerialPort/qserialport.h>

|———Node:#include Text: #include
|———Node:system_lib_string Text: <QtSerialPort/qserialport.h>
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:comment
|——Node:function_definition Text: QT_BEGIN_NAMESPACE

Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS)
Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS_LOW)

class QModbusRtuSerialSlavePrivate : public QModbusServerPrivate
{
    Q_DECLARE_PUBLIC(QModbusRtuSerialSlave)

public:
    QModbusRtuSerialSlavePrivate()
    {
    }

    ~QModbusRtuSerialSlavePrivate()
    {
    }

    void setupSerialPort()
    {
        Q_Q(QModbusRtuSerialSlave);

        m_serialPort = new QSerialPort(q);
        m_serialPort->setBaudRate(QSerialPort::Baud9600);
        m_serialPort->setParity(QSerialPort::NoParity);
        m_serialPort->setDataBits(QSerialPort::Data8);
        m_serialPort->setStopBits(QSerialPort::OneStop);

        QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]() {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        });

        using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
        QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });

        QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]() {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        });
    }

    void handleErrorOccurred(QSerialPort::SerialPortError);
    void serialPortReadyRead();
    void aboutToClose();

    QSerialPort *m_serialPort;
    bool m_processesBroadcast = false;
}
|———Node:type_identifier Text: QT_BEGIN_NAMESPACE
|———Node:function_declarator Text: Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS)
Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS_LOW)

class QModbusRtuSerialSlavePrivate : public QModbusServerPrivate
|————Node:identifier Text: Q_DECLARE_LOGGING_CATEGORY
|————Node:parameter_list Text: (QT_MODBUS)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: QT_MODBUS
|——————Node:type_identifier Text: QT_MODBUS
|—————Node:) Text: )
|————Node:call_expression Text: Q_DECLARE_LOGGING_CATEGORY(QT_MODBUS_LOW)
|—————Node:identifier Text: Q_DECLARE_LOGGING_CATEGORY
|—————Node:argument_list Text: (QT_MODBUS_LOW)
|——————Node:( Text: (
|——————Node:identifier Text: QT_MODBUS_LOW
|——————Node:) Text: )
|————Node:identifier Text: class
|————Node:identifier Text: QModbusRtuSerialSlavePrivate
|————Node:ERROR Text: :
|—————Node:: Text: :
|————Node:identifier Text: public
|————Node:identifier Text: QModbusServerPrivate
|———Node:compound_statement Text: {
    Q_DECLARE_PUBLIC(QModbusRtuSerialSlave)

public:
    QModbusRtuSerialSlavePrivate()
    {
    }

    ~QModbusRtuSerialSlavePrivate()
    {
    }

    void setupSerialPort()
    {
        Q_Q(QModbusRtuSerialSlave);

        m_serialPort = new QSerialPort(q);
        m_serialPort->setBaudRate(QSerialPort::Baud9600);
        m_serialPort->setParity(QSerialPort::NoParity);
        m_serialPort->setDataBits(QSerialPort::Data8);
        m_serialPort->setStopBits(QSerialPort::OneStop);

        QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]() {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        });

        using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
        QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });

        QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]() {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        });
    }

    void handleErrorOccurred(QSerialPort::SerialPortError);
    void serialPortReadyRead();
    void aboutToClose();

    QSerialPort *m_serialPort;
    bool m_processesBroadcast = false;
}
|————Node:{ Text: {
|————Node:function_definition Text: Q_DECLARE_PUBLIC(QModbusRtuSerialSlave)

public:
    QModbusRtuSerialSlavePrivate()
    {
    }
|—————Node:macro_type_specifier Text: Q_DECLARE_PUBLIC(QModbusRtuSerialSlave)
|——————Node:identifier Text: Q_DECLARE_PUBLIC
|——————Node:( Text: (
|——————Node:type_descriptor Text: QModbusRtuSerialSlave
|———————Node:type_identifier Text: QModbusRtuSerialSlave
|——————Node:) Text: )
|—————Node:ERROR Text: public:
|——————Node:identifier Text: public
|——————Node:: Text: :
|—————Node:function_declarator Text: QModbusRtuSerialSlavePrivate()
|——————Node:identifier Text: QModbusRtuSerialSlavePrivate
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:compound_statement Text: {
    }
|——————Node:{ Text: {
|——————Node:} Text: }
|————Node:expression_statement Text: ~QModbusRtuSerialSlavePrivate()
|—————Node:unary_expression Text: ~QModbusRtuSerialSlavePrivate()
|——————Node:~ Text: ~
|——————Node:call_expression Text: QModbusRtuSerialSlavePrivate()
|———————Node:identifier Text: QModbusRtuSerialSlavePrivate
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:; Text: 
|————Node:compound_statement Text: {
    }
|—————Node:{ Text: {
|—————Node:} Text: }
|————Node:function_definition Text: void setupSerialPort()
    {
        Q_Q(QModbusRtuSerialSlave);

        m_serialPort = new QSerialPort(q);
        m_serialPort->setBaudRate(QSerialPort::Baud9600);
        m_serialPort->setParity(QSerialPort::NoParity);
        m_serialPort->setDataBits(QSerialPort::Data8);
        m_serialPort->setStopBits(QSerialPort::OneStop);

        QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]() {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        });

        using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
        QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });

        QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]() {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        });
    }
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: setupSerialPort()
|——————Node:identifier Text: setupSerialPort
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:compound_statement Text: {
        Q_Q(QModbusRtuSerialSlave);

        m_serialPort = new QSerialPort(q);
        m_serialPort->setBaudRate(QSerialPort::Baud9600);
        m_serialPort->setParity(QSerialPort::NoParity);
        m_serialPort->setDataBits(QSerialPort::Data8);
        m_serialPort->setStopBits(QSerialPort::OneStop);

        QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]() {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        });

        using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
        QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });

        QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]() {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        });
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: Q_Q(QModbusRtuSerialSlave);
|———————Node:call_expression Text: Q_Q(QModbusRtuSerialSlave)
|————————Node:identifier Text: Q_Q
|————————Node:argument_list Text: (QModbusRtuSerialSlave)
|—————————Node:( Text: (
|—————————Node:identifier Text: QModbusRtuSerialSlave
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_serialPort = new QSerialPort(q);
|———————Node:assignment_expression Text: m_serialPort = new QSerialPort(q)
|————————Node:identifier Text: m_serialPort
|————————Node:= Text: =
|————————Node:ERROR Text: new
|—————————Node:identifier Text: new
|————————Node:call_expression Text: QSerialPort(q)
|—————————Node:identifier Text: QSerialPort
|—————————Node:argument_list Text: (q)
|——————————Node:( Text: (
|——————————Node:identifier Text: q
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_serialPort->setBaudRate(QSerialPort::Baud9600);
|———————Node:call_expression Text: m_serialPort->setBaudRate(QSerialPort::Baud9600)
|————————Node:field_expression Text: m_serialPort->setBaudRate
|—————————Node:identifier Text: m_serialPort
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: setBaudRate
|————————Node:argument_list Text: (QSerialPort::Baud9600)
|—————————Node:( Text: (
|—————————Node:identifier Text: QSerialPort
|—————————Node:ERROR Text: ::Baud9600
|——————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:identifier Text: Baud9600
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_serialPort->setParity(QSerialPort::NoParity);
|———————Node:call_expression Text: m_serialPort->setParity(QSerialPort::NoParity)
|————————Node:field_expression Text: m_serialPort->setParity
|—————————Node:identifier Text: m_serialPort
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: setParity
|————————Node:argument_list Text: (QSerialPort::NoParity)
|—————————Node:( Text: (
|—————————Node:identifier Text: QSerialPort
|—————————Node:ERROR Text: ::NoParity
|——————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:identifier Text: NoParity
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_serialPort->setDataBits(QSerialPort::Data8);
|———————Node:call_expression Text: m_serialPort->setDataBits(QSerialPort::Data8)
|————————Node:field_expression Text: m_serialPort->setDataBits
|—————————Node:identifier Text: m_serialPort
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: setDataBits
|————————Node:argument_list Text: (QSerialPort::Data8)
|—————————Node:( Text: (
|—————————Node:identifier Text: QSerialPort
|—————————Node:ERROR Text: ::Data8
|——————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:identifier Text: Data8
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_serialPort->setStopBits(QSerialPort::OneStop);
|———————Node:call_expression Text: m_serialPort->setStopBits(QSerialPort::OneStop)
|————————Node:field_expression Text: m_serialPort->setStopBits
|—————————Node:identifier Text: m_serialPort
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: setStopBits
|————————Node:argument_list Text: (QSerialPort::OneStop)
|—————————Node:( Text: (
|—————————Node:identifier Text: QSerialPort
|—————————Node:ERROR Text: ::OneStop
|——————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:identifier Text: OneStop
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:labeled_statement Text: QObject::connect(m_serialPort, &QSerialPort::readyRead, [this]()
|———————Node:statement_identifier Text: QObject
|———————Node:ERROR Text: ::connect(m_serialPort, &QSerialPort:
|————————Node:: Text: :
|————————Node:: Text: :
|————————Node:identifier Text: connect
|————————Node:( Text: (
|————————Node:identifier Text: m_serialPort
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &QSerialPort
|—————————Node:& Text: &
|—————————Node:identifier Text: QSerialPort
|————————Node:: Text: :
|———————Node:: Text: :
|———————Node:expression_statement Text: readyRead, [this]()
|————————Node:call_expression Text: readyRead, [this]()
|—————————Node:subscript_expression Text: readyRead, [this]
|——————————Node:identifier Text: readyRead
|——————————Node:ERROR Text: ,
|———————————Node:, Text: ,
|——————————Node:[ Text: [
|——————————Node:identifier Text: this
|——————————Node:] Text: ]
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: 
|——————Node:compound_statement Text: {
            Q_Q(QModbusRtuSerialSlave);

            const int size = m_serialPort->size();
            const QByteArray buffer = m_serialPort->read(size);

            qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();

            // Index                         -> description
            // SlaveId                       -> 1 byte
            // FunctionCode                  -> 1 byte
            // FunctionCode specific content -> 0-252 bytes
            // CRC                           -> 2 bytes

            // We expect at least the slave address, function code and CRC.
            if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
            const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));

            // slave address byte + function code byte + PDU size + 2 bytes CRC
            if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }

            const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
            if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }

            // The quantity of messages that the remote device has detected on the communications
            // system since its last restart, clear counters operation, or powerup.
            incrementCounter(QModbusServerPrivate::Counter::BusMessage);

            // Slave address is set to 0, this is a broadcast.
            m_processesBroadcast = (buffer.at(0) == 0);

            // If we do not process a Broadcast ...
            if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            } // else { Broadcast -> Slave Id will never match, deliberately ignore }

            // The quantity of messages addressed to the remote device, or broadcast, that the
            // remote device has processed since its last restart, clear counters operation, or
            // powerup.
            incrementCounter(QModbusServerPrivate::Counter::ServerMessage);

            // remove slave address, function code & CRC
            const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) << "Sending response (incl ADU):" << result.toHex();

            if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            int writtenBytes = m_serialPort->write(result);
            if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: Q_Q(QModbusRtuSerialSlave);
|————————Node:call_expression Text: Q_Q(QModbusRtuSerialSlave)
|—————————Node:identifier Text: Q_Q
|—————————Node:argument_list Text: (QModbusRtuSerialSlave)
|——————————Node:( Text: (
|——————————Node:identifier Text: QModbusRtuSerialSlave
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: const int size = m_serialPort->size();
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: size = m_serialPort->size()
|—————————Node:identifier Text: size
|—————————Node:= Text: =
|—————————Node:call_expression Text: m_serialPort->size()
|——————————Node:field_expression Text: m_serialPort->size
|———————————Node:identifier Text: m_serialPort
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: const QByteArray buffer = m_serialPort->read(size);
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:type_identifier Text: QByteArray
|————————Node:init_declarator Text: buffer = m_serialPort->read(size)
|—————————Node:identifier Text: buffer
|—————————Node:= Text: =
|—————————Node:call_expression Text: m_serialPort->read(size)
|——————————Node:field_expression Text: m_serialPort->read
|———————————Node:identifier Text: m_serialPort
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: read
|——————————Node:argument_list Text: (size)
|———————————Node:( Text: (
|———————————Node:identifier Text: size
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex();
|————————Node:binary_expression Text: qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):" << buffer.toHex()
|—————————Node:binary_expression Text: qCDebug(QT_MODBUS_LOW) << "Received buffer (incl ADU):"
|——————————Node:call_expression Text: qCDebug(QT_MODBUS_LOW)
|———————————Node:identifier Text: qCDebug
|———————————Node:argument_list Text: (QT_MODBUS_LOW)
|————————————Node:( Text: (
|————————————Node:identifier Text: QT_MODBUS_LOW
|————————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:string_literal Text: "Received buffer (incl ADU):"
|———————————Node:" Text: "
|———————————Node:string_content Text: Received buffer (incl ADU):
|———————————Node:" Text: "
|—————————Node:<< Text: <<
|—————————Node:call_expression Text: buffer.toHex()
|——————————Node:field_expression Text: buffer.toHex
|———————————Node:identifier Text: buffer
|———————————Node:. Text: .
|———————————Node:field_identifier Text: toHex
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:if_statement Text: if (buffer.size() < 4) { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (buffer.size() < 4)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: buffer.size() < 4
|——————————Node:call_expression Text: buffer.size()
|———————————Node:field_expression Text: buffer.size
|————————————Node:identifier Text: buffer
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:< Text: <
|——————————Node:number_literal Text: 4
|—————————Node:) Text: )
|————————Node:compound_statement Text: { // TODO: LRC should be 3 bytes.
                qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";

                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup. In case of a message
                // length < 4 bytes, the receiving device is not able to calculate the CRC.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }
|—————————Node:{ Text: {
|—————————Node:comment
|—————————Node:expression_statement Text: qCWarning(QT_MODBUS) << "Invalid Modbus PDU received";
|——————————Node:binary_expression Text: qCWarning(QT_MODBUS) << "Invalid Modbus PDU received"
|———————————Node:call_expression Text: qCWarning(QT_MODBUS)
|————————————Node:identifier Text: qCWarning
|————————————Node:argument_list Text: (QT_MODBUS)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QT_MODBUS
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:string_literal Text: "Invalid Modbus PDU received"
|————————————Node:" Text: "
|————————————Node:string_content Text: Invalid Modbus PDU received
|————————————Node:" Text: "
|——————————Node:; Text: ;
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::BusCommunicationError);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: BusCommunicationError);
|————————————Node:identifier Text: BusCommunicationError
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:declaration Text: const QModbusPdu::FunctionCode code = QModbusRequest::FunctionCode(buffer.at(1));
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:type_identifier Text: QModbusPdu
|————————Node:ERROR Text: ::FunctionCode
|—————————Node:: Text: :
|—————————Node:: Text: :
|—————————Node:identifier Text: FunctionCode
|————————Node:init_declarator Text: code = QModbusRequest::FunctionCode(buffer.at(1))
|—————————Node:identifier Text: code
|—————————Node:= Text: =
|—————————Node:ERROR Text: QModbusRequest::
|——————————Node:identifier Text: QModbusRequest
|——————————Node:: Text: :
|——————————Node:: Text: :
|—————————Node:call_expression Text: FunctionCode(buffer.at(1))
|——————————Node:identifier Text: FunctionCode
|——————————Node:argument_list Text: (buffer.at(1))
|———————————Node:( Text: (
|———————————Node:call_expression Text: buffer.at(1)
|————————————Node:field_expression Text: buffer.at
|—————————————Node:identifier Text: buffer
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: at
|————————————Node:argument_list Text: (1)
|—————————————Node:( Text: (
|—————————————Node:number_literal Text: 1
|—————————————Node:) Text: )
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: const int pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2));
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: pduSizeWithoutFcode = QModbusRequest::calculateDataSize(code, buffer.mid(2))
|—————————Node:identifier Text: pduSizeWithoutFcode
|—————————Node:= Text: =
|—————————Node:ERROR Text: QModbusRequest::
|——————————Node:identifier Text: QModbusRequest
|——————————Node:: Text: :
|——————————Node:: Text: :
|—————————Node:call_expression Text: calculateDataSize(code, buffer.mid(2))
|——————————Node:identifier Text: calculateDataSize
|——————————Node:argument_list Text: (code, buffer.mid(2))
|———————————Node:( Text: (
|———————————Node:identifier Text: code
|———————————Node:, Text: ,
|———————————Node:call_expression Text: buffer.mid(2)
|————————————Node:field_expression Text: buffer.mid
|—————————————Node:identifier Text: buffer
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: mid
|————————————Node:argument_list Text: (2)
|—————————————Node:( Text: (
|—————————————Node:number_literal Text: 2
|—————————————Node:) Text: )
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment
|———————Node:if_statement Text: if ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()) {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: ((pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (pduSizeWithoutFcode < 0) || (2 + pduSizeWithoutFcode + 2) != buffer.size()
|——————————Node:parenthesized_expression Text: (pduSizeWithoutFcode < 0)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: pduSizeWithoutFcode < 0
|————————————Node:identifier Text: pduSizeWithoutFcode
|————————————Node:< Text: <
|————————————Node:number_literal Text: 0
|———————————Node:) Text: )
|——————————Node:|| Text: ||
|——————————Node:binary_expression Text: (2 + pduSizeWithoutFcode + 2) != buffer.size()
|———————————Node:parenthesized_expression Text: (2 + pduSizeWithoutFcode + 2)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: 2 + pduSizeWithoutFcode + 2
|—————————————Node:binary_expression Text: 2 + pduSizeWithoutFcode
|——————————————Node:number_literal Text: 2
|——————————————Node:+ Text: +
|——————————————Node:identifier Text: pduSizeWithoutFcode
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 2
|————————————Node:) Text: )
|———————————Node:!= Text: !=
|———————————Node:call_expression Text: buffer.size()
|————————————Node:field_expression Text: buffer.size
|—————————————Node:identifier Text: buffer
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: size
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
                // The quantity of messages addressed to the remote device that it could not
                // handle due to a character overrun condition, since its last restart, clear
                // counters operation, or powerup. A character overrun is caused by data
                // characters arriving at the port faster than they can be stored, or by the loss
                // of a character due to a hardware malfunction.
                incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
                return;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring";
|——————————Node:binary_expression Text: qCWarning(QT_MODBUS) << "ADU does not match expected size, ignoring"
|———————————Node:call_expression Text: qCWarning(QT_MODBUS)
|————————————Node:identifier Text: qCWarning
|————————————Node:argument_list Text: (QT_MODBUS)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QT_MODBUS
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:string_literal Text: "ADU does not match expected size, ignoring"
|————————————Node:" Text: "
|————————————Node:string_content Text: ADU does not match expected size, ignoring
|————————————Node:" Text: "
|——————————Node:; Text: ;
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusCharacterOverrun);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::BusCharacterOverrun);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: BusCharacterOverrun);
|————————————Node:identifier Text: BusCharacterOverrun
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:declaration Text: const quint16 receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1]);
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:type_identifier Text: quint16
|————————Node:init_declarator Text: receivedCrc = quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1])
|—————————Node:identifier Text: receivedCrc
|—————————Node:= Text: =
|—————————Node:binary_expression Text: quint8(buffer[buffer.size() - 2]) << 8
                                        | quint8(buffer[buffer.size() -1])
|——————————Node:binary_expression Text: quint8(buffer[buffer.size() - 2]) << 8
|———————————Node:call_expression Text: quint8(buffer[buffer.size() - 2])
|————————————Node:identifier Text: quint8
|————————————Node:argument_list Text: (buffer[buffer.size() - 2])
|—————————————Node:( Text: (
|—————————————Node:subscript_expression Text: buffer[buffer.size() - 2]
|——————————————Node:identifier Text: buffer
|——————————————Node:[ Text: [
|——————————————Node:binary_expression Text: buffer.size() - 2
|———————————————Node:call_expression Text: buffer.size()
|————————————————Node:field_expression Text: buffer.size
|—————————————————Node:identifier Text: buffer
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: size
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|———————————————Node:- Text: -
|———————————————Node:number_literal Text: 2
|——————————————Node:] Text: ]
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 8
|——————————Node:| Text: |
|——————————Node:call_expression Text: quint8(buffer[buffer.size() -1])
|———————————Node:identifier Text: quint8
|———————————Node:argument_list Text: (buffer[buffer.size() -1])
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: buffer[buffer.size() -1]
|—————————————Node:identifier Text: buffer
|—————————————Node:[ Text: [
|—————————————Node:binary_expression Text: buffer.size() -1
|——————————————Node:call_expression Text: buffer.size()
|———————————————Node:field_expression Text: buffer.size
|————————————————Node:identifier Text: buffer
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: size
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:- Text: -
|——————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|————————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)) {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (!matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc))
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)
|——————————Node:! Text: !
|——————————Node:call_expression Text: matchingCRC(buffer.constData(), buffer.size() - 2, receivedCrc)
|———————————Node:identifier Text: matchingCRC
|———————————Node:argument_list Text: (buffer.constData(), buffer.size() - 2, receivedCrc)
|————————————Node:( Text: (
|————————————Node:call_expression Text: buffer.constData()
|—————————————Node:field_expression Text: buffer.constData
|——————————————Node:identifier Text: buffer
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: constData
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: buffer.size() - 2
|—————————————Node:call_expression Text: buffer.size()
|——————————————Node:field_expression Text: buffer.size
|———————————————Node:identifier Text: buffer
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: size
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:- Text: -
|—————————————Node:number_literal Text: 2
|————————————Node:, Text: ,
|————————————Node:identifier Text: receivedCrc
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
                // The quantity of CRC errors encountered by the remote device since its last
                // restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                return;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC";
|——————————Node:binary_expression Text: qCWarning(QT_MODBUS) << "Ignoring request with wrong CRC"
|———————————Node:call_expression Text: qCWarning(QT_MODBUS)
|————————————Node:identifier Text: qCWarning
|————————————Node:argument_list Text: (QT_MODBUS)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QT_MODBUS
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:string_literal Text: "Ignoring request with wrong CRC"
|————————————Node:" Text: "
|————————————Node:string_content Text: Ignoring request with wrong CRC
|————————————Node:" Text: "
|——————————Node:; Text: ;
|—————————Node:comment
|—————————Node:comment
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::BusCommunicationError);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: BusCommunicationError);
|————————————Node:identifier Text: BusCommunicationError
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:comment
|———————Node:comment
|———————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusMessage);
|————————Node:statement_identifier Text: incrementCounter
|————————Node:ERROR Text: (QModbusServerPrivate:
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: QModbusServerPrivate
|——————————Node:type_identifier Text: QModbusServerPrivate
|—————————Node:: Text: :
|————————Node:: Text: :
|————————Node:labeled_statement Text: Counter::BusMessage);
|—————————Node:statement_identifier Text: Counter
|—————————Node:: Text: :
|—————————Node:ERROR Text: :
|——————————Node:: Text: :
|—————————Node:expression_statement Text: BusMessage);
|——————————Node:identifier Text: BusMessage
|——————————Node:ERROR Text: )
|———————————Node:) Text: )
|——————————Node:; Text: ;
|———————Node:comment
|———————Node:expression_statement Text: m_processesBroadcast = (buffer.at(0) == 0);
|————————Node:assignment_expression Text: m_processesBroadcast = (buffer.at(0) == 0)
|—————————Node:identifier Text: m_processesBroadcast
|—————————Node:= Text: =
|—————————Node:parenthesized_expression Text: (buffer.at(0) == 0)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: buffer.at(0) == 0
|———————————Node:call_expression Text: buffer.at(0)
|————————————Node:field_expression Text: buffer.at
|—————————————Node:identifier Text: buffer
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: at
|————————————Node:argument_list Text: (0)
|—————————————Node:( Text: (
|—————————————Node:number_literal Text: 0
|—————————————Node:) Text: )
|———————————Node:== Text: ==
|———————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment
|———————Node:if_statement Text: if (!q->processesBroadcast()) {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (!q->processesBroadcast())
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !q->processesBroadcast()
|——————————Node:! Text: !
|——————————Node:call_expression Text: q->processesBroadcast()
|———————————Node:field_expression Text: q->processesBroadcast
|————————————Node:identifier Text: q
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: processesBroadcast
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                // check if the slave address matches ...
                if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
            }
|—————————Node:{ Text: {
|—————————Node:comment
|—————————Node:if_statement Text: if (q->slaveAddress() != buffer.at(0)) {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (q->slaveAddress() != buffer.at(0))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: q->slaveAddress() != buffer.at(0)
|————————————Node:call_expression Text: q->slaveAddress()
|—————————————Node:field_expression Text: q->slaveAddress
|——————————————Node:identifier Text: q
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: slaveAddress
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:!= Text: !=
|————————————Node:call_expression Text: buffer.at(0)
|—————————————Node:field_expression Text: buffer.at
|——————————————Node:identifier Text: buffer
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: at
|—————————————Node:argument_list Text: (0)
|——————————————Node:( Text: (
|——————————————Node:number_literal Text: 0
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    // no, not our address! Ignore!
                    qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
                    return;
                }
|———————————Node:{ Text: {
|———————————Node:comment
|———————————Node:expression_statement Text: qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0));
|————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got" << quint8(buffer.at(0))
|—————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
                                       << "got"
|——————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Wrong slave address, expected" << q->slaveAddress()
|———————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Wrong slave address, expected"
|————————————————Node:call_expression Text: qCDebug(QT_MODBUS)
|—————————————————Node:identifier Text: qCDebug
|—————————————————Node:argument_list Text: (QT_MODBUS)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: QT_MODBUS
|——————————————————Node:) Text: )
|————————————————Node:<< Text: <<
|————————————————Node:string_literal Text: "Wrong slave address, expected"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text: Wrong slave address, expected
|—————————————————Node:" Text: "
|———————————————Node:<< Text: <<
|———————————————Node:call_expression Text: q->slaveAddress()
|————————————————Node:field_expression Text: q->slaveAddress
|—————————————————Node:identifier Text: q
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: slaveAddress
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:<< Text: <<
|——————————————Node:string_literal Text: "got"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: got
|———————————————Node:" Text: "
|—————————————Node:<< Text: <<
|—————————————Node:call_expression Text: quint8(buffer.at(0))
|——————————————Node:identifier Text: quint8
|——————————————Node:argument_list Text: (buffer.at(0))
|———————————————Node:( Text: (
|———————————————Node:call_expression Text: buffer.at(0)
|————————————————Node:field_expression Text: buffer.at
|—————————————————Node:identifier Text: buffer
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: at
|————————————————Node:argument_list Text: (0)
|—————————————————Node:( Text: (
|—————————————————Node:number_literal Text: 0
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:return_statement Text: return;
|————————————Node:return Text: return
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:comment
|———————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::ServerMessage);
|————————Node:statement_identifier Text: incrementCounter
|————————Node:ERROR Text: (QModbusServerPrivate:
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: QModbusServerPrivate
|——————————Node:type_identifier Text: QModbusServerPrivate
|—————————Node:: Text: :
|————————Node:: Text: :
|————————Node:labeled_statement Text: Counter::ServerMessage);
|—————————Node:statement_identifier Text: Counter
|—————————Node:: Text: :
|—————————Node:ERROR Text: :
|——————————Node:: Text: :
|—————————Node:expression_statement Text: ServerMessage);
|——————————Node:identifier Text: ServerMessage
|——————————Node:ERROR Text: )
|———————————Node:) Text: )
|——————————Node:; Text: ;
|———————Node:comment
|———————Node:ERROR Text: const QModbusRequest req(code, buffer.mid(2, pduSizeWithoutFcode));
            qCDebug(QT_MODBUS) << "Request PDU" << req;
            const QModbusResponse response = q->processRequest(req);

            if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
            QDataStream out(&result, QIODevice::WriteOnly);
            out << quint8(q->slaveAddress());
            out << response;
            out << calculateCRC(result, result.size());

            qCDebug(QT_MODBUS_LOW) <<
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:type_identifier Text: QModbusRequest
|————————Node:function_declarator Text: req(code, buffer.mid(2, pduSizeWithoutFcode)
|—————————Node:identifier Text: req
|—————————Node:parameter_list Text: (code, buffer.mid(2, pduSizeWithoutFcode)
|——————————Node:( Text: (
|——————————Node:identifier Text: code
|——————————Node:, Text: ,
|——————————Node:identifier Text: buffer
|——————————Node:ERROR Text: .mid(2
|———————————Node:. Text: .
|———————————Node:identifier Text: mid
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|——————————Node:, Text: ,
|——————————Node:identifier Text: pduSizeWithoutFcode
|——————————Node:) Text: )
|————————Node:ERROR Text: );
|—————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:declaration Text: qCDebug(QT_MODBUS) << "Request PDU" << req;
|—————————Node:macro_type_specifier Text: qCDebug(QT_MODBUS)
|——————————Node:identifier Text: qCDebug
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: QT_MODBUS
|———————————Node:type_identifier Text: QT_MODBUS
|——————————Node:) Text: )
|—————————Node:ERROR Text: << "Request PDU" <<
|——————————Node:<< Text: <<
|——————————Node:" Text: "
|——————————Node:identifier Text: Request
|——————————Node:identifier Text: PDU
|——————————Node:" Text: "
|——————————Node:<< Text: <<
|—————————Node:identifier Text: req
|—————————Node:; Text: ;
|————————Node:declaration Text: const QModbusResponse response = q->processRequest(req);
|—————————Node:type_qualifier Text: const
|——————————Node:const Text: const
|—————————Node:type_identifier Text: QModbusResponse
|—————————Node:init_declarator Text: response = q->processRequest(req)
|——————————Node:identifier Text: response
|——————————Node:= Text: =
|——————————Node:call_expression Text: q->processRequest(req)
|———————————Node:field_expression Text: q->processRequest
|————————————Node:identifier Text: q
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: processRequest
|———————————Node:argument_list Text: (req)
|————————————Node:( Text: (
|————————————Node:identifier Text: req
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:declaration Text: if (q->processesBroadcast() || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray result;
|—————————Node:macro_type_specifier Text: if (q->processesBroadcast()
|——————————Node:identifier Text: if
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: q
|———————————Node:type_identifier Text: q
|——————————Node:ERROR Text: ->processesBroadcast(
|———————————Node:-> Text: ->
|———————————Node:identifier Text: processesBroadcast
|———————————Node:( Text: (
|——————————Node:) Text: )
|—————————Node:ERROR Text: || !response.isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }

            qCDebug(QT_MODBUS) << "Response PDU:" << response;

            QByteArray
|——————————Node:|| Text: ||
|——————————Node:! Text: !
|——————————Node:identifier Text: response
|——————————Node:. Text: .
|——————————Node:function_declarator Text: isValid()) {
                // The quantity of messages addressed to the remote device for which it has
                // returned no response (neither a normal response nor an exception response),
                // since its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse)
|———————————Node:identifier Text: isValid
|———————————Node:parameter_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|———————————Node:ERROR Text: ) {
|————————————Node:) Text: )
|————————————Node:{ Text: {
|———————————Node:comment
|———————————Node:comment
|———————————Node:comment
|———————————Node:call_expression Text: incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse)
|————————————Node:identifier Text: incrementCounter
|————————————Node:argument_list Text: (QModbusServerPrivate::Counter::ServerNoResponse)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QModbusServerPrivate
|—————————————Node:ERROR Text: ::Counter::ServerNoResponse
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: Counter
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: ServerNoResponse
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|——————————Node:} Text: }
|——————————Node:function_declarator Text: qCDebug(QT_MODBUS) << "Response PDU:" << response
|———————————Node:identifier Text: qCDebug
|———————————Node:parameter_list Text: (QT_MODBUS)
|————————————Node:( Text: (
|————————————Node:parameter_declaration Text: QT_MODBUS
|—————————————Node:type_identifier Text: QT_MODBUS
|————————————Node:) Text: )
|———————————Node:ERROR Text: << "Response PDU:" <<
|————————————Node:<< Text: <<
|————————————Node:" Text: "
|————————————Node:identifier Text: Response
|————————————Node:identifier Text: PDU
|————————————Node:: Text: :
|————————————Node:" Text: "
|————————————Node:<< Text: <<
|———————————Node:identifier Text: response
|——————————Node:; Text: ;
|——————————Node:identifier Text: QByteArray
|—————————Node:identifier Text: result
|—————————Node:; Text: ;
|————————Node:declaration Text: QDataStream out(&result, QIODevice::WriteOnly);
|—————————Node:type_identifier Text: QDataStream
|—————————Node:function_declarator Text: out(&result, QIODevice::WriteOnly)
|——————————Node:identifier Text: out
|——————————Node:parameter_list Text: (&result, QIODevice::WriteOnly)
|———————————Node:( Text: (
|———————————Node:ERROR Text: &
|————————————Node:& Text: &
|———————————Node:parameter_declaration Text: result
|————————————Node:type_identifier Text: result
|———————————Node:, Text: ,
|———————————Node:parameter_declaration Text: QIODevice::WriteOnly
|————————————Node:type_identifier Text: QIODevice
|————————————Node:ERROR Text: ::
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|————————————Node:identifier Text: WriteOnly
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:declaration Text: out << quint8(q->slaveAddress());
|—————————Node:type_identifier Text: out
|—————————Node:ERROR Text: <<
|——————————Node:<< Text: <<
|—————————Node:function_declarator Text: quint8(q->slaveAddress())
|——————————Node:identifier Text: quint8
|——————————Node:parameter_list Text: (q->slaveAddress())
|———————————Node:( Text: (
|———————————Node:parameter_declaration Text: q->slaveAddress()
|————————————Node:type_identifier Text: q
|————————————Node:ERROR Text: ->
|—————————————Node:-> Text: ->
|————————————Node:function_declarator Text: slaveAddress()
|—————————————Node:identifier Text: slaveAddress
|—————————————Node:parameter_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:declaration Text: out << response;
|—————————Node:type_identifier Text: out
|—————————Node:ERROR Text: <<
|——————————Node:<< Text: <<
|—————————Node:identifier Text: response
|—————————Node:; Text: ;
|————————Node:declaration Text: out << calculateCRC(result, result.size());
|—————————Node:type_identifier Text: out
|—————————Node:ERROR Text: <<
|——————————Node:<< Text: <<
|—————————Node:function_declarator Text: calculateCRC(result, result.size())
|——————————Node:identifier Text: calculateCRC
|——————————Node:parameter_list Text: (result, result.size())
|———————————Node:( Text: (
|———————————Node:parameter_declaration Text: result
|————————————Node:type_identifier Text: result
|———————————Node:, Text: ,
|———————————Node:parameter_declaration Text: result.size()
|————————————Node:type_identifier Text: result
|————————————Node:ERROR Text: .
|—————————————Node:. Text: .
|————————————Node:function_declarator Text: size()
|—————————————Node:identifier Text: size
|—————————————Node:parameter_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:macro_type_specifier Text: qCDebug(QT_MODBUS_LOW)
|—————————Node:identifier Text: qCDebug
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: QT_MODBUS_LOW
|——————————Node:type_identifier Text: QT_MODBUS_LOW
|—————————Node:) Text: )
|————————Node:<< Text: <<
|———————Node:expression_statement Text: "Sending response (incl ADU):" << result.toHex();
|————————Node:binary_expression Text: "Sending response (incl ADU):" << result.toHex()
|—————————Node:string_literal Text: "Sending response (incl ADU):"
|——————————Node:" Text: "
|——————————Node:string_content Text: Sending response (incl ADU):
|——————————Node:" Text: "
|—————————Node:<< Text: <<
|—————————Node:call_expression Text: result.toHex()
|——————————Node:field_expression Text: result.toHex
|———————————Node:identifier Text: result
|———————————Node:. Text: .
|———————————Node:field_identifier Text: toHex
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (!m_serialPort->isOpen()) {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (!m_serialPort->isOpen())
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !m_serialPort->isOpen()
|——————————Node:! Text: !
|——————————Node:call_expression Text: m_serialPort->isOpen()
|———————————Node:field_expression Text: m_serialPort->isOpen
|————————————Node:identifier Text: m_serialPort
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: isOpen
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
                q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: qCDebug(QT_MODBUS) << "Requesting serial port has closed.";
|——————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Requesting serial port has closed."
|———————————Node:call_expression Text: qCDebug(QT_MODBUS)
|————————————Node:identifier Text: qCDebug
|————————————Node:argument_list Text: (QT_MODBUS)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QT_MODBUS
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:string_literal Text: "Requesting serial port has closed."
|————————————Node:" Text: "
|————————————Node:string_content Text: Requesting serial port has closed.
|————————————Node:" Text: "
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError);
|——————————Node:call_expression Text: q->setError(QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError)
|———————————Node:field_expression Text: q->setError
|————————————Node:identifier Text: q
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: setError
|———————————Node:argument_list Text: (QModbusRtuSerialSlave::tr("Requesting serial port is closed"),
                            QModbusDevice::WriteError)
|————————————Node:( Text: (
|————————————Node:ERROR Text: QModbusRtuSerialSlave::
|—————————————Node:identifier Text: QModbusRtuSerialSlave
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|————————————Node:call_expression Text: tr("Requesting serial port is closed")
|—————————————Node:identifier Text: tr
|—————————————Node:argument_list Text: ("Requesting serial port is closed")
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "Requesting serial port is closed"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: Requesting serial port is closed
|———————————————Node:" Text: "
|——————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:identifier Text: QModbusDevice
|————————————Node:ERROR Text: ::WriteError
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|—————————————Node:identifier Text: WriteError
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::ServerNoResponse);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: ServerNoResponse);
|————————————Node:identifier Text: ServerNoResponse
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:declaration Text: int writtenBytes = m_serialPort->write(result);
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: writtenBytes = m_serialPort->write(result)
|—————————Node:identifier Text: writtenBytes
|—————————Node:= Text: =
|—————————Node:call_expression Text: m_serialPort->write(result)
|——————————Node:field_expression Text: m_serialPort->write
|———————————Node:identifier Text: m_serialPort
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: write
|——————————Node:argument_list Text: (result)
|———————————Node:( Text: (
|———————————Node:identifier Text: result
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if ((writtenBytes == -1) || (writtenBytes < result.size())) {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: ((writtenBytes == -1) || (writtenBytes < result.size()))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (writtenBytes == -1) || (writtenBytes < result.size())
|——————————Node:parenthesized_expression Text: (writtenBytes == -1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: writtenBytes == -1
|————————————Node:identifier Text: writtenBytes
|————————————Node:== Text: ==
|————————————Node:number_literal Text: -1
|———————————Node:) Text: )
|——————————Node:|| Text: ||
|——————————Node:parenthesized_expression Text: (writtenBytes < result.size())
|———————————Node:( Text: (
|———————————Node:binary_expression Text: writtenBytes < result.size()
|————————————Node:identifier Text: writtenBytes
|————————————Node:< Text: <
|————————————Node:call_expression Text: result.size()
|—————————————Node:field_expression Text: result.size
|——————————————Node:identifier Text: result
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: size
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
                q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
                incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
                return;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: qCDebug(QT_MODBUS) << "Cannot write requested response to serial port.";
|——————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Cannot write requested response to serial port."
|———————————Node:call_expression Text: qCDebug(QT_MODBUS)
|————————————Node:identifier Text: qCDebug
|————————————Node:argument_list Text: (QT_MODBUS)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QT_MODBUS
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:string_literal Text: "Cannot write requested response to serial port."
|————————————Node:" Text: "
|————————————Node:string_content Text: Cannot write requested response to serial port.
|————————————Node:" Text: "
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError);
|——————————Node:call_expression Text: q->setError(QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError)
|———————————Node:field_expression Text: q->setError
|————————————Node:identifier Text: q
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: setError
|———————————Node:argument_list Text: (QModbusRtuSerialSlave::tr("Could not write response to client"),
                            QModbusDevice::WriteError)
|————————————Node:( Text: (
|————————————Node:ERROR Text: QModbusRtuSerialSlave::
|—————————————Node:identifier Text: QModbusRtuSerialSlave
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|————————————Node:call_expression Text: tr("Could not write response to client")
|—————————————Node:identifier Text: tr
|—————————————Node:argument_list Text: ("Could not write response to client")
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "Could not write response to client"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: Could not write response to client
|———————————————Node:" Text: "
|——————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:identifier Text: QModbusDevice
|————————————Node:ERROR Text: ::WriteError
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|—————————————Node:identifier Text: WriteError
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::ServerNoResponse);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::ServerNoResponse);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: ServerNoResponse);
|————————————Node:identifier Text: ServerNoResponse
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:if_statement Text: if (response.isException()) {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (response.isException())
|—————————Node:( Text: (
|—————————Node:call_expression Text: response.isException()
|——————————Node:field_expression Text: response.isException
|———————————Node:identifier Text: response
|———————————Node:. Text: .
|———————————Node:field_identifier Text: isException
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                // The quantity of messages addressed to the remote device for which it returned a
                // server device busy exception response, since its last restart, clear counters
                // operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);

                // The quantity of messages addressed to the remote device for which it returned a
                // negative acknowledge (NAK) exception response, since its last restart, clear
                // counters operation, or powerup.
                if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);

                // The quantity of Modbus exception responses returned by the remote device since
                // its last restart, clear counters operation, or powerup.
                incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
            }
|—————————Node:{ Text: {
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:if_statement Text: if (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
                    incrementCounter(QModbusServerPrivate::Counter::ServerBusy);
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (response.exceptionCode() == QModbusExceptionResponse::ServerDeviceBusy)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: response.exceptionCode() == QModbusExceptionResponse
|————————————Node:call_expression Text: response.exceptionCode()
|—————————————Node:field_expression Text: response.exceptionCode
|——————————————Node:identifier Text: response
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: exceptionCode
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:== Text: ==
|————————————Node:identifier Text: QModbusExceptionResponse
|———————————Node:ERROR Text: ::ServerDeviceBusy
|————————————Node:: Text: :
|————————————Node:: Text: :
|————————————Node:identifier Text: ServerDeviceBusy
|———————————Node:) Text: )
|——————————Node:expression_statement Text: incrementCounter(QModbusServerPrivate::Counter::ServerBusy);
|———————————Node:call_expression Text: incrementCounter(QModbusServerPrivate::Counter::ServerBusy)
|————————————Node:identifier Text: incrementCounter
|————————————Node:argument_list Text: (QModbusServerPrivate::Counter::ServerBusy)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QModbusServerPrivate
|—————————————Node:ERROR Text: ::Counter::ServerBusy
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: Counter
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: ServerBusy
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|—————————Node:comment
|—————————Node:comment
|—————————Node:comment
|—————————Node:if_statement Text: if (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
                    incrementCounter(QModbusServerPrivate::Counter::ServerNAK);
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (response.exceptionCode() == QModbusExceptionResponse::NegativeAcknowledge)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: response.exceptionCode() == QModbusExceptionResponse
|————————————Node:call_expression Text: response.exceptionCode()
|—————————————Node:field_expression Text: response.exceptionCode
|——————————————Node:identifier Text: response
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: exceptionCode
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:== Text: ==
|————————————Node:identifier Text: QModbusExceptionResponse
|———————————Node:ERROR Text: ::NegativeAcknowledge
|————————————Node:: Text: :
|————————————Node:: Text: :
|————————————Node:identifier Text: NegativeAcknowledge
|———————————Node:) Text: )
|——————————Node:expression_statement Text: incrementCounter(QModbusServerPrivate::Counter::ServerNAK);
|———————————Node:call_expression Text: incrementCounter(QModbusServerPrivate::Counter::ServerNAK)
|————————————Node:identifier Text: incrementCounter
|————————————Node:argument_list Text: (QModbusServerPrivate::Counter::ServerNAK)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: QModbusServerPrivate
|—————————————Node:ERROR Text: ::Counter::ServerNAK
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: Counter
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: ServerNAK
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|—————————Node:comment
|—————————Node:comment
|—————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusExceptionError);
|——————————Node:statement_identifier Text: incrementCounter
|——————————Node:ERROR Text: (QModbusServerPrivate:
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: QModbusServerPrivate
|————————————Node:type_identifier Text: QModbusServerPrivate
|———————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:labeled_statement Text: Counter::BusExceptionError);
|———————————Node:statement_identifier Text: Counter
|———————————Node:: Text: :
|———————————Node:ERROR Text: :
|————————————Node:: Text: :
|———————————Node:expression_statement Text: BusExceptionError);
|————————————Node:identifier Text: BusExceptionError
|————————————Node:ERROR Text: )
|—————————————Node:) Text: )
|————————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|——————Node:ERROR Text: )
|———————Node:) Text: )
|——————Node:expression_statement Text: ;
|———————Node:; Text: ;
|——————Node:declaration Text: using TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError);
|———————Node:type_identifier Text: using
|———————Node:init_declarator Text: TypeId = void (QSerialPort::*)(QSerialPort::SerialPortError)
|————————Node:identifier Text: TypeId
|————————Node:= Text: =
|————————Node:call_expression Text: void (QSerialPort::*)(QSerialPort::SerialPortError)
|—————————Node:call_expression Text: void (QSerialPort::*)
|——————————Node:identifier Text: void
|——————————Node:argument_list Text: (QSerialPort::*)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: QSerialPort::*
|————————————Node:identifier Text: QSerialPort
|————————————Node:ERROR Text: ::
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|————————————Node:* Text: *
|————————————Node:identifier Text: 
|———————————Node:) Text: )
|—————————Node:argument_list Text: (QSerialPort::SerialPortError)
|——————————Node:( Text: (
|——————————Node:ERROR Text: QSerialPort::
|———————————Node:identifier Text: QSerialPort
|———————————Node:: Text: :
|———————————Node:: Text: :
|——————————Node:identifier Text: SerialPortError
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:labeled_statement Text: QObject::connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });
|———————Node:statement_identifier Text: QObject
|———————Node:: Text: :
|———————Node:ERROR Text: :
|————————Node:: Text: :
|———————Node:expression_statement Text: connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        });
|————————Node:call_expression Text: connect(m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        })
|—————————Node:identifier Text: connect
|—————————Node:argument_list Text: (m_serialPort, static_cast<TypeId>(&QSerialPort::error),
                         [this](QSerialPort::SerialPortError error) {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        })
|——————————Node:( Text: (
|——————————Node:identifier Text: m_serialPort
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: static_cast<TypeId>(&QSerialPort::error)
|———————————Node:binary_expression Text: static_cast<TypeId
|————————————Node:identifier Text: static_cast
|————————————Node:< Text: <
|————————————Node:identifier Text: TypeId
|———————————Node:> Text: >
|———————————Node:parenthesized_expression Text: (&QSerialPort::error)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &QSerialPort
|—————————————Node:& Text: &
|—————————————Node:identifier Text: QSerialPort
|————————————Node:ERROR Text: ::error
|—————————————Node:: Text: :
|—————————————Node:: Text: :
|—————————————Node:identifier Text: error
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:ERROR Text: 
                         [this](QSerialPort::SerialPortError error)
|———————————Node:call_expression Text: 
                         [this](QSerialPort::SerialPortError error)
|————————————Node:subscript_expression Text: 
                         [this]
|—————————————Node:identifier Text: 
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: this
|—————————————Node:] Text: ]
|————————————Node:argument_list Text: (QSerialPort::SerialPortError error)
|—————————————Node:( Text: (
|—————————————Node:ERROR Text: QSerialPort::SerialPortError
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: SerialPortError
|—————————————Node:identifier Text: error
|—————————————Node:) Text: )
|——————————Node:compound_statement Text: {
            if (error == QSerialPort::NoError)
                return;

            qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());

            Q_Q(QModbusRtuSerialSlave);

            switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
        }
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (error == QSerialPort::NoError)
                return;
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (error == QSerialPort::NoError)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: error == QSerialPort
|——————————————Node:identifier Text: error
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: QSerialPort
|—————————————Node:ERROR Text: ::NoError
|——————————————Node:: Text: :
|——————————————Node:: Text: :
|——————————————Node:identifier Text: NoError
|—————————————Node:) Text: )
|————————————Node:return_statement Text: return;
|—————————————Node:return Text: return
|—————————————Node:; Text: ;
|———————————Node:expression_statement Text: qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString());
|————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "QSerialPort error:" << error
                               << (m_serialPort ? m_serialPort->errorString() : QString())
|—————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "QSerialPort error:" << error
|——————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "QSerialPort error:"
|———————————————Node:call_expression Text: qCDebug(QT_MODBUS)
|————————————————Node:identifier Text: qCDebug
|————————————————Node:argument_list Text: (QT_MODBUS)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: QT_MODBUS
|—————————————————Node:) Text: )
|———————————————Node:<< Text: <<
|———————————————Node:string_literal Text: "QSerialPort error:"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: QSerialPort error:
|————————————————Node:" Text: "
|——————————————Node:<< Text: <<
|——————————————Node:identifier Text: error
|—————————————Node:<< Text: <<
|—————————————Node:parenthesized_expression Text: (m_serialPort ? m_serialPort->errorString() : QString())
|——————————————Node:( Text: (
|——————————————Node:conditional_expression Text: m_serialPort ? m_serialPort->errorString() : QString()
|———————————————Node:identifier Text: m_serialPort
|———————————————Node:? Text: ?
|———————————————Node:call_expression Text: m_serialPort->errorString()
|————————————————Node:field_expression Text: m_serialPort->errorString
|—————————————————Node:identifier Text: m_serialPort
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: errorString
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|———————————————Node:: Text: :
|———————————————Node:call_expression Text: QString()
|————————————————Node:identifier Text: QString
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: Q_Q(QModbusRtuSerialSlave);
|————————————Node:call_expression Text: Q_Q(QModbusRtuSerialSlave)
|—————————————Node:identifier Text: Q_Q
|—————————————Node:argument_list Text: (QModbusRtuSerialSlave)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: QModbusRtuSerialSlave
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:switch_statement Text: switch (error) {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
|————————————Node:switch Text: switch
|————————————Node:parenthesized_expression Text: (error)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: error
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
            case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
            case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
            case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
            case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
            case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
            case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
            case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
            case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
            default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
            }
|—————————————Node:{ Text: {
|—————————————Node:case_statement Text: case QSerialPort::DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: DeviceNotFoundError:
                q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
|———————————————Node:statement_identifier Text: DeviceNotFoundError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Referenced serial device does not exist."),
                            QModbusDevice::ConnectionError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Referenced serial device does not exist.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Referenced serial device does not exist.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Referenced serial device does not exist."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Referenced serial device does not exist.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConnectionError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: PermissionError:
                q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
|———————————————Node:statement_identifier Text: PermissionError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Cannot open serial device due to permissions."),
                            QModbusDevice::ConnectionError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Cannot open serial device due to permissions.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Cannot open serial device due to permissions.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Cannot open serial device due to permissions."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Cannot open serial device due to permissions.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConnectionError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: OpenError:
            case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
|———————————————Node:statement_identifier Text: OpenError
|———————————————Node:: Text: :
|———————————————Node:case_statement Text: case QSerialPort::NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
                break;
|————————————————Node:case Text: case
|————————————————Node:identifier Text: QSerialPort
|————————————————Node:: Text: :
|————————————————Node:ERROR Text: :
|—————————————————Node:: Text: :
|————————————————Node:labeled_statement Text: NotOpenError:
                q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
|—————————————————Node:statement_identifier Text: NotOpenError
|—————————————————Node:: Text: :
|—————————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError);
|——————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError)
|———————————————————Node:field_expression Text: q->setError
|————————————————————Node:identifier Text: q
|————————————————————Node:-> Text: ->
|————————————————————Node:field_identifier Text: setError
|———————————————————Node:argument_list Text: (QModbusDevice::tr("Cannot open serial device."),
                            QModbusDevice::ConnectionError)
|————————————————————Node:( Text: (
|————————————————————Node:ERROR Text: QModbusDevice::
|—————————————————————Node:identifier Text: QModbusDevice
|—————————————————————Node:: Text: :
|—————————————————————Node:: Text: :
|————————————————————Node:call_expression Text: tr("Cannot open serial device.")
|—————————————————————Node:identifier Text: tr
|—————————————————————Node:argument_list Text: ("Cannot open serial device.")
|——————————————————————Node:( Text: (
|——————————————————————Node:string_literal Text: "Cannot open serial device."
|———————————————————————Node:" Text: "
|———————————————————————Node:string_content Text: Cannot open serial device.
|———————————————————————Node:" Text: "
|——————————————————————Node:) Text: )
|————————————————————Node:, Text: ,
|————————————————————Node:ERROR Text: QModbusDevice::
|—————————————————————Node:identifier Text: QModbusDevice
|—————————————————————Node:: Text: :
|—————————————————————Node:: Text: :
|————————————————————Node:identifier Text: ConnectionError
|————————————————————Node:) Text: )
|——————————————————Node:; Text: ;
|————————————————Node:break_statement Text: break;
|—————————————————Node:break Text: break
|—————————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
                incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: ParityError:
                q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
|———————————————Node:statement_identifier Text: ParityError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Parity error detected."),
                            QModbusDevice::ConfigurationError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Parity error detected.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Parity error detected.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Parity error detected."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Parity error detected.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConfigurationError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:labeled_statement Text: incrementCounter(QModbusServerPrivate::Counter::BusCommunicationError);
|———————————————Node:statement_identifier Text: incrementCounter
|———————————————Node:ERROR Text: (QModbusServerPrivate:
|————————————————Node:( Text: (
|————————————————Node:type_descriptor Text: QModbusServerPrivate
|—————————————————Node:type_identifier Text: QModbusServerPrivate
|————————————————Node:: Text: :
|———————————————Node:: Text: :
|———————————————Node:labeled_statement Text: Counter::BusCommunicationError);
|————————————————Node:statement_identifier Text: Counter
|————————————————Node:: Text: :
|————————————————Node:ERROR Text: :
|—————————————————Node:: Text: :
|————————————————Node:expression_statement Text: BusCommunicationError);
|—————————————————Node:identifier Text: BusCommunicationError
|—————————————————Node:ERROR Text: )
|——————————————————Node:) Text: )
|—————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: FramingError:
                q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
|———————————————Node:statement_identifier Text: FramingError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Framing error detected."),
                            QModbusDevice::ConfigurationError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Framing error detected.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Framing error detected.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Framing error detected."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Framing error detected.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConfigurationError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: BreakConditionError:
                q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
|———————————————Node:statement_identifier Text: BreakConditionError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Break condition error detected."),
                            QModbusDevice::ConnectionError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Break condition error detected.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Break condition error detected.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Break condition error detected."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Break condition error detected.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConnectionError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: WriteError:
                q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
|———————————————Node:statement_identifier Text: WriteError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Write error."), QModbusDevice::WriteError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Write error."), QModbusDevice::WriteError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Write error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Write error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Write error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Write error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:identifier Text: QModbusDevice
|——————————————————Node:ERROR Text: ::WriteError
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|———————————————————Node:identifier Text: WriteError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: ReadError:
                q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
|———————————————Node:statement_identifier Text: ReadError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Read error."), QModbusDevice::ReadError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Read error."), QModbusDevice::ReadError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Read error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Read error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Read error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Read error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:identifier Text: QModbusDevice
|——————————————————Node:ERROR Text: ::ReadError
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|———————————————————Node:identifier Text: ReadError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: ResourceError:
                q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
|———————————————Node:statement_identifier Text: ResourceError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Resource error."), QModbusDevice::ConnectionError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Resource error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Resource error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Resource error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Resource error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConnectionError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: UnsupportedOperationError:
                q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
|———————————————Node:statement_identifier Text: UnsupportedOperationError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Device operation is not supported error."),
                            QModbusDevice::ConfigurationError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Device operation is not supported error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Device operation is not supported error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Device operation is not supported error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Device operation is not supported error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:identifier Text: ConfigurationError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: TimeoutError:
                q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
|———————————————Node:statement_identifier Text: TimeoutError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Timeout error."), QModbusDevice::TimeoutError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Timeout error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Timeout error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Timeout error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Timeout error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:identifier Text: QModbusDevice
|——————————————————Node:ERROR Text: ::TimeoutError
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|———————————————————Node:identifier Text: TimeoutError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case QSerialPort::UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
                break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: QSerialPort
|——————————————Node:: Text: :
|——————————————Node:ERROR Text: :
|———————————————Node:: Text: :
|——————————————Node:labeled_statement Text: UnknownError:
                q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
|———————————————Node:statement_identifier Text: UnknownError
|———————————————Node:: Text: :
|———————————————Node:expression_statement Text: q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError);
|————————————————Node:call_expression Text: q->setError(QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError)
|—————————————————Node:field_expression Text: q->setError
|——————————————————Node:identifier Text: q
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: setError
|—————————————————Node:argument_list Text: (QModbusDevice::tr("Unknown error."), QModbusDevice::UnknownError)
|——————————————————Node:( Text: (
|——————————————————Node:ERROR Text: QModbusDevice::
|———————————————————Node:identifier Text: QModbusDevice
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|——————————————————Node:call_expression Text: tr("Unknown error.")
|———————————————————Node:identifier Text: tr
|———————————————————Node:argument_list Text: ("Unknown error.")
|————————————————————Node:( Text: (
|————————————————————Node:string_literal Text: "Unknown error."
|—————————————————————Node:" Text: "
|—————————————————————Node:string_content Text: Unknown error.
|—————————————————————Node:" Text: "
|————————————————————Node:) Text: )
|——————————————————Node:, Text: ,
|——————————————————Node:identifier Text: QModbusDevice
|——————————————————Node:ERROR Text: ::UnknownError
|———————————————————Node:: Text: :
|———————————————————Node:: Text: :
|———————————————————Node:identifier Text: UnknownError
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: default:
                qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
                break;
|——————————————Node:default Text: default
|——————————————Node:: Text: :
|——————————————Node:expression_statement Text: qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error;
|———————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Unhandled QSerialPort error" << error
|————————————————Node:binary_expression Text: qCDebug(QT_MODBUS) << "Unhandled QSerialPort error"
|—————————————————Node:call_expression Text: qCDebug(QT_MODBUS)
|——————————————————Node:identifier Text: qCDebug
|——————————————————Node:argument_list Text: (QT_MODBUS)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: QT_MODBUS
|———————————————————Node:) Text: )
|—————————————————Node:<< Text: <<
|—————————————————Node:string_literal Text: "Unhandled QSerialPort error"
|——————————————————Node:" Text: "
|——————————————————Node:string_content Text: Unhandled QSerialPort error
|——————————————————Node:" Text: "
|————————————————Node:<< Text: <<
|————————————————Node:identifier Text: error
|———————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:) Text: )
|————————Node:; Text: ;
|——————Node:labeled_statement Text: QObject::connect(m_serialPort, &QSerialPort::aboutToClose, [this]()
|———————Node:statement_identifier Text: QObject
|———————Node:ERROR Text: ::connect(m_serialPort, &QSerialPort:
|————————Node:: Text: :
|————————Node:: Text: :
|————————Node:identifier Text: connect
|————————Node:( Text: (
|————————Node:identifier Text: m_serialPort
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &QSerialPort
|—————————Node:& Text: &
|—————————Node:identifier Text: QSerialPort
|————————Node:: Text: :
|———————Node:: Text: :
|———————Node:expression_statement Text: aboutToClose, [this]()
|————————Node:call_expression Text: aboutToClose, [this]()
|—————————Node:subscript_expression Text: aboutToClose, [this]
|——————————Node:identifier Text: aboutToClose
|——————————Node:ERROR Text: ,
|———————————Node:, Text: ,
|——————————Node:[ Text: [
|——————————Node:identifier Text: this
|——————————Node:] Text: ]
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: 
|——————Node:compound_statement Text: {
            Q_Q(QModbusRtuSerialSlave);
            // update state if socket closure was caused by remote side
            if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: Q_Q(QModbusRtuSerialSlave);
|————————Node:call_expression Text: Q_Q(QModbusRtuSerialSlave)
|—————————Node:identifier Text: Q_Q
|—————————Node:argument_list Text: (QModbusRtuSerialSlave)
|——————————Node:( Text: (
|——————————Node:identifier Text: QModbusRtuSerialSlave
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment
|———————Node:if_statement Text: if (q->state() != QModbusDevice::ClosingState)
                q->setState(QModbusDevice::UnconnectedState);
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (q->state() != QModbusDevice::ClosingState)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: q->state() != QModbusDevice
|——————————Node:call_expression Text: q->state()
|———————————Node:field_expression Text: q->state
|————————————Node:identifier Text: q
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: state
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:!= Text: !=
|——————————Node:identifier Text: QModbusDevice
|—————————Node:ERROR Text: ::ClosingState
|——————————Node:: Text: :
|——————————Node:: Text: :
|——————————Node:identifier Text: ClosingState
|—————————Node:) Text: )
|————————Node:expression_statement Text: q->setState(QModbusDevice::UnconnectedState);
|—————————Node:call_expression Text: q->setState(QModbusDevice::UnconnectedState)
|——————————Node:field_expression Text: q->setState
|———————————Node:identifier Text: q
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: setState
|——————————Node:argument_list Text: (QModbusDevice::UnconnectedState)
|———————————Node:( Text: (
|———————————Node:ERROR Text: QModbusDevice::
|————————————Node:identifier Text: QModbusDevice
|————————————Node:: Text: :
|————————————Node:: Text: :
|———————————Node:identifier Text: UnconnectedState
|———————————Node:) Text: )
|—————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:ERROR Text: )
|———————Node:) Text: )
|——————Node:expression_statement Text: ;
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:declaration Text: void handleErrorOccurred(QSerialPort::SerialPortError);
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: handleErrorOccurred(QSerialPort::SerialPortError)
|——————Node:identifier Text: handleErrorOccurred
|——————Node:parameter_list Text: (QSerialPort::SerialPortError)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: QSerialPort::SerialPortError
|————————Node:type_identifier Text: QSerialPort
|————————Node:ERROR Text: ::
|—————————Node:: Text: :
|—————————Node:: Text: :
|————————Node:identifier Text: SerialPortError
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: void serialPortReadyRead();
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: serialPortReadyRead()
|——————Node:identifier Text: serialPortReadyRead
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: void aboutToClose();
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: aboutToClose()
|——————Node:identifier Text: aboutToClose
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: QSerialPort *m_serialPort;
|—————Node:type_identifier Text: QSerialPort
|—————Node:pointer_declarator Text: *m_serialPort
|——————Node:* Text: *
|——————Node:identifier Text: m_serialPort
|—————Node:; Text: ;
|————Node:declaration Text: bool m_processesBroadcast = false;
|—————Node:primitive_type Text: bool
|—————Node:init_declarator Text: m_processesBroadcast = false
|——————Node:identifier Text: m_processesBroadcast
|——————Node:= Text: =
|——————Node:false Text: false
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:expression_statement Text: ;
|———Node:; Text: ;
|——Node:type_identifier Text: QT_END_NAMESPACE
|——Node:; Text: 
|——Node:#endif Text: #endif
|—Node:comment
