rp2040-can-mcp2515-main.c

|Node:translation_unit
|—Node:preproc_include Text: #include <assert.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <assert.h>
|—Node:preproc_include Text: #include "pico/stdlib.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "pico/stdlib.h"
|———Node:" Text: "
|———Node:string_content Text: pico/stdlib.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "hardware/spi.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/spi.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/spi.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "tusb.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "tusb.h"
|———Node:" Text: "
|———Node:string_content Text: tusb.h
|———Node:" Text: "
|—Node:enum_specifier Text: enum gs_usb_breq {
	GS_USB_BREQ_HOST_FORMAT = 0,
	GS_USB_BREQ_BITTIMING,
	GS_USB_BREQ_MODE,
	GS_USB_BREQ_BERR,
	GS_USB_BREQ_BT_CONST,
	GS_USB_BREQ_DEVICE_CONFIG,
	GS_USB_BREQ_TIMESTAMP,
	GS_USB_BREQ_IDENTIFY,
	GS_USB_BREQ_GET_USER_ID,
	GS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING = GS_USB_BREQ_GET_USER_ID,
	GS_USB_BREQ_SET_USER_ID,
	GS_USB_BREQ_DATA_BITTIMING,
	GS_USB_BREQ_BT_CONST_EXT,
	GS_USB_BREQ_SET_TERMINATION,
	GS_USB_BREQ_GET_TERMINATION,
	GS_USB_BREQ_GET_STATE,
}
|——Node:enum Text: enum
|——Node:type_identifier Text: gs_usb_breq
|——Node:enumerator_list Text: {
	GS_USB_BREQ_HOST_FORMAT = 0,
	GS_USB_BREQ_BITTIMING,
	GS_USB_BREQ_MODE,
	GS_USB_BREQ_BERR,
	GS_USB_BREQ_BT_CONST,
	GS_USB_BREQ_DEVICE_CONFIG,
	GS_USB_BREQ_TIMESTAMP,
	GS_USB_BREQ_IDENTIFY,
	GS_USB_BREQ_GET_USER_ID,
	GS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING = GS_USB_BREQ_GET_USER_ID,
	GS_USB_BREQ_SET_USER_ID,
	GS_USB_BREQ_DATA_BITTIMING,
	GS_USB_BREQ_BT_CONST_EXT,
	GS_USB_BREQ_SET_TERMINATION,
	GS_USB_BREQ_GET_TERMINATION,
	GS_USB_BREQ_GET_STATE,
}
|———Node:{ Text: {
|———Node:enumerator Text: GS_USB_BREQ_HOST_FORMAT = 0
|————Node:identifier Text: GS_USB_BREQ_HOST_FORMAT
|————Node:= Text: =
|————Node:number_literal Text: 0
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_BITTIMING
|————Node:identifier Text: GS_USB_BREQ_BITTIMING
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_MODE
|————Node:identifier Text: GS_USB_BREQ_MODE
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_BERR
|————Node:identifier Text: GS_USB_BREQ_BERR
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_BT_CONST
|————Node:identifier Text: GS_USB_BREQ_BT_CONST
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_DEVICE_CONFIG
|————Node:identifier Text: GS_USB_BREQ_DEVICE_CONFIG
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_TIMESTAMP
|————Node:identifier Text: GS_USB_BREQ_TIMESTAMP
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_IDENTIFY
|————Node:identifier Text: GS_USB_BREQ_IDENTIFY
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_GET_USER_ID
|————Node:identifier Text: GS_USB_BREQ_GET_USER_ID
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING = GS_USB_BREQ_GET_USER_ID
|————Node:identifier Text: GS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING
|————Node:= Text: =
|————Node:identifier Text: GS_USB_BREQ_GET_USER_ID
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_SET_USER_ID
|————Node:identifier Text: GS_USB_BREQ_SET_USER_ID
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_DATA_BITTIMING
|————Node:identifier Text: GS_USB_BREQ_DATA_BITTIMING
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_BT_CONST_EXT
|————Node:identifier Text: GS_USB_BREQ_BT_CONST_EXT
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_SET_TERMINATION
|————Node:identifier Text: GS_USB_BREQ_SET_TERMINATION
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_GET_TERMINATION
|————Node:identifier Text: GS_USB_BREQ_GET_TERMINATION
|———Node:, Text: ,
|———Node:enumerator Text: GS_USB_BREQ_GET_STATE
|————Node:identifier Text: GS_USB_BREQ_GET_STATE
|———Node:, Text: ,
|———Node:} Text: }
|—Node:; Text: ;
|—Node:struct_specifier Text: struct gs_device_config {
	uint8_t reserved1;
	uint8_t reserved2;
	uint8_t reserved3;
	uint8_t icount;
	uint32_t sw_version;
	uint32_t hw_version;
} __attribute__((packed))
|——Node:struct Text: struct
|——Node:type_identifier Text: gs_device_config
|——Node:field_declaration_list Text: {
	uint8_t reserved1;
	uint8_t reserved2;
	uint8_t reserved3;
	uint8_t icount;
	uint32_t sw_version;
	uint32_t hw_version;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint8_t reserved1;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: reserved1
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t reserved2;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: reserved2
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t reserved3;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: reserved3
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t icount;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: icount
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t sw_version;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: sw_version
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t hw_version;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: hw_version
|————Node:; Text: ;
|———Node:} Text: }
|——Node:attribute_specifier Text: __attribute__((packed))
|———Node:__attribute__ Text: __attribute__
|———Node:( Text: (
|———Node:argument_list Text: (packed)
|————Node:( Text: (
|————Node:identifier Text: packed
|————Node:) Text: )
|———Node:) Text: )
|—Node:; Text: ;
|—Node:struct_specifier Text: struct gs_device_bt_const {
	uint32_t feature;
	uint32_t fclk_can;
	uint32_t tseg1_min;
	uint32_t tseg1_max;
	uint32_t tseg2_min;
	uint32_t tseg2_max;
	uint32_t sjw_max;
	uint32_t brp_min;
	uint32_t brp_max;
	uint32_t brp_inc;
} __attribute__((packed))
|——Node:struct Text: struct
|——Node:type_identifier Text: gs_device_bt_const
|——Node:field_declaration_list Text: {
	uint32_t feature;
	uint32_t fclk_can;
	uint32_t tseg1_min;
	uint32_t tseg1_max;
	uint32_t tseg2_min;
	uint32_t tseg2_max;
	uint32_t sjw_max;
	uint32_t brp_min;
	uint32_t brp_max;
	uint32_t brp_inc;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint32_t feature;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: feature
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t fclk_can;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: fclk_can
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t tseg1_min;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: tseg1_min
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t tseg1_max;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: tseg1_max
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t tseg2_min;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: tseg2_min
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t tseg2_max;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: tseg2_max
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t sjw_max;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: sjw_max
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t brp_min;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: brp_min
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t brp_max;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: brp_max
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t brp_inc;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: brp_inc
|————Node:; Text: ;
|———Node:} Text: }
|——Node:attribute_specifier Text: __attribute__((packed))
|———Node:__attribute__ Text: __attribute__
|———Node:( Text: (
|———Node:argument_list Text: (packed)
|————Node:( Text: (
|————Node:identifier Text: packed
|————Node:) Text: )
|———Node:) Text: )
|—Node:; Text: ;
|—Node:struct_specifier Text: struct gs_host_frame {
	uint32_t echo_id;
	uint32_t can_id;

	uint8_t can_dlc;
	uint8_t channel;
	uint8_t flags;
	uint8_t reserved;

	uint8_t data[8];
} __attribute__((packed))
|——Node:struct Text: struct
|——Node:type_identifier Text: gs_host_frame
|——Node:field_declaration_list Text: {
	uint32_t echo_id;
	uint32_t can_id;

	uint8_t can_dlc;
	uint8_t channel;
	uint8_t flags;
	uint8_t reserved;

	uint8_t data[8];
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint32_t echo_id;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: echo_id
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t can_id;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: can_id
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t can_dlc;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: can_dlc
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t channel;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: channel
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t flags;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: flags
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t reserved;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: reserved
|————Node:; Text: ;
|———Node:field_declaration Text: uint8_t data[8];
|————Node:primitive_type Text: uint8_t
|————Node:array_declarator Text: data[8]
|—————Node:field_identifier Text: data
|—————Node:[ Text: [
|—————Node:number_literal Text: 8
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:} Text: }
|——Node:attribute_specifier Text: __attribute__((packed))
|———Node:__attribute__ Text: __attribute__
|———Node:( Text: (
|———Node:argument_list Text: (packed)
|————Node:( Text: (
|————Node:identifier Text: packed
|————Node:) Text: )
|———Node:) Text: )
|—Node:; Text: ;
|—Node:struct_specifier Text: struct gs_device_bittiming {
	uint32_t prop_seg;
	uint32_t phase_seg1;
	uint32_t phase_seg2;
	uint32_t sjw;
	uint32_t brp;
} __attribute__((packed))
|——Node:struct Text: struct
|——Node:type_identifier Text: gs_device_bittiming
|——Node:field_declaration_list Text: {
	uint32_t prop_seg;
	uint32_t phase_seg1;
	uint32_t phase_seg2;
	uint32_t sjw;
	uint32_t brp;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint32_t prop_seg;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: prop_seg
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t phase_seg1;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: phase_seg1
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t phase_seg2;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: phase_seg2
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t sjw;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: sjw
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t brp;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: brp
|————Node:; Text: ;
|———Node:} Text: }
|——Node:attribute_specifier Text: __attribute__((packed))
|———Node:__attribute__ Text: __attribute__
|———Node:( Text: (
|———Node:argument_list Text: (packed)
|————Node:( Text: (
|————Node:identifier Text: packed
|————Node:) Text: )
|———Node:) Text: )
|—Node:; Text: ;
|—Node:struct_specifier Text: struct gs_device_mode {
	uint32_t mode;
	uint32_t flags;
} __attribute__((packed))
|——Node:struct Text: struct
|——Node:type_identifier Text: gs_device_mode
|——Node:field_declaration_list Text: {
	uint32_t mode;
	uint32_t flags;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint32_t mode;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: mode
|————Node:; Text: ;
|———Node:field_declaration Text: uint32_t flags;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: flags
|————Node:; Text: ;
|———Node:} Text: }
|——Node:attribute_specifier Text: __attribute__((packed))
|———Node:__attribute__ Text: __attribute__
|———Node:( Text: (
|———Node:argument_list Text: (packed)
|————Node:( Text: (
|————Node:identifier Text: packed
|————Node:) Text: )
|———Node:) Text: )
|—Node:; Text: ;
|—Node:struct_specifier Text: struct usb_control_out_t {
    uint8_t bRequest;
    void *buffer;
    uint16_t wLength;
}
|——Node:struct Text: struct
|——Node:type_identifier Text: usb_control_out_t
|——Node:field_declaration_list Text: {
    uint8_t bRequest;
    void *buffer;
    uint16_t wLength;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint8_t bRequest;
|————Node:primitive_type Text: uint8_t
|————Node:field_identifier Text: bRequest
|————Node:; Text: ;
|———Node:field_declaration Text: void *buffer;
|————Node:primitive_type Text: void
|————Node:pointer_declarator Text: *buffer
|—————Node:* Text: *
|—————Node:field_identifier Text: buffer
|————Node:; Text: ;
|———Node:field_declaration Text: uint16_t wLength;
|————Node:primitive_type Text: uint16_t
|————Node:field_identifier Text: wLength
|————Node:; Text: ;
|———Node:} Text: }
|—Node:; Text: ;
|—Node:enum_specifier Text: enum mcp2515_mode_t {
    MCP2515_MODE_NORMAL,
    MCP2515_MODE_SLEEP,
    MCP2515_MODE_LOOPBACK,
    MCP2515_MODE_LISTENONLY,
    MCP2515_MODE_CONFIG,
}
|——Node:enum Text: enum
|——Node:type_identifier Text: mcp2515_mode_t
|——Node:enumerator_list Text: {
    MCP2515_MODE_NORMAL,
    MCP2515_MODE_SLEEP,
    MCP2515_MODE_LOOPBACK,
    MCP2515_MODE_LISTENONLY,
    MCP2515_MODE_CONFIG,
}
|———Node:{ Text: {
|———Node:enumerator Text: MCP2515_MODE_NORMAL
|————Node:identifier Text: MCP2515_MODE_NORMAL
|———Node:, Text: ,
|———Node:enumerator Text: MCP2515_MODE_SLEEP
|————Node:identifier Text: MCP2515_MODE_SLEEP
|———Node:, Text: ,
|———Node:enumerator Text: MCP2515_MODE_LOOPBACK
|————Node:identifier Text: MCP2515_MODE_LOOPBACK
|———Node:, Text: ,
|———Node:enumerator Text: MCP2515_MODE_LISTENONLY
|————Node:identifier Text: MCP2515_MODE_LISTENONLY
|———Node:, Text: ,
|———Node:enumerator Text: MCP2515_MODE_CONFIG
|————Node:identifier Text: MCP2515_MODE_CONFIG
|———Node:, Text: ,
|———Node:} Text: }
|—Node:; Text: ;
|—Node:preproc_def Text: #define MCP2515_TX_BUFS 3

|——Node:#define Text: #define
|——Node:identifier Text: MCP2515_TX_BUFS
|——Node:preproc_arg Text: 3
|—Node:declaration Text: const static uint16_t MCP2515_CMD_RESET = 0b11000000;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CMD_RESET = 0b11000000
|———Node:identifier Text: MCP2515_CMD_RESET
|———Node:= Text: =
|———Node:number_literal Text: 0b11000000
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CMD_WRITE = 0b00000010;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CMD_WRITE = 0b00000010
|———Node:identifier Text: MCP2515_CMD_WRITE
|———Node:= Text: =
|———Node:number_literal Text: 0b00000010
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CMD_READ  = 0b00000011;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CMD_READ  = 0b00000011
|———Node:identifier Text: MCP2515_CMD_READ
|———Node:= Text: =
|———Node:number_literal Text: 0b00000011
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CMD_BIT_MODIFY = 0b00000101;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CMD_BIT_MODIFY = 0b00000101
|———Node:identifier Text: MCP2515_CMD_BIT_MODIFY
|———Node:= Text: =
|———Node:number_literal Text: 0b00000101
|——Node:; Text: ;
|—Node:function_definition Text: inline static uint16_t MCP2515_CMD_READ_RX_BUFFER(size_t n) {
    return  0b10010000 | ((n & 1U) << 2U);
}
|——Node:storage_class_specifier Text: inline
|———Node:inline Text: inline
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:function_declarator Text: MCP2515_CMD_READ_RX_BUFFER(size_t n)
|———Node:identifier Text: MCP2515_CMD_READ_RX_BUFFER
|———Node:parameter_list Text: (size_t n)
|————Node:( Text: (
|————Node:parameter_declaration Text: size_t n
|—————Node:primitive_type Text: size_t
|—————Node:identifier Text: n
|————Node:) Text: )
|——Node:compound_statement Text: {
    return  0b10010000 | ((n & 1U) << 2U);
}
|———Node:{ Text: {
|———Node:return_statement Text: return  0b10010000 | ((n & 1U) << 2U);
|————Node:return Text: return
|————Node:binary_expression Text: 0b10010000 | ((n & 1U) << 2U)
|—————Node:number_literal Text: 0b10010000
|—————Node:| Text: |
|—————Node:parenthesized_expression Text: ((n & 1U) << 2U)
|——————Node:( Text: (
|——————Node:binary_expression Text: (n & 1U) << 2U
|———————Node:parenthesized_expression Text: (n & 1U)
|————————Node:( Text: (
|————————Node:binary_expression Text: n & 1U
|—————————Node:identifier Text: n
|—————————Node:& Text: &
|—————————Node:number_literal Text: 1U
|————————Node:) Text: )
|———————Node:<< Text: <<
|———————Node:number_literal Text: 2U
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:declaration Text: const static uint16_t MCP2515_CANSTAT = 0x0E;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CANSTAT = 0x0E
|———Node:identifier Text: MCP2515_CANSTAT
|———Node:= Text: =
|———Node:number_literal Text: 0x0E
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CANCTRL = 0x0F;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CANCTRL = 0x0F
|———Node:identifier Text: MCP2515_CANCTRL
|———Node:= Text: =
|———Node:number_literal Text: 0x0F
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CNF3 = 0x28;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CNF3 = 0x28
|———Node:identifier Text: MCP2515_CNF3
|———Node:= Text: =
|———Node:number_literal Text: 0x28
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CNF2 = 0x29;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CNF2 = 0x29
|———Node:identifier Text: MCP2515_CNF2
|———Node:= Text: =
|———Node:number_literal Text: 0x29
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CNF1 = 0x2A;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CNF1 = 0x2A
|———Node:identifier Text: MCP2515_CNF1
|———Node:= Text: =
|———Node:number_literal Text: 0x2A
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CANINTE = 0x2B;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CANINTE = 0x2B
|———Node:identifier Text: MCP2515_CANINTE
|———Node:= Text: =
|———Node:number_literal Text: 0x2B
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_CANINTF = 0x2C;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_CANINTF = 0x2C
|———Node:identifier Text: MCP2515_CANINTF
|———Node:= Text: =
|———Node:number_literal Text: 0x2C
|——Node:; Text: ;
|—Node:declaration Text: const static uint16_t MCP2515_RXB0CTRL = 0x60;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: MCP2515_RXB0CTRL = 0x60
|———Node:identifier Text: MCP2515_RXB0CTRL
|———Node:= Text: =
|———Node:number_literal Text: 0x60
|——Node:; Text: ;
|—Node:comment Text: // Rollover enable bit (use RX1 if RX0 is full)
|—Node:declaration Text: const static uint8_t MCP2515_RXB0CTRL_BUKT = 1 << 2;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint8_t
|——Node:init_declarator Text: MCP2515_RXB0CTRL_BUKT = 1 << 2
|———Node:identifier Text: MCP2515_RXB0CTRL_BUKT
|———Node:= Text: =
|———Node:binary_expression Text: 1 << 2
|————Node:number_literal Text: 1
|————Node:<< Text: <<
|————Node:number_literal Text: 2
|——Node:; Text: ;
|—Node:declaration Text: const uint32_t CAN_STDMSGID_MAX = 0x7FF;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: uint32_t
|——Node:init_declarator Text: CAN_STDMSGID_MAX = 0x7FF
|———Node:identifier Text: CAN_STDMSGID_MAX
|———Node:= Text: =
|———Node:number_literal Text: 0x7FF
|——Node:; Text: ;
|—Node:declaration Text: const uint8_t SIDL_EXTENDED_MSGID = 1U << 3U;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: uint8_t
|——Node:init_declarator Text: SIDL_EXTENDED_MSGID = 1U << 3U
|———Node:identifier Text: SIDL_EXTENDED_MSGID
|———Node:= Text: =
|———Node:binary_expression Text: 1U << 3U
|————Node:number_literal Text: 1U
|————Node:<< Text: <<
|————Node:number_literal Text: 3U
|——Node:; Text: ;
|—Node:declaration Text: const static uint MCP2515_IRQ_GPIO = 20;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: uint
|——Node:init_declarator Text: MCP2515_IRQ_GPIO = 20
|———Node:identifier Text: MCP2515_IRQ_GPIO
|———Node:= Text: =
|———Node:number_literal Text: 20
|——Node:; Text: ;
|—Node:declaration Text: volatile bool mcp2515_isr_pending = false;
|——Node:type_qualifier Text: volatile
|———Node:volatile Text: volatile
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: mcp2515_isr_pending = false
|———Node:identifier Text: mcp2515_isr_pending
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: volatile struct gs_host_frame tx[MCP2515_TX_BUFS];
|——Node:type_qualifier Text: volatile
|———Node:volatile Text: volatile
|——Node:struct_specifier Text: struct gs_host_frame
|———Node:struct Text: struct
|———Node:type_identifier Text: gs_host_frame
|——Node:array_declarator Text: tx[MCP2515_TX_BUFS]
|———Node:identifier Text: tx
|———Node:[ Text: [
|———Node:identifier Text: MCP2515_TX_BUFS
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:declaration Text: static uint32_t byte_order = 0;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:init_declarator Text: byte_order = 0
|———Node:identifier Text: byte_order
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:declaration Text: static struct gs_device_bittiming device_bittiming;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct gs_device_bittiming
|———Node:struct Text: struct
|———Node:type_identifier Text: gs_device_bittiming
|——Node:identifier Text: device_bittiming
|——Node:; Text: ;
|—Node:declaration Text: static struct gs_device_mode device_mode;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct gs_device_mode
|———Node:struct Text: struct
|———Node:type_identifier Text: gs_device_mode
|——Node:identifier Text: device_mode
|——Node:; Text: ;
|—Node:declaration Text: struct usb_control_out_t usb_control_out[] = {
    {GS_USB_BREQ_HOST_FORMAT, &byte_order, sizeof(byte_order)},
    {GS_USB_BREQ_BITTIMING, &device_bittiming, sizeof(device_bittiming)},
    {GS_USB_BREQ_MODE, &device_mode, sizeof(device_mode)},
};
|——Node:struct_specifier Text: struct usb_control_out_t
|———Node:struct Text: struct
|———Node:type_identifier Text: usb_control_out_t
|——Node:init_declarator Text: usb_control_out[] = {
    {GS_USB_BREQ_HOST_FORMAT, &byte_order, sizeof(byte_order)},
    {GS_USB_BREQ_BITTIMING, &device_bittiming, sizeof(device_bittiming)},
    {GS_USB_BREQ_MODE, &device_mode, sizeof(device_mode)},
}
|———Node:array_declarator Text: usb_control_out[]
|————Node:identifier Text: usb_control_out
|————Node:[ Text: [
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
    {GS_USB_BREQ_HOST_FORMAT, &byte_order, sizeof(byte_order)},
    {GS_USB_BREQ_BITTIMING, &device_bittiming, sizeof(device_bittiming)},
    {GS_USB_BREQ_MODE, &device_mode, sizeof(device_mode)},
}
|————Node:{ Text: {
|————Node:initializer_list Text: {GS_USB_BREQ_HOST_FORMAT, &byte_order, sizeof(byte_order)}
|—————Node:{ Text: {
|—————Node:identifier Text: GS_USB_BREQ_HOST_FORMAT
|—————Node:, Text: ,
|—————Node:pointer_expression Text: &byte_order
|——————Node:& Text: &
|——————Node:identifier Text: byte_order
|—————Node:, Text: ,
|—————Node:sizeof_expression Text: sizeof(byte_order)
|——————Node:sizeof Text: sizeof
|——————Node:parenthesized_expression Text: (byte_order)
|———————Node:( Text: (
|———————Node:identifier Text: byte_order
|———————Node:) Text: )
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {GS_USB_BREQ_BITTIMING, &device_bittiming, sizeof(device_bittiming)}
|—————Node:{ Text: {
|—————Node:identifier Text: GS_USB_BREQ_BITTIMING
|—————Node:, Text: ,
|—————Node:pointer_expression Text: &device_bittiming
|——————Node:& Text: &
|——————Node:identifier Text: device_bittiming
|—————Node:, Text: ,
|—————Node:sizeof_expression Text: sizeof(device_bittiming)
|——————Node:sizeof Text: sizeof
|——————Node:parenthesized_expression Text: (device_bittiming)
|———————Node:( Text: (
|———————Node:identifier Text: device_bittiming
|———————Node:) Text: )
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {GS_USB_BREQ_MODE, &device_mode, sizeof(device_mode)}
|—————Node:{ Text: {
|—————Node:identifier Text: GS_USB_BREQ_MODE
|—————Node:, Text: ,
|—————Node:pointer_expression Text: &device_mode
|——————Node:& Text: &
|——————Node:identifier Text: device_mode
|—————Node:, Text: ,
|—————Node:sizeof_expression Text: sizeof(device_mode)
|——————Node:sizeof Text: sizeof
|——————Node:parenthesized_expression Text: (device_mode)
|———————Node:( Text: (
|———————Node:identifier Text: device_mode
|———————Node:) Text: )
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:function_definition Text: void spi_transmit(uint8_t *tx, uint8_t* rx, size_t len) {
    asm volatile("nop \n nop \n nop");
    gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 0);
    asm volatile("nop \n nop \n nop");
    if(rx) {
        spi_write_read_blocking(spi_default, tx, rx, len);
    } else {
        spi_write_blocking(spi_default, tx, len);
    }
    asm volatile("nop \n nop \n nop");
    gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 1);
    asm volatile("nop \n nop \n nop");
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: spi_transmit(uint8_t *tx, uint8_t* rx, size_t len)
|———Node:identifier Text: spi_transmit
|———Node:parameter_list Text: (uint8_t *tx, uint8_t* rx, size_t len)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t *tx
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: *tx
|——————Node:* Text: *
|——————Node:identifier Text: tx
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t* rx
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: * rx
|——————Node:* Text: *
|——————Node:identifier Text: rx
|————Node:, Text: ,
|————Node:parameter_declaration Text: size_t len
|—————Node:primitive_type Text: size_t
|—————Node:identifier Text: len
|————Node:) Text: )
|——Node:compound_statement Text: {
    asm volatile("nop \n nop \n nop");
    gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 0);
    asm volatile("nop \n nop \n nop");
    if(rx) {
        spi_write_read_blocking(spi_default, tx, rx, len);
    } else {
        spi_write_blocking(spi_default, tx, len);
    }
    asm volatile("nop \n nop \n nop");
    gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 1);
    asm volatile("nop \n nop \n nop");
}
|———Node:{ Text: {
|———Node:expression_statement Text: asm volatile("nop \n nop \n nop");
|————Node:gnu_asm_expression Text: asm volatile("nop \n nop \n nop")
|—————Node:asm Text: asm
|—————Node:gnu_asm_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:( Text: (
|—————Node:string_literal Text: "nop \n nop \n nop"
|——————Node:" Text: "
|——————Node:string_content Text: nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop
|——————Node:" Text: "
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 0);
|————Node:call_expression Text: gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 0)
|—————Node:identifier Text: gpio_put
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_CSN_PIN, 0)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_CSN_PIN
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: asm volatile("nop \n nop \n nop");
|————Node:gnu_asm_expression Text: asm volatile("nop \n nop \n nop")
|—————Node:asm Text: asm
|—————Node:gnu_asm_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:( Text: (
|—————Node:string_literal Text: "nop \n nop \n nop"
|——————Node:" Text: "
|——————Node:string_content Text: nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop
|——————Node:" Text: "
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(rx) {
        spi_write_read_blocking(spi_default, tx, rx, len);
    } else {
        spi_write_blocking(spi_default, tx, len);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (rx)
|—————Node:( Text: (
|—————Node:identifier Text: rx
|—————Node:) Text: )
|————Node:compound_statement Text: {
        spi_write_read_blocking(spi_default, tx, rx, len);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: spi_write_read_blocking(spi_default, tx, rx, len);
|——————Node:call_expression Text: spi_write_read_blocking(spi_default, tx, rx, len)
|———————Node:identifier Text: spi_write_read_blocking
|———————Node:argument_list Text: (spi_default, tx, rx, len)
|————————Node:( Text: (
|————————Node:identifier Text: spi_default
|————————Node:, Text: ,
|————————Node:identifier Text: tx
|————————Node:, Text: ,
|————————Node:identifier Text: rx
|————————Node:, Text: ,
|————————Node:identifier Text: len
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        spi_write_blocking(spi_default, tx, len);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        spi_write_blocking(spi_default, tx, len);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: spi_write_blocking(spi_default, tx, len);
|———————Node:call_expression Text: spi_write_blocking(spi_default, tx, len)
|————————Node:identifier Text: spi_write_blocking
|————————Node:argument_list Text: (spi_default, tx, len)
|—————————Node:( Text: (
|—————————Node:identifier Text: spi_default
|—————————Node:, Text: ,
|—————————Node:identifier Text: tx
|—————————Node:, Text: ,
|—————————Node:identifier Text: len
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: asm volatile("nop \n nop \n nop");
|————Node:gnu_asm_expression Text: asm volatile("nop \n nop \n nop")
|—————Node:asm Text: asm
|—————Node:gnu_asm_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:( Text: (
|—————Node:string_literal Text: "nop \n nop \n nop"
|——————Node:" Text: "
|——————Node:string_content Text: nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop
|——————Node:" Text: "
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 1);
|————Node:call_expression Text: gpio_put(PICO_DEFAULT_SPI_CSN_PIN, 1)
|—————Node:identifier Text: gpio_put
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_CSN_PIN, 1)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_CSN_PIN
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: asm volatile("nop \n nop \n nop");
|————Node:gnu_asm_expression Text: asm volatile("nop \n nop \n nop")
|—————Node:asm Text: asm
|—————Node:gnu_asm_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:( Text: (
|—————Node:string_literal Text: "nop \n nop \n nop"
|——————Node:" Text: "
|——————Node:string_content Text: nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop 
|——————Node:escape_sequence Text: \n
|——————Node:string_content Text:  nop
|——————Node:" Text: "
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void mcp2515_reset() {
    uint8_t tx = MCP2515_CMD_RESET;
    spi_transmit(&tx, NULL, 1);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: mcp2515_reset()
|———Node:identifier Text: mcp2515_reset
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t tx = MCP2515_CMD_RESET;
    spi_transmit(&tx, NULL, 1);
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t tx = MCP2515_CMD_RESET;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: tx = MCP2515_CMD_RESET
|—————Node:identifier Text: tx
|—————Node:= Text: =
|—————Node:identifier Text: MCP2515_CMD_RESET
|————Node:; Text: ;
|———Node:expression_statement Text: spi_transmit(&tx, NULL, 1);
|————Node:call_expression Text: spi_transmit(&tx, NULL, 1)
|—————Node:identifier Text: spi_transmit
|—————Node:argument_list Text: (&tx, NULL, 1)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &tx
|———————Node:& Text: &
|———————Node:identifier Text: tx
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void mcp2515_write(uint8_t addr, uint8_t value) {
    uint8_t tx[] = {
        MCP2515_CMD_WRITE,
        addr,
        value
    };
    spi_transmit(tx, NULL, sizeof(tx));
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: mcp2515_write(uint8_t addr, uint8_t value)
|———Node:identifier Text: mcp2515_write
|———Node:parameter_list Text: (uint8_t addr, uint8_t value)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t addr
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: addr
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t value
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t tx[] = {
        MCP2515_CMD_WRITE,
        addr,
        value
    };
    spi_transmit(tx, NULL, sizeof(tx));
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t tx[] = {
        MCP2515_CMD_WRITE,
        addr,
        value
    };
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: tx[] = {
        MCP2515_CMD_WRITE,
        addr,
        value
    }
|—————Node:array_declarator Text: tx[]
|——————Node:identifier Text: tx
|——————Node:[ Text: [
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {
        MCP2515_CMD_WRITE,
        addr,
        value
    }
|——————Node:{ Text: {
|——————Node:identifier Text: MCP2515_CMD_WRITE
|——————Node:, Text: ,
|——————Node:identifier Text: addr
|——————Node:, Text: ,
|——————Node:identifier Text: value
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:expression_statement Text: spi_transmit(tx, NULL, sizeof(tx));
|————Node:call_expression Text: spi_transmit(tx, NULL, sizeof(tx))
|—————Node:identifier Text: spi_transmit
|—————Node:argument_list Text: (tx, NULL, sizeof(tx))
|——————Node:( Text: (
|——————Node:identifier Text: tx
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (tx)
|————————Node:( Text: (
|————————Node:identifier Text: tx
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t mcp2515_read(uint8_t addr) {
    uint8_t tx[] = {
        MCP2515_CMD_READ,
        addr,
        0 /* dummy for response */
    };
    uint8_t rx[sizeof(tx)];
    spi_transmit(tx, rx, sizeof(tx));
    return rx[2];
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: mcp2515_read(uint8_t addr)
|———Node:identifier Text: mcp2515_read
|———Node:parameter_list Text: (uint8_t addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t addr
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: addr
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t tx[] = {
        MCP2515_CMD_READ,
        addr,
        0 /* dummy for response */
    };
    uint8_t rx[sizeof(tx)];
    spi_transmit(tx, rx, sizeof(tx));
    return rx[2];
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t tx[] = {
        MCP2515_CMD_READ,
        addr,
        0 /* dummy for response */
    };
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: tx[] = {
        MCP2515_CMD_READ,
        addr,
        0 /* dummy for response */
    }
|—————Node:array_declarator Text: tx[]
|——————Node:identifier Text: tx
|——————Node:[ Text: [
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {
        MCP2515_CMD_READ,
        addr,
        0 /* dummy for response */
    }
|——————Node:{ Text: {
|——————Node:identifier Text: MCP2515_CMD_READ
|——————Node:, Text: ,
|——————Node:identifier Text: addr
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:comment Text: /* dummy for response */
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: uint8_t rx[sizeof(tx)];
|————Node:primitive_type Text: uint8_t
|————Node:array_declarator Text: rx[sizeof(tx)]
|—————Node:identifier Text: rx
|—————Node:[ Text: [
|—————Node:sizeof_expression Text: sizeof(tx)
|——————Node:sizeof Text: sizeof
|——————Node:parenthesized_expression Text: (tx)
|———————Node:( Text: (
|———————Node:identifier Text: tx
|———————Node:) Text: )
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: spi_transmit(tx, rx, sizeof(tx));
|————Node:call_expression Text: spi_transmit(tx, rx, sizeof(tx))
|—————Node:identifier Text: spi_transmit
|—————Node:argument_list Text: (tx, rx, sizeof(tx))
|——————Node:( Text: (
|——————Node:identifier Text: tx
|——————Node:, Text: ,
|——————Node:identifier Text: rx
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (tx)
|————————Node:( Text: (
|————————Node:identifier Text: tx
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return rx[2];
|————Node:return Text: return
|————Node:subscript_expression Text: rx[2]
|—————Node:identifier Text: rx
|—————Node:[ Text: [
|—————Node:number_literal Text: 2
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void mcp2515_bit_modify(uint8_t reg, uint8_t mask, uint8_t val) {
    uint8_t tx[] = {MCP2515_CMD_BIT_MODIFY, reg, mask, val};
    spi_transmit(tx, NULL, sizeof(tx));
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: mcp2515_bit_modify(uint8_t reg, uint8_t mask, uint8_t val)
|———Node:identifier Text: mcp2515_bit_modify
|———Node:parameter_list Text: (uint8_t reg, uint8_t mask, uint8_t val)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t reg
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: reg
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t mask
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t val
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t tx[] = {MCP2515_CMD_BIT_MODIFY, reg, mask, val};
    spi_transmit(tx, NULL, sizeof(tx));
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t tx[] = {MCP2515_CMD_BIT_MODIFY, reg, mask, val};
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: tx[] = {MCP2515_CMD_BIT_MODIFY, reg, mask, val}
|—————Node:array_declarator Text: tx[]
|——————Node:identifier Text: tx
|——————Node:[ Text: [
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {MCP2515_CMD_BIT_MODIFY, reg, mask, val}
|——————Node:{ Text: {
|——————Node:identifier Text: MCP2515_CMD_BIT_MODIFY
|——————Node:, Text: ,
|——————Node:identifier Text: reg
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:, Text: ,
|——————Node:identifier Text: val
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:expression_statement Text: spi_transmit(tx, NULL, sizeof(tx));
|————Node:call_expression Text: spi_transmit(tx, NULL, sizeof(tx))
|—————Node:identifier Text: spi_transmit
|—————Node:argument_list Text: (tx, NULL, sizeof(tx))
|——————Node:( Text: (
|——————Node:identifier Text: tx
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (tx)
|————————Node:( Text: (
|————————Node:identifier Text: tx
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t mcp2515_canstat_to_irqs(uint8_t canstat) {
    return (canstat >> 1) & 0b111;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: mcp2515_canstat_to_irqs(uint8_t canstat)
|———Node:identifier Text: mcp2515_canstat_to_irqs
|———Node:parameter_list Text: (uint8_t canstat)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t canstat
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: canstat
|————Node:) Text: )
|——Node:compound_statement Text: {
    return (canstat >> 1) & 0b111;
}
|———Node:{ Text: {
|———Node:return_statement Text: return (canstat >> 1) & 0b111;
|————Node:return Text: return
|————Node:binary_expression Text: (canstat >> 1) & 0b111
|—————Node:parenthesized_expression Text: (canstat >> 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: canstat >> 1
|———————Node:identifier Text: canstat
|———————Node:>> Text: >>
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:& Text: &
|—————Node:number_literal Text: 0b111
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void mcp2515_isr(uint gpio, uint32_t event_mask) {
    mcp2515_isr_pending = true;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: mcp2515_isr(uint gpio, uint32_t event_mask)
|———Node:identifier Text: mcp2515_isr
|———Node:parameter_list Text: (uint gpio, uint32_t event_mask)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint gpio
|—————Node:type_identifier Text: uint
|—————Node:identifier Text: gpio
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t event_mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: event_mask
|————Node:) Text: )
|——Node:compound_statement Text: {
    mcp2515_isr_pending = true;
}
|———Node:{ Text: {
|———Node:expression_statement Text: mcp2515_isr_pending = true;
|————Node:assignment_expression Text: mcp2515_isr_pending = true
|—————Node:identifier Text: mcp2515_isr_pending
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: ssize_t mcp2515_get_free_tx() {
    for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        if(tx[i].echo_id == -1) {
            return i;
        }
    }

    return -1;
}
|——Node:primitive_type Text: ssize_t
|——Node:function_declarator Text: mcp2515_get_free_tx()
|———Node:identifier Text: mcp2515_get_free_tx
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        if(tx[i].echo_id == -1) {
            return i;
        }
    }

    return -1;
}
|———Node:{ Text: {
|———Node:for_statement Text: for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        if(tx[i].echo_id == -1) {
            return i;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: size_t i = 0;
|—————Node:primitive_type Text: size_t
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sizeof(tx) / sizeof(*tx)
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:binary_expression Text: sizeof(tx) / sizeof(*tx)
|——————Node:sizeof_expression Text: sizeof(tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (tx)
|————————Node:( Text: (
|————————Node:identifier Text: tx
|————————Node:) Text: )
|——————Node:/ Text: /
|——————Node:sizeof_expression Text: sizeof(*tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (*tx)
|————————Node:( Text: (
|————————Node:pointer_expression Text: *tx
|—————————Node:* Text: *
|—————————Node:identifier Text: tx
|————————Node:) Text: )
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if(tx[i].echo_id == -1) {
            return i;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if(tx[i].echo_id == -1) {
            return i;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (tx[i].echo_id == -1)
|———————Node:( Text: (
|———————Node:binary_expression Text: tx[i].echo_id == -1
|————————Node:field_expression Text: tx[i].echo_id
|—————————Node:subscript_expression Text: tx[i]
|——————————Node:identifier Text: tx
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: echo_id
|————————Node:== Text: ==
|————————Node:number_literal Text: -1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            return i;
        }
|———————Node:{ Text: {
|———————Node:return_statement Text: return i;
|————————Node:return Text: return
|————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return -1;
|————Node:return Text: return
|————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void mcp2515_set_mode(enum mcp2515_mode_t mode) {
    mcp2515_write(MCP2515_CANCTRL, (mode << 5U));

    // wait until mode is switched
    while((mcp2515_read(MCP2515_CANSTAT) >> 5) != mode) {}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: mcp2515_set_mode(enum mcp2515_mode_t mode)
|———Node:identifier Text: mcp2515_set_mode
|———Node:parameter_list Text: (enum mcp2515_mode_t mode)
|————Node:( Text: (
|————Node:parameter_declaration Text: enum mcp2515_mode_t mode
|—————Node:enum_specifier Text: enum mcp2515_mode_t
|——————Node:enum Text: enum
|——————Node:type_identifier Text: mcp2515_mode_t
|—————Node:identifier Text: mode
|————Node:) Text: )
|——Node:compound_statement Text: {
    mcp2515_write(MCP2515_CANCTRL, (mode << 5U));

    // wait until mode is switched
    while((mcp2515_read(MCP2515_CANSTAT) >> 5) != mode) {}
}
|———Node:{ Text: {
|———Node:expression_statement Text: mcp2515_write(MCP2515_CANCTRL, (mode << 5U));
|————Node:call_expression Text: mcp2515_write(MCP2515_CANCTRL, (mode << 5U))
|—————Node:identifier Text: mcp2515_write
|—————Node:argument_list Text: (MCP2515_CANCTRL, (mode << 5U))
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_CANCTRL
|——————Node:, Text: ,
|——————Node:parenthesized_expression Text: (mode << 5U)
|———————Node:( Text: (
|———————Node:binary_expression Text: mode << 5U
|————————Node:identifier Text: mode
|————————Node:<< Text: <<
|————————Node:number_literal Text: 5U
|———————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // wait until mode is switched
|———Node:while_statement Text: while((mcp2515_read(MCP2515_CANSTAT) >> 5) != mode) {}
|————Node:while Text: while
|————Node:parenthesized_expression Text: ((mcp2515_read(MCP2515_CANSTAT) >> 5) != mode)
|—————Node:( Text: (
|—————Node:binary_expression Text: (mcp2515_read(MCP2515_CANSTAT) >> 5) != mode
|——————Node:parenthesized_expression Text: (mcp2515_read(MCP2515_CANSTAT) >> 5)
|———————Node:( Text: (
|———————Node:binary_expression Text: mcp2515_read(MCP2515_CANSTAT) >> 5
|————————Node:call_expression Text: mcp2515_read(MCP2515_CANSTAT)
|—————————Node:identifier Text: mcp2515_read
|—————————Node:argument_list Text: (MCP2515_CANSTAT)
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP2515_CANSTAT
|——————————Node:) Text: )
|————————Node:>> Text: >>
|————————Node:number_literal Text: 5
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: mode
|—————Node:) Text: )
|————Node:compound_statement Text: {}
|—————Node:{ Text: {
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: int main() {
    tusb_init();

    for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        tx[i].echo_id = -1;
    }

    spi_init(spi_default, 1000 * 1000);
    gpio_set_function(PICO_DEFAULT_SPI_RX_PIN, GPIO_FUNC_SPI);
    gpio_set_function(PICO_DEFAULT_SPI_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(PICO_DEFAULT_SPI_TX_PIN, GPIO_FUNC_SPI);
    gpio_init(PICO_DEFAULT_SPI_CSN_PIN);
    gpio_set_dir(PICO_DEFAULT_SPI_CSN_PIN, GPIO_OUT);

    gpio_init(MCP2515_IRQ_GPIO);
    gpio_set_irq_enabled_with_callback(MCP2515_IRQ_GPIO, GPIO_IRQ_EDGE_FALL, true, mcp2515_isr);

    mcp2515_reset();
    sleep_ms(250);

    // enable interrupts on rxs and txs
    mcp2515_write(MCP2515_CANINTE, 0b11111);

    // use RX1 if RX0 is full
    mcp2515_write(MCP2515_RXB0CTRL, MCP2515_RXB0CTRL_BUKT);

    // transition from config to normal mode
    //mcp2515_set_mode(MCP2515_MODE_SLEEP);
      
    for(;;) {
        if(mcp2515_isr_pending) {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
        
        tud_task();


        if ( tud_vendor_available() ) {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
    }
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: main()
|———Node:identifier Text: main
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    tusb_init();

    for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        tx[i].echo_id = -1;
    }

    spi_init(spi_default, 1000 * 1000);
    gpio_set_function(PICO_DEFAULT_SPI_RX_PIN, GPIO_FUNC_SPI);
    gpio_set_function(PICO_DEFAULT_SPI_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(PICO_DEFAULT_SPI_TX_PIN, GPIO_FUNC_SPI);
    gpio_init(PICO_DEFAULT_SPI_CSN_PIN);
    gpio_set_dir(PICO_DEFAULT_SPI_CSN_PIN, GPIO_OUT);

    gpio_init(MCP2515_IRQ_GPIO);
    gpio_set_irq_enabled_with_callback(MCP2515_IRQ_GPIO, GPIO_IRQ_EDGE_FALL, true, mcp2515_isr);

    mcp2515_reset();
    sleep_ms(250);

    // enable interrupts on rxs and txs
    mcp2515_write(MCP2515_CANINTE, 0b11111);

    // use RX1 if RX0 is full
    mcp2515_write(MCP2515_RXB0CTRL, MCP2515_RXB0CTRL_BUKT);

    // transition from config to normal mode
    //mcp2515_set_mode(MCP2515_MODE_SLEEP);
      
    for(;;) {
        if(mcp2515_isr_pending) {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
        
        tud_task();


        if ( tud_vendor_available() ) {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
    }
}
|———Node:{ Text: {
|———Node:expression_statement Text: tusb_init();
|————Node:call_expression Text: tusb_init()
|—————Node:identifier Text: tusb_init
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for(size_t i = 0; i < sizeof(tx) / sizeof(*tx); i++) {
        tx[i].echo_id = -1;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: size_t i = 0;
|—————Node:primitive_type Text: size_t
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sizeof(tx) / sizeof(*tx)
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:binary_expression Text: sizeof(tx) / sizeof(*tx)
|——————Node:sizeof_expression Text: sizeof(tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (tx)
|————————Node:( Text: (
|————————Node:identifier Text: tx
|————————Node:) Text: )
|——————Node:/ Text: /
|——————Node:sizeof_expression Text: sizeof(*tx)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (*tx)
|————————Node:( Text: (
|————————Node:pointer_expression Text: *tx
|—————————Node:* Text: *
|—————————Node:identifier Text: tx
|————————Node:) Text: )
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        tx[i].echo_id = -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: tx[i].echo_id = -1;
|——————Node:assignment_expression Text: tx[i].echo_id = -1
|———————Node:field_expression Text: tx[i].echo_id
|————————Node:subscript_expression Text: tx[i]
|—————————Node:identifier Text: tx
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: echo_id
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: spi_init(spi_default, 1000 * 1000);
|————Node:call_expression Text: spi_init(spi_default, 1000 * 1000)
|—————Node:identifier Text: spi_init
|—————Node:argument_list Text: (spi_default, 1000 * 1000)
|——————Node:( Text: (
|——————Node:identifier Text: spi_default
|——————Node:, Text: ,
|——————Node:binary_expression Text: 1000 * 1000
|———————Node:number_literal Text: 1000
|———————Node:* Text: *
|———————Node:number_literal Text: 1000
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_set_function(PICO_DEFAULT_SPI_RX_PIN, GPIO_FUNC_SPI);
|————Node:call_expression Text: gpio_set_function(PICO_DEFAULT_SPI_RX_PIN, GPIO_FUNC_SPI)
|—————Node:identifier Text: gpio_set_function
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_RX_PIN, GPIO_FUNC_SPI)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_RX_PIN
|——————Node:, Text: ,
|——————Node:identifier Text: GPIO_FUNC_SPI
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_set_function(PICO_DEFAULT_SPI_SCK_PIN, GPIO_FUNC_SPI);
|————Node:call_expression Text: gpio_set_function(PICO_DEFAULT_SPI_SCK_PIN, GPIO_FUNC_SPI)
|—————Node:identifier Text: gpio_set_function
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_SCK_PIN, GPIO_FUNC_SPI)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_SCK_PIN
|——————Node:, Text: ,
|——————Node:identifier Text: GPIO_FUNC_SPI
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_set_function(PICO_DEFAULT_SPI_TX_PIN, GPIO_FUNC_SPI);
|————Node:call_expression Text: gpio_set_function(PICO_DEFAULT_SPI_TX_PIN, GPIO_FUNC_SPI)
|—————Node:identifier Text: gpio_set_function
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_TX_PIN, GPIO_FUNC_SPI)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_TX_PIN
|——————Node:, Text: ,
|——————Node:identifier Text: GPIO_FUNC_SPI
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_init(PICO_DEFAULT_SPI_CSN_PIN);
|————Node:call_expression Text: gpio_init(PICO_DEFAULT_SPI_CSN_PIN)
|—————Node:identifier Text: gpio_init
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_CSN_PIN)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_CSN_PIN
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_set_dir(PICO_DEFAULT_SPI_CSN_PIN, GPIO_OUT);
|————Node:call_expression Text: gpio_set_dir(PICO_DEFAULT_SPI_CSN_PIN, GPIO_OUT)
|—————Node:identifier Text: gpio_set_dir
|—————Node:argument_list Text: (PICO_DEFAULT_SPI_CSN_PIN, GPIO_OUT)
|——————Node:( Text: (
|——————Node:identifier Text: PICO_DEFAULT_SPI_CSN_PIN
|——————Node:, Text: ,
|——————Node:identifier Text: GPIO_OUT
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_init(MCP2515_IRQ_GPIO);
|————Node:call_expression Text: gpio_init(MCP2515_IRQ_GPIO)
|—————Node:identifier Text: gpio_init
|—————Node:argument_list Text: (MCP2515_IRQ_GPIO)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_IRQ_GPIO
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: gpio_set_irq_enabled_with_callback(MCP2515_IRQ_GPIO, GPIO_IRQ_EDGE_FALL, true, mcp2515_isr);
|————Node:call_expression Text: gpio_set_irq_enabled_with_callback(MCP2515_IRQ_GPIO, GPIO_IRQ_EDGE_FALL, true, mcp2515_isr)
|—————Node:identifier Text: gpio_set_irq_enabled_with_callback
|—————Node:argument_list Text: (MCP2515_IRQ_GPIO, GPIO_IRQ_EDGE_FALL, true, mcp2515_isr)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_IRQ_GPIO
|——————Node:, Text: ,
|——————Node:identifier Text: GPIO_IRQ_EDGE_FALL
|——————Node:, Text: ,
|——————Node:true Text: true
|——————Node:, Text: ,
|——————Node:identifier Text: mcp2515_isr
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_reset();
|————Node:call_expression Text: mcp2515_reset()
|—————Node:identifier Text: mcp2515_reset
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sleep_ms(250);
|————Node:call_expression Text: sleep_ms(250)
|—————Node:identifier Text: sleep_ms
|—————Node:argument_list Text: (250)
|——————Node:( Text: (
|——————Node:number_literal Text: 250
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // enable interrupts on rxs and txs
|———Node:expression_statement Text: mcp2515_write(MCP2515_CANINTE, 0b11111);
|————Node:call_expression Text: mcp2515_write(MCP2515_CANINTE, 0b11111)
|—————Node:identifier Text: mcp2515_write
|—————Node:argument_list Text: (MCP2515_CANINTE, 0b11111)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_CANINTE
|——————Node:, Text: ,
|——————Node:number_literal Text: 0b11111
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // use RX1 if RX0 is full
|———Node:expression_statement Text: mcp2515_write(MCP2515_RXB0CTRL, MCP2515_RXB0CTRL_BUKT);
|————Node:call_expression Text: mcp2515_write(MCP2515_RXB0CTRL, MCP2515_RXB0CTRL_BUKT)
|—————Node:identifier Text: mcp2515_write
|—————Node:argument_list Text: (MCP2515_RXB0CTRL, MCP2515_RXB0CTRL_BUKT)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_RXB0CTRL
|——————Node:, Text: ,
|——————Node:identifier Text: MCP2515_RXB0CTRL_BUKT
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // transition from config to normal mode
|———Node:comment Text: //mcp2515_set_mode(MCP2515_MODE_SLEEP);
|———Node:for_statement Text: for(;;) {
        if(mcp2515_isr_pending) {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
        
        tud_task();


        if ( tud_vendor_available() ) {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:; Text: ;
|————Node:; Text: ;
|————Node:) Text: )
|————Node:compound_statement Text: {
        if(mcp2515_isr_pending) {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
        
        tud_task();


        if ( tud_vendor_available() ) {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if(mcp2515_isr_pending) {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (mcp2515_isr_pending)
|———————Node:( Text: (
|———————Node:identifier Text: mcp2515_isr_pending
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            mcp2515_isr_pending = false;
            struct gs_host_frame rxf;
            uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));

            while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: mcp2515_isr_pending = false;
|————————Node:assignment_expression Text: mcp2515_isr_pending = false
|—————————Node:identifier Text: mcp2515_isr_pending
|—————————Node:= Text: =
|—————————Node:false Text: false
|————————Node:; Text: ;
|———————Node:declaration Text: struct gs_host_frame rxf;
|————————Node:struct_specifier Text: struct gs_host_frame
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: gs_host_frame
|————————Node:identifier Text: rxf
|————————Node:; Text: ;
|———————Node:declaration Text: uint8_t irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
|————————Node:primitive_type Text: uint8_t
|————————Node:init_declarator Text: irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT))
|—————————Node:identifier Text: irqs
|—————————Node:= Text: =
|—————————Node:call_expression Text: mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT))
|——————————Node:identifier Text: mcp2515_canstat_to_irqs
|——————————Node:argument_list Text: (mcp2515_read(MCP2515_CANSTAT))
|———————————Node:( Text: (
|———————————Node:call_expression Text: mcp2515_read(MCP2515_CANSTAT)
|————————————Node:identifier Text: mcp2515_read
|————————————Node:argument_list Text: (MCP2515_CANSTAT)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: MCP2515_CANSTAT
|—————————————Node:) Text: )
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:while_statement Text: while(irqs) {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
|————————Node:while Text: while
|————————Node:parenthesized_expression Text: (irqs)
|—————————Node:( Text: (
|—————————Node:identifier Text: irqs
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if((irqs & 0b110) == 0b110) {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                } else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: ((irqs & 0b110) == 0b110)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (irqs & 0b110) == 0b110
|————————————Node:parenthesized_expression Text: (irqs & 0b110)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: irqs & 0b110
|——————————————Node:identifier Text: irqs
|——————————————Node:& Text: &
|——————————————Node:number_literal Text: 0b110
|—————————————Node:) Text: )
|————————————Node:== Text: ==
|————————————Node:number_literal Text: 0b110
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    uint8_t rxn = irqs & 0b001;
                    // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
                    // and automatically clear pending RX
                    uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
                    uint8_t rx[sizeof(tx)] = {0};
                    spi_transmit(tx, rx, sizeof(tx));
                    // update CANSTAT
                    irqs = mcp2515_canstat_to_irqs(rx[14]);

                    rxf.echo_id = -1;
                    rxf.can_dlc = rx[5] & 0b1111;
                    rxf.flags = 0;
                    rxf.channel = 0;

                    if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
                    memcpy(rxf.data, &rx[6], rxf.can_dlc);

                    tud_vendor_write(&rxf, sizeof(rxf));
                }
|———————————Node:{ Text: {
|———————————Node:declaration Text: uint8_t rxn = irqs & 0b001;
|————————————Node:primitive_type Text: uint8_t
|————————————Node:init_declarator Text: rxn = irqs & 0b001
|—————————————Node:identifier Text: rxn
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: irqs & 0b001
|——————————————Node:identifier Text: irqs
|——————————————Node:& Text: &
|——————————————Node:number_literal Text: 0b001
|————————————Node:; Text: ;
|———————————Node:comment Text: // read RXBnSIDH ... RXBnD0 ... RXBnD7 CANSTAT
|———————————Node:comment Text: // and automatically clear pending RX
|———————————Node:declaration Text: uint8_t tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    };
|————————————Node:primitive_type Text: uint8_t
|————————————Node:init_declarator Text: tx[15] = {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    }
|—————————————Node:array_declarator Text: tx[15]
|——————————————Node:identifier Text: tx
|——————————————Node:[ Text: [
|——————————————Node:number_literal Text: 15
|——————————————Node:] Text: ]
|—————————————Node:= Text: =
|—————————————Node:initializer_list Text: {
                        MCP2515_CMD_READ_RX_BUFFER(rxn),
                    }
|——————————————Node:{ Text: {
|——————————————Node:call_expression Text: MCP2515_CMD_READ_RX_BUFFER(rxn)
|———————————————Node:identifier Text: MCP2515_CMD_READ_RX_BUFFER
|———————————————Node:argument_list Text: (rxn)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: rxn
|————————————————Node:) Text: )
|——————————————Node:, Text: ,
|——————————————Node:} Text: }
|————————————Node:; Text: ;
|———————————Node:declaration Text: uint8_t rx[sizeof(tx)] = {0};
|————————————Node:primitive_type Text: uint8_t
|————————————Node:init_declarator Text: rx[sizeof(tx)] = {0}
|—————————————Node:array_declarator Text: rx[sizeof(tx)]
|——————————————Node:identifier Text: rx
|——————————————Node:[ Text: [
|——————————————Node:sizeof_expression Text: sizeof(tx)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:parenthesized_expression Text: (tx)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: tx
|————————————————Node:) Text: )
|——————————————Node:] Text: ]
|—————————————Node:= Text: =
|—————————————Node:initializer_list Text: {0}
|——————————————Node:{ Text: {
|——————————————Node:number_literal Text: 0
|——————————————Node:} Text: }
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: spi_transmit(tx, rx, sizeof(tx));
|————————————Node:call_expression Text: spi_transmit(tx, rx, sizeof(tx))
|—————————————Node:identifier Text: spi_transmit
|—————————————Node:argument_list Text: (tx, rx, sizeof(tx))
|——————————————Node:( Text: (
|——————————————Node:identifier Text: tx
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: rx
|——————————————Node:, Text: ,
|——————————————Node:sizeof_expression Text: sizeof(tx)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:parenthesized_expression Text: (tx)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: tx
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:comment Text: // update CANSTAT
|———————————Node:expression_statement Text: irqs = mcp2515_canstat_to_irqs(rx[14]);
|————————————Node:assignment_expression Text: irqs = mcp2515_canstat_to_irqs(rx[14])
|—————————————Node:identifier Text: irqs
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: mcp2515_canstat_to_irqs(rx[14])
|——————————————Node:identifier Text: mcp2515_canstat_to_irqs
|——————————————Node:argument_list Text: (rx[14])
|———————————————Node:( Text: (
|———————————————Node:subscript_expression Text: rx[14]
|————————————————Node:identifier Text: rx
|————————————————Node:[ Text: [
|————————————————Node:number_literal Text: 14
|————————————————Node:] Text: ]
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: rxf.echo_id = -1;
|————————————Node:assignment_expression Text: rxf.echo_id = -1
|—————————————Node:field_expression Text: rxf.echo_id
|——————————————Node:identifier Text: rxf
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: echo_id
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: -1
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: rxf.can_dlc = rx[5] & 0b1111;
|————————————Node:assignment_expression Text: rxf.can_dlc = rx[5] & 0b1111
|—————————————Node:field_expression Text: rxf.can_dlc
|——————————————Node:identifier Text: rxf
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: can_dlc
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: rx[5] & 0b1111
|——————————————Node:subscript_expression Text: rx[5]
|———————————————Node:identifier Text: rx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 5
|———————————————Node:] Text: ]
|——————————————Node:& Text: &
|——————————————Node:number_literal Text: 0b1111
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: rxf.flags = 0;
|————————————Node:assignment_expression Text: rxf.flags = 0
|—————————————Node:field_expression Text: rxf.flags
|——————————————Node:identifier Text: rxf
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: flags
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: rxf.channel = 0;
|————————————Node:assignment_expression Text: rxf.channel = 0
|—————————————Node:field_expression Text: rxf.channel
|——————————————Node:identifier Text: rxf
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: channel
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if(rx[2] & SIDL_EXTENDED_MSGID) {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    } else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (rx[2] & SIDL_EXTENDED_MSGID)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: rx[2] & SIDL_EXTENDED_MSGID
|——————————————Node:subscript_expression Text: rx[2]
|———————————————Node:identifier Text: rx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 2
|———————————————Node:] Text: ]
|——————————————Node:& Text: &
|——————————————Node:identifier Text: SIDL_EXTENDED_MSGID
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U); // extended frame, see linux/can.h
                    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U);
|——————————————Node:assignment_expression Text: rxf.can_id = (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U)
|———————————————Node:field_expression Text: rxf.can_id
|————————————————Node:identifier Text: rxf
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: can_id
|———————————————Node:= Text: =
|———————————————Node:binary_expression Text: (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
                            | (1 << 31U)
|————————————————Node:binary_expression Text: (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
                            | rx[4]
|—————————————————Node:binary_expression Text: (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
                            | (rx[3] << 8U)
|——————————————————Node:binary_expression Text: (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
                            | ((rx[2] & 0b11) << 16U)
|———————————————————Node:binary_expression Text: (rx[1] << 21U)
                            | ((rx[2] >> 5U) << 18U)
|————————————————————Node:parenthesized_expression Text: (rx[1] << 21U)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: rx[1] << 21U
|——————————————————————Node:subscript_expression Text: rx[1]
|———————————————————————Node:identifier Text: rx
|———————————————————————Node:[ Text: [
|———————————————————————Node:number_literal Text: 1
|———————————————————————Node:] Text: ]
|——————————————————————Node:<< Text: <<
|——————————————————————Node:number_literal Text: 21U
|—————————————————————Node:) Text: )
|————————————————————Node:| Text: |
|————————————————————Node:parenthesized_expression Text: ((rx[2] >> 5U) << 18U)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: (rx[2] >> 5U) << 18U
|——————————————————————Node:parenthesized_expression Text: (rx[2] >> 5U)
|———————————————————————Node:( Text: (
|———————————————————————Node:binary_expression Text: rx[2] >> 5U
|————————————————————————Node:subscript_expression Text: rx[2]
|—————————————————————————Node:identifier Text: rx
|—————————————————————————Node:[ Text: [
|—————————————————————————Node:number_literal Text: 2
|—————————————————————————Node:] Text: ]
|————————————————————————Node:>> Text: >>
|————————————————————————Node:number_literal Text: 5U
|———————————————————————Node:) Text: )
|——————————————————————Node:<< Text: <<
|——————————————————————Node:number_literal Text: 18U
|—————————————————————Node:) Text: )
|———————————————————Node:| Text: |
|———————————————————Node:parenthesized_expression Text: ((rx[2] & 0b11) << 16U)
|————————————————————Node:( Text: (
|————————————————————Node:binary_expression Text: (rx[2] & 0b11) << 16U
|—————————————————————Node:parenthesized_expression Text: (rx[2] & 0b11)
|——————————————————————Node:( Text: (
|——————————————————————Node:binary_expression Text: rx[2] & 0b11
|———————————————————————Node:subscript_expression Text: rx[2]
|————————————————————————Node:identifier Text: rx
|————————————————————————Node:[ Text: [
|————————————————————————Node:number_literal Text: 2
|————————————————————————Node:] Text: ]
|———————————————————————Node:& Text: &
|———————————————————————Node:number_literal Text: 0b11
|——————————————————————Node:) Text: )
|—————————————————————Node:<< Text: <<
|—————————————————————Node:number_literal Text: 16U
|————————————————————Node:) Text: )
|——————————————————Node:| Text: |
|——————————————————Node:parenthesized_expression Text: (rx[3] << 8U)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: rx[3] << 8U
|————————————————————Node:subscript_expression Text: rx[3]
|—————————————————————Node:identifier Text: rx
|—————————————————————Node:[ Text: [
|—————————————————————Node:number_literal Text: 3
|—————————————————————Node:] Text: ]
|————————————————————Node:<< Text: <<
|————————————————————Node:number_literal Text: 8U
|———————————————————Node:) Text: )
|—————————————————Node:| Text: |
|—————————————————Node:subscript_expression Text: rx[4]
|——————————————————Node:identifier Text: rx
|——————————————————Node:[ Text: [
|——————————————————Node:number_literal Text: 4
|——————————————————Node:] Text: ]
|————————————————Node:| Text: |
|————————————————Node:parenthesized_expression Text: (1 << 31U)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: 1 << 31U
|——————————————————Node:number_literal Text: 1
|——————————————————Node:<< Text: <<
|——————————————————Node:number_literal Text: 31U
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:comment Text: // extended frame, see linux/can.h
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
|—————————————Node:else Text: else
|—————————————Node:compound_statement Text: {
                        rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
                    }
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U);
|———————————————Node:assignment_expression Text: rxf.can_id = (rx[1] << 3U) | (rx[2] >> 5U)
|————————————————Node:field_expression Text: rxf.can_id
|—————————————————Node:identifier Text: rxf
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: can_id
|————————————————Node:= Text: =
|————————————————Node:binary_expression Text: (rx[1] << 3U) | (rx[2] >> 5U)
|—————————————————Node:parenthesized_expression Text: (rx[1] << 3U)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: rx[1] << 3U
|———————————————————Node:subscript_expression Text: rx[1]
|————————————————————Node:identifier Text: rx
|————————————————————Node:[ Text: [
|————————————————————Node:number_literal Text: 1
|————————————————————Node:] Text: ]
|———————————————————Node:<< Text: <<
|———————————————————Node:number_literal Text: 3U
|——————————————————Node:) Text: )
|—————————————————Node:| Text: |
|—————————————————Node:parenthesized_expression Text: (rx[2] >> 5U)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: rx[2] >> 5U
|———————————————————Node:subscript_expression Text: rx[2]
|————————————————————Node:identifier Text: rx
|————————————————————Node:[ Text: [
|————————————————————Node:number_literal Text: 2
|————————————————————Node:] Text: ]
|———————————————————Node:>> Text: >>
|———————————————————Node:number_literal Text: 5U
|——————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|———————————Node:expression_statement Text: memcpy(rxf.data, &rx[6], rxf.can_dlc);
|————————————Node:call_expression Text: memcpy(rxf.data, &rx[6], rxf.can_dlc)
|—————————————Node:identifier Text: memcpy
|—————————————Node:argument_list Text: (rxf.data, &rx[6], rxf.can_dlc)
|——————————————Node:( Text: (
|——————————————Node:field_expression Text: rxf.data
|———————————————Node:identifier Text: rxf
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: data
|——————————————Node:, Text: ,
|——————————————Node:pointer_expression Text: &rx[6]
|———————————————Node:& Text: &
|———————————————Node:subscript_expression Text: rx[6]
|————————————————Node:identifier Text: rx
|————————————————Node:[ Text: [
|————————————————Node:number_literal Text: 6
|————————————————Node:] Text: ]
|——————————————Node:, Text: ,
|——————————————Node:field_expression Text: rxf.can_dlc
|———————————————Node:identifier Text: rxf
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: can_dlc
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: tud_vendor_write(&rxf, sizeof(rxf));
|————————————Node:call_expression Text: tud_vendor_write(&rxf, sizeof(rxf))
|—————————————Node:identifier Text: tud_vendor_write
|—————————————Node:argument_list Text: (&rxf, sizeof(rxf))
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &rxf
|———————————————Node:& Text: &
|———————————————Node:identifier Text: rxf
|——————————————Node:, Text: ,
|——————————————Node:sizeof_expression Text: sizeof(rxf)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:parenthesized_expression Text: (rxf)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: rxf
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
|———————————Node:else Text: else
|———————————Node:if_statement Text: if(irqs >= 0b011 && irqs <= 0b101) {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                } else {
                    for(;;);
                }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (irqs >= 0b011 && irqs <= 0b101)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: irqs >= 0b011 && irqs <= 0b101
|——————————————Node:binary_expression Text: irqs >= 0b011
|———————————————Node:identifier Text: irqs
|———————————————Node:>= Text: >=
|———————————————Node:number_literal Text: 0b011
|——————————————Node:&& Text: &&
|——————————————Node:binary_expression Text: irqs <= 0b101
|———————————————Node:identifier Text: irqs
|———————————————Node:<= Text: <=
|———————————————Node:number_literal Text: 0b101
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                    size_t txn = irqs - 0b011;
                    assert(txn >= 0 && txn < MCP2515_TX_BUFS);
                    assert(tx[txn].echo_id != -1);

                    tud_vendor_write(&tx[txn], sizeof(tx[txn]));
                    tx[txn].echo_id = -1;

                    // ack irq
                    mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);

                    irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
                }
|—————————————Node:{ Text: {
|—————————————Node:declaration Text: size_t txn = irqs - 0b011;
|——————————————Node:primitive_type Text: size_t
|——————————————Node:init_declarator Text: txn = irqs - 0b011
|———————————————Node:identifier Text: txn
|———————————————Node:= Text: =
|———————————————Node:binary_expression Text: irqs - 0b011
|————————————————Node:identifier Text: irqs
|————————————————Node:- Text: -
|————————————————Node:number_literal Text: 0b011
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: assert(txn >= 0 && txn < MCP2515_TX_BUFS);
|——————————————Node:call_expression Text: assert(txn >= 0 && txn < MCP2515_TX_BUFS)
|———————————————Node:identifier Text: assert
|———————————————Node:argument_list Text: (txn >= 0 && txn < MCP2515_TX_BUFS)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: txn >= 0 && txn < MCP2515_TX_BUFS
|—————————————————Node:binary_expression Text: txn >= 0
|——————————————————Node:identifier Text: txn
|——————————————————Node:>= Text: >=
|——————————————————Node:number_literal Text: 0
|—————————————————Node:&& Text: &&
|—————————————————Node:binary_expression Text: txn < MCP2515_TX_BUFS
|——————————————————Node:identifier Text: txn
|——————————————————Node:< Text: <
|——————————————————Node:identifier Text: MCP2515_TX_BUFS
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: assert(tx[txn].echo_id != -1);
|——————————————Node:call_expression Text: assert(tx[txn].echo_id != -1)
|———————————————Node:identifier Text: assert
|———————————————Node:argument_list Text: (tx[txn].echo_id != -1)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: tx[txn].echo_id != -1
|—————————————————Node:field_expression Text: tx[txn].echo_id
|——————————————————Node:subscript_expression Text: tx[txn]
|———————————————————Node:identifier Text: tx
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: txn
|———————————————————Node:] Text: ]
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: echo_id
|—————————————————Node:!= Text: !=
|—————————————————Node:number_literal Text: -1
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: tud_vendor_write(&tx[txn], sizeof(tx[txn]));
|——————————————Node:call_expression Text: tud_vendor_write(&tx[txn], sizeof(tx[txn]))
|———————————————Node:identifier Text: tud_vendor_write
|———————————————Node:argument_list Text: (&tx[txn], sizeof(tx[txn]))
|————————————————Node:( Text: (
|————————————————Node:pointer_expression Text: &tx[txn]
|—————————————————Node:& Text: &
|—————————————————Node:subscript_expression Text: tx[txn]
|——————————————————Node:identifier Text: tx
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: txn
|——————————————————Node:] Text: ]
|————————————————Node:, Text: ,
|————————————————Node:sizeof_expression Text: sizeof(tx[txn])
|—————————————————Node:sizeof Text: sizeof
|—————————————————Node:parenthesized_expression Text: (tx[txn])
|——————————————————Node:( Text: (
|——————————————————Node:subscript_expression Text: tx[txn]
|———————————————————Node:identifier Text: tx
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: txn
|———————————————————Node:] Text: ]
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: tx[txn].echo_id = -1;
|——————————————Node:assignment_expression Text: tx[txn].echo_id = -1
|———————————————Node:field_expression Text: tx[txn].echo_id
|————————————————Node:subscript_expression Text: tx[txn]
|—————————————————Node:identifier Text: tx
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: txn
|—————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: echo_id
|———————————————Node:= Text: =
|———————————————Node:number_literal Text: -1
|——————————————Node:; Text: ;
|—————————————Node:comment Text: // ack irq
|—————————————Node:expression_statement Text: mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0);
|——————————————Node:call_expression Text: mcp2515_bit_modify(MCP2515_CANINTF, 1 << (2 + txn), 0)
|———————————————Node:identifier Text: mcp2515_bit_modify
|———————————————Node:argument_list Text: (MCP2515_CANINTF, 1 << (2 + txn), 0)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: MCP2515_CANINTF
|————————————————Node:, Text: ,
|————————————————Node:binary_expression Text: 1 << (2 + txn)
|—————————————————Node:number_literal Text: 1
|—————————————————Node:<< Text: <<
|—————————————————Node:parenthesized_expression Text: (2 + txn)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: 2 + txn
|———————————————————Node:number_literal Text: 2
|———————————————————Node:+ Text: +
|———————————————————Node:identifier Text: txn
|——————————————————Node:) Text: )
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 0
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT));
|——————————————Node:assignment_expression Text: irqs = mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT))
|———————————————Node:identifier Text: irqs
|———————————————Node:= Text: =
|———————————————Node:call_expression Text: mcp2515_canstat_to_irqs(mcp2515_read(MCP2515_CANSTAT))
|————————————————Node:identifier Text: mcp2515_canstat_to_irqs
|————————————————Node:argument_list Text: (mcp2515_read(MCP2515_CANSTAT))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: mcp2515_read(MCP2515_CANSTAT)
|——————————————————Node:identifier Text: mcp2515_read
|——————————————————Node:argument_list Text: (MCP2515_CANSTAT)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: MCP2515_CANSTAT
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else {
                    for(;;);
                }
|—————————————Node:else Text: else
|—————————————Node:compound_statement Text: {
                    for(;;);
                }
|——————————————Node:{ Text: {
|——————————————Node:for_statement Text: for(;;);
|———————————————Node:for Text: for
|———————————————Node:( Text: (
|———————————————Node:; Text: ;
|———————————————Node:; Text: ;
|———————————————Node:) Text: )
|———————————————Node:expression_statement Text: ;
|————————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: tud_task();
|——————Node:call_expression Text: tud_task()
|———————Node:identifier Text: tud_task
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if ( tud_vendor_available() ) {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: ( tud_vendor_available() )
|———————Node:( Text: (
|———————Node:call_expression Text: tud_vendor_available()
|————————Node:identifier Text: tud_vendor_available
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            ssize_t txn = mcp2515_get_free_tx();
            if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
        }
|———————Node:{ Text: {
|———————Node:declaration Text: ssize_t txn = mcp2515_get_free_tx();
|————————Node:primitive_type Text: ssize_t
|————————Node:init_declarator Text: txn = mcp2515_get_free_tx()
|—————————Node:identifier Text: txn
|—————————Node:= Text: =
|—————————Node:call_expression Text: mcp2515_get_free_tx()
|——————————Node:identifier Text: mcp2515_get_free_tx
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if(txn >= 0) {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (txn >= 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: txn >= 0
|——————————Node:identifier Text: txn
|——————————Node:>= Text: >=
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                struct gs_host_frame *frame = &tx[txn];
                uint32_t count = tud_vendor_read(frame, sizeof(*frame));
                if(count != sizeof(*frame)) {
                    for(;;);
                }

                size_t hdr_size = 6;
                uint8_t tx[hdr_size + sizeof(frame->data)];
                memset(tx, 0, sizeof(tx));
                tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
                if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
                tx[5] = frame->can_dlc; // DLC
                memcpy(&tx[6], frame->data, frame->can_dlc);

                spi_transmit(tx, NULL, hdr_size + frame->can_dlc);

                // request to send
                tx[0] = 0b10000000U | (1U << txn);
                spi_transmit(tx, NULL, 1);
            }
|—————————Node:{ Text: {
|—————————Node:declaration Text: struct gs_host_frame *frame = &tx[txn];
|——————————Node:struct_specifier Text: struct gs_host_frame
|———————————Node:struct Text: struct
|———————————Node:type_identifier Text: gs_host_frame
|——————————Node:init_declarator Text: *frame = &tx[txn]
|———————————Node:pointer_declarator Text: *frame
|————————————Node:* Text: *
|————————————Node:identifier Text: frame
|———————————Node:= Text: =
|———————————Node:pointer_expression Text: &tx[txn]
|————————————Node:& Text: &
|————————————Node:subscript_expression Text: tx[txn]
|—————————————Node:identifier Text: tx
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: txn
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:declaration Text: uint32_t count = tud_vendor_read(frame, sizeof(*frame));
|——————————Node:primitive_type Text: uint32_t
|——————————Node:init_declarator Text: count = tud_vendor_read(frame, sizeof(*frame))
|———————————Node:identifier Text: count
|———————————Node:= Text: =
|———————————Node:call_expression Text: tud_vendor_read(frame, sizeof(*frame))
|————————————Node:identifier Text: tud_vendor_read
|————————————Node:argument_list Text: (frame, sizeof(*frame))
|—————————————Node:( Text: (
|—————————————Node:identifier Text: frame
|—————————————Node:, Text: ,
|—————————————Node:sizeof_expression Text: sizeof(*frame)
|——————————————Node:sizeof Text: sizeof
|——————————————Node:parenthesized_expression Text: (*frame)
|———————————————Node:( Text: (
|———————————————Node:pointer_expression Text: *frame
|————————————————Node:* Text: *
|————————————————Node:identifier Text: frame
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if(count != sizeof(*frame)) {
                    for(;;);
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (count != sizeof(*frame))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: count != sizeof(*frame)
|————————————Node:identifier Text: count
|————————————Node:!= Text: !=
|————————————Node:sizeof_expression Text: sizeof(*frame)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:parenthesized_expression Text: (*frame)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: *frame
|———————————————Node:* Text: *
|———————————————Node:identifier Text: frame
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    for(;;);
                }
|———————————Node:{ Text: {
|———————————Node:for_statement Text: for(;;);
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:; Text: ;
|————————————Node:; Text: ;
|————————————Node:) Text: )
|————————————Node:expression_statement Text: ;
|—————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:declaration Text: size_t hdr_size = 6;
|——————————Node:primitive_type Text: size_t
|——————————Node:init_declarator Text: hdr_size = 6
|———————————Node:identifier Text: hdr_size
|———————————Node:= Text: =
|———————————Node:number_literal Text: 6
|——————————Node:; Text: ;
|—————————Node:declaration Text: uint8_t tx[hdr_size + sizeof(frame->data)];
|——————————Node:primitive_type Text: uint8_t
|——————————Node:array_declarator Text: tx[hdr_size + sizeof(frame->data)]
|———————————Node:identifier Text: tx
|———————————Node:[ Text: [
|———————————Node:binary_expression Text: hdr_size + sizeof(frame->data)
|————————————Node:identifier Text: hdr_size
|————————————Node:+ Text: +
|————————————Node:sizeof_expression Text: sizeof(frame->data)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:parenthesized_expression Text: (frame->data)
|——————————————Node:( Text: (
|——————————————Node:field_expression Text: frame->data
|———————————————Node:identifier Text: frame
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: data
|——————————————Node:) Text: )
|———————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: memset(tx, 0, sizeof(tx));
|——————————Node:call_expression Text: memset(tx, 0, sizeof(tx))
|———————————Node:identifier Text: memset
|———————————Node:argument_list Text: (tx, 0, sizeof(tx))
|————————————Node:( Text: (
|————————————Node:identifier Text: tx
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:, Text: ,
|————————————Node:sizeof_expression Text: sizeof(tx)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:parenthesized_expression Text: (tx)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: tx
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn));
|——————————Node:assignment_expression Text: tx[0] = 0b01000000 | (txn == 0 ? 0 : (1 << txn))
|———————————Node:subscript_expression Text: tx[0]
|————————————Node:identifier Text: tx
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 0
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:binary_expression Text: 0b01000000 | (txn == 0 ? 0 : (1 << txn))
|————————————Node:number_literal Text: 0b01000000
|————————————Node:| Text: |
|————————————Node:parenthesized_expression Text: (txn == 0 ? 0 : (1 << txn))
|—————————————Node:( Text: (
|—————————————Node:conditional_expression Text: txn == 0 ? 0 : (1 << txn)
|——————————————Node:binary_expression Text: txn == 0
|———————————————Node:identifier Text: txn
|———————————————Node:== Text: ==
|———————————————Node:number_literal Text: 0
|——————————————Node:? Text: ?
|——————————————Node:number_literal Text: 0
|——————————————Node:: Text: :
|——————————————Node:parenthesized_expression Text: (1 << txn)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: 1 << txn
|————————————————Node:number_literal Text: 1
|————————————————Node:<< Text: <<
|————————————————Node:identifier Text: txn
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if(frame->can_id <= CAN_STDMSGID_MAX) {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                } else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (frame->can_id <= CAN_STDMSGID_MAX)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: frame->can_id <= CAN_STDMSGID_MAX
|————————————Node:field_expression Text: frame->can_id
|—————————————Node:identifier Text: frame
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:<= Text: <=
|————————————Node:identifier Text: CAN_STDMSGID_MAX
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    tx[1] = frame->can_id >> 3U; // SIDH
                    tx[2] = (frame->can_id & 0b111) << 5U; //SIDL
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: tx[1] = frame->can_id >> 3U;
|————————————Node:assignment_expression Text: tx[1] = frame->can_id >> 3U
|—————————————Node:subscript_expression Text: tx[1]
|——————————————Node:identifier Text: tx
|——————————————Node:[ Text: [
|——————————————Node:number_literal Text: 1
|——————————————Node:] Text: ]
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: frame->can_id >> 3U
|——————————————Node:field_expression Text: frame->can_id
|———————————————Node:identifier Text: frame
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: can_id
|——————————————Node:>> Text: >>
|——————————————Node:number_literal Text: 3U
|————————————Node:; Text: ;
|———————————Node:comment Text: // SIDH
|———————————Node:expression_statement Text: tx[2] = (frame->can_id & 0b111) << 5U;
|————————————Node:assignment_expression Text: tx[2] = (frame->can_id & 0b111) << 5U
|—————————————Node:subscript_expression Text: tx[2]
|——————————————Node:identifier Text: tx
|——————————————Node:[ Text: [
|——————————————Node:number_literal Text: 2
|——————————————Node:] Text: ]
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: (frame->can_id & 0b111) << 5U
|——————————————Node:parenthesized_expression Text: (frame->can_id & 0b111)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: frame->can_id & 0b111
|————————————————Node:field_expression Text: frame->can_id
|—————————————————Node:identifier Text: frame
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: can_id
|————————————————Node:& Text: &
|————————————————Node:number_literal Text: 0b111
|———————————————Node:) Text: )
|——————————————Node:<< Text: <<
|——————————————Node:number_literal Text: 5U
|————————————Node:; Text: ;
|———————————Node:comment Text: //SIDL
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                    // msgid 27..20
                    tx[1] = frame->can_id >> 21U;
                    // msgid 19..18, msgid 16,17, enable extended frame
                    tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
                    // msgid 15..8
                    tx[3] = frame->can_id >> 8U;
                    // msgid 7..0
                    tx[4] = frame->can_id;
                }
|————————————Node:{ Text: {
|————————————Node:comment Text: // msgid 27..20
|————————————Node:expression_statement Text: tx[1] = frame->can_id >> 21U;
|—————————————Node:assignment_expression Text: tx[1] = frame->can_id >> 21U
|——————————————Node:subscript_expression Text: tx[1]
|———————————————Node:identifier Text: tx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:binary_expression Text: frame->can_id >> 21U
|———————————————Node:field_expression Text: frame->can_id
|————————————————Node:identifier Text: frame
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: can_id
|———————————————Node:>> Text: >>
|———————————————Node:number_literal Text: 21U
|—————————————Node:; Text: ;
|————————————Node:comment Text: // msgid 19..18, msgid 16,17, enable extended frame
|————————————Node:expression_statement Text: tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U);
|—————————————Node:assignment_expression Text: tx[2] = (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U)
|——————————————Node:subscript_expression Text: tx[2]
|———————————————Node:identifier Text: tx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 2
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:binary_expression Text: (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
                            | (1U << 3U)
|———————————————Node:binary_expression Text: (((frame->can_id >> 18U) & 0b111U) << 5U)
                            | ((frame->can_id >> 16U) & 0b11U)
|————————————————Node:parenthesized_expression Text: (((frame->can_id >> 18U) & 0b111U) << 5U)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: ((frame->can_id >> 18U) & 0b111U) << 5U
|——————————————————Node:parenthesized_expression Text: ((frame->can_id >> 18U) & 0b111U)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: (frame->can_id >> 18U) & 0b111U
|————————————————————Node:parenthesized_expression Text: (frame->can_id >> 18U)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: frame->can_id >> 18U
|——————————————————————Node:field_expression Text: frame->can_id
|———————————————————————Node:identifier Text: frame
|———————————————————————Node:-> Text: ->
|———————————————————————Node:field_identifier Text: can_id
|——————————————————————Node:>> Text: >>
|——————————————————————Node:number_literal Text: 18U
|—————————————————————Node:) Text: )
|————————————————————Node:& Text: &
|————————————————————Node:number_literal Text: 0b111U
|———————————————————Node:) Text: )
|——————————————————Node:<< Text: <<
|——————————————————Node:number_literal Text: 5U
|—————————————————Node:) Text: )
|————————————————Node:| Text: |
|————————————————Node:parenthesized_expression Text: ((frame->can_id >> 16U) & 0b11U)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: (frame->can_id >> 16U) & 0b11U
|——————————————————Node:parenthesized_expression Text: (frame->can_id >> 16U)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: frame->can_id >> 16U
|————————————————————Node:field_expression Text: frame->can_id
|—————————————————————Node:identifier Text: frame
|—————————————————————Node:-> Text: ->
|—————————————————————Node:field_identifier Text: can_id
|————————————————————Node:>> Text: >>
|————————————————————Node:number_literal Text: 16U
|———————————————————Node:) Text: )
|——————————————————Node:& Text: &
|——————————————————Node:number_literal Text: 0b11U
|—————————————————Node:) Text: )
|———————————————Node:| Text: |
|———————————————Node:parenthesized_expression Text: (1U << 3U)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 1U << 3U
|—————————————————Node:number_literal Text: 1U
|—————————————————Node:<< Text: <<
|—————————————————Node:number_literal Text: 3U
|————————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:comment Text: // msgid 15..8
|————————————Node:expression_statement Text: tx[3] = frame->can_id >> 8U;
|—————————————Node:assignment_expression Text: tx[3] = frame->can_id >> 8U
|——————————————Node:subscript_expression Text: tx[3]
|———————————————Node:identifier Text: tx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 3
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:binary_expression Text: frame->can_id >> 8U
|———————————————Node:field_expression Text: frame->can_id
|————————————————Node:identifier Text: frame
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: can_id
|———————————————Node:>> Text: >>
|———————————————Node:number_literal Text: 8U
|—————————————Node:; Text: ;
|————————————Node:comment Text: // msgid 7..0
|————————————Node:expression_statement Text: tx[4] = frame->can_id;
|—————————————Node:assignment_expression Text: tx[4] = frame->can_id
|——————————————Node:subscript_expression Text: tx[4]
|———————————————Node:identifier Text: tx
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 4
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:field_expression Text: frame->can_id
|———————————————Node:identifier Text: frame
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: can_id
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:expression_statement Text: tx[5] = frame->can_dlc;
|——————————Node:assignment_expression Text: tx[5] = frame->can_dlc
|———————————Node:subscript_expression Text: tx[5]
|————————————Node:identifier Text: tx
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 5
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:field_expression Text: frame->can_dlc
|————————————Node:identifier Text: frame
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can_dlc
|——————————Node:; Text: ;
|—————————Node:comment Text: // DLC
|—————————Node:expression_statement Text: memcpy(&tx[6], frame->data, frame->can_dlc);
|——————————Node:call_expression Text: memcpy(&tx[6], frame->data, frame->can_dlc)
|———————————Node:identifier Text: memcpy
|———————————Node:argument_list Text: (&tx[6], frame->data, frame->can_dlc)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &tx[6]
|—————————————Node:& Text: &
|—————————————Node:subscript_expression Text: tx[6]
|——————————————Node:identifier Text: tx
|——————————————Node:[ Text: [
|——————————————Node:number_literal Text: 6
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:field_expression Text: frame->data
|—————————————Node:identifier Text: frame
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: data
|————————————Node:, Text: ,
|————————————Node:field_expression Text: frame->can_dlc
|—————————————Node:identifier Text: frame
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_dlc
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: spi_transmit(tx, NULL, hdr_size + frame->can_dlc);
|——————————Node:call_expression Text: spi_transmit(tx, NULL, hdr_size + frame->can_dlc)
|———————————Node:identifier Text: spi_transmit
|———————————Node:argument_list Text: (tx, NULL, hdr_size + frame->can_dlc)
|————————————Node:( Text: (
|————————————Node:identifier Text: tx
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: hdr_size + frame->can_dlc
|—————————————Node:identifier Text: hdr_size
|—————————————Node:+ Text: +
|—————————————Node:field_expression Text: frame->can_dlc
|——————————————Node:identifier Text: frame
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: can_dlc
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:comment Text: // request to send
|—————————Node:expression_statement Text: tx[0] = 0b10000000U | (1U << txn);
|——————————Node:assignment_expression Text: tx[0] = 0b10000000U | (1U << txn)
|———————————Node:subscript_expression Text: tx[0]
|————————————Node:identifier Text: tx
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 0
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:binary_expression Text: 0b10000000U | (1U << txn)
|————————————Node:number_literal Text: 0b10000000U
|————————————Node:| Text: |
|————————————Node:parenthesized_expression Text: (1U << txn)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 1U << txn
|——————————————Node:number_literal Text: 1U
|——————————————Node:<< Text: <<
|——————————————Node:identifier Text: txn
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: spi_transmit(tx, NULL, 1);
|——————————Node:call_expression Text: spi_transmit(tx, NULL, 1)
|———————————Node:identifier Text: spi_transmit
|———————————Node:argument_list Text: (tx, NULL, 1)
|————————————Node:( Text: (
|————————————Node:identifier Text: tx
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool usb_handle_control_out(uint8_t req) {
    if(req == GS_USB_BREQ_HOST_FORMAT) {
        return byte_order == 0xbeef;
    } else if(req == GS_USB_BREQ_MODE) {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    } else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
    return false;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: usb_handle_control_out(uint8_t req)
|———Node:identifier Text: usb_handle_control_out
|———Node:parameter_list Text: (uint8_t req)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t req
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: req
|————Node:) Text: )
|——Node:compound_statement Text: {
    if(req == GS_USB_BREQ_HOST_FORMAT) {
        return byte_order == 0xbeef;
    } else if(req == GS_USB_BREQ_MODE) {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    } else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
    return false;
}
|———Node:{ Text: {
|———Node:if_statement Text: if(req == GS_USB_BREQ_HOST_FORMAT) {
        return byte_order == 0xbeef;
    } else if(req == GS_USB_BREQ_MODE) {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    } else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (req == GS_USB_BREQ_HOST_FORMAT)
|—————Node:( Text: (
|—————Node:binary_expression Text: req == GS_USB_BREQ_HOST_FORMAT
|——————Node:identifier Text: req
|——————Node:== Text: ==
|——————Node:identifier Text: GS_USB_BREQ_HOST_FORMAT
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return byte_order == 0xbeef;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return byte_order == 0xbeef;
|——————Node:return Text: return
|——————Node:binary_expression Text: byte_order == 0xbeef
|———————Node:identifier Text: byte_order
|———————Node:== Text: ==
|———————Node:number_literal Text: 0xbeef
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if(req == GS_USB_BREQ_MODE) {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    } else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if(req == GS_USB_BREQ_MODE) {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    } else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (req == GS_USB_BREQ_MODE)
|———————Node:( Text: (
|———————Node:binary_expression Text: req == GS_USB_BREQ_MODE
|————————Node:identifier Text: req
|————————Node:== Text: ==
|————————Node:identifier Text: GS_USB_BREQ_MODE
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
        return true;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP);
|————————Node:call_expression Text: mcp2515_set_mode(device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP)
|—————————Node:identifier Text: mcp2515_set_mode
|—————————Node:argument_list Text: (device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP)
|——————————Node:( Text: (
|——————————Node:conditional_expression Text: device_mode.mode ? MCP2515_MODE_NORMAL : MCP2515_MODE_SLEEP
|———————————Node:field_expression Text: device_mode.mode
|————————————Node:identifier Text: device_mode
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mode
|———————————Node:? Text: ?
|———————————Node:identifier Text: MCP2515_MODE_NORMAL
|———————————Node:: Text: :
|———————————Node:identifier Text: MCP2515_MODE_SLEEP
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return true;
|————————Node:return Text: return
|————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if(req == GS_USB_BREQ_BITTIMING) {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (req == GS_USB_BREQ_BITTIMING)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: req == GS_USB_BREQ_BITTIMING
|——————————Node:identifier Text: req
|——————————Node:== Text: ==
|——————————Node:identifier Text: GS_USB_BREQ_BITTIMING
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
        mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
        mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
        return true;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        );
|——————————Node:call_expression Text: mcp2515_write(MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        )
|———————————Node:identifier Text: mcp2515_write
|———————————Node:argument_list Text: (MCP2515_CNF1, 
            (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
        )
|————————————Node:( Text: (
|————————————Node:identifier Text: MCP2515_CNF1
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: (((device_bittiming.sjw - 1) & 0b11U) << 6U)
            | ((device_bittiming.brp / 2 - 1) & 0b111111U)
|—————————————Node:parenthesized_expression Text: (((device_bittiming.sjw - 1) & 0b11U) << 6U)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: ((device_bittiming.sjw - 1) & 0b11U) << 6U
|———————————————Node:parenthesized_expression Text: ((device_bittiming.sjw - 1) & 0b11U)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: (device_bittiming.sjw - 1) & 0b11U
|—————————————————Node:parenthesized_expression Text: (device_bittiming.sjw - 1)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: device_bittiming.sjw - 1
|———————————————————Node:field_expression Text: device_bittiming.sjw
|————————————————————Node:identifier Text: device_bittiming
|————————————————————Node:. Text: .
|————————————————————Node:field_identifier Text: sjw
|———————————————————Node:- Text: -
|———————————————————Node:number_literal Text: 1
|——————————————————Node:) Text: )
|—————————————————Node:& Text: &
|—————————————————Node:number_literal Text: 0b11U
|————————————————Node:) Text: )
|———————————————Node:<< Text: <<
|———————————————Node:number_literal Text: 6U
|——————————————Node:) Text: )
|—————————————Node:| Text: |
|—————————————Node:parenthesized_expression Text: ((device_bittiming.brp / 2 - 1) & 0b111111U)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (device_bittiming.brp / 2 - 1) & 0b111111U
|———————————————Node:parenthesized_expression Text: (device_bittiming.brp / 2 - 1)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: device_bittiming.brp / 2 - 1
|—————————————————Node:binary_expression Text: device_bittiming.brp / 2
|——————————————————Node:field_expression Text: device_bittiming.brp
|———————————————————Node:identifier Text: device_bittiming
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: brp
|——————————————————Node:/ Text: /
|——————————————————Node:number_literal Text: 2
|—————————————————Node:- Text: -
|—————————————————Node:number_literal Text: 1
|————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0b111111U
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        );
|——————————Node:call_expression Text: mcp2515_write(MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        )
|———————————Node:identifier Text: mcp2515_write
|———————————Node:argument_list Text: (MCP2515_CNF2, 
            ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
        )
|————————————Node:( Text: (
|————————————Node:identifier Text: MCP2515_CNF2
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
            | (1U << 7U)
|—————————————Node:binary_expression Text: ((device_bittiming.prop_seg - 1) & 0b111U)
            | (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
|——————————————Node:parenthesized_expression Text: ((device_bittiming.prop_seg - 1) & 0b111U)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: (device_bittiming.prop_seg - 1) & 0b111U
|————————————————Node:parenthesized_expression Text: (device_bittiming.prop_seg - 1)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: device_bittiming.prop_seg - 1
|——————————————————Node:field_expression Text: device_bittiming.prop_seg
|———————————————————Node:identifier Text: device_bittiming
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: prop_seg
|——————————————————Node:- Text: -
|——————————————————Node:number_literal Text: 1
|—————————————————Node:) Text: )
|————————————————Node:& Text: &
|————————————————Node:number_literal Text: 0b111U
|———————————————Node:) Text: )
|——————————————Node:| Text: |
|——————————————Node:parenthesized_expression Text: (((device_bittiming.phase_seg1 - 1) & 0b111U) << 3)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: ((device_bittiming.phase_seg1 - 1) & 0b111U) << 3
|————————————————Node:parenthesized_expression Text: ((device_bittiming.phase_seg1 - 1) & 0b111U)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: (device_bittiming.phase_seg1 - 1) & 0b111U
|——————————————————Node:parenthesized_expression Text: (device_bittiming.phase_seg1 - 1)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: device_bittiming.phase_seg1 - 1
|————————————————————Node:field_expression Text: device_bittiming.phase_seg1
|—————————————————————Node:identifier Text: device_bittiming
|—————————————————————Node:. Text: .
|—————————————————————Node:field_identifier Text: phase_seg1
|————————————————————Node:- Text: -
|————————————————————Node:number_literal Text: 1
|———————————————————Node:) Text: )
|——————————————————Node:& Text: &
|——————————————————Node:number_literal Text: 0b111U
|—————————————————Node:) Text: )
|————————————————Node:<< Text: <<
|————————————————Node:number_literal Text: 3
|———————————————Node:) Text: )
|—————————————Node:| Text: |
|—————————————Node:parenthesized_expression Text: (1U << 7U)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: 1U << 7U
|———————————————Node:number_literal Text: 1U
|———————————————Node:<< Text: <<
|———————————————Node:number_literal Text: 7U
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        );
|——————————Node:call_expression Text: mcp2515_write(MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        )
|———————————Node:identifier Text: mcp2515_write
|———————————Node:argument_list Text: (MCP2515_CNF3, 
            (((device_bittiming.phase_seg2 - 1) & 0b111U))
        )
|————————————Node:( Text: (
|————————————Node:identifier Text: MCP2515_CNF3
|————————————Node:, Text: ,
|————————————Node:parenthesized_expression Text: (((device_bittiming.phase_seg2 - 1) & 0b111U))
|—————————————Node:( Text: (
|—————————————Node:parenthesized_expression Text: ((device_bittiming.phase_seg2 - 1) & 0b111U)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (device_bittiming.phase_seg2 - 1) & 0b111U
|———————————————Node:parenthesized_expression Text: (device_bittiming.phase_seg2 - 1)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: device_bittiming.phase_seg2 - 1
|—————————————————Node:field_expression Text: device_bittiming.phase_seg2
|——————————————————Node:identifier Text: device_bittiming
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: phase_seg2
|—————————————————Node:- Text: -
|—————————————————Node:number_literal Text: 1
|————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0b111U
|——————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return true;
|——————————Node:return Text: return
|——————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:return_statement Text: return false;
|————Node:return Text: return
|————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool tud_vendor_control_xfer_cb(uint8_t rhport, uint8_t stage, const tusb_control_request_t* request) {
    if(request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR || request->wIndex != 0) {
        return false;
    }

    if(request->bmRequestType_bit.direction == TUSB_DIR_OUT) {
        for(size_t i = 0; i < sizeof(usb_control_out) / sizeof(*usb_control_out); i++) {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
    } else if(request->bmRequestType_bit.direction == TUSB_DIR_IN) {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }

    return false;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: tud_vendor_control_xfer_cb(uint8_t rhport, uint8_t stage, const tusb_control_request_t* request)
|———Node:identifier Text: tud_vendor_control_xfer_cb
|———Node:parameter_list Text: (uint8_t rhport, uint8_t stage, const tusb_control_request_t* request)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t rhport
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: rhport
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t stage
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: stage
|————Node:, Text: ,
|————Node:parameter_declaration Text: const tusb_control_request_t* request
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: tusb_control_request_t
|—————Node:pointer_declarator Text: * request
|——————Node:* Text: *
|——————Node:identifier Text: request
|————Node:) Text: )
|——Node:compound_statement Text: {
    if(request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR || request->wIndex != 0) {
        return false;
    }

    if(request->bmRequestType_bit.direction == TUSB_DIR_OUT) {
        for(size_t i = 0; i < sizeof(usb_control_out) / sizeof(*usb_control_out); i++) {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
    } else if(request->bmRequestType_bit.direction == TUSB_DIR_IN) {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }

    return false;
}
|———Node:{ Text: {
|———Node:if_statement Text: if(request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR || request->wIndex != 0) {
        return false;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR || request->wIndex != 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR || request->wIndex != 0
|——————Node:binary_expression Text: request->bmRequestType_bit.type != TUSB_REQ_TYPE_VENDOR
|———————Node:field_expression Text: request->bmRequestType_bit.type
|————————Node:field_expression Text: request->bmRequestType_bit
|—————————Node:identifier Text: request
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: bmRequestType_bit
|————————Node:. Text: .
|————————Node:field_identifier Text: type
|———————Node:!= Text: !=
|———————Node:identifier Text: TUSB_REQ_TYPE_VENDOR
|——————Node:|| Text: ||
|——————Node:binary_expression Text: request->wIndex != 0
|———————Node:field_expression Text: request->wIndex
|————————Node:identifier Text: request
|————————Node:-> Text: ->
|————————Node:field_identifier Text: wIndex
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return false;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return false;
|——————Node:return Text: return
|——————Node:false Text: false
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if(request->bmRequestType_bit.direction == TUSB_DIR_OUT) {
        for(size_t i = 0; i < sizeof(usb_control_out) / sizeof(*usb_control_out); i++) {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
    } else if(request->bmRequestType_bit.direction == TUSB_DIR_IN) {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (request->bmRequestType_bit.direction == TUSB_DIR_OUT)
|—————Node:( Text: (
|—————Node:binary_expression Text: request->bmRequestType_bit.direction == TUSB_DIR_OUT
|——————Node:field_expression Text: request->bmRequestType_bit.direction
|———————Node:field_expression Text: request->bmRequestType_bit
|————————Node:identifier Text: request
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bmRequestType_bit
|———————Node:. Text: .
|———————Node:field_identifier Text: direction
|——————Node:== Text: ==
|——————Node:identifier Text: TUSB_DIR_OUT
|—————Node:) Text: )
|————Node:compound_statement Text: {
        for(size_t i = 0; i < sizeof(usb_control_out) / sizeof(*usb_control_out); i++) {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
    }
|—————Node:{ Text: {
|—————Node:for_statement Text: for(size_t i = 0; i < sizeof(usb_control_out) / sizeof(*usb_control_out); i++) {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: size_t i = 0;
|———————Node:primitive_type Text: size_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < sizeof(usb_control_out) / sizeof(*usb_control_out)
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:binary_expression Text: sizeof(usb_control_out) / sizeof(*usb_control_out)
|————————Node:sizeof_expression Text: sizeof(usb_control_out)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (usb_control_out)
|——————————Node:( Text: (
|——————————Node:identifier Text: usb_control_out
|——————————Node:) Text: )
|————————Node:/ Text: /
|————————Node:sizeof_expression Text: sizeof(*usb_control_out)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (*usb_control_out)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: *usb_control_out
|———————————Node:* Text: *
|———————————Node:identifier Text: usb_control_out
|——————————Node:) Text: )
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
        }
|———————Node:{ Text: {
|———————Node:if_statement Text: if(usb_control_out[i].bRequest == request->bRequest) {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (usb_control_out[i].bRequest == request->bRequest)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: usb_control_out[i].bRequest == request->bRequest
|——————————Node:field_expression Text: usb_control_out[i].bRequest
|———————————Node:subscript_expression Text: usb_control_out[i]
|————————————Node:identifier Text: usb_control_out
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: bRequest
|——————————Node:== Text: ==
|——————————Node:field_expression Text: request->bRequest
|———————————Node:identifier Text: request
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bRequest
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if(stage == CONTROL_STAGE_SETUP) {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                } else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (stage == CONTROL_STAGE_SETUP)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: stage == CONTROL_STAGE_SETUP
|————————————Node:identifier Text: stage
|————————————Node:== Text: ==
|————————————Node:identifier Text: CONTROL_STAGE_SETUP
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
                }
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if(usb_control_out[i].wLength == request->wLength) {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (usb_control_out[i].wLength == request->wLength)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: usb_control_out[i].wLength == request->wLength
|——————————————Node:field_expression Text: usb_control_out[i].wLength
|———————————————Node:subscript_expression Text: usb_control_out[i]
|————————————————Node:identifier Text: usb_control_out
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: wLength
|——————————————Node:== Text: ==
|——————————————Node:field_expression Text: request->wLength
|———————————————Node:identifier Text: request
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: wLength
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
                    }
|—————————————Node:{ Text: {
|—————————————Node:return_statement Text: return tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength);
|——————————————Node:return Text: return
|——————————————Node:call_expression Text: tud_control_xfer(rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength)
|———————————————Node:identifier Text: tud_control_xfer
|———————————————Node:argument_list Text: (rhport, request, usb_control_out[i].buffer, usb_control_out[i].wLength)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: rhport
|————————————————Node:, Text: ,
|————————————————Node:identifier Text: request
|————————————————Node:, Text: ,
|————————————————Node:field_expression Text: usb_control_out[i].buffer
|—————————————————Node:subscript_expression Text: usb_control_out[i]
|——————————————————Node:identifier Text: usb_control_out
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: buffer
|————————————————Node:, Text: ,
|————————————————Node:field_expression Text: usb_control_out[i].wLength
|—————————————————Node:subscript_expression Text: usb_control_out[i]
|——————————————————Node:identifier Text: usb_control_out
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: wLength
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:else_clause Text: else if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
|———————————Node:else Text: else
|———————————Node:if_statement Text: if(stage == CONTROL_STAGE_DATA) {
                    return usb_handle_control_out(request->bRequest);
                } else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (stage == CONTROL_STAGE_DATA)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: stage == CONTROL_STAGE_DATA
|——————————————Node:identifier Text: stage
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: CONTROL_STAGE_DATA
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                    return usb_handle_control_out(request->bRequest);
                }
|—————————————Node:{ Text: {
|—————————————Node:return_statement Text: return usb_handle_control_out(request->bRequest);
|——————————————Node:return Text: return
|——————————————Node:call_expression Text: usb_handle_control_out(request->bRequest)
|———————————————Node:identifier Text: usb_handle_control_out
|———————————————Node:argument_list Text: (request->bRequest)
|————————————————Node:( Text: (
|————————————————Node:field_expression Text: request->bRequest
|—————————————————Node:identifier Text: request
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: bRequest
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
|—————————————Node:else Text: else
|—————————————Node:if_statement Text: if(stage == CONTROL_STAGE_ACK) {
                    return true;
                }
|——————————————Node:if Text: if
|——————————————Node:parenthesized_expression Text: (stage == CONTROL_STAGE_ACK)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: stage == CONTROL_STAGE_ACK
|————————————————Node:identifier Text: stage
|————————————————Node:== Text: ==
|————————————————Node:identifier Text: CONTROL_STAGE_ACK
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
                    return true;
                }
|———————————————Node:{ Text: {
|———————————————Node:return_statement Text: return true;
|————————————————Node:return Text: return
|————————————————Node:true Text: true
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else if(request->bmRequestType_bit.direction == TUSB_DIR_IN) {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if(request->bmRequestType_bit.direction == TUSB_DIR_IN) {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (request->bmRequestType_bit.direction == TUSB_DIR_IN)
|———————Node:( Text: (
|———————Node:binary_expression Text: request->bmRequestType_bit.direction == TUSB_DIR_IN
|————————Node:field_expression Text: request->bmRequestType_bit.direction
|—————————Node:field_expression Text: request->bmRequestType_bit
|——————————Node:identifier Text: request
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: bmRequestType_bit
|—————————Node:. Text: .
|—————————Node:field_identifier Text: direction
|————————Node:== Text: ==
|————————Node:identifier Text: TUSB_DIR_IN
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if(request->bRequest == GS_USB_BREQ_DEVICE_CONFIG) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        } else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (request->bRequest == GS_USB_BREQ_DEVICE_CONFIG)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: request->bRequest == GS_USB_BREQ_DEVICE_CONFIG
|——————————Node:field_expression Text: request->bRequest
|———————————Node:identifier Text: request
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bRequest
|——————————Node:== Text: ==
|——————————Node:identifier Text: GS_USB_BREQ_DEVICE_CONFIG
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (stage == CONTROL_STAGE_SETUP)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: stage == CONTROL_STAGE_SETUP
|————————————Node:identifier Text: stage
|————————————Node:== Text: ==
|————————————Node:identifier Text: CONTROL_STAGE_SETUP
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                struct gs_device_config res;
                res.icount = 0;
                res.sw_version = 18;
                res.hw_version = 11;
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            }
|———————————Node:{ Text: {
|———————————Node:declaration Text: struct gs_device_config res;
|————————————Node:struct_specifier Text: struct gs_device_config
|—————————————Node:struct Text: struct
|—————————————Node:type_identifier Text: gs_device_config
|————————————Node:identifier Text: res
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: res.icount = 0;
|————————————Node:assignment_expression Text: res.icount = 0
|—————————————Node:field_expression Text: res.icount
|——————————————Node:identifier Text: res
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: icount
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: res.sw_version = 18;
|————————————Node:assignment_expression Text: res.sw_version = 18
|—————————————Node:field_expression Text: res.sw_version
|——————————————Node:identifier Text: res
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: sw_version
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 18
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: res.hw_version = 11;
|————————————Node:assignment_expression Text: res.hw_version = 11
|—————————————Node:field_expression Text: res.hw_version
|——————————————Node:identifier Text: res
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: hw_version
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 11
|————————————Node:; Text: ;
|———————————Node:return_statement Text: return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
|————————————Node:return Text: return
|————————————Node:call_expression Text: tud_control_xfer(rhport, request, (void*) &res, sizeof(res))
|—————————————Node:identifier Text: tud_control_xfer
|—————————————Node:argument_list Text: (rhport, request, (void*) &res, sizeof(res))
|——————————————Node:( Text: (
|——————————————Node:identifier Text: rhport
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: request
|——————————————Node:, Text: ,
|——————————————Node:cast_expression Text: (void*) &res
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: void*
|————————————————Node:primitive_type Text: void
|————————————————Node:abstract_pointer_declarator Text: *
|—————————————————Node:* Text: *
|———————————————Node:) Text: )
|———————————————Node:pointer_expression Text: &res
|————————————————Node:& Text: &
|————————————————Node:identifier Text: res
|——————————————Node:, Text: ,
|——————————————Node:sizeof_expression Text: sizeof(res)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:parenthesized_expression Text: (res)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: res
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
                return true;
            }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                return true;
            }
|————————————Node:{ Text: {
|————————————Node:return_statement Text: return true;
|—————————————Node:return Text: return
|—————————————Node:true Text: true
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:else_clause Text: else if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if(request->bRequest == GS_USB_BREQ_BT_CONST) {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (request->bRequest == GS_USB_BREQ_BT_CONST)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: request->bRequest == GS_USB_BREQ_BT_CONST
|————————————Node:field_expression Text: request->bRequest
|—————————————Node:identifier Text: request
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: bRequest
|————————————Node:== Text: ==
|————————————Node:identifier Text: GS_USB_BREQ_BT_CONST
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
            if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
        }
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if(stage == CONTROL_STAGE_SETUP) {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            } else {
                return true;
            }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (stage == CONTROL_STAGE_SETUP)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: stage == CONTROL_STAGE_SETUP
|——————————————Node:identifier Text: stage
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: CONTROL_STAGE_SETUP
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
                return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
            }
|—————————————Node:{ Text: {
|—————————————Node:declaration Text: struct gs_device_bt_const res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                };
|——————————————Node:struct_specifier Text: struct gs_device_bt_const
|———————————————Node:struct Text: struct
|———————————————Node:type_identifier Text: gs_device_bt_const
|——————————————Node:init_declarator Text: res = {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                }
|———————————————Node:identifier Text: res
|———————————————Node:= Text: =
|———————————————Node:initializer_list Text: {
                    0,
                    8000000,
                    // tseg1 1..8 (3 bits)
                    1, 8,
                    // tseg2 1..8 (3 bits)
                    1, 8,
                    // sjw 0..3 (2 bits)
                    4,
                    // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
                    2, 64, 2
                }
|————————————————Node:{ Text: {
|————————————————Node:number_literal Text: 0
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 8000000
|————————————————Node:, Text: ,
|————————————————Node:comment Text: // tseg1 1..8 (3 bits)
|————————————————Node:number_literal Text: 1
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 8
|————————————————Node:, Text: ,
|————————————————Node:comment Text: // tseg2 1..8 (3 bits)
|————————————————Node:number_literal Text: 1
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 8
|————————————————Node:, Text: ,
|————————————————Node:comment Text: // sjw 0..3 (2 bits)
|————————————————Node:number_literal Text: 4
|————————————————Node:, Text: ,
|————————————————Node:comment Text: // brp 2..64 with increment of 2 (Tq = 2 * (BRP + 1) / Fosc)
|————————————————Node:number_literal Text: 2
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 64
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 2
|————————————————Node:} Text: }
|——————————————Node:; Text: ;
|—————————————Node:return_statement Text: return tud_control_xfer(rhport, request, (void*) &res, sizeof(res));
|——————————————Node:return Text: return
|——————————————Node:call_expression Text: tud_control_xfer(rhport, request, (void*) &res, sizeof(res))
|———————————————Node:identifier Text: tud_control_xfer
|———————————————Node:argument_list Text: (rhport, request, (void*) &res, sizeof(res))
|————————————————Node:( Text: (
|————————————————Node:identifier Text: rhport
|————————————————Node:, Text: ,
|————————————————Node:identifier Text: request
|————————————————Node:, Text: ,
|————————————————Node:cast_expression Text: (void*) &res
|—————————————————Node:( Text: (
|—————————————————Node:type_descriptor Text: void*
|——————————————————Node:primitive_type Text: void
|——————————————————Node:abstract_pointer_declarator Text: *
|———————————————————Node:* Text: *
|—————————————————Node:) Text: )
|—————————————————Node:pointer_expression Text: &res
|——————————————————Node:& Text: &
|——————————————————Node:identifier Text: res
|————————————————Node:, Text: ,
|————————————————Node:sizeof_expression Text: sizeof(res)
|—————————————————Node:sizeof Text: sizeof
|—————————————————Node:parenthesized_expression Text: (res)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: res
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else {
                return true;
            }
|—————————————Node:else Text: else
|—————————————Node:compound_statement Text: {
                return true;
            }
|——————————————Node:{ Text: {
|——————————————Node:return_statement Text: return true;
|———————————————Node:return Text: return
|———————————————Node:true Text: true
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|———————————Node:} Text: }
|———————Node:} Text: }
|———Node:return_statement Text: return false;
|————Node:return Text: return
|————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
