can_bus-driver\ctu_can_fd_hw.c

|Node:translation_unit
|—Node:comment Text: // SPDX-License-Identifier: GPL-2.0+
|—Node:comment Text: /*******************************************************************************
 *
 * CTU CAN FD IP Core
 * Copyright (C) 2015-2018
 *
 * Authors:
 *     Ondrej Ille <ondrej.ille@gmail.com>
 *     Martin Jerabek <martin.jerabek01@gmail.com>
 *     Jaroslav Beran <jara.beran@gmail.com>
 *
 * Project advisors:
 *     Jiri Novak <jnovak@fel.cvut.cz>
 *     Pavel Pisa <pisa@cmp.felk.cvut.cz>
 *
 * Department of Measurement         (http://meas.fel.cvut.cz/)
 * Faculty of Electrical Engineering (http://www.fel.cvut.cz)
 * Czech Technical University        (http://www.cvut.cz/)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 ******************************************************************************/
|—Node:preproc_ifdef Text: #ifndef __KERNEL__
# include "ctu_can_fd_linux_defs.h"
#else
# include <linux/can/dev.h>
#endif
|——Node:#ifndef Text: #ifndef
|——Node:identifier Text: __KERNEL__
|——Node:preproc_include Text: # include "ctu_can_fd_linux_defs.h"

|———Node:#include Text: # include
|———Node:string_literal Text: "ctu_can_fd_linux_defs.h"
|————Node:" Text: "
|————Node:string_content Text: ctu_can_fd_linux_defs.h
|————Node:" Text: "
|——Node:preproc_else Text: #else
# include <linux/can/dev.h>

|———Node:#else Text: #else
|———Node:preproc_include Text: # include <linux/can/dev.h>

|————Node:#include Text: # include
|————Node:system_lib_string Text: <linux/can/dev.h>
|——Node:#endif Text: #endif
|—Node:preproc_include Text: #include "ctu_can_fd_frame.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "ctu_can_fd_frame.h"
|———Node:" Text: "
|———Node:string_content Text: ctu_can_fd_frame.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "ctu_can_fd_hw.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "ctu_can_fd_hw.h"
|———Node:" Text: "
|———Node:string_content Text: ctu_can_fd_hw.h
|———Node:" Text: "
|—Node:function_definition Text: void ctucan_hw_write32(struct ctucan_hw_priv *priv,
			enum ctu_can_fd_can_registers reg, u32 val)
{
	iowrite32(val, (char *)priv->mem_base + reg);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_write32(struct ctucan_hw_priv *priv,
			enum ctu_can_fd_can_registers reg, u32 val)
|———Node:identifier Text: ctucan_hw_write32
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			enum ctu_can_fd_can_registers reg, u32 val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers reg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: reg
|————Node:, Text: ,
|————Node:parameter_declaration Text: u32 val
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	iowrite32(val, (char *)priv->mem_base + reg);
}
|———Node:{ Text: {
|———Node:expression_statement Text: iowrite32(val, (char *)priv->mem_base + reg);
|————Node:call_expression Text: iowrite32(val, (char *)priv->mem_base + reg)
|—————Node:identifier Text: iowrite32
|—————Node:argument_list Text: (val, (char *)priv->mem_base + reg)
|——————Node:( Text: (
|——————Node:identifier Text: val
|——————Node:, Text: ,
|——————Node:binary_expression Text: (char *)priv->mem_base + reg
|———————Node:cast_expression Text: (char *)priv->mem_base
|————————Node:( Text: (
|————————Node:type_descriptor Text: char *
|—————————Node:primitive_type Text: char
|—————————Node:abstract_pointer_declarator Text: *
|——————————Node:* Text: *
|————————Node:) Text: )
|————————Node:field_expression Text: priv->mem_base
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: mem_base
|———————Node:+ Text: +
|———————Node:identifier Text: reg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_write32_be(struct ctucan_hw_priv *priv,
			   enum ctu_can_fd_can_registers reg, u32 val)
{
	iowrite32(val, (char *)priv->mem_base + reg);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_write32_be(struct ctucan_hw_priv *priv,
			   enum ctu_can_fd_can_registers reg, u32 val)
|———Node:identifier Text: ctucan_hw_write32_be
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			   enum ctu_can_fd_can_registers reg, u32 val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers reg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: reg
|————Node:, Text: ,
|————Node:parameter_declaration Text: u32 val
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	iowrite32(val, (char *)priv->mem_base + reg);
}
|———Node:{ Text: {
|———Node:expression_statement Text: iowrite32(val, (char *)priv->mem_base + reg);
|————Node:call_expression Text: iowrite32(val, (char *)priv->mem_base + reg)
|—————Node:identifier Text: iowrite32
|—————Node:argument_list Text: (val, (char *)priv->mem_base + reg)
|——————Node:( Text: (
|——————Node:identifier Text: val
|——————Node:, Text: ,
|——————Node:binary_expression Text: (char *)priv->mem_base + reg
|———————Node:cast_expression Text: (char *)priv->mem_base
|————————Node:( Text: (
|————————Node:type_descriptor Text: char *
|—————————Node:primitive_type Text: char
|—————————Node:abstract_pointer_declarator Text: *
|——————————Node:* Text: *
|————————Node:) Text: )
|————————Node:field_expression Text: priv->mem_base
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: mem_base
|———————Node:+ Text: +
|———————Node:identifier Text: reg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: u32 ctucan_hw_read32(struct ctucan_hw_priv *priv,
		      enum ctu_can_fd_can_registers reg)
{
	return ioread32((char *)priv->mem_base + reg);
}
|——Node:type_identifier Text: u32
|——Node:function_declarator Text: ctucan_hw_read32(struct ctucan_hw_priv *priv,
		      enum ctu_can_fd_can_registers reg)
|———Node:identifier Text: ctucan_hw_read32
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
		      enum ctu_can_fd_can_registers reg)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers reg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: reg
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ioread32((char *)priv->mem_base + reg);
}
|———Node:{ Text: {
|———Node:return_statement Text: return ioread32((char *)priv->mem_base + reg);
|————Node:return Text: return
|————Node:call_expression Text: ioread32((char *)priv->mem_base + reg)
|—————Node:identifier Text: ioread32
|—————Node:argument_list Text: ((char *)priv->mem_base + reg)
|——————Node:( Text: (
|——————Node:binary_expression Text: (char *)priv->mem_base + reg
|———————Node:cast_expression Text: (char *)priv->mem_base
|————————Node:( Text: (
|————————Node:type_descriptor Text: char *
|—————————Node:primitive_type Text: char
|—————————Node:abstract_pointer_declarator Text: *
|——————————Node:* Text: *
|————————Node:) Text: )
|————————Node:field_expression Text: priv->mem_base
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: mem_base
|———————Node:+ Text: +
|———————Node:identifier Text: reg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: u32 ctucan_hw_read32_be(struct ctucan_hw_priv *priv,
			 enum ctu_can_fd_can_registers reg)
{
	return ioread32be((char *)priv->mem_base + reg);
}
|——Node:type_identifier Text: u32
|——Node:function_declarator Text: ctucan_hw_read32_be(struct ctucan_hw_priv *priv,
			 enum ctu_can_fd_can_registers reg)
|———Node:identifier Text: ctucan_hw_read32_be
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			 enum ctu_can_fd_can_registers reg)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers reg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: reg
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ioread32be((char *)priv->mem_base + reg);
}
|———Node:{ Text: {
|———Node:return_statement Text: return ioread32be((char *)priv->mem_base + reg);
|————Node:return Text: return
|————Node:call_expression Text: ioread32be((char *)priv->mem_base + reg)
|—————Node:identifier Text: ioread32be
|—————Node:argument_list Text: ((char *)priv->mem_base + reg)
|——————Node:( Text: (
|——————Node:binary_expression Text: (char *)priv->mem_base + reg
|———————Node:cast_expression Text: (char *)priv->mem_base
|————————Node:( Text: (
|————————Node:type_descriptor Text: char *
|—————————Node:primitive_type Text: char
|—————————Node:abstract_pointer_declarator Text: *
|——————————Node:* Text: *
|————————Node:) Text: )
|————————Node:field_expression Text: priv->mem_base
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: mem_base
|———————Node:+ Text: +
|———————Node:identifier Text: reg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static void ctucan_hw_write_txt_buf(struct ctucan_hw_priv *priv,
				     enum ctu_can_fd_can_registers buf_base,
				     u32 offset, u32 val)
{
	priv->write_reg(priv, buf_base + offset, val);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_write_txt_buf(struct ctucan_hw_priv *priv,
				     enum ctu_can_fd_can_registers buf_base,
				     u32 offset, u32 val)
|———Node:identifier Text: ctucan_hw_write_txt_buf
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
				     enum ctu_can_fd_can_registers buf_base,
				     u32 offset, u32 val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers buf_base
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: buf_base
|————Node:, Text: ,
|————Node:parameter_declaration Text: u32 offset
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: offset
|————Node:, Text: ,
|————Node:parameter_declaration Text: u32 val
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	priv->write_reg(priv, buf_base + offset, val);
}
|———Node:{ Text: {
|———Node:expression_statement Text: priv->write_reg(priv, buf_base + offset, val);
|————Node:call_expression Text: priv->write_reg(priv, buf_base + offset, val)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, buf_base + offset, val)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:binary_expression Text: buf_base + offset
|———————Node:identifier Text: buf_base
|———————Node:+ Text: +
|———————Node:identifier Text: offset
|——————Node:, Text: ,
|——————Node:identifier Text: val
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static inline union ctu_can_fd_identifier_w ctucan_hw_id_to_hwid(canid_t id)
{
	union ctu_can_fd_identifier_w hwid;

	hwid.u32 = 0;

	if (id & CAN_EFF_FLAG) {
		hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18;

		/* getting lowest 18 bits, replace with sth nicer... */
		hwid.s.identifier_ext = (id & 0x3FFFF);
	} else {
		hwid.s.identifier_base = id & CAN_SFF_MASK;
	}
	return hwid;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:storage_class_specifier Text: inline
|———Node:inline Text: inline
|——Node:union_specifier Text: union ctu_can_fd_identifier_w
|———Node:union Text: union
|———Node:type_identifier Text: ctu_can_fd_identifier_w
|——Node:function_declarator Text: ctucan_hw_id_to_hwid(canid_t id)
|———Node:identifier Text: ctucan_hw_id_to_hwid
|———Node:parameter_list Text: (canid_t id)
|————Node:( Text: (
|————Node:parameter_declaration Text: canid_t id
|—————Node:type_identifier Text: canid_t
|—————Node:identifier Text: id
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_identifier_w hwid;

	hwid.u32 = 0;

	if (id & CAN_EFF_FLAG) {
		hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18;

		/* getting lowest 18 bits, replace with sth nicer... */
		hwid.s.identifier_ext = (id & 0x3FFFF);
	} else {
		hwid.s.identifier_base = id & CAN_SFF_MASK;
	}
	return hwid;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_identifier_w hwid;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: hwid
|————Node:; Text: ;
|———Node:expression_statement Text: hwid.u32 = 0;
|————Node:assignment_expression Text: hwid.u32 = 0
|—————Node:field_expression Text: hwid.u32
|——————Node:identifier Text: hwid
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (id & CAN_EFF_FLAG) {
		hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18;

		/* getting lowest 18 bits, replace with sth nicer... */
		hwid.s.identifier_ext = (id & 0x3FFFF);
	} else {
		hwid.s.identifier_base = id & CAN_SFF_MASK;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (id & CAN_EFF_FLAG)
|—————Node:( Text: (
|—————Node:binary_expression Text: id & CAN_EFF_FLAG
|——————Node:identifier Text: id
|——————Node:& Text: &
|——————Node:identifier Text: CAN_EFF_FLAG
|—————Node:) Text: )
|————Node:compound_statement Text: {
		hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18;

		/* getting lowest 18 bits, replace with sth nicer... */
		hwid.s.identifier_ext = (id & 0x3FFFF);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18;
|——————Node:assignment_expression Text: hwid.s.identifier_base = (id & CAN_EFF_MASK) >> 18
|———————Node:field_expression Text: hwid.s.identifier_base
|————————Node:field_expression Text: hwid.s
|—————————Node:identifier Text: hwid
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: identifier_base
|———————Node:= Text: =
|———————Node:binary_expression Text: (id & CAN_EFF_MASK) >> 18
|————————Node:parenthesized_expression Text: (id & CAN_EFF_MASK)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: id & CAN_EFF_MASK
|——————————Node:identifier Text: id
|——————————Node:& Text: &
|——————————Node:identifier Text: CAN_EFF_MASK
|—————————Node:) Text: )
|————————Node:>> Text: >>
|————————Node:number_literal Text: 18
|——————Node:; Text: ;
|—————Node:comment Text: /* getting lowest 18 bits, replace with sth nicer... */
|—————Node:expression_statement Text: hwid.s.identifier_ext = (id & 0x3FFFF);
|——————Node:assignment_expression Text: hwid.s.identifier_ext = (id & 0x3FFFF)
|———————Node:field_expression Text: hwid.s.identifier_ext
|————————Node:field_expression Text: hwid.s
|—————————Node:identifier Text: hwid
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: identifier_ext
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: (id & 0x3FFFF)
|————————Node:( Text: (
|————————Node:binary_expression Text: id & 0x3FFFF
|—————————Node:identifier Text: id
|—————————Node:& Text: &
|—————————Node:number_literal Text: 0x3FFFF
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		hwid.s.identifier_base = id & CAN_SFF_MASK;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		hwid.s.identifier_base = id & CAN_SFF_MASK;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: hwid.s.identifier_base = id & CAN_SFF_MASK;
|———————Node:assignment_expression Text: hwid.s.identifier_base = id & CAN_SFF_MASK
|————————Node:field_expression Text: hwid.s.identifier_base
|—————————Node:field_expression Text: hwid.s
|——————————Node:identifier Text: hwid
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: identifier_base
|————————Node:= Text: =
|————————Node:binary_expression Text: id & CAN_SFF_MASK
|—————————Node:identifier Text: id
|—————————Node:& Text: &
|—————————Node:identifier Text: CAN_SFF_MASK
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hwid;
|————Node:return Text: return
|————Node:identifier Text: hwid
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // TODO: rename or do not depend on previous value of id
|—Node:function_definition Text: static inline void ctucan_hw_hwid_to_id(union ctu_can_fd_identifier_w hwid,
					 canid_t *id,
					 enum ctu_can_fd_frame_form_w_ide type)
{
	/* Preserve flags which we dont set */
	*id &= ~(CAN_EFF_FLAG | CAN_EFF_MASK);

	if (type == EXTENDED) {
		*id |= CAN_EFF_FLAG;
		*id |= hwid.s.identifier_base << 18;
		*id |= hwid.s.identifier_ext;
	} else {
		*id = hwid.s.identifier_base;
	}
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:storage_class_specifier Text: inline
|———Node:inline Text: inline
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_hwid_to_id(union ctu_can_fd_identifier_w hwid,
					 canid_t *id,
					 enum ctu_can_fd_frame_form_w_ide type)
|———Node:identifier Text: ctucan_hw_hwid_to_id
|———Node:parameter_list Text: (union ctu_can_fd_identifier_w hwid,
					 canid_t *id,
					 enum ctu_can_fd_frame_form_w_ide type)
|————Node:( Text: (
|————Node:parameter_declaration Text: union ctu_can_fd_identifier_w hwid
|—————Node:union_specifier Text: union ctu_can_fd_identifier_w
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_identifier_w
|—————Node:identifier Text: hwid
|————Node:, Text: ,
|————Node:parameter_declaration Text: canid_t *id
|—————Node:type_identifier Text: canid_t
|—————Node:pointer_declarator Text: *id
|——————Node:* Text: *
|——————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_frame_form_w_ide type
|—————Node:enum_specifier Text: enum ctu_can_fd_frame_form_w_ide
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_frame_form_w_ide
|—————Node:identifier Text: type
|————Node:) Text: )
|——Node:compound_statement Text: {
	/* Preserve flags which we dont set */
	*id &= ~(CAN_EFF_FLAG | CAN_EFF_MASK);

	if (type == EXTENDED) {
		*id |= CAN_EFF_FLAG;
		*id |= hwid.s.identifier_base << 18;
		*id |= hwid.s.identifier_ext;
	} else {
		*id = hwid.s.identifier_base;
	}
}
|———Node:{ Text: {
|———Node:comment Text: /* Preserve flags which we dont set */
|———Node:expression_statement Text: *id &= ~(CAN_EFF_FLAG | CAN_EFF_MASK);
|————Node:assignment_expression Text: *id &= ~(CAN_EFF_FLAG | CAN_EFF_MASK)
|—————Node:pointer_expression Text: *id
|——————Node:* Text: *
|——————Node:identifier Text: id
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~(CAN_EFF_FLAG | CAN_EFF_MASK)
|——————Node:~ Text: ~
|——————Node:parenthesized_expression Text: (CAN_EFF_FLAG | CAN_EFF_MASK)
|———————Node:( Text: (
|———————Node:binary_expression Text: CAN_EFF_FLAG | CAN_EFF_MASK
|————————Node:identifier Text: CAN_EFF_FLAG
|————————Node:| Text: |
|————————Node:identifier Text: CAN_EFF_MASK
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (type == EXTENDED) {
		*id |= CAN_EFF_FLAG;
		*id |= hwid.s.identifier_base << 18;
		*id |= hwid.s.identifier_ext;
	} else {
		*id = hwid.s.identifier_base;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (type == EXTENDED)
|—————Node:( Text: (
|—————Node:binary_expression Text: type == EXTENDED
|——————Node:identifier Text: type
|——————Node:== Text: ==
|——————Node:identifier Text: EXTENDED
|—————Node:) Text: )
|————Node:compound_statement Text: {
		*id |= CAN_EFF_FLAG;
		*id |= hwid.s.identifier_base << 18;
		*id |= hwid.s.identifier_ext;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: *id |= CAN_EFF_FLAG;
|——————Node:assignment_expression Text: *id |= CAN_EFF_FLAG
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN_EFF_FLAG
|——————Node:; Text: ;
|—————Node:expression_statement Text: *id |= hwid.s.identifier_base << 18;
|——————Node:assignment_expression Text: *id |= hwid.s.identifier_base << 18
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:|= Text: |=
|———————Node:binary_expression Text: hwid.s.identifier_base << 18
|————————Node:field_expression Text: hwid.s.identifier_base
|—————————Node:field_expression Text: hwid.s
|——————————Node:identifier Text: hwid
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: identifier_base
|————————Node:<< Text: <<
|————————Node:number_literal Text: 18
|——————Node:; Text: ;
|—————Node:expression_statement Text: *id |= hwid.s.identifier_ext;
|——————Node:assignment_expression Text: *id |= hwid.s.identifier_ext
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:|= Text: |=
|———————Node:field_expression Text: hwid.s.identifier_ext
|————————Node:field_expression Text: hwid.s
|—————————Node:identifier Text: hwid
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: identifier_ext
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		*id = hwid.s.identifier_base;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		*id = hwid.s.identifier_base;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: *id = hwid.s.identifier_base;
|———————Node:assignment_expression Text: *id = hwid.s.identifier_base
|————————Node:pointer_expression Text: *id
|—————————Node:* Text: *
|—————————Node:identifier Text: id
|————————Node:= Text: =
|————————Node:field_expression Text: hwid.s.identifier_base
|—————————Node:field_expression Text: hwid.s
|——————————Node:identifier Text: hwid
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: identifier_base
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: static bool ctucan_hw_len_to_dlc(u8 len, u8 *dlc)
{
	*dlc = can_len2dlc(len);
	return true;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_len_to_dlc(u8 len, u8 *dlc)
|———Node:identifier Text: ctucan_hw_len_to_dlc
|———Node:parameter_list Text: (u8 len, u8 *dlc)
|————Node:( Text: (
|————Node:parameter_declaration Text: u8 len
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 *dlc
|—————Node:type_identifier Text: u8
|—————Node:pointer_declarator Text: *dlc
|——————Node:* Text: *
|——————Node:identifier Text: dlc
|————Node:) Text: )
|——Node:compound_statement Text: {
	*dlc = can_len2dlc(len);
	return true;
}
|———Node:{ Text: {
|———Node:expression_statement Text: *dlc = can_len2dlc(len);
|————Node:assignment_expression Text: *dlc = can_len2dlc(len)
|—————Node:pointer_expression Text: *dlc
|——————Node:* Text: *
|——————Node:identifier Text: dlc
|—————Node:= Text: =
|—————Node:call_expression Text: can_len2dlc(len)
|——————Node:identifier Text: can_len2dlc
|——————Node:argument_list Text: (len)
|———————Node:( Text: (
|———————Node:identifier Text: len
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_check_access(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_device_id_version reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);

	if (reg.s.device_id != CTU_CAN_FD_ID)
		return false;

	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_check_access(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_check_access
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_device_id_version reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);

	if (reg.s.device_id != CTU_CAN_FD_ID)
		return false;

	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_device_id_version reg;
|————Node:union_specifier Text: union ctu_can_fd_device_id_version
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_device_id_version
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_DEVICE_ID)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_DEVICE_ID
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (reg.s.device_id != CTU_CAN_FD_ID)
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (reg.s.device_id != CTU_CAN_FD_ID)
|—————Node:( Text: (
|—————Node:binary_expression Text: reg.s.device_id != CTU_CAN_FD_ID
|——————Node:field_expression Text: reg.s.device_id
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: device_id
|——————Node:!= Text: !=
|——————Node:identifier Text: CTU_CAN_FD_ID
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: u32 ctucan_hw_get_version(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_device_id_version reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);
	return reg.s.ver_major * 10 + reg.s.ver_minor;
}
|——Node:type_identifier Text: u32
|——Node:function_declarator Text: ctucan_hw_get_version(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_get_version
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_device_id_version reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);
	return reg.s.ver_major * 10 + reg.s.ver_minor;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_device_id_version reg;
|————Node:union_specifier Text: union ctu_can_fd_device_id_version
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_device_id_version
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_DEVICE_ID)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_DEVICE_ID)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_DEVICE_ID
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return reg.s.ver_major * 10 + reg.s.ver_minor;
|————Node:return Text: return
|————Node:binary_expression Text: reg.s.ver_major * 10 + reg.s.ver_minor
|—————Node:binary_expression Text: reg.s.ver_major * 10
|——————Node:field_expression Text: reg.s.ver_major
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: ver_major
|——————Node:* Text: *
|——————Node:number_literal Text: 10
|—————Node:+ Text: +
|—————Node:field_expression Text: reg.s.ver_minor
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ver_minor
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_enable(struct ctucan_hw_priv *priv, bool enable)
{
	union ctu_can_fd_mode_settings reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
	reg.s.ena = enable ? CTU_CAN_ENABLED : CTU_CAN_DISABLED;
	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_enable(struct ctucan_hw_priv *priv, bool enable)
|———Node:identifier Text: ctucan_hw_enable
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, bool enable)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool enable
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: enable
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_mode_settings reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
	reg.s.ena = enable ? CTU_CAN_ENABLED : CTU_CAN_DISABLED;
	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_mode_settings reg;
|————Node:union_specifier Text: union ctu_can_fd_mode_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_settings
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_MODE)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_MODE)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_MODE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ena = enable ? CTU_CAN_ENABLED : CTU_CAN_DISABLED;
|————Node:assignment_expression Text: reg.s.ena = enable ? CTU_CAN_ENABLED : CTU_CAN_DISABLED
|—————Node:field_expression Text: reg.s.ena
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ena
|—————Node:= Text: =
|—————Node:conditional_expression Text: enable ? CTU_CAN_ENABLED : CTU_CAN_DISABLED
|——————Node:identifier Text: enable
|——————Node:? Text: ?
|——————Node:identifier Text: CTU_CAN_ENABLED
|——————Node:: Text: :
|——————Node:identifier Text: CTU_CAN_DISABLED
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_MODE, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_MODE
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_reset(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_mode_settings mode;

	mode.u32 = 0;
	mode.s.rst = 1;
	/* it does not matter that we overwrite the rest of the reg
	 * - we're resetting
	 */
	priv->write_reg(priv, CTU_CAN_FD_MODE, mode.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_reset(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_reset
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_mode_settings mode;

	mode.u32 = 0;
	mode.s.rst = 1;
	/* it does not matter that we overwrite the rest of the reg
	 * - we're resetting
	 */
	priv->write_reg(priv, CTU_CAN_FD_MODE, mode.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_mode_settings mode;
|————Node:union_specifier Text: union ctu_can_fd_mode_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_settings
|————Node:identifier Text: mode
|————Node:; Text: ;
|———Node:expression_statement Text: mode.u32 = 0;
|————Node:assignment_expression Text: mode.u32 = 0
|—————Node:field_expression Text: mode.u32
|——————Node:identifier Text: mode
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: mode.s.rst = 1;
|————Node:assignment_expression Text: mode.s.rst = 1
|—————Node:field_expression Text: mode.s.rst
|——————Node:field_expression Text: mode.s
|———————Node:identifier Text: mode
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rst
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:comment Text: /* it does not matter that we overwrite the rest of the reg
	 * - we're resetting
	 */
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_MODE, mode.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_MODE, mode.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_MODE, mode.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_MODE
|——————Node:, Text: ,
|——————Node:field_expression Text: mode.u32
|———————Node:identifier Text: mode
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_set_ret_limit(struct ctucan_hw_priv *priv, bool enable, u8 limit)
{
	union ctu_can_fd_mode_settings reg;

	if (limit > CTU_CAN_FD_RETR_MAX)
		return false;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
	reg.s.rtrle = enable ? RTRLE_ENABLED : RTRLE_DISABLED;
	reg.s.rtrth = limit & 0xF;
	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_set_ret_limit(struct ctucan_hw_priv *priv, bool enable, u8 limit)
|———Node:identifier Text: ctucan_hw_set_ret_limit
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, bool enable, u8 limit)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool enable
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: enable
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 limit
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: limit
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_mode_settings reg;

	if (limit > CTU_CAN_FD_RETR_MAX)
		return false;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
	reg.s.rtrle = enable ? RTRLE_ENABLED : RTRLE_DISABLED;
	reg.s.rtrth = limit & 0xF;
	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_mode_settings reg;
|————Node:union_specifier Text: union ctu_can_fd_mode_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_settings
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:if_statement Text: if (limit > CTU_CAN_FD_RETR_MAX)
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (limit > CTU_CAN_FD_RETR_MAX)
|—————Node:( Text: (
|—————Node:binary_expression Text: limit > CTU_CAN_FD_RETR_MAX
|——————Node:identifier Text: limit
|——————Node:> Text: >
|——————Node:identifier Text: CTU_CAN_FD_RETR_MAX
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_MODE)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_MODE)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_MODE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.rtrle = enable ? RTRLE_ENABLED : RTRLE_DISABLED;
|————Node:assignment_expression Text: reg.s.rtrle = enable ? RTRLE_ENABLED : RTRLE_DISABLED
|—————Node:field_expression Text: reg.s.rtrle
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rtrle
|—————Node:= Text: =
|—————Node:conditional_expression Text: enable ? RTRLE_ENABLED : RTRLE_DISABLED
|——————Node:identifier Text: enable
|——————Node:? Text: ?
|——————Node:identifier Text: RTRLE_ENABLED
|——————Node:: Text: :
|——————Node:identifier Text: RTRLE_DISABLED
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.rtrth = limit & 0xF;
|————Node:assignment_expression Text: reg.s.rtrth = limit & 0xF
|—————Node:field_expression Text: reg.s.rtrth
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rtrth
|—————Node:= Text: =
|—————Node:binary_expression Text: limit & 0xF
|——————Node:identifier Text: limit
|——————Node:& Text: &
|——————Node:number_literal Text: 0xF
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_MODE, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_MODE
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_mode_reg(struct ctucan_hw_priv *priv,
			     const struct can_ctrlmode *mode)
{
	u32 flags = mode->flags;
	union ctu_can_fd_mode_settings reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);

	if (mode->mask & CAN_CTRLMODE_LOOPBACK)
		reg.s.ilbp = flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED;

	if (mode->mask & CAN_CTRLMODE_LISTENONLY)
		reg.s.lom = flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED;

	if (mode->mask & CAN_CTRLMODE_FD)
		reg.s.fde = flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE;

	if (mode->mask & CAN_CTRLMODE_PRESUME_ACK)
		reg.s.stm = flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED;

	if (mode->mask & CAN_CTRLMODE_FD_NON_ISO)
		reg.s.nisofd = flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD;

	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_mode_reg(struct ctucan_hw_priv *priv,
			     const struct can_ctrlmode *mode)
|———Node:identifier Text: ctucan_hw_set_mode_reg
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			     const struct can_ctrlmode *mode)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: const struct can_ctrlmode *mode
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct can_ctrlmode
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_ctrlmode
|—————Node:pointer_declarator Text: *mode
|——————Node:* Text: *
|——————Node:identifier Text: mode
|————Node:) Text: )
|——Node:compound_statement Text: {
	u32 flags = mode->flags;
	union ctu_can_fd_mode_settings reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);

	if (mode->mask & CAN_CTRLMODE_LOOPBACK)
		reg.s.ilbp = flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED;

	if (mode->mask & CAN_CTRLMODE_LISTENONLY)
		reg.s.lom = flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED;

	if (mode->mask & CAN_CTRLMODE_FD)
		reg.s.fde = flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE;

	if (mode->mask & CAN_CTRLMODE_PRESUME_ACK)
		reg.s.stm = flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED;

	if (mode->mask & CAN_CTRLMODE_FD_NON_ISO)
		reg.s.nisofd = flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD;

	priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: u32 flags = mode->flags;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: flags = mode->flags
|—————Node:identifier Text: flags
|—————Node:= Text: =
|—————Node:field_expression Text: mode->flags
|——————Node:identifier Text: mode
|——————Node:-> Text: ->
|——————Node:field_identifier Text: flags
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_mode_settings reg;
|————Node:union_specifier Text: union ctu_can_fd_mode_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_settings
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_MODE)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_MODE)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_MODE)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_MODE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_LOOPBACK)
		reg.s.ilbp = flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_LOOPBACK)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_LOOPBACK
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_LOOPBACK
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.ilbp = flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED;
|—————Node:assignment_expression Text: reg.s.ilbp = flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED
|——————Node:field_expression Text: reg.s.ilbp
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: ilbp
|——————Node:= Text: =
|——————Node:conditional_expression Text: flags & CAN_CTRLMODE_LOOPBACK ?
					INT_LOOP_ENABLED : INT_LOOP_DISABLED
|———————Node:binary_expression Text: flags & CAN_CTRLMODE_LOOPBACK
|————————Node:identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CAN_CTRLMODE_LOOPBACK
|———————Node:? Text: ?
|———————Node:identifier Text: INT_LOOP_ENABLED
|———————Node:: Text: :
|———————Node:identifier Text: INT_LOOP_DISABLED
|—————Node:; Text: ;
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_LISTENONLY)
		reg.s.lom = flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_LISTENONLY)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_LISTENONLY
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_LISTENONLY
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.lom = flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED;
|—————Node:assignment_expression Text: reg.s.lom = flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED
|——————Node:field_expression Text: reg.s.lom
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: lom
|——————Node:= Text: =
|——————Node:conditional_expression Text: flags & CAN_CTRLMODE_LISTENONLY ?
					LOM_ENABLED : LOM_DISABLED
|———————Node:binary_expression Text: flags & CAN_CTRLMODE_LISTENONLY
|————————Node:identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CAN_CTRLMODE_LISTENONLY
|———————Node:? Text: ?
|———————Node:identifier Text: LOM_ENABLED
|———————Node:: Text: :
|———————Node:identifier Text: LOM_DISABLED
|—————Node:; Text: ;
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_FD)
		reg.s.fde = flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_FD)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_FD
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_FD
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.fde = flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE;
|—————Node:assignment_expression Text: reg.s.fde = flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE
|——————Node:field_expression Text: reg.s.fde
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: fde
|——————Node:= Text: =
|——————Node:conditional_expression Text: flags & CAN_CTRLMODE_FD ?
				FDE_ENABLE : FDE_DISABLE
|———————Node:binary_expression Text: flags & CAN_CTRLMODE_FD
|————————Node:identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CAN_CTRLMODE_FD
|———————Node:? Text: ?
|———————Node:identifier Text: FDE_ENABLE
|———————Node:: Text: :
|———————Node:identifier Text: FDE_DISABLE
|—————Node:; Text: ;
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_PRESUME_ACK)
		reg.s.stm = flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_PRESUME_ACK)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_PRESUME_ACK
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_PRESUME_ACK
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.stm = flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED;
|—————Node:assignment_expression Text: reg.s.stm = flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED
|——————Node:field_expression Text: reg.s.stm
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: stm
|——————Node:= Text: =
|——————Node:conditional_expression Text: flags & CAN_CTRLMODE_PRESUME_ACK ?
				STM_ENABLED : STM_DISABLED
|———————Node:binary_expression Text: flags & CAN_CTRLMODE_PRESUME_ACK
|————————Node:identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CAN_CTRLMODE_PRESUME_ACK
|———————Node:? Text: ?
|———————Node:identifier Text: STM_ENABLED
|———————Node:: Text: :
|———————Node:identifier Text: STM_DISABLED
|—————Node:; Text: ;
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_FD_NON_ISO)
		reg.s.nisofd = flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_FD_NON_ISO)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_FD_NON_ISO
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_FD_NON_ISO
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.nisofd = flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD;
|—————Node:assignment_expression Text: reg.s.nisofd = flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD
|——————Node:field_expression Text: reg.s.nisofd
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: nisofd
|——————Node:= Text: =
|——————Node:conditional_expression Text: flags & CAN_CTRLMODE_FD_NON_ISO ?
				NON_ISO_FD : ISO_FD
|———————Node:binary_expression Text: flags & CAN_CTRLMODE_FD_NON_ISO
|————————Node:identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CAN_CTRLMODE_FD_NON_ISO
|———————Node:? Text: ?
|———————Node:identifier Text: NON_ISO_FD
|———————Node:: Text: :
|———————Node:identifier Text: ISO_FD
|—————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_MODE, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_MODE, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_MODE
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_rel_rx_buf(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_command reg;

	reg.u32 = 0;
	reg.s.rrb = 1;
	priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_rel_rx_buf(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_rel_rx_buf
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_command reg;

	reg.u32 = 0;
	reg.s.rrb = 1;
	priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_command reg;
|————Node:union_specifier Text: union ctu_can_fd_command
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_command
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.rrb = 1;
|————Node:assignment_expression Text: reg.s.rrb = 1
|—————Node:field_expression Text: reg.s.rrb
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rrb
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_COMMAND, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_COMMAND
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_clr_overrun_flag(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_command reg;

	reg.u32 = 0;
	reg.s.cdo = 1;
	priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_clr_overrun_flag(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_clr_overrun_flag
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_command reg;

	reg.u32 = 0;
	reg.s.cdo = 1;
	priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_command reg;
|————Node:union_specifier Text: union ctu_can_fd_command
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_command
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.cdo = 1;
|————Node:assignment_expression Text: reg.s.cdo = 1
|—————Node:field_expression Text: reg.s.cdo
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: cdo
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_COMMAND, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_COMMAND, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_COMMAND
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static void ctucan_hw_int_conf(struct ctucan_hw_priv *priv,
				enum ctu_can_fd_can_registers sreg,
				enum ctu_can_fd_can_registers creg,
				union ctu_can_fd_int_stat mask,
				union ctu_can_fd_int_stat val)
{
	priv->write_reg(priv, sreg, mask.u32 & val.u32);
	priv->write_reg(priv, creg, mask.u32 & (~val.u32));
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_int_conf(struct ctucan_hw_priv *priv,
				enum ctu_can_fd_can_registers sreg,
				enum ctu_can_fd_can_registers creg,
				union ctu_can_fd_int_stat mask,
				union ctu_can_fd_int_stat val)
|———Node:identifier Text: ctucan_hw_int_conf
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
				enum ctu_can_fd_can_registers sreg,
				enum ctu_can_fd_can_registers creg,
				union ctu_can_fd_int_stat mask,
				union ctu_can_fd_int_stat val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers sreg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: sreg
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_can_registers creg
|—————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_can_registers
|—————Node:identifier Text: creg
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat mask
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat val
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	priv->write_reg(priv, sreg, mask.u32 & val.u32);
	priv->write_reg(priv, creg, mask.u32 & (~val.u32));
}
|———Node:{ Text: {
|———Node:expression_statement Text: priv->write_reg(priv, sreg, mask.u32 & val.u32);
|————Node:call_expression Text: priv->write_reg(priv, sreg, mask.u32 & val.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, sreg, mask.u32 & val.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: sreg
|——————Node:, Text: ,
|——————Node:binary_expression Text: mask.u32 & val.u32
|———————Node:field_expression Text: mask.u32
|————————Node:identifier Text: mask
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:& Text: &
|———————Node:field_expression Text: val.u32
|————————Node:identifier Text: val
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, creg, mask.u32 & (~val.u32));
|————Node:call_expression Text: priv->write_reg(priv, creg, mask.u32 & (~val.u32))
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, creg, mask.u32 & (~val.u32))
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: creg
|——————Node:, Text: ,
|——————Node:binary_expression Text: mask.u32 & (~val.u32)
|———————Node:field_expression Text: mask.u32
|————————Node:identifier Text: mask
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:& Text: &
|———————Node:parenthesized_expression Text: (~val.u32)
|————————Node:( Text: (
|————————Node:unary_expression Text: ~val.u32
|—————————Node:~ Text: ~
|—————————Node:field_expression Text: val.u32
|——————————Node:identifier Text: val
|——————————Node:. Text: .
|——————————Node:field_identifier Text: u32
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_int_ena(struct ctucan_hw_priv *priv,
			union ctu_can_fd_int_stat mask,
			union ctu_can_fd_int_stat val)
{
	ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_ENA_SET,
			    CTU_CAN_FD_INT_ENA_CLR, mask, val);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_int_ena(struct ctucan_hw_priv *priv,
			union ctu_can_fd_int_stat mask,
			union ctu_can_fd_int_stat val)
|———Node:identifier Text: ctucan_hw_int_ena
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			union ctu_can_fd_int_stat mask,
			union ctu_can_fd_int_stat val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat mask
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat val
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_ENA_SET,
			    CTU_CAN_FD_INT_ENA_CLR, mask, val);
}
|———Node:{ Text: {
|———Node:expression_statement Text: ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_ENA_SET,
			    CTU_CAN_FD_INT_ENA_CLR, mask, val);
|————Node:call_expression Text: ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_ENA_SET,
			    CTU_CAN_FD_INT_ENA_CLR, mask, val)
|—————Node:identifier Text: ctucan_hw_int_conf
|—————Node:argument_list Text: (priv, CTU_CAN_FD_INT_ENA_SET,
			    CTU_CAN_FD_INT_ENA_CLR, mask, val)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_INT_ENA_SET
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_INT_ENA_CLR
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:, Text: ,
|——————Node:identifier Text: val
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_int_mask(struct ctucan_hw_priv *priv,
			 union ctu_can_fd_int_stat mask,
			 union ctu_can_fd_int_stat val)
{
	ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_MASK_SET,
			    CTU_CAN_FD_INT_MASK_CLR, mask, val);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_int_mask(struct ctucan_hw_priv *priv,
			 union ctu_can_fd_int_stat mask,
			 union ctu_can_fd_int_stat val)
|———Node:identifier Text: ctucan_hw_int_mask
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			 union ctu_can_fd_int_stat mask,
			 union ctu_can_fd_int_stat val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat mask
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_int_stat val
|—————Node:union_specifier Text: union ctu_can_fd_int_stat
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_int_stat
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_MASK_SET,
			    CTU_CAN_FD_INT_MASK_CLR, mask, val);
}
|———Node:{ Text: {
|———Node:expression_statement Text: ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_MASK_SET,
			    CTU_CAN_FD_INT_MASK_CLR, mask, val);
|————Node:call_expression Text: ctucan_hw_int_conf(priv, CTU_CAN_FD_INT_MASK_SET,
			    CTU_CAN_FD_INT_MASK_CLR, mask, val)
|—————Node:identifier Text: ctucan_hw_int_conf
|—————Node:argument_list Text: (priv, CTU_CAN_FD_INT_MASK_SET,
			    CTU_CAN_FD_INT_MASK_CLR, mask, val)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_INT_MASK_SET
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_INT_MASK_CLR
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:, Text: ,
|——————Node:identifier Text: val
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_mode(struct ctucan_hw_priv *priv,
			 const struct can_ctrlmode *mode)
{
	ctucan_hw_set_mode_reg(priv, mode);

	/* One shot mode supported indirectly via Retransmitt limit */
	if (mode->mask & CAN_CTRLMODE_ONE_SHOT)
		ctucan_hw_set_ret_limit(priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0);

	/* Bus error reporting -> Allow Error interrupt */
	if (mode->mask & CAN_CTRLMODE_BERR_REPORTING) {
		union ctu_can_fd_int_stat ena, mask;

		ena.u32 = 0;
		mask.u32 = 0;
		ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT);
		mask.s.bei = 1;
		ctucan_hw_int_ena(priv, ena, mask);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_mode(struct ctucan_hw_priv *priv,
			 const struct can_ctrlmode *mode)
|———Node:identifier Text: ctucan_hw_set_mode
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			 const struct can_ctrlmode *mode)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: const struct can_ctrlmode *mode
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct can_ctrlmode
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_ctrlmode
|—————Node:pointer_declarator Text: *mode
|——————Node:* Text: *
|——————Node:identifier Text: mode
|————Node:) Text: )
|——Node:compound_statement Text: {
	ctucan_hw_set_mode_reg(priv, mode);

	/* One shot mode supported indirectly via Retransmitt limit */
	if (mode->mask & CAN_CTRLMODE_ONE_SHOT)
		ctucan_hw_set_ret_limit(priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0);

	/* Bus error reporting -> Allow Error interrupt */
	if (mode->mask & CAN_CTRLMODE_BERR_REPORTING) {
		union ctu_can_fd_int_stat ena, mask;

		ena.u32 = 0;
		mask.u32 = 0;
		ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT);
		mask.s.bei = 1;
		ctucan_hw_int_ena(priv, ena, mask);
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: ctucan_hw_set_mode_reg(priv, mode);
|————Node:call_expression Text: ctucan_hw_set_mode_reg(priv, mode)
|—————Node:identifier Text: ctucan_hw_set_mode_reg
|—————Node:argument_list Text: (priv, mode)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: mode
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* One shot mode supported indirectly via Retransmitt limit */
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_ONE_SHOT)
		ctucan_hw_set_ret_limit(priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_ONE_SHOT)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_ONE_SHOT
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_ONE_SHOT
|—————Node:) Text: )
|————Node:expression_statement Text: ctucan_hw_set_ret_limit(priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0);
|—————Node:call_expression Text: ctucan_hw_set_ret_limit(priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0)
|——————Node:identifier Text: ctucan_hw_set_ret_limit
|——————Node:argument_list Text: (priv, !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT), 0)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:unary_expression Text: !!(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT)
|————————Node:! Text: !
|————————Node:unary_expression Text: !(mode->flags &
					 CAN_CTRLMODE_ONE_SHOT)
|—————————Node:! Text: !
|—————————Node:parenthesized_expression Text: (mode->flags &
					 CAN_CTRLMODE_ONE_SHOT)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: mode->flags &
					 CAN_CTRLMODE_ONE_SHOT
|———————————Node:field_expression Text: mode->flags
|————————————Node:identifier Text: mode
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: flags
|———————————Node:& Text: &
|———————————Node:identifier Text: CAN_CTRLMODE_ONE_SHOT
|——————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:comment Text: /* Bus error reporting -> Allow Error interrupt */
|———Node:if_statement Text: if (mode->mask & CAN_CTRLMODE_BERR_REPORTING) {
		union ctu_can_fd_int_stat ena, mask;

		ena.u32 = 0;
		mask.u32 = 0;
		ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT);
		mask.s.bei = 1;
		ctucan_hw_int_ena(priv, ena, mask);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode->mask & CAN_CTRLMODE_BERR_REPORTING)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode->mask & CAN_CTRLMODE_BERR_REPORTING
|——————Node:field_expression Text: mode->mask
|———————Node:identifier Text: mode
|———————Node:-> Text: ->
|———————Node:field_identifier Text: mask
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_BERR_REPORTING
|—————Node:) Text: )
|————Node:compound_statement Text: {
		union ctu_can_fd_int_stat ena, mask;

		ena.u32 = 0;
		mask.u32 = 0;
		ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT);
		mask.s.bei = 1;
		ctucan_hw_int_ena(priv, ena, mask);
	}
|—————Node:{ Text: {
|—————Node:declaration Text: union ctu_can_fd_int_stat ena, mask;
|——————Node:union_specifier Text: union ctu_can_fd_int_stat
|———————Node:union Text: union
|———————Node:type_identifier Text: ctu_can_fd_int_stat
|——————Node:identifier Text: ena
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:; Text: ;
|—————Node:expression_statement Text: ena.u32 = 0;
|——————Node:assignment_expression Text: ena.u32 = 0
|———————Node:field_expression Text: ena.u32
|————————Node:identifier Text: ena
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: mask.u32 = 0;
|——————Node:assignment_expression Text: mask.u32 = 0
|———————Node:field_expression Text: mask.u32
|————————Node:identifier Text: mask
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT);
|——————Node:assignment_expression Text: ena.s.bei = !!(mode->flags & CAN_CTRLMODE_ONE_SHOT)
|———————Node:field_expression Text: ena.s.bei
|————————Node:field_expression Text: ena.s
|—————————Node:identifier Text: ena
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: bei
|———————Node:= Text: =
|———————Node:unary_expression Text: !!(mode->flags & CAN_CTRLMODE_ONE_SHOT)
|————————Node:! Text: !
|————————Node:unary_expression Text: !(mode->flags & CAN_CTRLMODE_ONE_SHOT)
|—————————Node:! Text: !
|—————————Node:parenthesized_expression Text: (mode->flags & CAN_CTRLMODE_ONE_SHOT)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: mode->flags & CAN_CTRLMODE_ONE_SHOT
|———————————Node:field_expression Text: mode->flags
|————————————Node:identifier Text: mode
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: flags
|———————————Node:& Text: &
|———————————Node:identifier Text: CAN_CTRLMODE_ONE_SHOT
|——————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mask.s.bei = 1;
|——————Node:assignment_expression Text: mask.s.bei = 1
|———————Node:field_expression Text: mask.s.bei
|————————Node:field_expression Text: mask.s
|—————————Node:identifier Text: mask
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: bei
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctucan_hw_int_ena(priv, ena, mask);
|——————Node:call_expression Text: ctucan_hw_int_ena(priv, ena, mask)
|———————Node:identifier Text: ctucan_hw_int_ena
|———————Node:argument_list Text: (priv, ena, mask)
|————————Node:( Text: (
|————————Node:identifier Text: priv
|————————Node:, Text: ,
|————————Node:identifier Text: ena
|————————Node:, Text: ,
|————————Node:identifier Text: mask
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:declaration Text: const struct can_bittiming_const ctu_can_fd_bit_timing_max = {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 190,
	.tseg2_min = 1,
	.tseg2_max = 63,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 8,
	.brp_inc = 1,
};
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:struct_specifier Text: struct can_bittiming_const
|———Node:struct Text: struct
|———Node:type_identifier Text: can_bittiming_const
|——Node:init_declarator Text: ctu_can_fd_bit_timing_max = {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 190,
	.tseg2_min = 1,
	.tseg2_max = 63,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 8,
	.brp_inc = 1,
}
|———Node:identifier Text: ctu_can_fd_bit_timing_max
|———Node:= Text: =
|———Node:initializer_list Text: {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 190,
	.tseg2_min = 1,
	.tseg2_max = 63,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 8,
	.brp_inc = 1,
}
|————Node:{ Text: {
|————Node:initializer_pair Text: .name = "ctu_can_fd"
|—————Node:field_designator Text: .name
|——————Node:. Text: .
|——————Node:field_identifier Text: name
|—————Node:= Text: =
|—————Node:string_literal Text: "ctu_can_fd"
|——————Node:" Text: "
|——————Node:string_content Text: ctu_can_fd
|——————Node:" Text: "
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg1_min = 2
|—————Node:field_designator Text: .tseg1_min
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg1_min
|—————Node:= Text: =
|—————Node:number_literal Text: 2
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg1_max = 190
|—————Node:field_designator Text: .tseg1_max
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg1_max
|—————Node:= Text: =
|—————Node:number_literal Text: 190
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg2_min = 1
|—————Node:field_designator Text: .tseg2_min
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg2_min
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg2_max = 63
|—————Node:field_designator Text: .tseg2_max
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg2_max
|—————Node:= Text: =
|—————Node:number_literal Text: 63
|————Node:, Text: ,
|————Node:initializer_pair Text: .sjw_max = 31
|—————Node:field_designator Text: .sjw_max
|——————Node:. Text: .
|——————Node:field_identifier Text: sjw_max
|—————Node:= Text: =
|—————Node:number_literal Text: 31
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_min = 1
|—————Node:field_designator Text: .brp_min
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_min
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_max = 8
|—————Node:field_designator Text: .brp_max
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_max
|—————Node:= Text: =
|—————Node:number_literal Text: 8
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_inc = 1
|—————Node:field_designator Text: .brp_inc
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_inc
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:declaration Text: const struct can_bittiming_const ctu_can_fd_bit_timing_data_max = {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 94,
	.tseg2_min = 1,
	.tseg2_max = 31,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 2,
	.brp_inc = 1,
};
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:struct_specifier Text: struct can_bittiming_const
|———Node:struct Text: struct
|———Node:type_identifier Text: can_bittiming_const
|——Node:init_declarator Text: ctu_can_fd_bit_timing_data_max = {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 94,
	.tseg2_min = 1,
	.tseg2_max = 31,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 2,
	.brp_inc = 1,
}
|———Node:identifier Text: ctu_can_fd_bit_timing_data_max
|———Node:= Text: =
|———Node:initializer_list Text: {
	.name = "ctu_can_fd",
	.tseg1_min = 2,
	.tseg1_max = 94,
	.tseg2_min = 1,
	.tseg2_max = 31,
	.sjw_max = 31,
	.brp_min = 1,
	.brp_max = 2,
	.brp_inc = 1,
}
|————Node:{ Text: {
|————Node:initializer_pair Text: .name = "ctu_can_fd"
|—————Node:field_designator Text: .name
|——————Node:. Text: .
|——————Node:field_identifier Text: name
|—————Node:= Text: =
|—————Node:string_literal Text: "ctu_can_fd"
|——————Node:" Text: "
|——————Node:string_content Text: ctu_can_fd
|——————Node:" Text: "
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg1_min = 2
|—————Node:field_designator Text: .tseg1_min
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg1_min
|—————Node:= Text: =
|—————Node:number_literal Text: 2
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg1_max = 94
|—————Node:field_designator Text: .tseg1_max
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg1_max
|—————Node:= Text: =
|—————Node:number_literal Text: 94
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg2_min = 1
|—————Node:field_designator Text: .tseg2_min
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg2_min
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:initializer_pair Text: .tseg2_max = 31
|—————Node:field_designator Text: .tseg2_max
|——————Node:. Text: .
|——————Node:field_identifier Text: tseg2_max
|—————Node:= Text: =
|—————Node:number_literal Text: 31
|————Node:, Text: ,
|————Node:initializer_pair Text: .sjw_max = 31
|—————Node:field_designator Text: .sjw_max
|——————Node:. Text: .
|——————Node:field_identifier Text: sjw_max
|—————Node:= Text: =
|—————Node:number_literal Text: 31
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_min = 1
|—————Node:field_designator Text: .brp_min
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_min
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_max = 2
|—————Node:field_designator Text: .brp_max
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_max
|—————Node:= Text: =
|—————Node:number_literal Text: 2
|————Node:, Text: ,
|————Node:initializer_pair Text: .brp_inc = 1
|—————Node:field_designator Text: .brp_inc
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_inc
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:function_definition Text: void ctucan_hw_set_nom_bittiming(struct ctucan_hw_priv *priv,
				  struct can_bittiming *nbt)
{
	union ctu_can_fd_btr btr;

	/* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP is
	 * 7 bits wide but PH1 only 6, so we must re-distribute the values here.
	 */
	u32 prop_seg = nbt->prop_seg;
	u32 phase_seg1 = nbt->phase_seg1;

	if (phase_seg1 > 63) {
		prop_seg += phase_seg1 - 63;
		phase_seg1 = 63;
		nbt->prop_seg = prop_seg;
		nbt->phase_seg1 = phase_seg1;
	}

	btr.u32 = 0;
	btr.s.prop = prop_seg;
	btr.s.ph1 = phase_seg1;
	btr.s.ph2 = nbt->phase_seg2;
	btr.s.brp = nbt->brp;
	btr.s.sjw = nbt->sjw;

	priv->write_reg(priv, CTU_CAN_FD_BTR, btr.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_nom_bittiming(struct ctucan_hw_priv *priv,
				  struct can_bittiming *nbt)
|———Node:identifier Text: ctucan_hw_set_nom_bittiming
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
				  struct can_bittiming *nbt)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can_bittiming *nbt
|—————Node:struct_specifier Text: struct can_bittiming
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_bittiming
|—————Node:pointer_declarator Text: *nbt
|——————Node:* Text: *
|——————Node:identifier Text: nbt
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_btr btr;

	/* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP is
	 * 7 bits wide but PH1 only 6, so we must re-distribute the values here.
	 */
	u32 prop_seg = nbt->prop_seg;
	u32 phase_seg1 = nbt->phase_seg1;

	if (phase_seg1 > 63) {
		prop_seg += phase_seg1 - 63;
		phase_seg1 = 63;
		nbt->prop_seg = prop_seg;
		nbt->phase_seg1 = phase_seg1;
	}

	btr.u32 = 0;
	btr.s.prop = prop_seg;
	btr.s.ph1 = phase_seg1;
	btr.s.ph2 = nbt->phase_seg2;
	btr.s.brp = nbt->brp;
	btr.s.sjw = nbt->sjw;

	priv->write_reg(priv, CTU_CAN_FD_BTR, btr.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_btr btr;
|————Node:union_specifier Text: union ctu_can_fd_btr
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_btr
|————Node:identifier Text: btr
|————Node:; Text: ;
|———Node:comment Text: /* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP is
	 * 7 bits wide but PH1 only 6, so we must re-distribute the values here.
	 */
|———Node:declaration Text: u32 prop_seg = nbt->prop_seg;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: prop_seg = nbt->prop_seg
|—————Node:identifier Text: prop_seg
|—————Node:= Text: =
|—————Node:field_expression Text: nbt->prop_seg
|——————Node:identifier Text: nbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: prop_seg
|————Node:; Text: ;
|———Node:declaration Text: u32 phase_seg1 = nbt->phase_seg1;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: phase_seg1 = nbt->phase_seg1
|—————Node:identifier Text: phase_seg1
|—————Node:= Text: =
|—————Node:field_expression Text: nbt->phase_seg1
|——————Node:identifier Text: nbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: phase_seg1
|————Node:; Text: ;
|———Node:if_statement Text: if (phase_seg1 > 63) {
		prop_seg += phase_seg1 - 63;
		phase_seg1 = 63;
		nbt->prop_seg = prop_seg;
		nbt->phase_seg1 = phase_seg1;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (phase_seg1 > 63)
|—————Node:( Text: (
|—————Node:binary_expression Text: phase_seg1 > 63
|——————Node:identifier Text: phase_seg1
|——————Node:> Text: >
|——————Node:number_literal Text: 63
|—————Node:) Text: )
|————Node:compound_statement Text: {
		prop_seg += phase_seg1 - 63;
		phase_seg1 = 63;
		nbt->prop_seg = prop_seg;
		nbt->phase_seg1 = phase_seg1;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: prop_seg += phase_seg1 - 63;
|——————Node:assignment_expression Text: prop_seg += phase_seg1 - 63
|———————Node:identifier Text: prop_seg
|———————Node:+= Text: +=
|———————Node:binary_expression Text: phase_seg1 - 63
|————————Node:identifier Text: phase_seg1
|————————Node:- Text: -
|————————Node:number_literal Text: 63
|——————Node:; Text: ;
|—————Node:expression_statement Text: phase_seg1 = 63;
|——————Node:assignment_expression Text: phase_seg1 = 63
|———————Node:identifier Text: phase_seg1
|———————Node:= Text: =
|———————Node:number_literal Text: 63
|——————Node:; Text: ;
|—————Node:expression_statement Text: nbt->prop_seg = prop_seg;
|——————Node:assignment_expression Text: nbt->prop_seg = prop_seg
|———————Node:field_expression Text: nbt->prop_seg
|————————Node:identifier Text: nbt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: prop_seg
|———————Node:= Text: =
|———————Node:identifier Text: prop_seg
|——————Node:; Text: ;
|—————Node:expression_statement Text: nbt->phase_seg1 = phase_seg1;
|——————Node:assignment_expression Text: nbt->phase_seg1 = phase_seg1
|———————Node:field_expression Text: nbt->phase_seg1
|————————Node:identifier Text: nbt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: phase_seg1
|———————Node:= Text: =
|———————Node:identifier Text: phase_seg1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: btr.u32 = 0;
|————Node:assignment_expression Text: btr.u32 = 0
|—————Node:field_expression Text: btr.u32
|——————Node:identifier Text: btr
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: btr.s.prop = prop_seg;
|————Node:assignment_expression Text: btr.s.prop = prop_seg
|—————Node:field_expression Text: btr.s.prop
|——————Node:field_expression Text: btr.s
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: prop
|—————Node:= Text: =
|—————Node:identifier Text: prop_seg
|————Node:; Text: ;
|———Node:expression_statement Text: btr.s.ph1 = phase_seg1;
|————Node:assignment_expression Text: btr.s.ph1 = phase_seg1
|—————Node:field_expression Text: btr.s.ph1
|——————Node:field_expression Text: btr.s
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ph1
|—————Node:= Text: =
|—————Node:identifier Text: phase_seg1
|————Node:; Text: ;
|———Node:expression_statement Text: btr.s.ph2 = nbt->phase_seg2;
|————Node:assignment_expression Text: btr.s.ph2 = nbt->phase_seg2
|—————Node:field_expression Text: btr.s.ph2
|——————Node:field_expression Text: btr.s
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ph2
|—————Node:= Text: =
|—————Node:field_expression Text: nbt->phase_seg2
|——————Node:identifier Text: nbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: phase_seg2
|————Node:; Text: ;
|———Node:expression_statement Text: btr.s.brp = nbt->brp;
|————Node:assignment_expression Text: btr.s.brp = nbt->brp
|—————Node:field_expression Text: btr.s.brp
|——————Node:field_expression Text: btr.s
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: brp
|—————Node:= Text: =
|—————Node:field_expression Text: nbt->brp
|——————Node:identifier Text: nbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: brp
|————Node:; Text: ;
|———Node:expression_statement Text: btr.s.sjw = nbt->sjw;
|————Node:assignment_expression Text: btr.s.sjw = nbt->sjw
|—————Node:field_expression Text: btr.s.sjw
|——————Node:field_expression Text: btr.s
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: sjw
|—————Node:= Text: =
|—————Node:field_expression Text: nbt->sjw
|——————Node:identifier Text: nbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: sjw
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_BTR, btr.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_BTR, btr.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_BTR, btr.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_BTR
|——————Node:, Text: ,
|——————Node:field_expression Text: btr.u32
|———————Node:identifier Text: btr
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_data_bittiming(struct ctucan_hw_priv *priv,
				   struct can_bittiming *dbt)
{
	union ctu_can_fd_btr_fd btr_fd;

	/* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP_FD is
	 * 6 bits wide but PH1_FD only 5, so we must re-distribute the values
	 * here.
	 */
	u32 prop_seg = dbt->prop_seg;
	u32 phase_seg1 = dbt->phase_seg1;

	if (phase_seg1 > 31) {
		prop_seg += phase_seg1 - 31;
		phase_seg1 = 31;
		dbt->prop_seg = prop_seg;
		dbt->phase_seg1 = phase_seg1;
	}

	btr_fd.u32 = 0;
	btr_fd.s.prop_fd = prop_seg;
	btr_fd.s.ph1_fd = phase_seg1;
	btr_fd.s.ph2_fd = dbt->phase_seg2;
	btr_fd.s.brp_fd = dbt->brp;
	btr_fd.s.sjw_fd = dbt->sjw;

	priv->write_reg(priv, CTU_CAN_FD_BTR_FD, btr_fd.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_data_bittiming(struct ctucan_hw_priv *priv,
				   struct can_bittiming *dbt)
|———Node:identifier Text: ctucan_hw_set_data_bittiming
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
				   struct can_bittiming *dbt)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can_bittiming *dbt
|—————Node:struct_specifier Text: struct can_bittiming
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_bittiming
|—————Node:pointer_declarator Text: *dbt
|——————Node:* Text: *
|——————Node:identifier Text: dbt
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_btr_fd btr_fd;

	/* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP_FD is
	 * 6 bits wide but PH1_FD only 5, so we must re-distribute the values
	 * here.
	 */
	u32 prop_seg = dbt->prop_seg;
	u32 phase_seg1 = dbt->phase_seg1;

	if (phase_seg1 > 31) {
		prop_seg += phase_seg1 - 31;
		phase_seg1 = 31;
		dbt->prop_seg = prop_seg;
		dbt->phase_seg1 = phase_seg1;
	}

	btr_fd.u32 = 0;
	btr_fd.s.prop_fd = prop_seg;
	btr_fd.s.ph1_fd = phase_seg1;
	btr_fd.s.ph2_fd = dbt->phase_seg2;
	btr_fd.s.brp_fd = dbt->brp;
	btr_fd.s.sjw_fd = dbt->sjw;

	priv->write_reg(priv, CTU_CAN_FD_BTR_FD, btr_fd.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_btr_fd btr_fd;
|————Node:union_specifier Text: union ctu_can_fd_btr_fd
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_btr_fd
|————Node:identifier Text: btr_fd
|————Node:; Text: ;
|———Node:comment Text: /* The timing calculation functions have only constraints on tseg1,
	 * which is prop_seg + phase1_seg combined. tseg1 is then split in half
	 * and stored into prog_seg and phase_seg1. In CTU CAN FD, PROP_FD is
	 * 6 bits wide but PH1_FD only 5, so we must re-distribute the values
	 * here.
	 */
|———Node:declaration Text: u32 prop_seg = dbt->prop_seg;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: prop_seg = dbt->prop_seg
|—————Node:identifier Text: prop_seg
|—————Node:= Text: =
|—————Node:field_expression Text: dbt->prop_seg
|——————Node:identifier Text: dbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: prop_seg
|————Node:; Text: ;
|———Node:declaration Text: u32 phase_seg1 = dbt->phase_seg1;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: phase_seg1 = dbt->phase_seg1
|—————Node:identifier Text: phase_seg1
|—————Node:= Text: =
|—————Node:field_expression Text: dbt->phase_seg1
|——————Node:identifier Text: dbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: phase_seg1
|————Node:; Text: ;
|———Node:if_statement Text: if (phase_seg1 > 31) {
		prop_seg += phase_seg1 - 31;
		phase_seg1 = 31;
		dbt->prop_seg = prop_seg;
		dbt->phase_seg1 = phase_seg1;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (phase_seg1 > 31)
|—————Node:( Text: (
|—————Node:binary_expression Text: phase_seg1 > 31
|——————Node:identifier Text: phase_seg1
|——————Node:> Text: >
|——————Node:number_literal Text: 31
|—————Node:) Text: )
|————Node:compound_statement Text: {
		prop_seg += phase_seg1 - 31;
		phase_seg1 = 31;
		dbt->prop_seg = prop_seg;
		dbt->phase_seg1 = phase_seg1;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: prop_seg += phase_seg1 - 31;
|——————Node:assignment_expression Text: prop_seg += phase_seg1 - 31
|———————Node:identifier Text: prop_seg
|———————Node:+= Text: +=
|———————Node:binary_expression Text: phase_seg1 - 31
|————————Node:identifier Text: phase_seg1
|————————Node:- Text: -
|————————Node:number_literal Text: 31
|——————Node:; Text: ;
|—————Node:expression_statement Text: phase_seg1 = 31;
|——————Node:assignment_expression Text: phase_seg1 = 31
|———————Node:identifier Text: phase_seg1
|———————Node:= Text: =
|———————Node:number_literal Text: 31
|——————Node:; Text: ;
|—————Node:expression_statement Text: dbt->prop_seg = prop_seg;
|——————Node:assignment_expression Text: dbt->prop_seg = prop_seg
|———————Node:field_expression Text: dbt->prop_seg
|————————Node:identifier Text: dbt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: prop_seg
|———————Node:= Text: =
|———————Node:identifier Text: prop_seg
|——————Node:; Text: ;
|—————Node:expression_statement Text: dbt->phase_seg1 = phase_seg1;
|——————Node:assignment_expression Text: dbt->phase_seg1 = phase_seg1
|———————Node:field_expression Text: dbt->phase_seg1
|————————Node:identifier Text: dbt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: phase_seg1
|———————Node:= Text: =
|———————Node:identifier Text: phase_seg1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: btr_fd.u32 = 0;
|————Node:assignment_expression Text: btr_fd.u32 = 0
|—————Node:field_expression Text: btr_fd.u32
|——————Node:identifier Text: btr_fd
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: btr_fd.s.prop_fd = prop_seg;
|————Node:assignment_expression Text: btr_fd.s.prop_fd = prop_seg
|—————Node:field_expression Text: btr_fd.s.prop_fd
|——————Node:field_expression Text: btr_fd.s
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: prop_fd
|—————Node:= Text: =
|—————Node:identifier Text: prop_seg
|————Node:; Text: ;
|———Node:expression_statement Text: btr_fd.s.ph1_fd = phase_seg1;
|————Node:assignment_expression Text: btr_fd.s.ph1_fd = phase_seg1
|—————Node:field_expression Text: btr_fd.s.ph1_fd
|——————Node:field_expression Text: btr_fd.s
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ph1_fd
|—————Node:= Text: =
|—————Node:identifier Text: phase_seg1
|————Node:; Text: ;
|———Node:expression_statement Text: btr_fd.s.ph2_fd = dbt->phase_seg2;
|————Node:assignment_expression Text: btr_fd.s.ph2_fd = dbt->phase_seg2
|—————Node:field_expression Text: btr_fd.s.ph2_fd
|——————Node:field_expression Text: btr_fd.s
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ph2_fd
|—————Node:= Text: =
|—————Node:field_expression Text: dbt->phase_seg2
|——————Node:identifier Text: dbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: phase_seg2
|————Node:; Text: ;
|———Node:expression_statement Text: btr_fd.s.brp_fd = dbt->brp;
|————Node:assignment_expression Text: btr_fd.s.brp_fd = dbt->brp
|—————Node:field_expression Text: btr_fd.s.brp_fd
|——————Node:field_expression Text: btr_fd.s
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: brp_fd
|—————Node:= Text: =
|—————Node:field_expression Text: dbt->brp
|——————Node:identifier Text: dbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: brp
|————Node:; Text: ;
|———Node:expression_statement Text: btr_fd.s.sjw_fd = dbt->sjw;
|————Node:assignment_expression Text: btr_fd.s.sjw_fd = dbt->sjw
|—————Node:field_expression Text: btr_fd.s.sjw_fd
|——————Node:field_expression Text: btr_fd.s
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: sjw_fd
|—————Node:= Text: =
|—————Node:field_expression Text: dbt->sjw
|——————Node:identifier Text: dbt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: sjw
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_BTR_FD, btr_fd.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_BTR_FD, btr_fd.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_BTR_FD, btr_fd.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_BTR_FD
|——————Node:, Text: ,
|——————Node:field_expression Text: btr_fd.u32
|———————Node:identifier Text: btr_fd
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_err_limits(struct ctucan_hw_priv *priv, u8 ewl, u8 erp)
{
	union ctu_can_fd_ewl_erp_fault_state reg;

	reg.u32 = 0;
	reg.s.ew_limit = ewl;
	reg.s.erp_limit = erp;
	// era, bof, erp are read-only

	priv->write_reg(priv, CTU_CAN_FD_EWL, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_err_limits(struct ctucan_hw_priv *priv, u8 ewl, u8 erp)
|———Node:identifier Text: ctucan_hw_set_err_limits
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, u8 ewl, u8 erp)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 ewl
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: ewl
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 erp
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: erp
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_ewl_erp_fault_state reg;

	reg.u32 = 0;
	reg.s.ew_limit = ewl;
	reg.s.erp_limit = erp;
	// era, bof, erp are read-only

	priv->write_reg(priv, CTU_CAN_FD_EWL, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_ewl_erp_fault_state reg;
|————Node:union_specifier Text: union ctu_can_fd_ewl_erp_fault_state
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_ewl_erp_fault_state
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ew_limit = ewl;
|————Node:assignment_expression Text: reg.s.ew_limit = ewl
|—————Node:field_expression Text: reg.s.ew_limit
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ew_limit
|—————Node:= Text: =
|—————Node:identifier Text: ewl
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.erp_limit = erp;
|————Node:assignment_expression Text: reg.s.erp_limit = erp
|—————Node:field_expression Text: reg.s.erp_limit
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: erp_limit
|—————Node:= Text: =
|—————Node:identifier Text: erp
|————Node:; Text: ;
|———Node:comment Text: // era, bof, erp are read-only
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_EWL, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_EWL, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_EWL, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_EWL
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_read_err_ctrs(struct ctucan_hw_priv *priv,
			      struct can_berr_counter *ctr)
{
	union ctu_can_fd_rec_tec reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);
	ctr->txerr = reg.s.tec_val;
	ctr->rxerr = reg.s.rec_val;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_read_err_ctrs(struct ctucan_hw_priv *priv,
			      struct can_berr_counter *ctr)
|———Node:identifier Text: ctucan_hw_read_err_ctrs
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			      struct can_berr_counter *ctr)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can_berr_counter *ctr
|—————Node:struct_specifier Text: struct can_berr_counter
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_berr_counter
|—————Node:pointer_declarator Text: *ctr
|——————Node:* Text: *
|——————Node:identifier Text: ctr
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_rec_tec reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);
	ctr->txerr = reg.s.tec_val;
	ctr->rxerr = reg.s.rec_val;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_rec_tec reg;
|————Node:union_specifier Text: union ctu_can_fd_rec_tec
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_rec_tec
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_REC)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_REC)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_REC)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_REC
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctr->txerr = reg.s.tec_val;
|————Node:assignment_expression Text: ctr->txerr = reg.s.tec_val
|—————Node:field_expression Text: ctr->txerr
|——————Node:identifier Text: ctr
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txerr
|—————Node:= Text: =
|—————Node:field_expression Text: reg.s.tec_val
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: tec_val
|————Node:; Text: ;
|———Node:expression_statement Text: ctr->rxerr = reg.s.rec_val;
|————Node:assignment_expression Text: ctr->rxerr = reg.s.rec_val
|—————Node:field_expression Text: ctr->rxerr
|——————Node:identifier Text: ctr
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rxerr
|—————Node:= Text: =
|—————Node:field_expression Text: reg.s.rec_val
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rec_val
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: enum can_state ctucan_hw_read_error_state(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_ewl_erp_fault_state reg;
	union ctu_can_fd_rec_tec err;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_EWL);
	err.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);

	if (reg.s.era) {
		if (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
			return CAN_STATE_ERROR_ACTIVE;
		else
			return CAN_STATE_ERROR_WARNING;
	} else if (reg.s.erp) {
		return CAN_STATE_ERROR_PASSIVE;
	} else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
	WARN(true, "Invalid error state");
	return CAN_STATE_ERROR_PASSIVE;
}
|——Node:enum_specifier Text: enum can_state
|———Node:enum Text: enum
|———Node:type_identifier Text: can_state
|——Node:function_declarator Text: ctucan_hw_read_error_state(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_read_error_state
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_ewl_erp_fault_state reg;
	union ctu_can_fd_rec_tec err;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_EWL);
	err.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);

	if (reg.s.era) {
		if (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
			return CAN_STATE_ERROR_ACTIVE;
		else
			return CAN_STATE_ERROR_WARNING;
	} else if (reg.s.erp) {
		return CAN_STATE_ERROR_PASSIVE;
	} else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
	WARN(true, "Invalid error state");
	return CAN_STATE_ERROR_PASSIVE;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_ewl_erp_fault_state reg;
|————Node:union_specifier Text: union ctu_can_fd_ewl_erp_fault_state
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_ewl_erp_fault_state
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_rec_tec err;
|————Node:union_specifier Text: union ctu_can_fd_rec_tec
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_rec_tec
|————Node:identifier Text: err
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_EWL);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_EWL)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_EWL)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_EWL)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_EWL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: err.u32 = priv->read_reg(priv, CTU_CAN_FD_REC);
|————Node:assignment_expression Text: err.u32 = priv->read_reg(priv, CTU_CAN_FD_REC)
|—————Node:field_expression Text: err.u32
|——————Node:identifier Text: err
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_REC)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_REC)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_REC
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (reg.s.era) {
		if (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
			return CAN_STATE_ERROR_ACTIVE;
		else
			return CAN_STATE_ERROR_WARNING;
	} else if (reg.s.erp) {
		return CAN_STATE_ERROR_PASSIVE;
	} else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (reg.s.era)
|—————Node:( Text: (
|—————Node:field_expression Text: reg.s.era
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: era
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
			return CAN_STATE_ERROR_ACTIVE;
		else
			return CAN_STATE_ERROR_WARNING;
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
			return CAN_STATE_ERROR_ACTIVE;
		else
			return CAN_STATE_ERROR_WARNING;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val)
|———————Node:( Text: (
|———————Node:binary_expression Text: reg.s.ew_limit > err.s.rec_val &&
		    reg.s.ew_limit > err.s.tec_val
|————————Node:binary_expression Text: reg.s.ew_limit > err.s.rec_val
|—————————Node:field_expression Text: reg.s.ew_limit
|——————————Node:field_expression Text: reg.s
|———————————Node:identifier Text: reg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ew_limit
|—————————Node:> Text: >
|—————————Node:field_expression Text: err.s.rec_val
|——————————Node:field_expression Text: err.s
|———————————Node:identifier Text: err
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rec_val
|————————Node:&& Text: &&
|————————Node:binary_expression Text: reg.s.ew_limit > err.s.tec_val
|—————————Node:field_expression Text: reg.s.ew_limit
|——————————Node:field_expression Text: reg.s
|———————————Node:identifier Text: reg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ew_limit
|—————————Node:> Text: >
|—————————Node:field_expression Text: err.s.tec_val
|——————————Node:field_expression Text: err.s
|———————————Node:identifier Text: err
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tec_val
|———————Node:) Text: )
|——————Node:return_statement Text: return CAN_STATE_ERROR_ACTIVE;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_STATE_ERROR_ACTIVE
|———————Node:; Text: ;
|——————Node:else_clause Text: else
			return CAN_STATE_ERROR_WARNING;
|———————Node:else Text: else
|———————Node:return_statement Text: return CAN_STATE_ERROR_WARNING;
|————————Node:return Text: return
|————————Node:identifier Text: CAN_STATE_ERROR_WARNING
|————————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (reg.s.erp) {
		return CAN_STATE_ERROR_PASSIVE;
	} else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
|—————Node:else Text: else
|—————Node:if_statement Text: if (reg.s.erp) {
		return CAN_STATE_ERROR_PASSIVE;
	} else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (reg.s.erp)
|———————Node:( Text: (
|———————Node:field_expression Text: reg.s.erp
|————————Node:field_expression Text: reg.s
|—————————Node:identifier Text: reg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: erp
|———————Node:) Text: )
|——————Node:compound_statement Text: {
		return CAN_STATE_ERROR_PASSIVE;
	}
|———————Node:{ Text: {
|———————Node:return_statement Text: return CAN_STATE_ERROR_PASSIVE;
|————————Node:return Text: return
|————————Node:identifier Text: CAN_STATE_ERROR_PASSIVE
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
|———————Node:else Text: else
|———————Node:if_statement Text: if (reg.s.bof) {
		return CAN_STATE_BUS_OFF;
	}
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (reg.s.bof)
|—————————Node:( Text: (
|—————————Node:field_expression Text: reg.s.bof
|——————————Node:field_expression Text: reg.s
|———————————Node:identifier Text: reg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bof
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
		return CAN_STATE_BUS_OFF;
	}
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return CAN_STATE_BUS_OFF;
|——————————Node:return Text: return
|——————————Node:identifier Text: CAN_STATE_BUS_OFF
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:expression_statement Text: WARN(true, "Invalid error state");
|————Node:call_expression Text: WARN(true, "Invalid error state")
|—————Node:identifier Text: WARN
|—————Node:argument_list Text: (true, "Invalid error state")
|——————Node:( Text: (
|——————Node:true Text: true
|——————Node:, Text: ,
|——————Node:string_literal Text: "Invalid error state"
|———————Node:" Text: "
|———————Node:string_content Text: Invalid error state
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return CAN_STATE_ERROR_PASSIVE;
|————Node:return Text: return
|————Node:identifier Text: CAN_STATE_ERROR_PASSIVE
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_err_ctrs(struct ctucan_hw_priv *priv,
			     const struct can_berr_counter *ctr)
{
	union ctu_can_fd_ctr_pres reg;

	reg.u32 = 0;

	reg.s.ctpv = ctr->txerr;
	reg.s.ptx = 1;
	priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);

	reg.s.ctpv = ctr->rxerr;
	reg.s.ptx = 0;
	reg.s.prx = 1;
	priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_err_ctrs(struct ctucan_hw_priv *priv,
			     const struct can_berr_counter *ctr)
|———Node:identifier Text: ctucan_hw_set_err_ctrs
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			     const struct can_berr_counter *ctr)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: const struct can_berr_counter *ctr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct can_berr_counter
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_berr_counter
|—————Node:pointer_declarator Text: *ctr
|——————Node:* Text: *
|——————Node:identifier Text: ctr
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_ctr_pres reg;

	reg.u32 = 0;

	reg.s.ctpv = ctr->txerr;
	reg.s.ptx = 1;
	priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);

	reg.s.ctpv = ctr->rxerr;
	reg.s.ptx = 0;
	reg.s.prx = 1;
	priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_ctr_pres reg;
|————Node:union_specifier Text: union ctu_can_fd_ctr_pres
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_ctr_pres
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ctpv = ctr->txerr;
|————Node:assignment_expression Text: reg.s.ctpv = ctr->txerr
|—————Node:field_expression Text: reg.s.ctpv
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ctpv
|—————Node:= Text: =
|—————Node:field_expression Text: ctr->txerr
|——————Node:identifier Text: ctr
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txerr
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ptx = 1;
|————Node:assignment_expression Text: reg.s.ptx = 1
|—————Node:field_expression Text: reg.s.ptx
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ptx
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_CTR_PRES, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_CTR_PRES
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ctpv = ctr->rxerr;
|————Node:assignment_expression Text: reg.s.ctpv = ctr->rxerr
|—————Node:field_expression Text: reg.s.ctpv
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ctpv
|—————Node:= Text: =
|—————Node:field_expression Text: ctr->rxerr
|——————Node:identifier Text: ctr
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rxerr
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.ptx = 0;
|————Node:assignment_expression Text: reg.s.ptx = 0
|—————Node:field_expression Text: reg.s.ptx
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ptx
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.prx = 1;
|————Node:assignment_expression Text: reg.s.prx = 1
|—————Node:field_expression Text: reg.s.prx
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: prx
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_CTR_PRES, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_CTR_PRES, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_CTR_PRES
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_get_mask_filter_support(struct ctucan_hw_priv *priv, u8 fnum)
{
	union ctu_can_fd_filter_control_filter_status reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		if (reg.s.sfa)
			return true;
	break;
	case CTU_CAN_FD_FILTER_B:
		if (reg.s.sfb)
			return true;
	break;
	case CTU_CAN_FD_FILTER_C:
		if (reg.s.sfc)
			return true;
	break;
	}

	return false;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_get_mask_filter_support(struct ctucan_hw_priv *priv, u8 fnum)
|———Node:identifier Text: ctucan_hw_get_mask_filter_support
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, u8 fnum)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 fnum
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: fnum
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_filter_control_filter_status reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		if (reg.s.sfa)
			return true;
	break;
	case CTU_CAN_FD_FILTER_B:
		if (reg.s.sfb)
			return true;
	break;
	case CTU_CAN_FD_FILTER_C:
		if (reg.s.sfc)
			return true;
	break;
	}

	return false;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_filter_control_filter_status reg;
|————Node:union_specifier Text: union ctu_can_fd_filter_control_filter_status
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_filter_control_filter_status
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:switch_statement Text: switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		if (reg.s.sfa)
			return true;
	break;
	case CTU_CAN_FD_FILTER_B:
		if (reg.s.sfb)
			return true;
	break;
	case CTU_CAN_FD_FILTER_C:
		if (reg.s.sfc)
			return true;
	break;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (fnum)
|—————Node:( Text: (
|—————Node:identifier Text: fnum
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case CTU_CAN_FD_FILTER_A:
		if (reg.s.sfa)
			return true;
	break;
	case CTU_CAN_FD_FILTER_B:
		if (reg.s.sfb)
			return true;
	break;
	case CTU_CAN_FD_FILTER_C:
		if (reg.s.sfc)
			return true;
	break;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_A:
		if (reg.s.sfa)
			return true;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_A
|——————Node:: Text: :
|——————Node:if_statement Text: if (reg.s.sfa)
			return true;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (reg.s.sfa)
|————————Node:( Text: (
|————————Node:field_expression Text: reg.s.sfa
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sfa
|————————Node:) Text: )
|———————Node:return_statement Text: return true;
|————————Node:return Text: return
|————————Node:true Text: true
|————————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_B:
		if (reg.s.sfb)
			return true;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_B
|——————Node:: Text: :
|——————Node:if_statement Text: if (reg.s.sfb)
			return true;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (reg.s.sfb)
|————————Node:( Text: (
|————————Node:field_expression Text: reg.s.sfb
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sfb
|————————Node:) Text: )
|———————Node:return_statement Text: return true;
|————————Node:return Text: return
|————————Node:true Text: true
|————————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_C:
		if (reg.s.sfc)
			return true;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_C
|——————Node:: Text: :
|——————Node:if_statement Text: if (reg.s.sfc)
			return true;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (reg.s.sfc)
|————————Node:( Text: (
|————————Node:field_expression Text: reg.s.sfc
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sfc
|————————Node:) Text: )
|———————Node:return_statement Text: return true;
|————————Node:return Text: return
|————————Node:true Text: true
|————————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return false;
|————Node:return Text: return
|————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_get_range_filter_support(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_filter_control_filter_status reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	if (reg.s.sfr)
		return true;

	return false;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_get_range_filter_support(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_get_range_filter_support
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_filter_control_filter_status reg;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	if (reg.s.sfr)
		return true;

	return false;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_filter_control_filter_status reg;
|————Node:union_specifier Text: union ctu_can_fd_filter_control_filter_status
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_filter_control_filter_status
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (reg.s.sfr)
		return true;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (reg.s.sfr)
|—————Node:( Text: (
|—————Node:field_expression Text: reg.s.sfr
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: sfr
|—————Node:) Text: )
|————Node:return_statement Text: return true;
|—————Node:return Text: return
|—————Node:true Text: true
|—————Node:; Text: ;
|———Node:return_statement Text: return false;
|————Node:return Text: return
|————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_set_mask_filter(struct ctucan_hw_priv *priv, u8 fnum,
				bool enable, const struct can_filter *filter)
{
	union ctu_can_fd_filter_control_filter_status creg;
	enum ctu_can_fd_can_registers maddr, vaddr;
	union ctu_can_fd_identifier_w hwid_mask;
	union ctu_can_fd_identifier_w hwid_val;
	uint8_t val = 0;

	if (!ctucan_hw_get_mask_filter_support(priv, fnum))
		return false;

	if (enable)
		val = 1;

	creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		maddr = CTU_CAN_FD_FILTER_A_MASK;
		vaddr = CTU_CAN_FD_FILTER_A_VAL;
		creg.s.fanb = val;
		creg.s.fane = val;
		creg.s.fafb = val;
		creg.s.fafe = val;
	break;
	case CTU_CAN_FD_FILTER_B:
		maddr = CTU_CAN_FD_FILTER_B_MASK;
		vaddr = CTU_CAN_FD_FILTER_B_VAL;
		creg.s.fbnb = val;
		creg.s.fbne = val;
		creg.s.fbfb = val;
		creg.s.fbfe = val;
	break;
	case CTU_CAN_FD_FILTER_C:
		maddr = CTU_CAN_FD_FILTER_C_MASK;
		vaddr = CTU_CAN_FD_FILTER_C_VAL;
		creg.s.fcnb = val;
		creg.s.fcne = val;
		creg.s.fcfb = val;
		creg.s.fcfe = val;
	break;
	default:
		return false;
	}

	hwid_mask = ctucan_hw_id_to_hwid(filter->can_id);
	hwid_val = ctucan_hw_id_to_hwid(filter->can_mask);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
	priv->write_reg(priv, maddr, hwid_mask.u32);
	priv->write_reg(priv, vaddr, hwid_val.u32);
	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_set_mask_filter(struct ctucan_hw_priv *priv, u8 fnum,
				bool enable, const struct can_filter *filter)
|———Node:identifier Text: ctucan_hw_set_mask_filter
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, u8 fnum,
				bool enable, const struct can_filter *filter)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 fnum
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: fnum
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool enable
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: enable
|————Node:, Text: ,
|————Node:parameter_declaration Text: const struct can_filter *filter
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct can_filter
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_filter
|—————Node:pointer_declarator Text: *filter
|——————Node:* Text: *
|——————Node:identifier Text: filter
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_filter_control_filter_status creg;
	enum ctu_can_fd_can_registers maddr, vaddr;
	union ctu_can_fd_identifier_w hwid_mask;
	union ctu_can_fd_identifier_w hwid_val;
	uint8_t val = 0;

	if (!ctucan_hw_get_mask_filter_support(priv, fnum))
		return false;

	if (enable)
		val = 1;

	creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		maddr = CTU_CAN_FD_FILTER_A_MASK;
		vaddr = CTU_CAN_FD_FILTER_A_VAL;
		creg.s.fanb = val;
		creg.s.fane = val;
		creg.s.fafb = val;
		creg.s.fafe = val;
	break;
	case CTU_CAN_FD_FILTER_B:
		maddr = CTU_CAN_FD_FILTER_B_MASK;
		vaddr = CTU_CAN_FD_FILTER_B_VAL;
		creg.s.fbnb = val;
		creg.s.fbne = val;
		creg.s.fbfb = val;
		creg.s.fbfe = val;
	break;
	case CTU_CAN_FD_FILTER_C:
		maddr = CTU_CAN_FD_FILTER_C_MASK;
		vaddr = CTU_CAN_FD_FILTER_C_VAL;
		creg.s.fcnb = val;
		creg.s.fcne = val;
		creg.s.fcfb = val;
		creg.s.fcfe = val;
	break;
	default:
		return false;
	}

	hwid_mask = ctucan_hw_id_to_hwid(filter->can_id);
	hwid_val = ctucan_hw_id_to_hwid(filter->can_mask);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
	priv->write_reg(priv, maddr, hwid_mask.u32);
	priv->write_reg(priv, vaddr, hwid_val.u32);
	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_filter_control_filter_status creg;
|————Node:union_specifier Text: union ctu_can_fd_filter_control_filter_status
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_filter_control_filter_status
|————Node:identifier Text: creg
|————Node:; Text: ;
|———Node:declaration Text: enum ctu_can_fd_can_registers maddr, vaddr;
|————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|—————Node:enum Text: enum
|—————Node:type_identifier Text: ctu_can_fd_can_registers
|————Node:identifier Text: maddr
|————Node:, Text: ,
|————Node:identifier Text: vaddr
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_identifier_w hwid_mask;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: hwid_mask
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_identifier_w hwid_val;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: hwid_val
|————Node:; Text: ;
|———Node:declaration Text: uint8_t val = 0;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: val = 0
|—————Node:identifier Text: val
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (!ctucan_hw_get_mask_filter_support(priv, fnum))
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!ctucan_hw_get_mask_filter_support(priv, fnum))
|—————Node:( Text: (
|—————Node:unary_expression Text: !ctucan_hw_get_mask_filter_support(priv, fnum)
|——————Node:! Text: !
|——————Node:call_expression Text: ctucan_hw_get_mask_filter_support(priv, fnum)
|———————Node:identifier Text: ctucan_hw_get_mask_filter_support
|———————Node:argument_list Text: (priv, fnum)
|————————Node:( Text: (
|————————Node:identifier Text: priv
|————————Node:, Text: ,
|————————Node:identifier Text: fnum
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:if_statement Text: if (enable)
		val = 1;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (enable)
|—————Node:( Text: (
|—————Node:identifier Text: enable
|—————Node:) Text: )
|————Node:expression_statement Text: val = 1;
|—————Node:assignment_expression Text: val = 1
|——————Node:identifier Text: val
|——————Node:= Text: =
|——————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);
|————Node:assignment_expression Text: creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|—————Node:field_expression Text: creg.u32
|——————Node:identifier Text: creg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:switch_statement Text: switch (fnum) {
	case CTU_CAN_FD_FILTER_A:
		maddr = CTU_CAN_FD_FILTER_A_MASK;
		vaddr = CTU_CAN_FD_FILTER_A_VAL;
		creg.s.fanb = val;
		creg.s.fane = val;
		creg.s.fafb = val;
		creg.s.fafe = val;
	break;
	case CTU_CAN_FD_FILTER_B:
		maddr = CTU_CAN_FD_FILTER_B_MASK;
		vaddr = CTU_CAN_FD_FILTER_B_VAL;
		creg.s.fbnb = val;
		creg.s.fbne = val;
		creg.s.fbfb = val;
		creg.s.fbfe = val;
	break;
	case CTU_CAN_FD_FILTER_C:
		maddr = CTU_CAN_FD_FILTER_C_MASK;
		vaddr = CTU_CAN_FD_FILTER_C_VAL;
		creg.s.fcnb = val;
		creg.s.fcne = val;
		creg.s.fcfb = val;
		creg.s.fcfe = val;
	break;
	default:
		return false;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (fnum)
|—————Node:( Text: (
|—————Node:identifier Text: fnum
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case CTU_CAN_FD_FILTER_A:
		maddr = CTU_CAN_FD_FILTER_A_MASK;
		vaddr = CTU_CAN_FD_FILTER_A_VAL;
		creg.s.fanb = val;
		creg.s.fane = val;
		creg.s.fafb = val;
		creg.s.fafe = val;
	break;
	case CTU_CAN_FD_FILTER_B:
		maddr = CTU_CAN_FD_FILTER_B_MASK;
		vaddr = CTU_CAN_FD_FILTER_B_VAL;
		creg.s.fbnb = val;
		creg.s.fbne = val;
		creg.s.fbfb = val;
		creg.s.fbfe = val;
	break;
	case CTU_CAN_FD_FILTER_C:
		maddr = CTU_CAN_FD_FILTER_C_MASK;
		vaddr = CTU_CAN_FD_FILTER_C_VAL;
		creg.s.fcnb = val;
		creg.s.fcne = val;
		creg.s.fcfb = val;
		creg.s.fcfe = val;
	break;
	default:
		return false;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_A:
		maddr = CTU_CAN_FD_FILTER_A_MASK;
		vaddr = CTU_CAN_FD_FILTER_A_VAL;
		creg.s.fanb = val;
		creg.s.fane = val;
		creg.s.fafb = val;
		creg.s.fafe = val;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_A
|——————Node:: Text: :
|——————Node:expression_statement Text: maddr = CTU_CAN_FD_FILTER_A_MASK;
|———————Node:assignment_expression Text: maddr = CTU_CAN_FD_FILTER_A_MASK
|————————Node:identifier Text: maddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_A_MASK
|———————Node:; Text: ;
|——————Node:expression_statement Text: vaddr = CTU_CAN_FD_FILTER_A_VAL;
|———————Node:assignment_expression Text: vaddr = CTU_CAN_FD_FILTER_A_VAL
|————————Node:identifier Text: vaddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_A_VAL
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fanb = val;
|———————Node:assignment_expression Text: creg.s.fanb = val
|————————Node:field_expression Text: creg.s.fanb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fanb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fane = val;
|———————Node:assignment_expression Text: creg.s.fane = val
|————————Node:field_expression Text: creg.s.fane
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fane
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fafb = val;
|———————Node:assignment_expression Text: creg.s.fafb = val
|————————Node:field_expression Text: creg.s.fafb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fafb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fafe = val;
|———————Node:assignment_expression Text: creg.s.fafe = val
|————————Node:field_expression Text: creg.s.fafe
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fafe
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_B:
		maddr = CTU_CAN_FD_FILTER_B_MASK;
		vaddr = CTU_CAN_FD_FILTER_B_VAL;
		creg.s.fbnb = val;
		creg.s.fbne = val;
		creg.s.fbfb = val;
		creg.s.fbfe = val;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_B
|——————Node:: Text: :
|——————Node:expression_statement Text: maddr = CTU_CAN_FD_FILTER_B_MASK;
|———————Node:assignment_expression Text: maddr = CTU_CAN_FD_FILTER_B_MASK
|————————Node:identifier Text: maddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_B_MASK
|———————Node:; Text: ;
|——————Node:expression_statement Text: vaddr = CTU_CAN_FD_FILTER_B_VAL;
|———————Node:assignment_expression Text: vaddr = CTU_CAN_FD_FILTER_B_VAL
|————————Node:identifier Text: vaddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_B_VAL
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fbnb = val;
|———————Node:assignment_expression Text: creg.s.fbnb = val
|————————Node:field_expression Text: creg.s.fbnb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fbnb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fbne = val;
|———————Node:assignment_expression Text: creg.s.fbne = val
|————————Node:field_expression Text: creg.s.fbne
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fbne
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fbfb = val;
|———————Node:assignment_expression Text: creg.s.fbfb = val
|————————Node:field_expression Text: creg.s.fbfb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fbfb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fbfe = val;
|———————Node:assignment_expression Text: creg.s.fbfe = val
|————————Node:field_expression Text: creg.s.fbfe
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fbfe
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_FILTER_C:
		maddr = CTU_CAN_FD_FILTER_C_MASK;
		vaddr = CTU_CAN_FD_FILTER_C_VAL;
		creg.s.fcnb = val;
		creg.s.fcne = val;
		creg.s.fcfb = val;
		creg.s.fcfe = val;
	break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_FILTER_C
|——————Node:: Text: :
|——————Node:expression_statement Text: maddr = CTU_CAN_FD_FILTER_C_MASK;
|———————Node:assignment_expression Text: maddr = CTU_CAN_FD_FILTER_C_MASK
|————————Node:identifier Text: maddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_C_MASK
|———————Node:; Text: ;
|——————Node:expression_statement Text: vaddr = CTU_CAN_FD_FILTER_C_VAL;
|———————Node:assignment_expression Text: vaddr = CTU_CAN_FD_FILTER_C_VAL
|————————Node:identifier Text: vaddr
|————————Node:= Text: =
|————————Node:identifier Text: CTU_CAN_FD_FILTER_C_VAL
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fcnb = val;
|———————Node:assignment_expression Text: creg.s.fcnb = val
|————————Node:field_expression Text: creg.s.fcnb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fcnb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fcne = val;
|———————Node:assignment_expression Text: creg.s.fcne = val
|————————Node:field_expression Text: creg.s.fcne
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fcne
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fcfb = val;
|———————Node:assignment_expression Text: creg.s.fcfb = val
|————————Node:field_expression Text: creg.s.fcfb
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fcfb
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:expression_statement Text: creg.s.fcfe = val;
|———————Node:assignment_expression Text: creg.s.fcfe = val
|————————Node:field_expression Text: creg.s.fcfe
|—————————Node:field_expression Text: creg.s
|——————————Node:identifier Text: creg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: fcfe
|————————Node:= Text: =
|————————Node:identifier Text: val
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
		return false;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:return_statement Text: return false;
|———————Node:return Text: return
|———————Node:false Text: false
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: hwid_mask = ctucan_hw_id_to_hwid(filter->can_id);
|————Node:assignment_expression Text: hwid_mask = ctucan_hw_id_to_hwid(filter->can_id)
|—————Node:identifier Text: hwid_mask
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_id_to_hwid(filter->can_id)
|——————Node:identifier Text: ctucan_hw_id_to_hwid
|——————Node:argument_list Text: (filter->can_id)
|———————Node:( Text: (
|———————Node:field_expression Text: filter->can_id
|————————Node:identifier Text: filter
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_id
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hwid_val = ctucan_hw_id_to_hwid(filter->can_mask);
|————Node:assignment_expression Text: hwid_val = ctucan_hw_id_to_hwid(filter->can_mask)
|—————Node:identifier Text: hwid_val
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_id_to_hwid(filter->can_mask)
|——————Node:identifier Text: ctucan_hw_id_to_hwid
|——————Node:argument_list Text: (filter->can_mask)
|———————Node:( Text: (
|———————Node:field_expression Text: filter->can_mask
|————————Node:identifier Text: filter
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_mask
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|——————Node:, Text: ,
|——————Node:field_expression Text: creg.u32
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, maddr, hwid_mask.u32);
|————Node:call_expression Text: priv->write_reg(priv, maddr, hwid_mask.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, maddr, hwid_mask.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: maddr
|——————Node:, Text: ,
|——————Node:field_expression Text: hwid_mask.u32
|———————Node:identifier Text: hwid_mask
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, vaddr, hwid_val.u32);
|————Node:call_expression Text: priv->write_reg(priv, vaddr, hwid_val.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, vaddr, hwid_val.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: vaddr
|——————Node:, Text: ,
|——————Node:field_expression Text: hwid_val.u32
|———————Node:identifier Text: hwid_val
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_range_filter(struct ctucan_hw_priv *priv, canid_t low_th,
				 canid_t high_th, bool enable)
{
	union ctu_can_fd_identifier_w hwid_low;
	union ctu_can_fd_identifier_w hwid_high;
	union ctu_can_fd_filter_control_filter_status creg;

	hwid_low = ctucan_hw_id_to_hwid(low_th);
	hwid_high = ctucan_hw_id_to_hwid(high_th);

	creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	creg.s.frnb = enable;
	creg.s.frne = enable;
	creg.s.frfb = enable;
	creg.s.frfe = enable;

	priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_LOW, hwid_low.u32);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_HIGH, hwid_high.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_range_filter(struct ctucan_hw_priv *priv, canid_t low_th,
				 canid_t high_th, bool enable)
|———Node:identifier Text: ctucan_hw_set_range_filter
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, canid_t low_th,
				 canid_t high_th, bool enable)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: canid_t low_th
|—————Node:type_identifier Text: canid_t
|—————Node:identifier Text: low_th
|————Node:, Text: ,
|————Node:parameter_declaration Text: canid_t high_th
|—————Node:type_identifier Text: canid_t
|—————Node:identifier Text: high_th
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool enable
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: enable
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_identifier_w hwid_low;
	union ctu_can_fd_identifier_w hwid_high;
	union ctu_can_fd_filter_control_filter_status creg;

	hwid_low = ctucan_hw_id_to_hwid(low_th);
	hwid_high = ctucan_hw_id_to_hwid(high_th);

	creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);

	creg.s.frnb = enable;
	creg.s.frne = enable;
	creg.s.frfb = enable;
	creg.s.frfe = enable;

	priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_LOW, hwid_low.u32);
	priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_HIGH, hwid_high.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_identifier_w hwid_low;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: hwid_low
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_identifier_w hwid_high;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: hwid_high
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_filter_control_filter_status creg;
|————Node:union_specifier Text: union ctu_can_fd_filter_control_filter_status
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_filter_control_filter_status
|————Node:identifier Text: creg
|————Node:; Text: ;
|———Node:expression_statement Text: hwid_low = ctucan_hw_id_to_hwid(low_th);
|————Node:assignment_expression Text: hwid_low = ctucan_hw_id_to_hwid(low_th)
|—————Node:identifier Text: hwid_low
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_id_to_hwid(low_th)
|——————Node:identifier Text: ctucan_hw_id_to_hwid
|——————Node:argument_list Text: (low_th)
|———————Node:( Text: (
|———————Node:identifier Text: low_th
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hwid_high = ctucan_hw_id_to_hwid(high_th);
|————Node:assignment_expression Text: hwid_high = ctucan_hw_id_to_hwid(high_th)
|—————Node:identifier Text: hwid_high
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_id_to_hwid(high_th)
|——————Node:identifier Text: ctucan_hw_id_to_hwid
|——————Node:argument_list Text: (high_th)
|———————Node:( Text: (
|———————Node:identifier Text: high_th
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL);
|————Node:assignment_expression Text: creg.u32 = priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|—————Node:field_expression Text: creg.u32
|——————Node:identifier Text: creg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_FILTER_CONTROL)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: creg.s.frnb = enable;
|————Node:assignment_expression Text: creg.s.frnb = enable
|—————Node:field_expression Text: creg.s.frnb
|——————Node:field_expression Text: creg.s
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: frnb
|—————Node:= Text: =
|—————Node:identifier Text: enable
|————Node:; Text: ;
|———Node:expression_statement Text: creg.s.frne = enable;
|————Node:assignment_expression Text: creg.s.frne = enable
|—————Node:field_expression Text: creg.s.frne
|——————Node:field_expression Text: creg.s
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: frne
|—————Node:= Text: =
|—————Node:identifier Text: enable
|————Node:; Text: ;
|———Node:expression_statement Text: creg.s.frfb = enable;
|————Node:assignment_expression Text: creg.s.frfb = enable
|—————Node:field_expression Text: creg.s.frfb
|——————Node:field_expression Text: creg.s
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: frfb
|—————Node:= Text: =
|—————Node:identifier Text: enable
|————Node:; Text: ;
|———Node:expression_statement Text: creg.s.frfe = enable;
|————Node:assignment_expression Text: creg.s.frfe = enable
|—————Node:field_expression Text: creg.s.frfe
|——————Node:field_expression Text: creg.s
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: frfe
|—————Node:= Text: =
|—————Node:identifier Text: enable
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_CONTROL, creg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_FILTER_CONTROL
|——————Node:, Text: ,
|——————Node:field_expression Text: creg.u32
|———————Node:identifier Text: creg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_LOW, hwid_low.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_LOW, hwid_low.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_RAN_LOW, hwid_low.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_FILTER_RAN_LOW
|——————Node:, Text: ,
|——————Node:field_expression Text: hwid_low.u32
|———————Node:identifier Text: hwid_low
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_HIGH, hwid_high.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_FILTER_RAN_HIGH, hwid_high.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_FILTER_RAN_HIGH, hwid_high.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_FILTER_RAN_HIGH
|——————Node:, Text: ,
|——————Node:field_expression Text: hwid_high.u32
|———————Node:identifier Text: hwid_high
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_rx_tsop(struct ctucan_hw_priv *priv,
			    enum ctu_can_fd_rx_settings_rtsop val)
{
	union ctu_can_fd_rx_status_rx_settings reg;

	reg.u32 = 0;
	reg.s.rtsop = val;
	priv->write_reg(priv, CTU_CAN_FD_RX_STATUS, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_rx_tsop(struct ctucan_hw_priv *priv,
			    enum ctu_can_fd_rx_settings_rtsop val)
|———Node:identifier Text: ctucan_hw_set_rx_tsop
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			    enum ctu_can_fd_rx_settings_rtsop val)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum ctu_can_fd_rx_settings_rtsop val
|—————Node:enum_specifier Text: enum ctu_can_fd_rx_settings_rtsop
|——————Node:enum Text: enum
|——————Node:type_identifier Text: ctu_can_fd_rx_settings_rtsop
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_rx_status_rx_settings reg;

	reg.u32 = 0;
	reg.s.rtsop = val;
	priv->write_reg(priv, CTU_CAN_FD_RX_STATUS, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_rx_status_rx_settings reg;
|————Node:union_specifier Text: union ctu_can_fd_rx_status_rx_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_rx_status_rx_settings
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.rtsop = val;
|————Node:assignment_expression Text: reg.s.rtsop = val
|—————Node:field_expression Text: reg.s.rtsop
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rtsop
|—————Node:= Text: =
|—————Node:identifier Text: val
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_RX_STATUS, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_RX_STATUS, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_RX_STATUS, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_RX_STATUS
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_read_rx_frame(struct ctucan_hw_priv *priv,
			      struct canfd_frame *cf, u64 *ts)
{
	union ctu_can_fd_frame_form_w ffw;

	ffw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
	ctucan_hw_read_rx_frame_ffw(priv, cf, ts, ffw);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_read_rx_frame(struct ctucan_hw_priv *priv,
			      struct canfd_frame *cf, u64 *ts)
|———Node:identifier Text: ctucan_hw_read_rx_frame
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			      struct canfd_frame *cf, u64 *ts)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct canfd_frame *cf
|—————Node:struct_specifier Text: struct canfd_frame
|——————Node:struct Text: struct
|——————Node:type_identifier Text: canfd_frame
|—————Node:pointer_declarator Text: *cf
|——————Node:* Text: *
|——————Node:identifier Text: cf
|————Node:, Text: ,
|————Node:parameter_declaration Text: u64 *ts
|—————Node:type_identifier Text: u64
|—————Node:pointer_declarator Text: *ts
|——————Node:* Text: *
|——————Node:identifier Text: ts
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_frame_form_w ffw;

	ffw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
	ctucan_hw_read_rx_frame_ffw(priv, cf, ts, ffw);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_frame_form_w ffw;
|————Node:union_specifier Text: union ctu_can_fd_frame_form_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_frame_form_w
|————Node:identifier Text: ffw
|————Node:; Text: ;
|———Node:expression_statement Text: ffw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
|————Node:assignment_expression Text: ffw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|—————Node:field_expression Text: ffw.u32
|——————Node:identifier Text: ffw
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_RX_DATA)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_RX_DATA
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_hw_read_rx_frame_ffw(priv, cf, ts, ffw);
|————Node:call_expression Text: ctucan_hw_read_rx_frame_ffw(priv, cf, ts, ffw)
|—————Node:identifier Text: ctucan_hw_read_rx_frame_ffw
|—————Node:argument_list Text: (priv, cf, ts, ffw)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: cf
|——————Node:, Text: ,
|——————Node:identifier Text: ts
|——————Node:, Text: ,
|——————Node:identifier Text: ffw
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_read_rx_frame_ffw(struct ctucan_hw_priv *priv,
				  struct canfd_frame *cf, u64 *ts,
				  union ctu_can_fd_frame_form_w ffw)
{
	union ctu_can_fd_identifier_w idw;
	unsigned int i;
	enum ctu_can_fd_frame_form_w_ide ide;

	idw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
	cf->can_id = 0;
	cf->flags = 0;

	/* BRS, ESI, RTR Flags */
	if (ffw.s.fdf == FD_CAN) {
		if (ffw.s.brs == BR_SHIFT)
			cf->flags |= CANFD_BRS;
		if (ffw.s.esi_rsv == ESI_ERR_PASIVE)
			cf->flags |= CANFD_ESI;
	} else if (ffw.s.rtr == RTR_FRAME) {
		cf->can_id |= CAN_RTR_FLAG;
	}

	/* DLC */
	if (ffw.s.dlc <= 8) {
		cf->len = ffw.s.dlc;
	} else {
		if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
	}

	ide = (enum ctu_can_fd_frame_form_w_ide)ffw.s.ide;
	ctucan_hw_hwid_to_id(idw, &cf->can_id, ide);

	/* Timestamp */
	*ts = (u64)(priv->read_reg(priv, CTU_CAN_FD_RX_DATA));
	*ts |= ((u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32);

	/* Data */
	for (i = 0; i < cf->len; i += 4) {
		u32 data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
		*(__le32 *)(cf->data + i) = cpu_to_le32(data);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_read_rx_frame_ffw(struct ctucan_hw_priv *priv,
				  struct canfd_frame *cf, u64 *ts,
				  union ctu_can_fd_frame_form_w ffw)
|———Node:identifier Text: ctucan_hw_read_rx_frame_ffw
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
				  struct canfd_frame *cf, u64 *ts,
				  union ctu_can_fd_frame_form_w ffw)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct canfd_frame *cf
|—————Node:struct_specifier Text: struct canfd_frame
|——————Node:struct Text: struct
|——————Node:type_identifier Text: canfd_frame
|—————Node:pointer_declarator Text: *cf
|——————Node:* Text: *
|——————Node:identifier Text: cf
|————Node:, Text: ,
|————Node:parameter_declaration Text: u64 *ts
|—————Node:type_identifier Text: u64
|—————Node:pointer_declarator Text: *ts
|——————Node:* Text: *
|——————Node:identifier Text: ts
|————Node:, Text: ,
|————Node:parameter_declaration Text: union ctu_can_fd_frame_form_w ffw
|—————Node:union_specifier Text: union ctu_can_fd_frame_form_w
|——————Node:union Text: union
|——————Node:type_identifier Text: ctu_can_fd_frame_form_w
|—————Node:identifier Text: ffw
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_identifier_w idw;
	unsigned int i;
	enum ctu_can_fd_frame_form_w_ide ide;

	idw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
	cf->can_id = 0;
	cf->flags = 0;

	/* BRS, ESI, RTR Flags */
	if (ffw.s.fdf == FD_CAN) {
		if (ffw.s.brs == BR_SHIFT)
			cf->flags |= CANFD_BRS;
		if (ffw.s.esi_rsv == ESI_ERR_PASIVE)
			cf->flags |= CANFD_ESI;
	} else if (ffw.s.rtr == RTR_FRAME) {
		cf->can_id |= CAN_RTR_FLAG;
	}

	/* DLC */
	if (ffw.s.dlc <= 8) {
		cf->len = ffw.s.dlc;
	} else {
		if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
	}

	ide = (enum ctu_can_fd_frame_form_w_ide)ffw.s.ide;
	ctucan_hw_hwid_to_id(idw, &cf->can_id, ide);

	/* Timestamp */
	*ts = (u64)(priv->read_reg(priv, CTU_CAN_FD_RX_DATA));
	*ts |= ((u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32);

	/* Data */
	for (i = 0; i < cf->len; i += 4) {
		u32 data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
		*(__le32 *)(cf->data + i) = cpu_to_le32(data);
	}
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_identifier_w idw;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: idw
|————Node:; Text: ;
|———Node:declaration Text: unsigned int i;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:declaration Text: enum ctu_can_fd_frame_form_w_ide ide;
|————Node:enum_specifier Text: enum ctu_can_fd_frame_form_w_ide
|—————Node:enum Text: enum
|—————Node:type_identifier Text: ctu_can_fd_frame_form_w_ide
|————Node:identifier Text: ide
|————Node:; Text: ;
|———Node:expression_statement Text: idw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
|————Node:assignment_expression Text: idw.u32 = priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|—————Node:field_expression Text: idw.u32
|——————Node:identifier Text: idw
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_RX_DATA)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_RX_DATA
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: cf->can_id = 0;
|————Node:assignment_expression Text: cf->can_id = 0
|—————Node:field_expression Text: cf->can_id
|——————Node:identifier Text: cf
|——————Node:-> Text: ->
|——————Node:field_identifier Text: can_id
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: cf->flags = 0;
|————Node:assignment_expression Text: cf->flags = 0
|—————Node:field_expression Text: cf->flags
|——————Node:identifier Text: cf
|——————Node:-> Text: ->
|——————Node:field_identifier Text: flags
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: /* BRS, ESI, RTR Flags */
|———Node:if_statement Text: if (ffw.s.fdf == FD_CAN) {
		if (ffw.s.brs == BR_SHIFT)
			cf->flags |= CANFD_BRS;
		if (ffw.s.esi_rsv == ESI_ERR_PASIVE)
			cf->flags |= CANFD_ESI;
	} else if (ffw.s.rtr == RTR_FRAME) {
		cf->can_id |= CAN_RTR_FLAG;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ffw.s.fdf == FD_CAN)
|—————Node:( Text: (
|—————Node:binary_expression Text: ffw.s.fdf == FD_CAN
|——————Node:field_expression Text: ffw.s.fdf
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: fdf
|——————Node:== Text: ==
|——————Node:identifier Text: FD_CAN
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (ffw.s.brs == BR_SHIFT)
			cf->flags |= CANFD_BRS;
		if (ffw.s.esi_rsv == ESI_ERR_PASIVE)
			cf->flags |= CANFD_ESI;
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (ffw.s.brs == BR_SHIFT)
			cf->flags |= CANFD_BRS;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ffw.s.brs == BR_SHIFT)
|———————Node:( Text: (
|———————Node:binary_expression Text: ffw.s.brs == BR_SHIFT
|————————Node:field_expression Text: ffw.s.brs
|—————————Node:field_expression Text: ffw.s
|——————————Node:identifier Text: ffw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: brs
|————————Node:== Text: ==
|————————Node:identifier Text: BR_SHIFT
|———————Node:) Text: )
|——————Node:expression_statement Text: cf->flags |= CANFD_BRS;
|———————Node:assignment_expression Text: cf->flags |= CANFD_BRS
|————————Node:field_expression Text: cf->flags
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: flags
|————————Node:|= Text: |=
|————————Node:identifier Text: CANFD_BRS
|———————Node:; Text: ;
|—————Node:if_statement Text: if (ffw.s.esi_rsv == ESI_ERR_PASIVE)
			cf->flags |= CANFD_ESI;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ffw.s.esi_rsv == ESI_ERR_PASIVE)
|———————Node:( Text: (
|———————Node:binary_expression Text: ffw.s.esi_rsv == ESI_ERR_PASIVE
|————————Node:field_expression Text: ffw.s.esi_rsv
|—————————Node:field_expression Text: ffw.s
|——————————Node:identifier Text: ffw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: esi_rsv
|————————Node:== Text: ==
|————————Node:identifier Text: ESI_ERR_PASIVE
|———————Node:) Text: )
|——————Node:expression_statement Text: cf->flags |= CANFD_ESI;
|———————Node:assignment_expression Text: cf->flags |= CANFD_ESI
|————————Node:field_expression Text: cf->flags
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: flags
|————————Node:|= Text: |=
|————————Node:identifier Text: CANFD_ESI
|———————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (ffw.s.rtr == RTR_FRAME) {
		cf->can_id |= CAN_RTR_FLAG;
	}
|—————Node:else Text: else
|—————Node:if_statement Text: if (ffw.s.rtr == RTR_FRAME) {
		cf->can_id |= CAN_RTR_FLAG;
	}
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ffw.s.rtr == RTR_FRAME)
|———————Node:( Text: (
|———————Node:binary_expression Text: ffw.s.rtr == RTR_FRAME
|————————Node:field_expression Text: ffw.s.rtr
|—————————Node:field_expression Text: ffw.s
|——————————Node:identifier Text: ffw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: rtr
|————————Node:== Text: ==
|————————Node:identifier Text: RTR_FRAME
|———————Node:) Text: )
|——————Node:compound_statement Text: {
		cf->can_id |= CAN_RTR_FLAG;
	}
|———————Node:{ Text: {
|———————Node:expression_statement Text: cf->can_id |= CAN_RTR_FLAG;
|————————Node:assignment_expression Text: cf->can_id |= CAN_RTR_FLAG
|—————————Node:field_expression Text: cf->can_id
|——————————Node:identifier Text: cf
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_id
|—————————Node:|= Text: |=
|—————————Node:identifier Text: CAN_RTR_FLAG
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:comment Text: /* DLC */
|———Node:if_statement Text: if (ffw.s.dlc <= 8) {
		cf->len = ffw.s.dlc;
	} else {
		if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ffw.s.dlc <= 8)
|—————Node:( Text: (
|—————Node:binary_expression Text: ffw.s.dlc <= 8
|——————Node:field_expression Text: ffw.s.dlc
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: dlc
|——————Node:<= Text: <=
|——————Node:number_literal Text: 8
|—————Node:) Text: )
|————Node:compound_statement Text: {
		cf->len = ffw.s.dlc;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: cf->len = ffw.s.dlc;
|——————Node:assignment_expression Text: cf->len = ffw.s.dlc
|———————Node:field_expression Text: cf->len
|————————Node:identifier Text: cf
|————————Node:-> Text: ->
|————————Node:field_identifier Text: len
|———————Node:= Text: =
|———————Node:field_expression Text: ffw.s.dlc
|————————Node:field_expression Text: ffw.s
|—————————Node:identifier Text: ffw
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: dlc
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
	}
|——————Node:{ Text: {
|——————Node:if_statement Text: if (ffw.s.fdf == FD_CAN)
			cf->len = (ffw.s.rwcnt - 3) << 2;
		else
			cf->len = 8;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (ffw.s.fdf == FD_CAN)
|————————Node:( Text: (
|————————Node:binary_expression Text: ffw.s.fdf == FD_CAN
|—————————Node:field_expression Text: ffw.s.fdf
|——————————Node:field_expression Text: ffw.s
|———————————Node:identifier Text: ffw
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: fdf
|—————————Node:== Text: ==
|—————————Node:identifier Text: FD_CAN
|————————Node:) Text: )
|———————Node:expression_statement Text: cf->len = (ffw.s.rwcnt - 3) << 2;
|————————Node:assignment_expression Text: cf->len = (ffw.s.rwcnt - 3) << 2
|—————————Node:field_expression Text: cf->len
|——————————Node:identifier Text: cf
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: len
|—————————Node:= Text: =
|—————————Node:binary_expression Text: (ffw.s.rwcnt - 3) << 2
|——————————Node:parenthesized_expression Text: (ffw.s.rwcnt - 3)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ffw.s.rwcnt - 3
|————————————Node:field_expression Text: ffw.s.rwcnt
|—————————————Node:field_expression Text: ffw.s
|——————————————Node:identifier Text: ffw
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: s
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: rwcnt
|————————————Node:- Text: -
|————————————Node:number_literal Text: 3
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 2
|————————Node:; Text: ;
|———————Node:else_clause Text: else
			cf->len = 8;
|————————Node:else Text: else
|————————Node:expression_statement Text: cf->len = 8;
|—————————Node:assignment_expression Text: cf->len = 8
|——————————Node:field_expression Text: cf->len
|———————————Node:identifier Text: cf
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: len
|——————————Node:= Text: =
|——————————Node:number_literal Text: 8
|—————————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: ide = (enum ctu_can_fd_frame_form_w_ide)ffw.s.ide;
|————Node:assignment_expression Text: ide = (enum ctu_can_fd_frame_form_w_ide)ffw.s.ide
|—————Node:identifier Text: ide
|—————Node:= Text: =
|—————Node:cast_expression Text: (enum ctu_can_fd_frame_form_w_ide)ffw.s.ide
|——————Node:( Text: (
|——————Node:type_descriptor Text: enum ctu_can_fd_frame_form_w_ide
|———————Node:enum_specifier Text: enum ctu_can_fd_frame_form_w_ide
|————————Node:enum Text: enum
|————————Node:type_identifier Text: ctu_can_fd_frame_form_w_ide
|——————Node:) Text: )
|——————Node:field_expression Text: ffw.s.ide
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: ide
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_hw_hwid_to_id(idw, &cf->can_id, ide);
|————Node:call_expression Text: ctucan_hw_hwid_to_id(idw, &cf->can_id, ide)
|—————Node:identifier Text: ctucan_hw_hwid_to_id
|—————Node:argument_list Text: (idw, &cf->can_id, ide)
|——————Node:( Text: (
|——————Node:identifier Text: idw
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &cf->can_id
|———————Node:& Text: &
|———————Node:field_expression Text: cf->can_id
|————————Node:identifier Text: cf
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_id
|——————Node:, Text: ,
|——————Node:identifier Text: ide
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Timestamp */
|———Node:expression_statement Text: *ts = (u64)(priv->read_reg(priv, CTU_CAN_FD_RX_DATA));
|————Node:assignment_expression Text: *ts = (u64)(priv->read_reg(priv, CTU_CAN_FD_RX_DATA))
|—————Node:pointer_expression Text: *ts
|——————Node:* Text: *
|——————Node:identifier Text: ts
|—————Node:= Text: =
|—————Node:call_expression Text: (u64)(priv->read_reg(priv, CTU_CAN_FD_RX_DATA))
|——————Node:parenthesized_expression Text: (u64)
|———————Node:( Text: (
|———————Node:identifier Text: u64
|———————Node:) Text: )
|——————Node:argument_list Text: (priv->read_reg(priv, CTU_CAN_FD_RX_DATA))
|———————Node:( Text: (
|———————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|————————Node:field_expression Text: priv->read_reg
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: read_reg
|————————Node:argument_list Text: (priv, CTU_CAN_FD_RX_DATA)
|—————————Node:( Text: (
|—————————Node:identifier Text: priv
|—————————Node:, Text: ,
|—————————Node:identifier Text: CTU_CAN_FD_RX_DATA
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: *ts |= ((u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32);
|————Node:assignment_expression Text: *ts |= ((u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32)
|—————Node:pointer_expression Text: *ts
|——————Node:* Text: *
|——————Node:identifier Text: ts
|—————Node:|= Text: |=
|—————Node:parenthesized_expression Text: ((u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32)
|——————Node:( Text: (
|——————Node:binary_expression Text: (u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA) << 32
|———————Node:cast_expression Text: (u64)priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|————————Node:( Text: (
|————————Node:type_descriptor Text: u64
|—————————Node:type_identifier Text: u64
|————————Node:) Text: )
|————————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|—————————Node:field_expression Text: priv->read_reg
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: read_reg
|—————————Node:argument_list Text: (priv, CTU_CAN_FD_RX_DATA)
|——————————Node:( Text: (
|——————————Node:identifier Text: priv
|——————————Node:, Text: ,
|——————————Node:identifier Text: CTU_CAN_FD_RX_DATA
|——————————Node:) Text: )
|———————Node:<< Text: <<
|———————Node:number_literal Text: 32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Data */
|———Node:for_statement Text: for (i = 0; i < cf->len; i += 4) {
		u32 data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
		*(__le32 *)(cf->data + i) = cpu_to_le32(data);
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i = 0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i < cf->len
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:field_expression Text: cf->len
|——————Node:identifier Text: cf
|——————Node:-> Text: ->
|——————Node:field_identifier Text: len
|————Node:; Text: ;
|————Node:assignment_expression Text: i += 4
|—————Node:identifier Text: i
|—————Node:+= Text: +=
|—————Node:number_literal Text: 4
|————Node:) Text: )
|————Node:compound_statement Text: {
		u32 data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
		*(__le32 *)(cf->data + i) = cpu_to_le32(data);
	}
|—————Node:{ Text: {
|—————Node:declaration Text: u32 data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA);
|——————Node:type_identifier Text: u32
|——————Node:init_declarator Text: data = priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|———————Node:identifier Text: data
|———————Node:= Text: =
|———————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_RX_DATA)
|————————Node:field_expression Text: priv->read_reg
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: read_reg
|————————Node:argument_list Text: (priv, CTU_CAN_FD_RX_DATA)
|—————————Node:( Text: (
|—————————Node:identifier Text: priv
|—————————Node:, Text: ,
|—————————Node:identifier Text: CTU_CAN_FD_RX_DATA
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: *(__le32 *)(cf->data + i) = cpu_to_le32(data);
|——————Node:assignment_expression Text: *(__le32 *)(cf->data + i) = cpu_to_le32(data)
|———————Node:pointer_expression Text: *(__le32 *)(cf->data + i)
|————————Node:* Text: *
|————————Node:cast_expression Text: (__le32 *)(cf->data + i)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: __le32 *
|——————————Node:type_identifier Text: __le32
|——————————Node:abstract_pointer_declarator Text: *
|———————————Node:* Text: *
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (cf->data + i)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: cf->data + i
|———————————Node:field_expression Text: cf->data
|————————————Node:identifier Text: cf
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: data
|———————————Node:+ Text: +
|———————————Node:identifier Text: i
|——————————Node:) Text: )
|———————Node:= Text: =
|———————Node:call_expression Text: cpu_to_le32(data)
|————————Node:identifier Text: cpu_to_le32
|————————Node:argument_list Text: (data)
|—————————Node:( Text: (
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: enum ctu_can_fd_tx_status_tx1s ctucan_hw_get_tx_status(struct ctucan_hw_priv
							*priv, u8 buf)
{
	union ctu_can_fd_tx_status reg;
	uint32_t status;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_TX_STATUS);

	switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		status = reg.s.tx1s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		status = reg.s.tx2s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		status = reg.s.tx3s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		status = reg.s.tx4s;
		break;
	default:
		status = ~0;
	}
	return (enum ctu_can_fd_tx_status_tx1s)status;
}
|——Node:enum_specifier Text: enum ctu_can_fd_tx_status_tx1s
|———Node:enum Text: enum
|———Node:type_identifier Text: ctu_can_fd_tx_status_tx1s
|——Node:function_declarator Text: ctucan_hw_get_tx_status(struct ctucan_hw_priv
							*priv, u8 buf)
|———Node:identifier Text: ctucan_hw_get_tx_status
|———Node:parameter_list Text: (struct ctucan_hw_priv
							*priv, u8 buf)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv
							*priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 buf
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: buf
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_tx_status reg;
	uint32_t status;

	reg.u32 = priv->read_reg(priv, CTU_CAN_FD_TX_STATUS);

	switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		status = reg.s.tx1s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		status = reg.s.tx2s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		status = reg.s.tx3s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		status = reg.s.tx4s;
		break;
	default:
		status = ~0;
	}
	return (enum ctu_can_fd_tx_status_tx1s)status;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_tx_status reg;
|————Node:union_specifier Text: union ctu_can_fd_tx_status
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_tx_status
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:declaration Text: uint32_t status;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: status
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_TX_STATUS);
|————Node:assignment_expression Text: reg.u32 = priv->read_reg(priv, CTU_CAN_FD_TX_STATUS)
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_TX_STATUS)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_TX_STATUS)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_TX_STATUS
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:switch_statement Text: switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		status = reg.s.tx1s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		status = reg.s.tx2s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		status = reg.s.tx3s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		status = reg.s.tx4s;
		break;
	default:
		status = ~0;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (buf)
|—————Node:( Text: (
|—————Node:identifier Text: buf
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case CTU_CAN_FD_TXT_BUFFER_1:
		status = reg.s.tx1s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		status = reg.s.tx2s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		status = reg.s.tx3s;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		status = reg.s.tx4s;
		break;
	default:
		status = ~0;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_1:
		status = reg.s.tx1s;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_1
|——————Node:: Text: :
|——————Node:expression_statement Text: status = reg.s.tx1s;
|———————Node:assignment_expression Text: status = reg.s.tx1s
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:field_expression Text: reg.s.tx1s
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tx1s
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_2:
		status = reg.s.tx2s;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_2
|——————Node:: Text: :
|——————Node:expression_statement Text: status = reg.s.tx2s;
|———————Node:assignment_expression Text: status = reg.s.tx2s
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:field_expression Text: reg.s.tx2s
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tx2s
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_3:
		status = reg.s.tx3s;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_3
|——————Node:: Text: :
|——————Node:expression_statement Text: status = reg.s.tx3s;
|———————Node:assignment_expression Text: status = reg.s.tx3s
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:field_expression Text: reg.s.tx3s
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tx3s
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_4:
		status = reg.s.tx4s;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_4
|——————Node:: Text: :
|——————Node:expression_statement Text: status = reg.s.tx4s;
|———————Node:assignment_expression Text: status = reg.s.tx4s
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:field_expression Text: reg.s.tx4s
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tx4s
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
		status = ~0;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: status = ~0;
|———————Node:assignment_expression Text: status = ~0
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:unary_expression Text: ~0
|—————————Node:~ Text: ~
|—————————Node:number_literal Text: 0
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return (enum ctu_can_fd_tx_status_tx1s)status;
|————Node:return Text: return
|————Node:cast_expression Text: (enum ctu_can_fd_tx_status_tx1s)status
|—————Node:( Text: (
|—————Node:type_descriptor Text: enum ctu_can_fd_tx_status_tx1s
|——————Node:enum_specifier Text: enum ctu_can_fd_tx_status_tx1s
|———————Node:enum Text: enum
|———————Node:type_identifier Text: ctu_can_fd_tx_status_tx1s
|—————Node:) Text: )
|—————Node:identifier Text: status
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_is_txt_buf_accessible(struct ctucan_hw_priv *priv, u8 buf)
{
	enum ctu_can_fd_tx_status_tx1s buf_status;

	buf_status = ctucan_hw_get_tx_status(priv, buf);
	if (buf_status == TXT_RDY || buf_status == TXT_TRAN ||
	    buf_status == TXT_ABTP)
		return false;

	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_is_txt_buf_accessible(struct ctucan_hw_priv *priv, u8 buf)
|———Node:identifier Text: ctucan_hw_is_txt_buf_accessible
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, u8 buf)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 buf
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: buf
|————Node:) Text: )
|——Node:compound_statement Text: {
	enum ctu_can_fd_tx_status_tx1s buf_status;

	buf_status = ctucan_hw_get_tx_status(priv, buf);
	if (buf_status == TXT_RDY || buf_status == TXT_TRAN ||
	    buf_status == TXT_ABTP)
		return false;

	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: enum ctu_can_fd_tx_status_tx1s buf_status;
|————Node:enum_specifier Text: enum ctu_can_fd_tx_status_tx1s
|—————Node:enum Text: enum
|—————Node:type_identifier Text: ctu_can_fd_tx_status_tx1s
|————Node:identifier Text: buf_status
|————Node:; Text: ;
|———Node:expression_statement Text: buf_status = ctucan_hw_get_tx_status(priv, buf);
|————Node:assignment_expression Text: buf_status = ctucan_hw_get_tx_status(priv, buf)
|—————Node:identifier Text: buf_status
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_get_tx_status(priv, buf)
|——————Node:identifier Text: ctucan_hw_get_tx_status
|——————Node:argument_list Text: (priv, buf)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: buf
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (buf_status == TXT_RDY || buf_status == TXT_TRAN ||
	    buf_status == TXT_ABTP)
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (buf_status == TXT_RDY || buf_status == TXT_TRAN ||
	    buf_status == TXT_ABTP)
|—————Node:( Text: (
|—————Node:binary_expression Text: buf_status == TXT_RDY || buf_status == TXT_TRAN ||
	    buf_status == TXT_ABTP
|——————Node:binary_expression Text: buf_status == TXT_RDY || buf_status == TXT_TRAN
|———————Node:binary_expression Text: buf_status == TXT_RDY
|————————Node:identifier Text: buf_status
|————————Node:== Text: ==
|————————Node:identifier Text: TXT_RDY
|———————Node:|| Text: ||
|———————Node:binary_expression Text: buf_status == TXT_TRAN
|————————Node:identifier Text: buf_status
|————————Node:== Text: ==
|————————Node:identifier Text: TXT_TRAN
|——————Node:|| Text: ||
|——————Node:binary_expression Text: buf_status == TXT_ABTP
|———————Node:identifier Text: buf_status
|———————Node:== Text: ==
|———————Node:identifier Text: TXT_ABTP
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool ctucan_hw_txt_buf_give_command(struct ctucan_hw_priv *priv, u8 cmd, u8 buf)
{
	union ctu_can_fd_tx_command reg;

	reg.u32 = 0;

	switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		reg.s.txb1 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		reg.s.txb2 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		reg.s.txb3 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		reg.s.txb4 = 1;
		break;
	default:
		return false;
	}

	// TODO: use named constants for the command
	if (cmd & 0x1)
		reg.s.txce = 1;
	else if (cmd & 0x2)
		reg.s.txcr = 1;
	else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;

	priv->write_reg(priv, CTU_CAN_FD_TX_COMMAND, reg.u32);
	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_txt_buf_give_command(struct ctucan_hw_priv *priv, u8 cmd, u8 buf)
|———Node:identifier Text: ctucan_hw_txt_buf_give_command
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, u8 cmd, u8 buf)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 cmd
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: cmd
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 buf
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: buf
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_tx_command reg;

	reg.u32 = 0;

	switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		reg.s.txb1 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		reg.s.txb2 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		reg.s.txb3 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		reg.s.txb4 = 1;
		break;
	default:
		return false;
	}

	// TODO: use named constants for the command
	if (cmd & 0x1)
		reg.s.txce = 1;
	else if (cmd & 0x2)
		reg.s.txcr = 1;
	else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;

	priv->write_reg(priv, CTU_CAN_FD_TX_COMMAND, reg.u32);
	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_tx_command reg;
|————Node:union_specifier Text: union ctu_can_fd_tx_command
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_tx_command
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:switch_statement Text: switch (buf) {
	case CTU_CAN_FD_TXT_BUFFER_1:
		reg.s.txb1 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		reg.s.txb2 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		reg.s.txb3 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		reg.s.txb4 = 1;
		break;
	default:
		return false;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (buf)
|—————Node:( Text: (
|—————Node:identifier Text: buf
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case CTU_CAN_FD_TXT_BUFFER_1:
		reg.s.txb1 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_2:
		reg.s.txb2 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_3:
		reg.s.txb3 = 1;
		break;
	case CTU_CAN_FD_TXT_BUFFER_4:
		reg.s.txb4 = 1;
		break;
	default:
		return false;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_1:
		reg.s.txb1 = 1;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_1
|——————Node:: Text: :
|——————Node:expression_statement Text: reg.s.txb1 = 1;
|———————Node:assignment_expression Text: reg.s.txb1 = 1
|————————Node:field_expression Text: reg.s.txb1
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: txb1
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_2:
		reg.s.txb2 = 1;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_2
|——————Node:: Text: :
|——————Node:expression_statement Text: reg.s.txb2 = 1;
|———————Node:assignment_expression Text: reg.s.txb2 = 1
|————————Node:field_expression Text: reg.s.txb2
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: txb2
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_3:
		reg.s.txb3 = 1;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_3
|——————Node:: Text: :
|——————Node:expression_statement Text: reg.s.txb3 = 1;
|———————Node:assignment_expression Text: reg.s.txb3 = 1
|————————Node:field_expression Text: reg.s.txb3
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: txb3
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case CTU_CAN_FD_TXT_BUFFER_4:
		reg.s.txb4 = 1;
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_4
|——————Node:: Text: :
|——————Node:expression_statement Text: reg.s.txb4 = 1;
|———————Node:assignment_expression Text: reg.s.txb4 = 1
|————————Node:field_expression Text: reg.s.txb4
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: txb4
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
		return false;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:return_statement Text: return false;
|———————Node:return Text: return
|———————Node:false Text: false
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: // TODO: use named constants for the command
|———Node:if_statement Text: if (cmd & 0x1)
		reg.s.txce = 1;
	else if (cmd & 0x2)
		reg.s.txcr = 1;
	else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cmd & 0x1)
|—————Node:( Text: (
|—————Node:binary_expression Text: cmd & 0x1
|——————Node:identifier Text: cmd
|——————Node:& Text: &
|——————Node:number_literal Text: 0x1
|—————Node:) Text: )
|————Node:expression_statement Text: reg.s.txce = 1;
|—————Node:assignment_expression Text: reg.s.txce = 1
|——————Node:field_expression Text: reg.s.txce
|———————Node:field_expression Text: reg.s
|————————Node:identifier Text: reg
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: txce
|——————Node:= Text: =
|——————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:else_clause Text: else if (cmd & 0x2)
		reg.s.txcr = 1;
	else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;
|—————Node:else Text: else
|—————Node:if_statement Text: if (cmd & 0x2)
		reg.s.txcr = 1;
	else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (cmd & 0x2)
|———————Node:( Text: (
|———————Node:binary_expression Text: cmd & 0x2
|————————Node:identifier Text: cmd
|————————Node:& Text: &
|————————Node:number_literal Text: 0x2
|———————Node:) Text: )
|——————Node:expression_statement Text: reg.s.txcr = 1;
|———————Node:assignment_expression Text: reg.s.txcr = 1
|————————Node:field_expression Text: reg.s.txcr
|—————————Node:field_expression Text: reg.s
|——————————Node:identifier Text: reg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: txcr
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:else_clause Text: else if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;
|———————Node:else Text: else
|———————Node:if_statement Text: if (cmd & 0x4)
		reg.s.txca = 1;
	else
		return false;
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (cmd & 0x4)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: cmd & 0x4
|——————————Node:identifier Text: cmd
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0x4
|—————————Node:) Text: )
|————————Node:expression_statement Text: reg.s.txca = 1;
|—————————Node:assignment_expression Text: reg.s.txca = 1
|——————————Node:field_expression Text: reg.s.txca
|———————————Node:field_expression Text: reg.s
|————————————Node:identifier Text: reg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: s
|———————————Node:. Text: .
|———————————Node:field_identifier Text: txca
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:else_clause Text: else
		return false;
|—————————Node:else Text: else
|—————————Node:return_statement Text: return false;
|——————————Node:return Text: return
|——————————Node:false Text: false
|——————————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_TX_COMMAND, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_TX_COMMAND, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_TX_COMMAND, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TX_COMMAND
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_set_txt_priority(struct ctucan_hw_priv *priv, const u8 *prio)
{
	union ctu_can_fd_tx_priority reg;

	reg.u32 = 0;
	reg.s.txt1p = prio[0];
	reg.s.txt2p = prio[1];
	reg.s.txt3p = prio[2];
	reg.s.txt4p = prio[3];

	priv->write_reg(priv, CTU_CAN_FD_TX_PRIORITY, reg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_set_txt_priority(struct ctucan_hw_priv *priv, const u8 *prio)
|———Node:identifier Text: ctucan_hw_set_txt_priority
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, const u8 *prio)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: const u8 *prio
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: u8
|—————Node:pointer_declarator Text: *prio
|——————Node:* Text: *
|——————Node:identifier Text: prio
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_tx_priority reg;

	reg.u32 = 0;
	reg.s.txt1p = prio[0];
	reg.s.txt2p = prio[1];
	reg.s.txt3p = prio[2];
	reg.s.txt4p = prio[3];

	priv->write_reg(priv, CTU_CAN_FD_TX_PRIORITY, reg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_tx_priority reg;
|————Node:union_specifier Text: union ctu_can_fd_tx_priority
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_tx_priority
|————Node:identifier Text: reg
|————Node:; Text: ;
|———Node:expression_statement Text: reg.u32 = 0;
|————Node:assignment_expression Text: reg.u32 = 0
|—————Node:field_expression Text: reg.u32
|——————Node:identifier Text: reg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.txt1p = prio[0];
|————Node:assignment_expression Text: reg.s.txt1p = prio[0]
|—————Node:field_expression Text: reg.s.txt1p
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txt1p
|—————Node:= Text: =
|—————Node:subscript_expression Text: prio[0]
|——————Node:identifier Text: prio
|——————Node:[ Text: [
|——————Node:number_literal Text: 0
|——————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.txt2p = prio[1];
|————Node:assignment_expression Text: reg.s.txt2p = prio[1]
|—————Node:field_expression Text: reg.s.txt2p
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txt2p
|—————Node:= Text: =
|—————Node:subscript_expression Text: prio[1]
|——————Node:identifier Text: prio
|——————Node:[ Text: [
|——————Node:number_literal Text: 1
|——————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.txt3p = prio[2];
|————Node:assignment_expression Text: reg.s.txt3p = prio[2]
|—————Node:field_expression Text: reg.s.txt3p
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txt3p
|—————Node:= Text: =
|—————Node:subscript_expression Text: prio[2]
|——————Node:identifier Text: prio
|——————Node:[ Text: [
|——————Node:number_literal Text: 2
|——————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: reg.s.txt4p = prio[3];
|————Node:assignment_expression Text: reg.s.txt4p = prio[3]
|—————Node:field_expression Text: reg.s.txt4p
|——————Node:field_expression Text: reg.s
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txt4p
|—————Node:= Text: =
|—————Node:subscript_expression Text: prio[3]
|——————Node:identifier Text: prio
|——————Node:[ Text: [
|——————Node:number_literal Text: 3
|——————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_TX_PRIORITY, reg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_TX_PRIORITY, reg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_TX_PRIORITY, reg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TX_PRIORITY
|——————Node:, Text: ,
|——————Node:field_expression Text: reg.u32
|———————Node:identifier Text: reg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:declaration Text: static const enum ctu_can_fd_can_registers
	tx_buf_bases[CTU_CAN_FD_TXT_BUFFER_COUNT] = {
		CTU_CAN_FD_TXTB1_DATA_1, CTU_CAN_FD_TXTB2_DATA_1,
		CTU_CAN_FD_TXTB3_DATA_1, CTU_CAN_FD_TXTB4_DATA_1
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:enum_specifier Text: enum ctu_can_fd_can_registers
|———Node:enum Text: enum
|———Node:type_identifier Text: ctu_can_fd_can_registers
|——Node:init_declarator Text: tx_buf_bases[CTU_CAN_FD_TXT_BUFFER_COUNT] = {
		CTU_CAN_FD_TXTB1_DATA_1, CTU_CAN_FD_TXTB2_DATA_1,
		CTU_CAN_FD_TXTB3_DATA_1, CTU_CAN_FD_TXTB4_DATA_1
}
|———Node:array_declarator Text: tx_buf_bases[CTU_CAN_FD_TXT_BUFFER_COUNT]
|————Node:identifier Text: tx_buf_bases
|————Node:[ Text: [
|————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_COUNT
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
		CTU_CAN_FD_TXTB1_DATA_1, CTU_CAN_FD_TXTB2_DATA_1,
		CTU_CAN_FD_TXTB3_DATA_1, CTU_CAN_FD_TXTB4_DATA_1
}
|————Node:{ Text: {
|————Node:identifier Text: CTU_CAN_FD_TXTB1_DATA_1
|————Node:, Text: ,
|————Node:identifier Text: CTU_CAN_FD_TXTB2_DATA_1
|————Node:, Text: ,
|————Node:identifier Text: CTU_CAN_FD_TXTB3_DATA_1
|————Node:, Text: ,
|————Node:identifier Text: CTU_CAN_FD_TXTB4_DATA_1
|————Node:} Text: }
|——Node:; Text: ;
|—Node:function_definition Text: bool ctucan_hw_insert_frame(struct ctucan_hw_priv *priv,
			     const struct canfd_frame *cf, u64 ts, u8 buf,
			     bool isfdf)
{
	enum ctu_can_fd_can_registers buf_base;
	union ctu_can_fd_frame_form_w ffw;
	union ctu_can_fd_identifier_w idw;
	u8 dlc;
	unsigned int i;

	ffw.u32 = 0;
	idw.u32 = 0;

	if (buf >= CTU_CAN_FD_TXT_BUFFER_COUNT)
		return false;
	buf_base = tx_buf_bases[buf];

	if (!ctucan_hw_is_txt_buf_accessible(priv, buf))
		return false;

	if (cf->can_id & CAN_RTR_FLAG)
		ffw.s.rtr = RTR_FRAME;

	if (cf->can_id & CAN_EFF_FLAG)
		ffw.s.ide = EXTENDED;
	else
		ffw.s.ide = BASE;

	idw = ctucan_hw_id_to_hwid(cf->can_id);

	if (!ctucan_hw_len_to_dlc(cf->len, &dlc))
		return false;
	ffw.s.dlc = dlc;

	if (isfdf) {
		ffw.s.fdf = FD_CAN;
		if (cf->flags & CANFD_BRS)
			ffw.s.brs = BR_SHIFT;
	}

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_FRAME_FORM_W, ffw.u32);

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_IDENTIFIER_W, idw.u32);

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_L_W, (u32)(ts));

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_U_W, (u32)(ts >> 32));

	if (!(cf->can_id & CAN_RTR_FLAG)) {
		for (i = 0; i < cf->len; i += 4) {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
	}

	return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: ctucan_hw_insert_frame(struct ctucan_hw_priv *priv,
			     const struct canfd_frame *cf, u64 ts, u8 buf,
			     bool isfdf)
|———Node:identifier Text: ctucan_hw_insert_frame
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv,
			     const struct canfd_frame *cf, u64 ts, u8 buf,
			     bool isfdf)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: const struct canfd_frame *cf
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct canfd_frame
|——————Node:struct Text: struct
|——————Node:type_identifier Text: canfd_frame
|—————Node:pointer_declarator Text: *cf
|——————Node:* Text: *
|——————Node:identifier Text: cf
|————Node:, Text: ,
|————Node:parameter_declaration Text: u64 ts
|—————Node:type_identifier Text: u64
|—————Node:identifier Text: ts
|————Node:, Text: ,
|————Node:parameter_declaration Text: u8 buf
|—————Node:type_identifier Text: u8
|—————Node:identifier Text: buf
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool isfdf
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: isfdf
|————Node:) Text: )
|——Node:compound_statement Text: {
	enum ctu_can_fd_can_registers buf_base;
	union ctu_can_fd_frame_form_w ffw;
	union ctu_can_fd_identifier_w idw;
	u8 dlc;
	unsigned int i;

	ffw.u32 = 0;
	idw.u32 = 0;

	if (buf >= CTU_CAN_FD_TXT_BUFFER_COUNT)
		return false;
	buf_base = tx_buf_bases[buf];

	if (!ctucan_hw_is_txt_buf_accessible(priv, buf))
		return false;

	if (cf->can_id & CAN_RTR_FLAG)
		ffw.s.rtr = RTR_FRAME;

	if (cf->can_id & CAN_EFF_FLAG)
		ffw.s.ide = EXTENDED;
	else
		ffw.s.ide = BASE;

	idw = ctucan_hw_id_to_hwid(cf->can_id);

	if (!ctucan_hw_len_to_dlc(cf->len, &dlc))
		return false;
	ffw.s.dlc = dlc;

	if (isfdf) {
		ffw.s.fdf = FD_CAN;
		if (cf->flags & CANFD_BRS)
			ffw.s.brs = BR_SHIFT;
	}

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_FRAME_FORM_W, ffw.u32);

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_IDENTIFIER_W, idw.u32);

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_L_W, (u32)(ts));

	ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_U_W, (u32)(ts >> 32));

	if (!(cf->can_id & CAN_RTR_FLAG)) {
		for (i = 0; i < cf->len; i += 4) {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
	}

	return true;
}
|———Node:{ Text: {
|———Node:declaration Text: enum ctu_can_fd_can_registers buf_base;
|————Node:enum_specifier Text: enum ctu_can_fd_can_registers
|—————Node:enum Text: enum
|—————Node:type_identifier Text: ctu_can_fd_can_registers
|————Node:identifier Text: buf_base
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_frame_form_w ffw;
|————Node:union_specifier Text: union ctu_can_fd_frame_form_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_frame_form_w
|————Node:identifier Text: ffw
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_identifier_w idw;
|————Node:union_specifier Text: union ctu_can_fd_identifier_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_identifier_w
|————Node:identifier Text: idw
|————Node:; Text: ;
|———Node:declaration Text: u8 dlc;
|————Node:type_identifier Text: u8
|————Node:identifier Text: dlc
|————Node:; Text: ;
|———Node:declaration Text: unsigned int i;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:expression_statement Text: ffw.u32 = 0;
|————Node:assignment_expression Text: ffw.u32 = 0
|—————Node:field_expression Text: ffw.u32
|——————Node:identifier Text: ffw
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: idw.u32 = 0;
|————Node:assignment_expression Text: idw.u32 = 0
|—————Node:field_expression Text: idw.u32
|——————Node:identifier Text: idw
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (buf >= CTU_CAN_FD_TXT_BUFFER_COUNT)
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (buf >= CTU_CAN_FD_TXT_BUFFER_COUNT)
|—————Node:( Text: (
|—————Node:binary_expression Text: buf >= CTU_CAN_FD_TXT_BUFFER_COUNT
|——————Node:identifier Text: buf
|——————Node:>= Text: >=
|——————Node:identifier Text: CTU_CAN_FD_TXT_BUFFER_COUNT
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:expression_statement Text: buf_base = tx_buf_bases[buf];
|————Node:assignment_expression Text: buf_base = tx_buf_bases[buf]
|—————Node:identifier Text: buf_base
|—————Node:= Text: =
|—————Node:subscript_expression Text: tx_buf_bases[buf]
|——————Node:identifier Text: tx_buf_bases
|——————Node:[ Text: [
|——————Node:identifier Text: buf
|——————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (!ctucan_hw_is_txt_buf_accessible(priv, buf))
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!ctucan_hw_is_txt_buf_accessible(priv, buf))
|—————Node:( Text: (
|—————Node:unary_expression Text: !ctucan_hw_is_txt_buf_accessible(priv, buf)
|——————Node:! Text: !
|——————Node:call_expression Text: ctucan_hw_is_txt_buf_accessible(priv, buf)
|———————Node:identifier Text: ctucan_hw_is_txt_buf_accessible
|———————Node:argument_list Text: (priv, buf)
|————————Node:( Text: (
|————————Node:identifier Text: priv
|————————Node:, Text: ,
|————————Node:identifier Text: buf
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:if_statement Text: if (cf->can_id & CAN_RTR_FLAG)
		ffw.s.rtr = RTR_FRAME;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cf->can_id & CAN_RTR_FLAG)
|—————Node:( Text: (
|—————Node:binary_expression Text: cf->can_id & CAN_RTR_FLAG
|——————Node:field_expression Text: cf->can_id
|———————Node:identifier Text: cf
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can_id
|——————Node:& Text: &
|——————Node:identifier Text: CAN_RTR_FLAG
|—————Node:) Text: )
|————Node:expression_statement Text: ffw.s.rtr = RTR_FRAME;
|—————Node:assignment_expression Text: ffw.s.rtr = RTR_FRAME
|——————Node:field_expression Text: ffw.s.rtr
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: rtr
|——————Node:= Text: =
|——————Node:identifier Text: RTR_FRAME
|—————Node:; Text: ;
|———Node:if_statement Text: if (cf->can_id & CAN_EFF_FLAG)
		ffw.s.ide = EXTENDED;
	else
		ffw.s.ide = BASE;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cf->can_id & CAN_EFF_FLAG)
|—————Node:( Text: (
|—————Node:binary_expression Text: cf->can_id & CAN_EFF_FLAG
|——————Node:field_expression Text: cf->can_id
|———————Node:identifier Text: cf
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can_id
|——————Node:& Text: &
|——————Node:identifier Text: CAN_EFF_FLAG
|—————Node:) Text: )
|————Node:expression_statement Text: ffw.s.ide = EXTENDED;
|—————Node:assignment_expression Text: ffw.s.ide = EXTENDED
|——————Node:field_expression Text: ffw.s.ide
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: ide
|——————Node:= Text: =
|——————Node:identifier Text: EXTENDED
|—————Node:; Text: ;
|————Node:else_clause Text: else
		ffw.s.ide = BASE;
|—————Node:else Text: else
|—————Node:expression_statement Text: ffw.s.ide = BASE;
|——————Node:assignment_expression Text: ffw.s.ide = BASE
|———————Node:field_expression Text: ffw.s.ide
|————————Node:field_expression Text: ffw.s
|—————————Node:identifier Text: ffw
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: ide
|———————Node:= Text: =
|———————Node:identifier Text: BASE
|——————Node:; Text: ;
|———Node:expression_statement Text: idw = ctucan_hw_id_to_hwid(cf->can_id);
|————Node:assignment_expression Text: idw = ctucan_hw_id_to_hwid(cf->can_id)
|—————Node:identifier Text: idw
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_hw_id_to_hwid(cf->can_id)
|——————Node:identifier Text: ctucan_hw_id_to_hwid
|——————Node:argument_list Text: (cf->can_id)
|———————Node:( Text: (
|———————Node:field_expression Text: cf->can_id
|————————Node:identifier Text: cf
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_id
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!ctucan_hw_len_to_dlc(cf->len, &dlc))
		return false;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!ctucan_hw_len_to_dlc(cf->len, &dlc))
|—————Node:( Text: (
|—————Node:unary_expression Text: !ctucan_hw_len_to_dlc(cf->len, &dlc)
|——————Node:! Text: !
|——————Node:call_expression Text: ctucan_hw_len_to_dlc(cf->len, &dlc)
|———————Node:identifier Text: ctucan_hw_len_to_dlc
|———————Node:argument_list Text: (cf->len, &dlc)
|————————Node:( Text: (
|————————Node:field_expression Text: cf->len
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: len
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &dlc
|—————————Node:& Text: &
|—————————Node:identifier Text: dlc
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:return_statement Text: return false;
|—————Node:return Text: return
|—————Node:false Text: false
|—————Node:; Text: ;
|———Node:expression_statement Text: ffw.s.dlc = dlc;
|————Node:assignment_expression Text: ffw.s.dlc = dlc
|—————Node:field_expression Text: ffw.s.dlc
|——————Node:field_expression Text: ffw.s
|———————Node:identifier Text: ffw
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: dlc
|—————Node:= Text: =
|—————Node:identifier Text: dlc
|————Node:; Text: ;
|———Node:if_statement Text: if (isfdf) {
		ffw.s.fdf = FD_CAN;
		if (cf->flags & CANFD_BRS)
			ffw.s.brs = BR_SHIFT;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (isfdf)
|—————Node:( Text: (
|—————Node:identifier Text: isfdf
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ffw.s.fdf = FD_CAN;
		if (cf->flags & CANFD_BRS)
			ffw.s.brs = BR_SHIFT;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ffw.s.fdf = FD_CAN;
|——————Node:assignment_expression Text: ffw.s.fdf = FD_CAN
|———————Node:field_expression Text: ffw.s.fdf
|————————Node:field_expression Text: ffw.s
|—————————Node:identifier Text: ffw
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: fdf
|———————Node:= Text: =
|———————Node:identifier Text: FD_CAN
|——————Node:; Text: ;
|—————Node:if_statement Text: if (cf->flags & CANFD_BRS)
			ffw.s.brs = BR_SHIFT;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (cf->flags & CANFD_BRS)
|———————Node:( Text: (
|———————Node:binary_expression Text: cf->flags & CANFD_BRS
|————————Node:field_expression Text: cf->flags
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: CANFD_BRS
|———————Node:) Text: )
|——————Node:expression_statement Text: ffw.s.brs = BR_SHIFT;
|———————Node:assignment_expression Text: ffw.s.brs = BR_SHIFT
|————————Node:field_expression Text: ffw.s.brs
|—————————Node:field_expression Text: ffw.s
|——————————Node:identifier Text: ffw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: brs
|————————Node:= Text: =
|————————Node:identifier Text: BR_SHIFT
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_FRAME_FORM_W, ffw.u32);
|————Node:call_expression Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_FRAME_FORM_W, ffw.u32)
|—————Node:identifier Text: ctucan_hw_write_txt_buf
|—————Node:argument_list Text: (priv, buf_base,
				 CTU_CAN_FD_FRAME_FORM_W, ffw.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: buf_base
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_FRAME_FORM_W
|——————Node:, Text: ,
|——————Node:field_expression Text: ffw.u32
|———————Node:identifier Text: ffw
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_IDENTIFIER_W, idw.u32);
|————Node:call_expression Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_IDENTIFIER_W, idw.u32)
|—————Node:identifier Text: ctucan_hw_write_txt_buf
|—————Node:argument_list Text: (priv, buf_base,
				 CTU_CAN_FD_IDENTIFIER_W, idw.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: buf_base
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_IDENTIFIER_W
|——————Node:, Text: ,
|——————Node:field_expression Text: idw.u32
|———————Node:identifier Text: idw
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_L_W, (u32)(ts));
|————Node:call_expression Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_L_W, (u32)(ts))
|—————Node:identifier Text: ctucan_hw_write_txt_buf
|—————Node:argument_list Text: (priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_L_W, (u32)(ts))
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: buf_base
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_L_W
|——————Node:, Text: ,
|——————Node:call_expression Text: (u32)(ts)
|———————Node:parenthesized_expression Text: (u32)
|————————Node:( Text: (
|————————Node:identifier Text: u32
|————————Node:) Text: )
|———————Node:argument_list Text: (ts)
|————————Node:( Text: (
|————————Node:identifier Text: ts
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_U_W, (u32)(ts >> 32));
|————Node:call_expression Text: ctucan_hw_write_txt_buf(priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_U_W, (u32)(ts >> 32))
|—————Node:identifier Text: ctucan_hw_write_txt_buf
|—————Node:argument_list Text: (priv, buf_base,
				 CTU_CAN_FD_TIMESTAMP_U_W, (u32)(ts >> 32))
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: buf_base
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_U_W
|——————Node:, Text: ,
|——————Node:call_expression Text: (u32)(ts >> 32)
|———————Node:parenthesized_expression Text: (u32)
|————————Node:( Text: (
|————————Node:identifier Text: u32
|————————Node:) Text: )
|———————Node:argument_list Text: (ts >> 32)
|————————Node:( Text: (
|————————Node:binary_expression Text: ts >> 32
|—————————Node:identifier Text: ts
|—————————Node:>> Text: >>
|—————————Node:number_literal Text: 32
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!(cf->can_id & CAN_RTR_FLAG)) {
		for (i = 0; i < cf->len; i += 4) {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!(cf->can_id & CAN_RTR_FLAG))
|—————Node:( Text: (
|—————Node:unary_expression Text: !(cf->can_id & CAN_RTR_FLAG)
|——————Node:! Text: !
|——————Node:parenthesized_expression Text: (cf->can_id & CAN_RTR_FLAG)
|———————Node:( Text: (
|———————Node:binary_expression Text: cf->can_id & CAN_RTR_FLAG
|————————Node:field_expression Text: cf->can_id
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: can_id
|————————Node:& Text: &
|————————Node:identifier Text: CAN_RTR_FLAG
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		for (i = 0; i < cf->len; i += 4) {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
	}
|—————Node:{ Text: {
|—————Node:for_statement Text: for (i = 0; i < cf->len; i += 4) {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: i < cf->len
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:field_expression Text: cf->len
|————————Node:identifier Text: cf
|————————Node:-> Text: ->
|————————Node:field_identifier Text: len
|——————Node:; Text: ;
|——————Node:assignment_expression Text: i += 4
|———————Node:identifier Text: i
|———————Node:+= Text: +=
|———————Node:number_literal Text: 4
|——————Node:) Text: )
|——————Node:compound_statement Text: {
			u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));

			ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
		}
|———————Node:{ Text: {
|———————Node:declaration Text: u32 data = le32_to_cpu(*(__le32 *)(cf->data + i));
|————————Node:type_identifier Text: u32
|————————Node:init_declarator Text: data = le32_to_cpu(*(__le32 *)(cf->data + i))
|—————————Node:identifier Text: data
|—————————Node:= Text: =
|—————————Node:call_expression Text: le32_to_cpu(*(__le32 *)(cf->data + i))
|——————————Node:identifier Text: le32_to_cpu
|——————————Node:argument_list Text: (*(__le32 *)(cf->data + i))
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: *(__le32 *)(cf->data + i)
|————————————Node:* Text: *
|————————————Node:cast_expression Text: (__le32 *)(cf->data + i)
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: __le32 *
|——————————————Node:type_identifier Text: __le32
|——————————————Node:abstract_pointer_declarator Text: *
|———————————————Node:* Text: *
|—————————————Node:) Text: )
|—————————————Node:parenthesized_expression Text: (cf->data + i)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: cf->data + i
|———————————————Node:field_expression Text: cf->data
|————————————————Node:identifier Text: cf
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: data
|———————————————Node:+ Text: +
|———————————————Node:identifier Text: i
|——————————————Node:) Text: )
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data);
|————————Node:call_expression Text: ctucan_hw_write_txt_buf(priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data)
|—————————Node:identifier Text: ctucan_hw_write_txt_buf
|—————————Node:argument_list Text: (priv, buf_base,
					CTU_CAN_FD_DATA_1_4_W + i, data)
|——————————Node:( Text: (
|——————————Node:identifier Text: priv
|——————————Node:, Text: ,
|——————————Node:identifier Text: buf_base
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: CTU_CAN_FD_DATA_1_4_W + i
|———————————Node:identifier Text: CTU_CAN_FD_DATA_1_4_W
|———————————Node:+ Text: +
|———————————Node:identifier Text: i
|——————————Node:, Text: ,
|——————————Node:identifier Text: data
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: u64 ctucan_hw_read_timestamp(struct ctucan_hw_priv *priv)
{
	union ctu_can_fd_timestamp_low ts_low;
	union ctu_can_fd_timestamp_high ts_high;
	union ctu_can_fd_timestamp_high ts_high_2;

	ts_high.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);
	ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);
	ts_high_2.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);

	if (ts_high.u32 != ts_high_2.u32)
		ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);

	return (((u64)ts_high_2.u32) << 32) | ((u64)ts_low.u32);
}
|——Node:type_identifier Text: u64
|——Node:function_declarator Text: ctucan_hw_read_timestamp(struct ctucan_hw_priv *priv)
|———Node:identifier Text: ctucan_hw_read_timestamp
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_timestamp_low ts_low;
	union ctu_can_fd_timestamp_high ts_high;
	union ctu_can_fd_timestamp_high ts_high_2;

	ts_high.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);
	ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);
	ts_high_2.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);

	if (ts_high.u32 != ts_high_2.u32)
		ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);

	return (((u64)ts_high_2.u32) << 32) | ((u64)ts_low.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_timestamp_low ts_low;
|————Node:union_specifier Text: union ctu_can_fd_timestamp_low
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_timestamp_low
|————Node:identifier Text: ts_low
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_timestamp_high ts_high;
|————Node:union_specifier Text: union ctu_can_fd_timestamp_high
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_timestamp_high
|————Node:identifier Text: ts_high
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_timestamp_high ts_high_2;
|————Node:union_specifier Text: union ctu_can_fd_timestamp_high
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_timestamp_high
|————Node:identifier Text: ts_high_2
|————Node:; Text: ;
|———Node:expression_statement Text: ts_high.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);
|————Node:assignment_expression Text: ts_high.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|—————Node:field_expression Text: ts_high.u32
|——————Node:identifier Text: ts_high
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_HIGH
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);
|————Node:assignment_expression Text: ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW)
|—————Node:field_expression Text: ts_low.u32
|——————Node:identifier Text: ts_low
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_TIMESTAMP_LOW)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_LOW
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ts_high_2.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH);
|————Node:assignment_expression Text: ts_high_2.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|—————Node:field_expression Text: ts_high_2.u32
|——————Node:identifier Text: ts_high_2
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|——————Node:field_expression Text: priv->read_reg
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (priv, CTU_CAN_FD_TIMESTAMP_HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: priv
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_HIGH
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ts_high.u32 != ts_high_2.u32)
		ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ts_high.u32 != ts_high_2.u32)
|—————Node:( Text: (
|—————Node:binary_expression Text: ts_high.u32 != ts_high_2.u32
|——————Node:field_expression Text: ts_high.u32
|———————Node:identifier Text: ts_high
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:!= Text: !=
|——————Node:field_expression Text: ts_high_2.u32
|———————Node:identifier Text: ts_high_2
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|—————Node:) Text: )
|————Node:expression_statement Text: ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW);
|—————Node:assignment_expression Text: ts_low.u32 = priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW)
|——————Node:field_expression Text: ts_low.u32
|———————Node:identifier Text: ts_low
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:= Text: =
|——————Node:call_expression Text: priv->read_reg(priv, CTU_CAN_FD_TIMESTAMP_LOW)
|———————Node:field_expression Text: priv->read_reg
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: read_reg
|———————Node:argument_list Text: (priv, CTU_CAN_FD_TIMESTAMP_LOW)
|————————Node:( Text: (
|————————Node:identifier Text: priv
|————————Node:, Text: ,
|————————Node:identifier Text: CTU_CAN_FD_TIMESTAMP_LOW
|————————Node:) Text: )
|—————Node:; Text: ;
|———Node:return_statement Text: return (((u64)ts_high_2.u32) << 32) | ((u64)ts_low.u32);
|————Node:return Text: return
|————Node:binary_expression Text: (((u64)ts_high_2.u32) << 32) | ((u64)ts_low.u32)
|—————Node:parenthesized_expression Text: (((u64)ts_high_2.u32) << 32)
|——————Node:( Text: (
|——————Node:binary_expression Text: ((u64)ts_high_2.u32) << 32
|———————Node:parenthesized_expression Text: ((u64)ts_high_2.u32)
|————————Node:( Text: (
|————————Node:cast_expression Text: (u64)ts_high_2.u32
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: u64
|——————————Node:type_identifier Text: u64
|—————————Node:) Text: )
|—————————Node:field_expression Text: ts_high_2.u32
|——————————Node:identifier Text: ts_high_2
|——————————Node:. Text: .
|——————————Node:field_identifier Text: u32
|————————Node:) Text: )
|———————Node:<< Text: <<
|———————Node:number_literal Text: 32
|——————Node:) Text: )
|—————Node:| Text: |
|—————Node:parenthesized_expression Text: ((u64)ts_low.u32)
|——————Node:( Text: (
|——————Node:cast_expression Text: (u64)ts_low.u32
|———————Node:( Text: (
|———————Node:type_descriptor Text: u64
|————————Node:type_identifier Text: u64
|———————Node:) Text: )
|———————Node:field_expression Text: ts_low.u32
|————————Node:identifier Text: ts_low
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void ctucan_hw_configure_ssp(struct ctucan_hw_priv *priv, bool enable_ssp,
			     bool use_trv_delay, int ssp_offset)
{
	union ctu_can_fd_trv_delay_ssp_cfg ssp_cfg;

	ssp_cfg.u32 = 0;
	if (enable_ssp) {
		if (use_trv_delay)
			ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
		else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
	} else {
		ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
	}

	ssp_cfg.s.ssp_offset = (uint32_t)ssp_offset;
	priv->write_reg(priv, CTU_CAN_FD_TRV_DELAY, ssp_cfg.u32);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_hw_configure_ssp(struct ctucan_hw_priv *priv, bool enable_ssp,
			     bool use_trv_delay, int ssp_offset)
|———Node:identifier Text: ctucan_hw_configure_ssp
|———Node:parameter_list Text: (struct ctucan_hw_priv *priv, bool enable_ssp,
			     bool use_trv_delay, int ssp_offset)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct ctucan_hw_priv *priv
|—————Node:struct_specifier Text: struct ctucan_hw_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: ctucan_hw_priv
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool enable_ssp
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: enable_ssp
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool use_trv_delay
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: use_trv_delay
|————Node:, Text: ,
|————Node:parameter_declaration Text: int ssp_offset
|—————Node:primitive_type Text: int
|—————Node:identifier Text: ssp_offset
|————Node:) Text: )
|——Node:compound_statement Text: {
	union ctu_can_fd_trv_delay_ssp_cfg ssp_cfg;

	ssp_cfg.u32 = 0;
	if (enable_ssp) {
		if (use_trv_delay)
			ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
		else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
	} else {
		ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
	}

	ssp_cfg.s.ssp_offset = (uint32_t)ssp_offset;
	priv->write_reg(priv, CTU_CAN_FD_TRV_DELAY, ssp_cfg.u32);
}
|———Node:{ Text: {
|———Node:declaration Text: union ctu_can_fd_trv_delay_ssp_cfg ssp_cfg;
|————Node:union_specifier Text: union ctu_can_fd_trv_delay_ssp_cfg
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_trv_delay_ssp_cfg
|————Node:identifier Text: ssp_cfg
|————Node:; Text: ;
|———Node:expression_statement Text: ssp_cfg.u32 = 0;
|————Node:assignment_expression Text: ssp_cfg.u32 = 0
|—————Node:field_expression Text: ssp_cfg.u32
|——————Node:identifier Text: ssp_cfg
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (enable_ssp) {
		if (use_trv_delay)
			ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
		else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
	} else {
		ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (enable_ssp)
|—————Node:( Text: (
|—————Node:identifier Text: enable_ssp
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (use_trv_delay)
			ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
		else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (use_trv_delay)
			ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
		else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (use_trv_delay)
|———————Node:( Text: (
|———————Node:identifier Text: use_trv_delay
|———————Node:) Text: )
|——————Node:expression_statement Text: ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET;
|———————Node:assignment_expression Text: ssp_cfg.s.ssp_src = SSP_SRC_MEAS_N_OFFSET
|————————Node:field_expression Text: ssp_cfg.s.ssp_src
|—————————Node:field_expression Text: ssp_cfg.s
|——————————Node:identifier Text: ssp_cfg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: ssp_src
|————————Node:= Text: =
|————————Node:identifier Text: SSP_SRC_MEAS_N_OFFSET
|———————Node:; Text: ;
|——————Node:else_clause Text: else
			ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
|———————Node:else Text: else
|———————Node:expression_statement Text: ssp_cfg.s.ssp_src = SSP_SRC_OFFSET;
|————————Node:assignment_expression Text: ssp_cfg.s.ssp_src = SSP_SRC_OFFSET
|—————————Node:field_expression Text: ssp_cfg.s.ssp_src
|——————————Node:field_expression Text: ssp_cfg.s
|———————————Node:identifier Text: ssp_cfg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: s
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ssp_src
|—————————Node:= Text: =
|—————————Node:identifier Text: SSP_SRC_OFFSET
|————————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP;
|———————Node:assignment_expression Text: ssp_cfg.s.ssp_src = SSP_SRC_NO_SSP
|————————Node:field_expression Text: ssp_cfg.s.ssp_src
|—————————Node:field_expression Text: ssp_cfg.s
|——————————Node:identifier Text: ssp_cfg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: ssp_src
|————————Node:= Text: =
|————————Node:identifier Text: SSP_SRC_NO_SSP
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: ssp_cfg.s.ssp_offset = (uint32_t)ssp_offset;
|————Node:assignment_expression Text: ssp_cfg.s.ssp_offset = (uint32_t)ssp_offset
|—————Node:field_expression Text: ssp_cfg.s.ssp_offset
|——————Node:field_expression Text: ssp_cfg.s
|———————Node:identifier Text: ssp_cfg
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ssp_offset
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t)ssp_offset
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:identifier Text: ssp_offset
|————Node:; Text: ;
|———Node:expression_statement Text: priv->write_reg(priv, CTU_CAN_FD_TRV_DELAY, ssp_cfg.u32);
|————Node:call_expression Text: priv->write_reg(priv, CTU_CAN_FD_TRV_DELAY, ssp_cfg.u32)
|—————Node:field_expression Text: priv->write_reg
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (priv, CTU_CAN_FD_TRV_DELAY, ssp_cfg.u32)
|——————Node:( Text: (
|——————Node:identifier Text: priv
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TRV_DELAY
|——————Node:, Text: ,
|——————Node:field_expression Text: ssp_cfg.u32
|———————Node:identifier Text: ssp_cfg
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // TODO: AL_CAPTURE and ERROR_CAPTURE
