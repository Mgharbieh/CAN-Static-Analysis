can_bus-driver\ctu_can_fd.c

|Node:translation_unit
|—Node:comment Text: /*******************************************************************************
 * 
 * CTU CAN FD IP Core
 * Copyright (C) 2015-2018 Ondrej Ille <ondrej.ille@gmail.com>
 * 
 * Project advisors and co-authors: 
 * 	Jiri Novak <jnovak@fel.cvut.cz>
 * 	Pavel Pisa <pisa@cmp.felk.cvut.cz>
 * 	Martin Jerabek <jerabma7@fel.cvut.cz>
 * 
 * Department of Measurement         (http://meas.fel.cvut.cz/)
 * Faculty of Electrical Engineering (http://www.fel.cvut.cz)
 * Czech Technical University        (http://www.cvut.cz/)
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
*******************************************************************************/
|—Node:preproc_include Text: #include <linux/clk.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/clk.h>
|—Node:preproc_include Text: #include <linux/errno.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/errno.h>
|—Node:preproc_include Text: #include <linux/init.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/init.h>
|—Node:preproc_include Text: #include <linux/interrupt.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/interrupt.h>
|—Node:preproc_include Text: #include <linux/io.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/io.h>
|—Node:preproc_include Text: #include <linux/kernel.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/kernel.h>
|—Node:preproc_include Text: #include <linux/module.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/module.h>
|—Node:preproc_include Text: #include <linux/netdevice.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/netdevice.h>
|—Node:preproc_include Text: #include <linux/of.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/of.h>
|—Node:preproc_include Text: #include <linux/platform_device.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/platform_device.h>
|—Node:preproc_include Text: #include <linux/skbuff.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/skbuff.h>
|—Node:preproc_include Text: #include <linux/string.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/string.h>
|—Node:preproc_include Text: #include <linux/types.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/types.h>
|—Node:preproc_include Text: #include <linux/can/dev.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/can/dev.h>
|—Node:preproc_include Text: #include <linux/can/error.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/can/error.h>
|—Node:preproc_include Text: #include <linux/can/led.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/can/led.h>
|—Node:preproc_include Text: #include <linux/pm_runtime.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/pm_runtime.h>
|—Node:preproc_include Text: #include "ctu_can_fd_hw.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "ctu_can_fd_hw.h"
|———Node:" Text: "
|———Node:string_content Text: ctu_can_fd_hw.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "ctu_can_fd_regs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "ctu_can_fd_regs.h"
|———Node:" Text: "
|———Node:string_content Text: ctu_can_fd_regs.h
|———Node:" Text: "
|—Node:preproc_def Text: #define DRIVER_NAME	"ctucanfd"

|——Node:#define Text: #define
|——Node:identifier Text: DRIVER_NAME
|——Node:preproc_arg Text: "ctucanfd"
|—Node:comment Text: /*
 * TX buffer rotation:
 * - when a buffer transitions to empty state, rotate order and priorities
 * - if more buffers seem to transition at the same time, rotate by the number of buffers
 * - it may be assumed that buffers transition to empty state in FIFO order (because we manage priorities that way)
 *
 * - at frame filling, do not rotate anything, just increment buffer modulo counter
 */
|—Node:struct_specifier Text: struct ctucan_priv {
	struct can_priv can; // must be first member!
	struct ctucanfd_priv p;

	unsigned int txb_head;
	unsigned int txb_tail;
	u32 txb_prio;
	unsigned int txb_mask;

	struct napi_struct napi;
	struct device *dev;
	struct clk *can_clk;
}
|——Node:struct Text: struct
|——Node:type_identifier Text: ctucan_priv
|——Node:field_declaration_list Text: {
	struct can_priv can; // must be first member!
	struct ctucanfd_priv p;

	unsigned int txb_head;
	unsigned int txb_tail;
	u32 txb_prio;
	unsigned int txb_mask;

	struct napi_struct napi;
	struct device *dev;
	struct clk *can_clk;
}
|———Node:{ Text: {
|———Node:field_declaration Text: struct can_priv can;
|————Node:struct_specifier Text: struct can_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_priv
|————Node:field_identifier Text: can
|————Node:; Text: ;
|———Node:comment Text: // must be first member!
|———Node:field_declaration Text: struct ctucanfd_priv p;
|————Node:struct_specifier Text: struct ctucanfd_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucanfd_priv
|————Node:field_identifier Text: p
|————Node:; Text: ;
|———Node:field_declaration Text: unsigned int txb_head;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:field_identifier Text: txb_head
|————Node:; Text: ;
|———Node:field_declaration Text: unsigned int txb_tail;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:field_identifier Text: txb_tail
|————Node:; Text: ;
|———Node:field_declaration Text: u32 txb_prio;
|————Node:type_identifier Text: u32
|————Node:field_identifier Text: txb_prio
|————Node:; Text: ;
|———Node:field_declaration Text: unsigned int txb_mask;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:field_identifier Text: txb_mask
|————Node:; Text: ;
|———Node:field_declaration Text: struct napi_struct napi;
|————Node:struct_specifier Text: struct napi_struct
|—————Node:struct Text: struct
|—————Node:type_identifier Text: napi_struct
|————Node:field_identifier Text: napi
|————Node:; Text: ;
|———Node:field_declaration Text: struct device *dev;
|————Node:struct_specifier Text: struct device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: device
|————Node:pointer_declarator Text: *dev
|—————Node:* Text: *
|—————Node:field_identifier Text: dev
|————Node:; Text: ;
|———Node:field_declaration Text: struct clk *can_clk;
|————Node:struct_specifier Text: struct clk
|—————Node:struct Text: struct
|—————Node:type_identifier Text: clk
|————Node:pointer_declarator Text: *can_clk
|—————Node:* Text: *
|—————Node:field_identifier Text: can_clk
|————Node:; Text: ;
|———Node:} Text: }
|—Node:; Text: ;
|—Node:function_definition Text: static int ctucan_reset(struct net_device *ndev)
{
	int i;
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_reset");

	ctu_can_fd_reset(&priv->p);
	for (i=0; i<100; ++i) {
		if (ctu_can_fd_check_access(&priv->p))
			return 0;
		udelay(100);
	}

	netdev_warn(ndev, "device did not leave reset\n");
	return -ETIMEDOUT;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_reset(struct net_device *ndev)
|———Node:identifier Text: ctucan_reset
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	int i;
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_reset");

	ctu_can_fd_reset(&priv->p);
	for (i=0; i<100; ++i) {
		if (ctu_can_fd_check_access(&priv->p))
			return 0;
		udelay(100);
	}

	netdev_warn(ndev, "device did not leave reset\n");
	return -ETIMEDOUT;
}
|———Node:{ Text: {
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_reset");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_reset")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_reset")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_reset"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_reset
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_reset(&priv->p);
|————Node:call_expression Text: ctu_can_fd_reset(&priv->p)
|—————Node:identifier Text: ctu_can_fd_reset
|—————Node:argument_list Text: (&priv->p)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<100; ++i) {
		if (ctu_can_fd_check_access(&priv->p))
			return 0;
		udelay(100);
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<100
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:number_literal Text: 100
|————Node:; Text: ;
|————Node:update_expression Text: ++i
|—————Node:++ Text: ++
|—————Node:identifier Text: i
|————Node:) Text: )
|————Node:compound_statement Text: {
		if (ctu_can_fd_check_access(&priv->p))
			return 0;
		udelay(100);
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (ctu_can_fd_check_access(&priv->p))
			return 0;
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ctu_can_fd_check_access(&priv->p))
|———————Node:( Text: (
|———————Node:call_expression Text: ctu_can_fd_check_access(&priv->p)
|————————Node:identifier Text: ctu_can_fd_check_access
|————————Node:argument_list Text: (&priv->p)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|—————Node:expression_statement Text: udelay(100);
|——————Node:call_expression Text: udelay(100)
|———————Node:identifier Text: udelay
|———————Node:argument_list Text: (100)
|————————Node:( Text: (
|————————Node:number_literal Text: 100
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: netdev_warn(ndev, "device did not leave reset\n");
|————Node:call_expression Text: netdev_warn(ndev, "device did not leave reset\n")
|—————Node:identifier Text: netdev_warn
|—————Node:argument_list Text: (ndev, "device did not leave reset\n")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "device did not leave reset\n"
|———————Node:" Text: "
|———————Node:string_content Text: device did not leave reset
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return -ETIMEDOUT;
|————Node:return Text: return
|————Node:unary_expression Text: -ETIMEDOUT
|—————Node:- Text: -
|—————Node:identifier Text: ETIMEDOUT
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_set_bittiming - CAN set bit timing routine
 * @ndev:	Pointer to net_device structure
 *
 * This is the driver set bittiming routine.
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_set_bittiming(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct can_bittiming *bt = &priv->can.bittiming;
	union ctu_can_fd_mode_command_status_settings mode;
	netdev_info(ndev, "ctucan_set_bittiming");

	mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);

	if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}

	ctu_can_fd_set_nom_bittiming(&priv->p, bt);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_set_bittiming(struct net_device *ndev)
|———Node:identifier Text: ctucan_set_bittiming
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct can_bittiming *bt = &priv->can.bittiming;
	union ctu_can_fd_mode_command_status_settings mode;
	netdev_info(ndev, "ctucan_set_bittiming");

	mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);

	if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}

	ctu_can_fd_set_nom_bittiming(&priv->p, bt);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct can_bittiming *bt = &priv->can.bittiming;
|————Node:struct_specifier Text: struct can_bittiming
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_bittiming
|————Node:init_declarator Text: *bt = &priv->can.bittiming
|—————Node:pointer_declarator Text: *bt
|——————Node:* Text: *
|——————Node:identifier Text: bt
|—————Node:= Text: =
|—————Node:pointer_expression Text: &priv->can.bittiming
|——————Node:& Text: &
|——————Node:field_expression Text: priv->can.bittiming
|———————Node:field_expression Text: priv->can
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can
|———————Node:. Text: .
|———————Node:field_identifier Text: bittiming
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_mode_command_status_settings mode;
|————Node:union_specifier Text: union ctu_can_fd_mode_command_status_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_command_status_settings
|————Node:identifier Text: mode
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_set_bittiming");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_set_bittiming")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_set_bittiming")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_set_bittiming"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_set_bittiming
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);
|————Node:assignment_expression Text: mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE)
|—————Node:field_expression Text: mode.u32
|——————Node:identifier Text: mode
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE)
|——————Node:field_expression Text: priv->p.read_reg
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|———————Node:. Text: .
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (&priv->p, CTU_CAN_FD_MODE)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_MODE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode.s.ena)
|—————Node:( Text: (
|—————Node:field_expression Text: mode.s.ena
|——————Node:field_expression Text: mode.s
|———————Node:identifier Text: mode
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ena
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
|——————Node:call_expression Text: netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n")
|———————Node:identifier Text: netdev_alert
|———————Node:argument_list Text: (ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "BUG! Cannot set bittiming - CAN is enabled\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: BUG! Cannot set bittiming - CAN is enabled
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -EPERM;
|——————Node:return Text: return
|——————Node:unary_expression Text: -EPERM
|———————Node:- Text: -
|———————Node:identifier Text: EPERM
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctu_can_fd_set_nom_bittiming(&priv->p, bt);
|————Node:call_expression Text: ctu_can_fd_set_nom_bittiming(&priv->p, bt)
|—————Node:identifier Text: ctu_can_fd_set_nom_bittiming
|—————Node:argument_list Text: (&priv->p, bt)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: bt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_set_data_bittiming - CAN set data bit timing routine
 * @ndev:	Pointer to net_device structure
 *
 * This is the driver set data bittiming routine.
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_set_data_bittiming(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct can_bittiming *dbt = &priv->can.data_bittiming;
	union ctu_can_fd_mode_command_status_settings mode;
	netdev_info(ndev, "ctucan_set_data_bittiming");

	mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);

	if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}

	ctu_can_fd_set_data_bittiming(&priv->p, dbt);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_set_data_bittiming(struct net_device *ndev)
|———Node:identifier Text: ctucan_set_data_bittiming
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct can_bittiming *dbt = &priv->can.data_bittiming;
	union ctu_can_fd_mode_command_status_settings mode;
	netdev_info(ndev, "ctucan_set_data_bittiming");

	mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);

	if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}

	ctu_can_fd_set_data_bittiming(&priv->p, dbt);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct can_bittiming *dbt = &priv->can.data_bittiming;
|————Node:struct_specifier Text: struct can_bittiming
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_bittiming
|————Node:init_declarator Text: *dbt = &priv->can.data_bittiming
|—————Node:pointer_declarator Text: *dbt
|——————Node:* Text: *
|——————Node:identifier Text: dbt
|—————Node:= Text: =
|—————Node:pointer_expression Text: &priv->can.data_bittiming
|——————Node:& Text: &
|——————Node:field_expression Text: priv->can.data_bittiming
|———————Node:field_expression Text: priv->can
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can
|———————Node:. Text: .
|———————Node:field_identifier Text: data_bittiming
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_mode_command_status_settings mode;
|————Node:union_specifier Text: union ctu_can_fd_mode_command_status_settings
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_mode_command_status_settings
|————Node:identifier Text: mode
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_set_data_bittiming");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_set_data_bittiming")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_set_data_bittiming")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_set_data_bittiming"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_set_data_bittiming
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE);
|————Node:assignment_expression Text: mode.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE)
|—————Node:field_expression Text: mode.u32
|——————Node:identifier Text: mode
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_MODE)
|——————Node:field_expression Text: priv->p.read_reg
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|———————Node:. Text: .
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (&priv->p, CTU_CAN_FD_MODE)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_MODE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (mode.s.ena) {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (mode.s.ena)
|—————Node:( Text: (
|—————Node:field_expression Text: mode.s.ena
|——————Node:field_expression Text: mode.s
|———————Node:identifier Text: mode
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: ena
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
		return -EPERM;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n");
|——————Node:call_expression Text: netdev_alert(ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n")
|———————Node:identifier Text: netdev_alert
|———————Node:argument_list Text: (ndev,
				 "BUG! Cannot set bittiming - CAN is enabled\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "BUG! Cannot set bittiming - CAN is enabled\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: BUG! Cannot set bittiming - CAN is enabled
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -EPERM;
|——————Node:return Text: return
|——————Node:unary_expression Text: -EPERM
|———————Node:- Text: -
|———————Node:identifier Text: EPERM
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctu_can_fd_set_data_bittiming(&priv->p, dbt);
|————Node:call_expression Text: ctu_can_fd_set_data_bittiming(&priv->p, dbt)
|—————Node:identifier Text: ctu_can_fd_set_data_bittiming
|—————Node:argument_list Text: (&priv->p, dbt)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: dbt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_chip_start - This the drivers start routine
 * @ndev:	Pointer to net_device structure
 *
 * This is the drivers start routine.
 *
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_chip_start(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat int_ena, int_msk;
	int err;
	struct can_ctrlmode mode;
	netdev_info(ndev, "ctucan_chip_start");

	err = ctucan_reset(ndev);
	if (err < 0)
		return err;

	priv->txb_prio = 0x01234567;
	priv->txb_head = 0;
	priv->txb_tail = 0;
	priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, priv->txb_prio);


	err = ctucan_set_bittiming(ndev);
	if (err < 0)
		return err;

	err = ctucan_set_data_bittiming(ndev);
	if (err < 0)
		return err;


	/* Enable interrupts */
	int_ena.u32 = 0;
	int_ena.s.rbnei = 1;
	int_ena.s.txbhci = 1;
	/*
	int_ena.s.ei = 1;
	int_ena.s.epi = 1;
	int_ena.s.doi = 1;
	 */
	int_msk.u32 = 0xFFFFFFFF;

	mode.flags = priv->can.ctrlmode;
	mode.mask = 0xFFFFFFFF;
	ctu_can_fd_set_mode_reg(&priv->p, &mode);

	/* One shot mode supported indirectly via Retransmit limit */
	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
		ctu_can_fd_set_ret_limit(&priv->p, true, 0);

	/* Bus error reporting -> Allow Error interrupt */
	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {
		int_ena.s.ali = 1;
		int_ena.s.bei = 1;
	}

	ctu_can_fd_int_ena(&priv->p, int_ena, int_msk);
	ctu_can_fd_int_mask(&priv->p, int_ena, int_msk);

	priv->can.state = CAN_STATE_ERROR_ACTIVE;

	/* Enable the controller */
	ctu_can_fd_enable(&priv->p, true);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_chip_start(struct net_device *ndev)
|———Node:identifier Text: ctucan_chip_start
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat int_ena, int_msk;
	int err;
	struct can_ctrlmode mode;
	netdev_info(ndev, "ctucan_chip_start");

	err = ctucan_reset(ndev);
	if (err < 0)
		return err;

	priv->txb_prio = 0x01234567;
	priv->txb_head = 0;
	priv->txb_tail = 0;
	priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, priv->txb_prio);


	err = ctucan_set_bittiming(ndev);
	if (err < 0)
		return err;

	err = ctucan_set_data_bittiming(ndev);
	if (err < 0)
		return err;


	/* Enable interrupts */
	int_ena.u32 = 0;
	int_ena.s.rbnei = 1;
	int_ena.s.txbhci = 1;
	/*
	int_ena.s.ei = 1;
	int_ena.s.epi = 1;
	int_ena.s.doi = 1;
	 */
	int_msk.u32 = 0xFFFFFFFF;

	mode.flags = priv->can.ctrlmode;
	mode.mask = 0xFFFFFFFF;
	ctu_can_fd_set_mode_reg(&priv->p, &mode);

	/* One shot mode supported indirectly via Retransmit limit */
	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
		ctu_can_fd_set_ret_limit(&priv->p, true, 0);

	/* Bus error reporting -> Allow Error interrupt */
	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {
		int_ena.s.ali = 1;
		int_ena.s.bei = 1;
	}

	ctu_can_fd_int_ena(&priv->p, int_ena, int_msk);
	ctu_can_fd_int_mask(&priv->p, int_ena, int_msk);

	priv->can.state = CAN_STATE_ERROR_ACTIVE;

	/* Enable the controller */
	ctu_can_fd_enable(&priv->p, true);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_int_stat int_ena, int_msk;
|————Node:union_specifier Text: union ctu_can_fd_int_stat
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_int_stat
|————Node:identifier Text: int_ena
|————Node:, Text: ,
|————Node:identifier Text: int_msk
|————Node:; Text: ;
|———Node:declaration Text: int err;
|————Node:primitive_type Text: int
|————Node:identifier Text: err
|————Node:; Text: ;
|———Node:declaration Text: struct can_ctrlmode mode;
|————Node:struct_specifier Text: struct can_ctrlmode
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_ctrlmode
|————Node:identifier Text: mode
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_chip_start");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_chip_start")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_chip_start")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_chip_start"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_chip_start
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: err = ctucan_reset(ndev);
|————Node:assignment_expression Text: err = ctucan_reset(ndev)
|—————Node:identifier Text: err
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_reset(ndev)
|——————Node:identifier Text: ctucan_reset
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (err < 0)
		return err;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (err < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: err < 0
|——————Node:identifier Text: err
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:return_statement Text: return err;
|—————Node:return Text: return
|—————Node:identifier Text: err
|—————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_prio = 0x01234567;
|————Node:assignment_expression Text: priv->txb_prio = 0x01234567
|—————Node:field_expression Text: priv->txb_prio
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_prio
|—————Node:= Text: =
|—————Node:number_literal Text: 0x01234567
|————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_head = 0;
|————Node:assignment_expression Text: priv->txb_head = 0
|—————Node:field_expression Text: priv->txb_head
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_head
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_tail = 0;
|————Node:assignment_expression Text: priv->txb_tail = 0
|—————Node:field_expression Text: priv->txb_tail
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_tail
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, priv->txb_prio);
|————Node:call_expression Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, priv->txb_prio)
|—————Node:field_expression Text: priv->p.write_reg
|——————Node:field_expression Text: priv->p
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: p
|——————Node:. Text: .
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (&priv->p, CTU_CAN_FD_TX_PRIORITY, priv->txb_prio)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TX_PRIORITY
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->txb_prio
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txb_prio
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: err = ctucan_set_bittiming(ndev);
|————Node:assignment_expression Text: err = ctucan_set_bittiming(ndev)
|—————Node:identifier Text: err
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_set_bittiming(ndev)
|——————Node:identifier Text: ctucan_set_bittiming
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (err < 0)
		return err;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (err < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: err < 0
|——————Node:identifier Text: err
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:return_statement Text: return err;
|—————Node:return Text: return
|—————Node:identifier Text: err
|—————Node:; Text: ;
|———Node:expression_statement Text: err = ctucan_set_data_bittiming(ndev);
|————Node:assignment_expression Text: err = ctucan_set_data_bittiming(ndev)
|—————Node:identifier Text: err
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_set_data_bittiming(ndev)
|——————Node:identifier Text: ctucan_set_data_bittiming
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (err < 0)
		return err;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (err < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: err < 0
|——————Node:identifier Text: err
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:return_statement Text: return err;
|—————Node:return Text: return
|—————Node:identifier Text: err
|—————Node:; Text: ;
|———Node:comment Text: /* Enable interrupts */
|———Node:expression_statement Text: int_ena.u32 = 0;
|————Node:assignment_expression Text: int_ena.u32 = 0
|—————Node:field_expression Text: int_ena.u32
|——————Node:identifier Text: int_ena
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: int_ena.s.rbnei = 1;
|————Node:assignment_expression Text: int_ena.s.rbnei = 1
|—————Node:field_expression Text: int_ena.s.rbnei
|——————Node:field_expression Text: int_ena.s
|———————Node:identifier Text: int_ena
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rbnei
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: int_ena.s.txbhci = 1;
|————Node:assignment_expression Text: int_ena.s.txbhci = 1
|—————Node:field_expression Text: int_ena.s.txbhci
|——————Node:field_expression Text: int_ena.s
|———————Node:identifier Text: int_ena
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txbhci
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:comment Text: /*
	int_ena.s.ei = 1;
	int_ena.s.epi = 1;
	int_ena.s.doi = 1;
	 */
|———Node:expression_statement Text: int_msk.u32 = 0xFFFFFFFF;
|————Node:assignment_expression Text: int_msk.u32 = 0xFFFFFFFF
|—————Node:field_expression Text: int_msk.u32
|——————Node:identifier Text: int_msk
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0xFFFFFFFF
|————Node:; Text: ;
|———Node:expression_statement Text: mode.flags = priv->can.ctrlmode;
|————Node:assignment_expression Text: mode.flags = priv->can.ctrlmode
|—————Node:field_expression Text: mode.flags
|——————Node:identifier Text: mode
|——————Node:. Text: .
|——————Node:field_identifier Text: flags
|—————Node:= Text: =
|—————Node:field_expression Text: priv->can.ctrlmode
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: ctrlmode
|————Node:; Text: ;
|———Node:expression_statement Text: mode.mask = 0xFFFFFFFF;
|————Node:assignment_expression Text: mode.mask = 0xFFFFFFFF
|—————Node:field_expression Text: mode.mask
|——————Node:identifier Text: mode
|——————Node:. Text: .
|——————Node:field_identifier Text: mask
|—————Node:= Text: =
|—————Node:number_literal Text: 0xFFFFFFFF
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_set_mode_reg(&priv->p, &mode);
|————Node:call_expression Text: ctu_can_fd_set_mode_reg(&priv->p, &mode)
|—————Node:identifier Text: ctu_can_fd_set_mode_reg
|—————Node:argument_list Text: (&priv->p, &mode)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &mode
|———————Node:& Text: &
|———————Node:identifier Text: mode
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* One shot mode supported indirectly via Retransmit limit */
|———Node:if_statement Text: if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
		ctu_can_fd_set_ret_limit(&priv->p, true, 0);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
|—————Node:( Text: (
|—————Node:binary_expression Text: priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT
|——————Node:field_expression Text: priv->can.ctrlmode
|———————Node:field_expression Text: priv->can
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can
|———————Node:. Text: .
|———————Node:field_identifier Text: ctrlmode
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_ONE_SHOT
|—————Node:) Text: )
|————Node:expression_statement Text: ctu_can_fd_set_ret_limit(&priv->p, true, 0);
|—————Node:call_expression Text: ctu_can_fd_set_ret_limit(&priv->p, true, 0)
|——————Node:identifier Text: ctu_can_fd_set_ret_limit
|——————Node:argument_list Text: (&priv->p, true, 0)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:true Text: true
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:comment Text: /* Bus error reporting -> Allow Error interrupt */
|———Node:if_statement Text: if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {
		int_ena.s.ali = 1;
		int_ena.s.bei = 1;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
|—————Node:( Text: (
|—————Node:binary_expression Text: priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING
|——————Node:field_expression Text: priv->can.ctrlmode
|———————Node:field_expression Text: priv->can
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can
|———————Node:. Text: .
|———————Node:field_identifier Text: ctrlmode
|——————Node:& Text: &
|——————Node:identifier Text: CAN_CTRLMODE_BERR_REPORTING
|—————Node:) Text: )
|————Node:compound_statement Text: {
		int_ena.s.ali = 1;
		int_ena.s.bei = 1;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: int_ena.s.ali = 1;
|——————Node:assignment_expression Text: int_ena.s.ali = 1
|———————Node:field_expression Text: int_ena.s.ali
|————————Node:field_expression Text: int_ena.s
|—————————Node:identifier Text: int_ena
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: ali
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: int_ena.s.bei = 1;
|——————Node:assignment_expression Text: int_ena.s.bei = 1
|———————Node:field_expression Text: int_ena.s.bei
|————————Node:field_expression Text: int_ena.s
|—————————Node:identifier Text: int_ena
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: bei
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctu_can_fd_int_ena(&priv->p, int_ena, int_msk);
|————Node:call_expression Text: ctu_can_fd_int_ena(&priv->p, int_ena, int_msk)
|—————Node:identifier Text: ctu_can_fd_int_ena
|—————Node:argument_list Text: (&priv->p, int_ena, int_msk)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: int_ena
|——————Node:, Text: ,
|——————Node:identifier Text: int_msk
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_int_mask(&priv->p, int_ena, int_msk);
|————Node:call_expression Text: ctu_can_fd_int_mask(&priv->p, int_ena, int_msk)
|—————Node:identifier Text: ctu_can_fd_int_mask
|—————Node:argument_list Text: (&priv->p, int_ena, int_msk)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: int_ena
|——————Node:, Text: ,
|——————Node:identifier Text: int_msk
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.state = CAN_STATE_ERROR_ACTIVE;
|————Node:assignment_expression Text: priv->can.state = CAN_STATE_ERROR_ACTIVE
|—————Node:field_expression Text: priv->can.state
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: state
|—————Node:= Text: =
|—————Node:identifier Text: CAN_STATE_ERROR_ACTIVE
|————Node:; Text: ;
|———Node:comment Text: /* Enable the controller */
|———Node:expression_statement Text: ctu_can_fd_enable(&priv->p, true);
|————Node:call_expression Text: ctu_can_fd_enable(&priv->p, true)
|—————Node:identifier Text: ctu_can_fd_enable
|—————Node:argument_list Text: (&priv->p, true)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:true Text: true
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_do_set_mode - This sets the mode of the driver
 * @ndev:	Pointer to net_device structure
 * @mode:	Tells the mode of the driver
 *
 * This check the drivers state and calls the
 * the corresponding modes to set.
 *
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_do_set_mode(struct net_device *ndev, enum can_mode mode)
{
	int ret;
	netdev_info(ndev, "ctucan_do_set_mode");

	switch (mode) {
	case CAN_MODE_START:
		ret = ctucan_chip_start(ndev);
		if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
		netif_wake_queue(ndev);
		break;
	default:
		ret = -EOPNOTSUPP;
		break;
	}

	return ret;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_do_set_mode(struct net_device *ndev, enum can_mode mode)
|———Node:identifier Text: ctucan_do_set_mode
|———Node:parameter_list Text: (struct net_device *ndev, enum can_mode mode)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:, Text: ,
|————Node:parameter_declaration Text: enum can_mode mode
|—————Node:enum_specifier Text: enum can_mode
|——————Node:enum Text: enum
|——————Node:type_identifier Text: can_mode
|—————Node:identifier Text: mode
|————Node:) Text: )
|——Node:compound_statement Text: {
	int ret;
	netdev_info(ndev, "ctucan_do_set_mode");

	switch (mode) {
	case CAN_MODE_START:
		ret = ctucan_chip_start(ndev);
		if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
		netif_wake_queue(ndev);
		break;
	default:
		ret = -EOPNOTSUPP;
		break;
	}

	return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: int ret;
|————Node:primitive_type Text: int
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_do_set_mode");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_do_set_mode")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_do_set_mode")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_do_set_mode"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_do_set_mode
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:switch_statement Text: switch (mode) {
	case CAN_MODE_START:
		ret = ctucan_chip_start(ndev);
		if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
		netif_wake_queue(ndev);
		break;
	default:
		ret = -EOPNOTSUPP;
		break;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (mode)
|—————Node:( Text: (
|—————Node:identifier Text: mode
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case CAN_MODE_START:
		ret = ctucan_chip_start(ndev);
		if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
		netif_wake_queue(ndev);
		break;
	default:
		ret = -EOPNOTSUPP;
		break;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case CAN_MODE_START:
		ret = ctucan_chip_start(ndev);
		if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
		netif_wake_queue(ndev);
		break;
|——————Node:case Text: case
|——————Node:identifier Text: CAN_MODE_START
|——————Node:: Text: :
|——————Node:expression_statement Text: ret = ctucan_chip_start(ndev);
|———————Node:assignment_expression Text: ret = ctucan_chip_start(ndev)
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:call_expression Text: ctucan_chip_start(ndev)
|—————————Node:identifier Text: ctucan_chip_start
|—————————Node:argument_list Text: (ndev)
|——————————Node:( Text: (
|——————————Node:identifier Text: ndev
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (ret < 0) {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (ret < 0)
|————————Node:( Text: (
|————————Node:binary_expression Text: ret < 0
|—————————Node:identifier Text: ret
|—————————Node:< Text: <
|—————————Node:number_literal Text: 0
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			netdev_err(ndev, "ctucan_chip_start failed!\n");
			return ret;
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: netdev_err(ndev, "ctucan_chip_start failed!\n");
|—————————Node:call_expression Text: netdev_err(ndev, "ctucan_chip_start failed!\n")
|——————————Node:identifier Text: netdev_err
|——————————Node:argument_list Text: (ndev, "ctucan_chip_start failed!\n")
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "ctucan_chip_start failed!\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: ctucan_chip_start failed!
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:return_statement Text: return ret;
|—————————Node:return Text: return
|—————————Node:identifier Text: ret
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: netif_wake_queue(ndev);
|———————Node:call_expression Text: netif_wake_queue(ndev)
|————————Node:identifier Text: netif_wake_queue
|————————Node:argument_list Text: (ndev)
|—————————Node:( Text: (
|—————————Node:identifier Text: ndev
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
		ret = -EOPNOTSUPP;
		break;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: ret = -EOPNOTSUPP;
|———————Node:assignment_expression Text: ret = -EOPNOTSUPP
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:unary_expression Text: -EOPNOTSUPP
|—————————Node:- Text: -
|—————————Node:identifier Text: EOPNOTSUPP
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_start_xmit - Starts the transmission
 * @skb:	sk_buff pointer that contains data to be Txed
 * @ndev:	Pointer to net_device structure
 *
 * This function is invoked from upper layers to initiate transmission. This
 * function uses the next available free txbuf and populates their fields to
 * start the transmission.
 *
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_start_xmit(struct sk_buff *skb, struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct canfd_frame *cf = (struct canfd_frame *)skb->data;
	u32 txb_id;
	bool ok;

	if (can_dropped_invalid_skb(ndev, skb))
		return NETDEV_TX_OK;


	/* Check if the TX buffer is full */
	if (unlikely(!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))) {
		netif_stop_queue(ndev);
		netdev_err(ndev, "BUG!, no TXB free when queue awake!\n");
		return NETDEV_TX_BUSY;
	}

	txb_id = priv->txb_head & priv->txb_mask;
	netdev_info(ndev, "ctucan_start_xmit: using TXB#%u", txb_id);
	priv->txb_head++;
	ok = ctu_can_fd_insert_frame(&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb));
	if (!ok) {
		netdev_err(ndev, "BUG! cannot insert frame into TXTB!");
		return NETDEV_TX_OK; // TODO: what else to return
	}
	can_put_echo_skb(skb, ndev, txb_id);
	ctu_can_fd_txt_set_rdy(&priv->p, txb_id);

	if (!(cf->can_id & CAN_RTR_FLAG)) {
		stats->tx_bytes += cf->len;
	}

	/* Check if all TX buffers are full */
	if (!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
		netif_stop_queue(ndev);

	return NETDEV_TX_OK;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_start_xmit(struct sk_buff *skb, struct net_device *ndev)
|———Node:identifier Text: ctucan_start_xmit
|———Node:parameter_list Text: (struct sk_buff *skb, struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct sk_buff *skb
|—————Node:struct_specifier Text: struct sk_buff
|——————Node:struct Text: struct
|——————Node:type_identifier Text: sk_buff
|—————Node:pointer_declarator Text: *skb
|——————Node:* Text: *
|——————Node:identifier Text: skb
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct canfd_frame *cf = (struct canfd_frame *)skb->data;
	u32 txb_id;
	bool ok;

	if (can_dropped_invalid_skb(ndev, skb))
		return NETDEV_TX_OK;


	/* Check if the TX buffer is full */
	if (unlikely(!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))) {
		netif_stop_queue(ndev);
		netdev_err(ndev, "BUG!, no TXB free when queue awake!\n");
		return NETDEV_TX_BUSY;
	}

	txb_id = priv->txb_head & priv->txb_mask;
	netdev_info(ndev, "ctucan_start_xmit: using TXB#%u", txb_id);
	priv->txb_head++;
	ok = ctu_can_fd_insert_frame(&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb));
	if (!ok) {
		netdev_err(ndev, "BUG! cannot insert frame into TXTB!");
		return NETDEV_TX_OK; // TODO: what else to return
	}
	can_put_echo_skb(skb, ndev, txb_id);
	ctu_can_fd_txt_set_rdy(&priv->p, txb_id);

	if (!(cf->can_id & CAN_RTR_FLAG)) {
		stats->tx_bytes += cf->len;
	}

	/* Check if all TX buffers are full */
	if (!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
		netif_stop_queue(ndev);

	return NETDEV_TX_OK;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct net_device_stats *stats = &ndev->stats;
|————Node:struct_specifier Text: struct net_device_stats
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device_stats
|————Node:init_declarator Text: *stats = &ndev->stats
|—————Node:pointer_declarator Text: *stats
|——————Node:* Text: *
|——————Node:identifier Text: stats
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ndev->stats
|——————Node:& Text: &
|——————Node:field_expression Text: ndev->stats
|———————Node:identifier Text: ndev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stats
|————Node:; Text: ;
|———Node:declaration Text: struct canfd_frame *cf = (struct canfd_frame *)skb->data;
|————Node:struct_specifier Text: struct canfd_frame
|—————Node:struct Text: struct
|—————Node:type_identifier Text: canfd_frame
|————Node:init_declarator Text: *cf = (struct canfd_frame *)skb->data
|—————Node:pointer_declarator Text: *cf
|——————Node:* Text: *
|——————Node:identifier Text: cf
|—————Node:= Text: =
|—————Node:cast_expression Text: (struct canfd_frame *)skb->data
|——————Node:( Text: (
|——————Node:type_descriptor Text: struct canfd_frame *
|———————Node:struct_specifier Text: struct canfd_frame
|————————Node:struct Text: struct
|————————Node:type_identifier Text: canfd_frame
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:field_expression Text: skb->data
|———————Node:identifier Text: skb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: data
|————Node:; Text: ;
|———Node:declaration Text: u32 txb_id;
|————Node:type_identifier Text: u32
|————Node:identifier Text: txb_id
|————Node:; Text: ;
|———Node:declaration Text: bool ok;
|————Node:primitive_type Text: bool
|————Node:identifier Text: ok
|————Node:; Text: ;
|———Node:if_statement Text: if (can_dropped_invalid_skb(ndev, skb))
		return NETDEV_TX_OK;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (can_dropped_invalid_skb(ndev, skb))
|—————Node:( Text: (
|—————Node:call_expression Text: can_dropped_invalid_skb(ndev, skb)
|——————Node:identifier Text: can_dropped_invalid_skb
|——————Node:argument_list Text: (ndev, skb)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:, Text: ,
|———————Node:identifier Text: skb
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:return_statement Text: return NETDEV_TX_OK;
|—————Node:return Text: return
|—————Node:identifier Text: NETDEV_TX_OK
|—————Node:; Text: ;
|———Node:comment Text: /* Check if the TX buffer is full */
|———Node:if_statement Text: if (unlikely(!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))) {
		netif_stop_queue(ndev);
		netdev_err(ndev, "BUG!, no TXB free when queue awake!\n");
		return NETDEV_TX_BUSY;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (unlikely(!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p))))
|—————Node:( Text: (
|—————Node:call_expression Text: unlikely(!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
|——————Node:identifier Text: unlikely
|——————Node:argument_list Text: (!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
|———————Node:( Text: (
|———————Node:unary_expression Text: !CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p))
|————————Node:! Text: !
|————————Node:call_expression Text: CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p))
|—————————Node:identifier Text: CTU_CAN_FD_TXTNF
|—————————Node:argument_list Text: (ctu_can_get_status(&priv->p))
|——————————Node:( Text: (
|——————————Node:call_expression Text: ctu_can_get_status(&priv->p)
|———————————Node:identifier Text: ctu_can_get_status
|———————————Node:argument_list Text: (&priv->p)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &priv->p
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: priv->p
|——————————————Node:identifier Text: priv
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: p
|————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netif_stop_queue(ndev);
		netdev_err(ndev, "BUG!, no TXB free when queue awake!\n");
		return NETDEV_TX_BUSY;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netif_stop_queue(ndev);
|——————Node:call_expression Text: netif_stop_queue(ndev)
|———————Node:identifier Text: netif_stop_queue
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: netdev_err(ndev, "BUG!, no TXB free when queue awake!\n");
|——————Node:call_expression Text: netdev_err(ndev, "BUG!, no TXB free when queue awake!\n")
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "BUG!, no TXB free when queue awake!\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "BUG!, no TXB free when queue awake!\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: BUG!, no TXB free when queue awake!
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return NETDEV_TX_BUSY;
|——————Node:return Text: return
|——————Node:identifier Text: NETDEV_TX_BUSY
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: txb_id = priv->txb_head & priv->txb_mask;
|————Node:assignment_expression Text: txb_id = priv->txb_head & priv->txb_mask
|—————Node:identifier Text: txb_id
|—————Node:= Text: =
|—————Node:binary_expression Text: priv->txb_head & priv->txb_mask
|——————Node:field_expression Text: priv->txb_head
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txb_head
|——————Node:& Text: &
|——————Node:field_expression Text: priv->txb_mask
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txb_mask
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_start_xmit: using TXB#%u", txb_id);
|————Node:call_expression Text: netdev_info(ndev, "ctucan_start_xmit: using TXB#%u", txb_id)
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_start_xmit: using TXB#%u", txb_id)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_start_xmit: using TXB#%u"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_start_xmit: using TXB#%u
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:identifier Text: txb_id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_head++;
|————Node:update_expression Text: priv->txb_head++
|—————Node:field_expression Text: priv->txb_head
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_head
|—————Node:++ Text: ++
|————Node:; Text: ;
|———Node:expression_statement Text: ok = ctu_can_fd_insert_frame(&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb));
|————Node:assignment_expression Text: ok = ctu_can_fd_insert_frame(&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb))
|—————Node:identifier Text: ok
|—————Node:= Text: =
|—————Node:call_expression Text: ctu_can_fd_insert_frame(&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb))
|——————Node:identifier Text: ctu_can_fd_insert_frame
|——————Node:argument_list Text: (&priv->p, cf, 0, txb_id, can_is_canfd_skb(skb))
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:identifier Text: cf
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:, Text: ,
|———————Node:identifier Text: txb_id
|———————Node:, Text: ,
|———————Node:call_expression Text: can_is_canfd_skb(skb)
|————————Node:identifier Text: can_is_canfd_skb
|————————Node:argument_list Text: (skb)
|—————————Node:( Text: (
|—————————Node:identifier Text: skb
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!ok) {
		netdev_err(ndev, "BUG! cannot insert frame into TXTB!");
		return NETDEV_TX_OK; // TODO: what else to return
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!ok)
|—————Node:( Text: (
|—————Node:unary_expression Text: !ok
|——————Node:! Text: !
|——————Node:identifier Text: ok
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "BUG! cannot insert frame into TXTB!");
		return NETDEV_TX_OK; // TODO: what else to return
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "BUG! cannot insert frame into TXTB!");
|——————Node:call_expression Text: netdev_err(ndev, "BUG! cannot insert frame into TXTB!")
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "BUG! cannot insert frame into TXTB!")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "BUG! cannot insert frame into TXTB!"
|—————————Node:" Text: "
|—————————Node:string_content Text: BUG! cannot insert frame into TXTB!
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return NETDEV_TX_OK;
|——————Node:return Text: return
|——————Node:identifier Text: NETDEV_TX_OK
|——————Node:; Text: ;
|—————Node:comment Text: // TODO: what else to return
|—————Node:} Text: }
|———Node:expression_statement Text: can_put_echo_skb(skb, ndev, txb_id);
|————Node:call_expression Text: can_put_echo_skb(skb, ndev, txb_id)
|—————Node:identifier Text: can_put_echo_skb
|—————Node:argument_list Text: (skb, ndev, txb_id)
|——————Node:( Text: (
|——————Node:identifier Text: skb
|——————Node:, Text: ,
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:identifier Text: txb_id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_txt_set_rdy(&priv->p, txb_id);
|————Node:call_expression Text: ctu_can_fd_txt_set_rdy(&priv->p, txb_id)
|—————Node:identifier Text: ctu_can_fd_txt_set_rdy
|—————Node:argument_list Text: (&priv->p, txb_id)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: txb_id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!(cf->can_id & CAN_RTR_FLAG)) {
		stats->tx_bytes += cf->len;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!(cf->can_id & CAN_RTR_FLAG))
|—————Node:( Text: (
|—————Node:unary_expression Text: !(cf->can_id & CAN_RTR_FLAG)
|——————Node:! Text: !
|——————Node:parenthesized_expression Text: (cf->can_id & CAN_RTR_FLAG)
|———————Node:( Text: (
|———————Node:binary_expression Text: cf->can_id & CAN_RTR_FLAG
|————————Node:field_expression Text: cf->can_id
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: can_id
|————————Node:& Text: &
|————————Node:identifier Text: CAN_RTR_FLAG
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		stats->tx_bytes += cf->len;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: stats->tx_bytes += cf->len;
|——————Node:assignment_expression Text: stats->tx_bytes += cf->len
|———————Node:field_expression Text: stats->tx_bytes
|————————Node:identifier Text: stats
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_bytes
|———————Node:+= Text: +=
|———————Node:field_expression Text: cf->len
|————————Node:identifier Text: cf
|————————Node:-> Text: ->
|————————Node:field_identifier Text: len
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Check if all TX buffers are full */
|———Node:if_statement Text: if (!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
		netif_stop_queue(ndev);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p)))
|—————Node:( Text: (
|—————Node:unary_expression Text: !CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p))
|——————Node:! Text: !
|——————Node:call_expression Text: CTU_CAN_FD_TXTNF(ctu_can_get_status(&priv->p))
|———————Node:identifier Text: CTU_CAN_FD_TXTNF
|———————Node:argument_list Text: (ctu_can_get_status(&priv->p))
|————————Node:( Text: (
|————————Node:call_expression Text: ctu_can_get_status(&priv->p)
|—————————Node:identifier Text: ctu_can_get_status
|—————————Node:argument_list Text: (&priv->p)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &priv->p
|———————————Node:& Text: &
|———————————Node:field_expression Text: priv->p
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: p
|——————————Node:) Text: )
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:expression_statement Text: netif_stop_queue(ndev);
|—————Node:call_expression Text: netif_stop_queue(ndev)
|——————Node:identifier Text: netif_stop_queue
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:return_statement Text: return NETDEV_TX_OK;
|————Node:return Text: return
|————Node:identifier Text: NETDEV_TX_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * xcan_rx -  Is called from CAN isr to complete the received
 *		frame  processing
 * @ndev:	Pointer to net_device structure
 *
 * This function is invoked from the CAN isr(poll) to process the Rx frames. It
 * does minimal processing and invokes "netif_receive_skb" to complete further
 * processing.
 * Return: 1 on success and 0 on failure.
 */
|—Node:function_definition Text: static int ctucan_rx(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct canfd_frame *cf;
	struct sk_buff *skb;
	u64 ts;
	union ctu_can_fd_frame_form_w ffw;
	//netdev_info(ndev, "ctucan_rx");


	ffw.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);
	if (ffw.s.fr_type == FD_CAN)
		skb = alloc_canfd_skb(ndev, &cf);
	else
		skb = alloc_can_skb(ndev, (struct can_frame **) &cf);

	if (unlikely(!skb)) {
		int i;
		/* Remove the rest of the frame from the controller */
		for (i = 0; i < ffw.s.rwcnt; i++)
			priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);

		stats->rx_dropped++;
		return 0;
	}

	ctu_can_fd_read_rx_frame_ffw(&priv->p, cf, &ts, ffw);

	stats->rx_bytes += cf->len;
	stats->rx_packets++;
	netif_receive_skb(skb);

	return 1;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_rx(struct net_device *ndev)
|———Node:identifier Text: ctucan_rx
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct canfd_frame *cf;
	struct sk_buff *skb;
	u64 ts;
	union ctu_can_fd_frame_form_w ffw;
	//netdev_info(ndev, "ctucan_rx");


	ffw.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);
	if (ffw.s.fr_type == FD_CAN)
		skb = alloc_canfd_skb(ndev, &cf);
	else
		skb = alloc_can_skb(ndev, (struct can_frame **) &cf);

	if (unlikely(!skb)) {
		int i;
		/* Remove the rest of the frame from the controller */
		for (i = 0; i < ffw.s.rwcnt; i++)
			priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);

		stats->rx_dropped++;
		return 0;
	}

	ctu_can_fd_read_rx_frame_ffw(&priv->p, cf, &ts, ffw);

	stats->rx_bytes += cf->len;
	stats->rx_packets++;
	netif_receive_skb(skb);

	return 1;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct net_device_stats *stats = &ndev->stats;
|————Node:struct_specifier Text: struct net_device_stats
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device_stats
|————Node:init_declarator Text: *stats = &ndev->stats
|—————Node:pointer_declarator Text: *stats
|——————Node:* Text: *
|——————Node:identifier Text: stats
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ndev->stats
|——————Node:& Text: &
|——————Node:field_expression Text: ndev->stats
|———————Node:identifier Text: ndev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stats
|————Node:; Text: ;
|———Node:declaration Text: struct canfd_frame *cf;
|————Node:struct_specifier Text: struct canfd_frame
|—————Node:struct Text: struct
|—————Node:type_identifier Text: canfd_frame
|————Node:pointer_declarator Text: *cf
|—————Node:* Text: *
|—————Node:identifier Text: cf
|————Node:; Text: ;
|———Node:declaration Text: struct sk_buff *skb;
|————Node:struct_specifier Text: struct sk_buff
|—————Node:struct Text: struct
|—————Node:type_identifier Text: sk_buff
|————Node:pointer_declarator Text: *skb
|—————Node:* Text: *
|—————Node:identifier Text: skb
|————Node:; Text: ;
|———Node:declaration Text: u64 ts;
|————Node:type_identifier Text: u64
|————Node:identifier Text: ts
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_frame_form_w ffw;
|————Node:union_specifier Text: union ctu_can_fd_frame_form_w
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_frame_form_w
|————Node:identifier Text: ffw
|————Node:; Text: ;
|———Node:comment Text: //netdev_info(ndev, "ctucan_rx");
|———Node:expression_statement Text: ffw.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);
|————Node:assignment_expression Text: ffw.u32 = priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA)
|—————Node:field_expression Text: ffw.u32
|——————Node:identifier Text: ffw
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:call_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA)
|——————Node:field_expression Text: priv->p.read_reg
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|———————Node:. Text: .
|———————Node:field_identifier Text: read_reg
|——————Node:argument_list Text: (&priv->p, CTU_CAN_FD_RX_DATA)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:identifier Text: CTU_CAN_FD_RX_DATA
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ffw.s.fr_type == FD_CAN)
		skb = alloc_canfd_skb(ndev, &cf);
	else
		skb = alloc_can_skb(ndev, (struct can_frame **) &cf);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ffw.s.fr_type == FD_CAN)
|—————Node:( Text: (
|—————Node:binary_expression Text: ffw.s.fr_type == FD_CAN
|——————Node:field_expression Text: ffw.s.fr_type
|———————Node:field_expression Text: ffw.s
|————————Node:identifier Text: ffw
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: fr_type
|——————Node:== Text: ==
|——————Node:identifier Text: FD_CAN
|—————Node:) Text: )
|————Node:expression_statement Text: skb = alloc_canfd_skb(ndev, &cf);
|—————Node:assignment_expression Text: skb = alloc_canfd_skb(ndev, &cf)
|——————Node:identifier Text: skb
|——————Node:= Text: =
|——————Node:call_expression Text: alloc_canfd_skb(ndev, &cf)
|———————Node:identifier Text: alloc_canfd_skb
|———————Node:argument_list Text: (ndev, &cf)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &cf
|—————————Node:& Text: &
|—————————Node:identifier Text: cf
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:else_clause Text: else
		skb = alloc_can_skb(ndev, (struct can_frame **) &cf);
|—————Node:else Text: else
|—————Node:expression_statement Text: skb = alloc_can_skb(ndev, (struct can_frame **) &cf);
|——————Node:assignment_expression Text: skb = alloc_can_skb(ndev, (struct can_frame **) &cf)
|———————Node:identifier Text: skb
|———————Node:= Text: =
|———————Node:call_expression Text: alloc_can_skb(ndev, (struct can_frame **) &cf)
|————————Node:identifier Text: alloc_can_skb
|————————Node:argument_list Text: (ndev, (struct can_frame **) &cf)
|—————————Node:( Text: (
|—————————Node:identifier Text: ndev
|—————————Node:, Text: ,
|—————————Node:cast_expression Text: (struct can_frame **) &cf
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: struct can_frame **
|———————————Node:struct_specifier Text: struct can_frame
|————————————Node:struct Text: struct
|————————————Node:type_identifier Text: can_frame
|———————————Node:abstract_pointer_declarator Text: **
|————————————Node:* Text: *
|————————————Node:abstract_pointer_declarator Text: *
|—————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:pointer_expression Text: &cf
|———————————Node:& Text: &
|———————————Node:identifier Text: cf
|—————————Node:) Text: )
|——————Node:; Text: ;
|———Node:if_statement Text: if (unlikely(!skb)) {
		int i;
		/* Remove the rest of the frame from the controller */
		for (i = 0; i < ffw.s.rwcnt; i++)
			priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);

		stats->rx_dropped++;
		return 0;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (unlikely(!skb))
|—————Node:( Text: (
|—————Node:call_expression Text: unlikely(!skb)
|——————Node:identifier Text: unlikely
|——————Node:argument_list Text: (!skb)
|———————Node:( Text: (
|———————Node:unary_expression Text: !skb
|————————Node:! Text: !
|————————Node:identifier Text: skb
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		int i;
		/* Remove the rest of the frame from the controller */
		for (i = 0; i < ffw.s.rwcnt; i++)
			priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);

		stats->rx_dropped++;
		return 0;
	}
|—————Node:{ Text: {
|—————Node:declaration Text: int i;
|——————Node:primitive_type Text: int
|——————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:comment Text: /* Remove the rest of the frame from the controller */
|—————Node:for_statement Text: for (i = 0; i < ffw.s.rwcnt; i++)
			priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: i < ffw.s.rwcnt
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:field_expression Text: ffw.s.rwcnt
|————————Node:field_expression Text: ffw.s
|—————————Node:identifier Text: ffw
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: rwcnt
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:expression_statement Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA);
|———————Node:call_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_RX_DATA)
|————————Node:field_expression Text: priv->p.read_reg
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|—————————Node:. Text: .
|—————————Node:field_identifier Text: read_reg
|————————Node:argument_list Text: (&priv->p, CTU_CAN_FD_RX_DATA)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: CTU_CAN_FD_RX_DATA
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:expression_statement Text: stats->rx_dropped++;
|——————Node:update_expression Text: stats->rx_dropped++
|———————Node:field_expression Text: stats->rx_dropped
|————————Node:identifier Text: stats
|————————Node:-> Text: ->
|————————Node:field_identifier Text: rx_dropped
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctu_can_fd_read_rx_frame_ffw(&priv->p, cf, &ts, ffw);
|————Node:call_expression Text: ctu_can_fd_read_rx_frame_ffw(&priv->p, cf, &ts, ffw)
|—————Node:identifier Text: ctu_can_fd_read_rx_frame_ffw
|—————Node:argument_list Text: (&priv->p, cf, &ts, ffw)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: cf
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &ts
|———————Node:& Text: &
|———————Node:identifier Text: ts
|——————Node:, Text: ,
|——————Node:identifier Text: ffw
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: stats->rx_bytes += cf->len;
|————Node:assignment_expression Text: stats->rx_bytes += cf->len
|—————Node:field_expression Text: stats->rx_bytes
|——————Node:identifier Text: stats
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_bytes
|—————Node:+= Text: +=
|—————Node:field_expression Text: cf->len
|——————Node:identifier Text: cf
|——————Node:-> Text: ->
|——————Node:field_identifier Text: len
|————Node:; Text: ;
|———Node:expression_statement Text: stats->rx_packets++;
|————Node:update_expression Text: stats->rx_packets++
|—————Node:field_expression Text: stats->rx_packets
|——————Node:identifier Text: stats
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_packets
|—————Node:++ Text: ++
|————Node:; Text: ;
|———Node:expression_statement Text: netif_receive_skb(skb);
|————Node:call_expression Text: netif_receive_skb(skb)
|—————Node:identifier Text: netif_receive_skb
|—————Node:argument_list Text: (skb)
|——————Node:( Text: (
|——————Node:identifier Text: skb
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * xcan_err_interrupt - error frame Isr
 * @ndev:	net_device pointer
 * @isr:	interrupt status register value
 *
 * This is the CAN error interrupt and it will
 * check the the type of error and forward the error
 * frame to upper layers.
 */
|—Node:preproc_if Text: #if 0
static void xcan_err_interrupt(struct net_device *ndev, u32 isr)
{
	struct xcan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct can_frame *cf;
	struct sk_buff *skb;
	u32 err_status, status, txerr = 0, rxerr = 0;
	netdev_info(ndev, "xcan_err_interrupt");

	skb = alloc_can_err_skb(ndev, &cf);

	err_status = priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET);
	priv->p.write_reg(&priv->p, XCAN_ESR_OFFSET, err_status);
	txerr = priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;
	rxerr = ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);
	status = priv->p.read_reg(&priv->p, XCAN_SR_OFFSET);

	if (isr & XCAN_IXR_BSOFF_MASK) {
		priv->can.state = CAN_STATE_BUS_OFF;
		priv->can.can_stats.bus_off++;
		/* Leave device in Config Mode in bus-off state */
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		can_bus_off(ndev);
		if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
	} else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}

	/* Check for Arbitration lost interrupt */
	if (isr & XCAN_IXR_ARBLST_MASK) {
		priv->can.can_stats.arbitration_lost++;
		if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
	}

	/* Check for RX FIFO Overflow interrupt */
	if (isr & XCAN_IXR_RXOFLW_MASK) {
		stats->rx_over_errors++;
		stats->rx_errors++;
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
	}

	/* Check for error interrupt */
	if (isr & XCAN_IXR_ERROR_MASK) {
		if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		/* Check for Ack error interrupt */
		if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}

		/* Check for Bit error interrupt */
		if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}

		/* Check for Stuff error interrupt */
		if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}

		/* Check for Form error interrupt */
		if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}

		/* Check for CRC error interrupt */
		if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
			priv->can.can_stats.bus_error++;
	}

	if (skb) {
		stats->rx_packets++;
		stats->rx_bytes += cf->can_dlc;
		netif_rx(skb);
	}

	netdev_dbg(ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET));
}
#endif
|——Node:#if Text: #if
|——Node:number_literal Text: 0
|——Node:
 Text: 

|——Node:function_definition Text: static void xcan_err_interrupt(struct net_device *ndev, u32 isr)
{
	struct xcan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct can_frame *cf;
	struct sk_buff *skb;
	u32 err_status, status, txerr = 0, rxerr = 0;
	netdev_info(ndev, "xcan_err_interrupt");

	skb = alloc_can_err_skb(ndev, &cf);

	err_status = priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET);
	priv->p.write_reg(&priv->p, XCAN_ESR_OFFSET, err_status);
	txerr = priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;
	rxerr = ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);
	status = priv->p.read_reg(&priv->p, XCAN_SR_OFFSET);

	if (isr & XCAN_IXR_BSOFF_MASK) {
		priv->can.state = CAN_STATE_BUS_OFF;
		priv->can.can_stats.bus_off++;
		/* Leave device in Config Mode in bus-off state */
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		can_bus_off(ndev);
		if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
	} else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}

	/* Check for Arbitration lost interrupt */
	if (isr & XCAN_IXR_ARBLST_MASK) {
		priv->can.can_stats.arbitration_lost++;
		if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
	}

	/* Check for RX FIFO Overflow interrupt */
	if (isr & XCAN_IXR_RXOFLW_MASK) {
		stats->rx_over_errors++;
		stats->rx_errors++;
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
	}

	/* Check for error interrupt */
	if (isr & XCAN_IXR_ERROR_MASK) {
		if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		/* Check for Ack error interrupt */
		if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}

		/* Check for Bit error interrupt */
		if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}

		/* Check for Stuff error interrupt */
		if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}

		/* Check for Form error interrupt */
		if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}

		/* Check for CRC error interrupt */
		if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
			priv->can.can_stats.bus_error++;
	}

	if (skb) {
		stats->rx_packets++;
		stats->rx_bytes += cf->can_dlc;
		netif_rx(skb);
	}

	netdev_dbg(ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET));
}
|———Node:storage_class_specifier Text: static
|————Node:static Text: static
|———Node:primitive_type Text: void
|———Node:function_declarator Text: xcan_err_interrupt(struct net_device *ndev, u32 isr)
|————Node:identifier Text: xcan_err_interrupt
|————Node:parameter_list Text: (struct net_device *ndev, u32 isr)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: struct net_device *ndev
|——————Node:struct_specifier Text: struct net_device
|———————Node:struct Text: struct
|———————Node:type_identifier Text: net_device
|——————Node:pointer_declarator Text: *ndev
|———————Node:* Text: *
|———————Node:identifier Text: ndev
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: u32 isr
|——————Node:type_identifier Text: u32
|——————Node:identifier Text: isr
|—————Node:) Text: )
|———Node:compound_statement Text: {
	struct xcan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	struct can_frame *cf;
	struct sk_buff *skb;
	u32 err_status, status, txerr = 0, rxerr = 0;
	netdev_info(ndev, "xcan_err_interrupt");

	skb = alloc_can_err_skb(ndev, &cf);

	err_status = priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET);
	priv->p.write_reg(&priv->p, XCAN_ESR_OFFSET, err_status);
	txerr = priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;
	rxerr = ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);
	status = priv->p.read_reg(&priv->p, XCAN_SR_OFFSET);

	if (isr & XCAN_IXR_BSOFF_MASK) {
		priv->can.state = CAN_STATE_BUS_OFF;
		priv->can.can_stats.bus_off++;
		/* Leave device in Config Mode in bus-off state */
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		can_bus_off(ndev);
		if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
	} else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}

	/* Check for Arbitration lost interrupt */
	if (isr & XCAN_IXR_ARBLST_MASK) {
		priv->can.can_stats.arbitration_lost++;
		if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
	}

	/* Check for RX FIFO Overflow interrupt */
	if (isr & XCAN_IXR_RXOFLW_MASK) {
		stats->rx_over_errors++;
		stats->rx_errors++;
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
	}

	/* Check for error interrupt */
	if (isr & XCAN_IXR_ERROR_MASK) {
		if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		/* Check for Ack error interrupt */
		if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}

		/* Check for Bit error interrupt */
		if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}

		/* Check for Stuff error interrupt */
		if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}

		/* Check for Form error interrupt */
		if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}

		/* Check for CRC error interrupt */
		if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
			priv->can.can_stats.bus_error++;
	}

	if (skb) {
		stats->rx_packets++;
		stats->rx_bytes += cf->can_dlc;
		netif_rx(skb);
	}

	netdev_dbg(ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET));
}
|————Node:{ Text: {
|————Node:declaration Text: struct xcan_priv *priv = netdev_priv(ndev);
|—————Node:struct_specifier Text: struct xcan_priv
|——————Node:struct Text: struct
|——————Node:type_identifier Text: xcan_priv
|—————Node:init_declarator Text: *priv = netdev_priv(ndev)
|——————Node:pointer_declarator Text: *priv
|———————Node:* Text: *
|———————Node:identifier Text: priv
|——————Node:= Text: =
|——————Node:call_expression Text: netdev_priv(ndev)
|———————Node:identifier Text: netdev_priv
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: struct net_device_stats *stats = &ndev->stats;
|—————Node:struct_specifier Text: struct net_device_stats
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device_stats
|—————Node:init_declarator Text: *stats = &ndev->stats
|——————Node:pointer_declarator Text: *stats
|———————Node:* Text: *
|———————Node:identifier Text: stats
|——————Node:= Text: =
|——————Node:pointer_expression Text: &ndev->stats
|———————Node:& Text: &
|———————Node:field_expression Text: ndev->stats
|————————Node:identifier Text: ndev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: stats
|—————Node:; Text: ;
|————Node:declaration Text: struct can_frame *cf;
|—————Node:struct_specifier Text: struct can_frame
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_frame
|—————Node:pointer_declarator Text: *cf
|——————Node:* Text: *
|——————Node:identifier Text: cf
|—————Node:; Text: ;
|————Node:declaration Text: struct sk_buff *skb;
|—————Node:struct_specifier Text: struct sk_buff
|——————Node:struct Text: struct
|——————Node:type_identifier Text: sk_buff
|—————Node:pointer_declarator Text: *skb
|——————Node:* Text: *
|——————Node:identifier Text: skb
|—————Node:; Text: ;
|————Node:declaration Text: u32 err_status, status, txerr = 0, rxerr = 0;
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: err_status
|—————Node:, Text: ,
|—————Node:identifier Text: status
|—————Node:, Text: ,
|—————Node:init_declarator Text: txerr = 0
|——————Node:identifier Text: txerr
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:, Text: ,
|—————Node:init_declarator Text: rxerr = 0
|——————Node:identifier Text: rxerr
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:expression_statement Text: netdev_info(ndev, "xcan_err_interrupt");
|—————Node:call_expression Text: netdev_info(ndev, "xcan_err_interrupt")
|——————Node:identifier Text: netdev_info
|——————Node:argument_list Text: (ndev, "xcan_err_interrupt")
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:, Text: ,
|———————Node:string_literal Text: "xcan_err_interrupt"
|————————Node:" Text: "
|————————Node:string_content Text: xcan_err_interrupt
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: skb = alloc_can_err_skb(ndev, &cf);
|—————Node:assignment_expression Text: skb = alloc_can_err_skb(ndev, &cf)
|——————Node:identifier Text: skb
|——————Node:= Text: =
|——————Node:call_expression Text: alloc_can_err_skb(ndev, &cf)
|———————Node:identifier Text: alloc_can_err_skb
|———————Node:argument_list Text: (ndev, &cf)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &cf
|—————————Node:& Text: &
|—————————Node:identifier Text: cf
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: err_status = priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET);
|—————Node:assignment_expression Text: err_status = priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET)
|——————Node:identifier Text: err_status
|——————Node:= Text: =
|——————Node:call_expression Text: priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET)
|———————Node:field_expression Text: priv->p.read_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: read_reg
|———————Node:argument_list Text: (&priv->p, XCAN_ESR_OFFSET)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: XCAN_ESR_OFFSET
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: priv->p.write_reg(&priv->p, XCAN_ESR_OFFSET, err_status);
|—————Node:call_expression Text: priv->p.write_reg(&priv->p, XCAN_ESR_OFFSET, err_status)
|——————Node:field_expression Text: priv->p.write_reg
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|———————Node:. Text: .
|———————Node:field_identifier Text: write_reg
|——————Node:argument_list Text: (&priv->p, XCAN_ESR_OFFSET, err_status)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:, Text: ,
|———————Node:identifier Text: XCAN_ESR_OFFSET
|———————Node:, Text: ,
|———————Node:identifier Text: err_status
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: txerr = priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;
|—————Node:assignment_expression Text: txerr = priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK
|——————Node:identifier Text: txerr
|——————Node:= Text: =
|——————Node:binary_expression Text: priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK
|———————Node:call_expression Text: priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET)
|————————Node:field_expression Text: priv->p.read_reg
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|—————————Node:. Text: .
|—————————Node:field_identifier Text: read_reg
|————————Node:argument_list Text: (&priv->p, XCAN_ECR_OFFSET)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_ECR_OFFSET
|—————————Node:) Text: )
|———————Node:& Text: &
|———————Node:identifier Text: XCAN_ECR_TEC_MASK
|—————Node:; Text: ;
|————Node:expression_statement Text: rxerr = ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);
|—————Node:assignment_expression Text: rxerr = ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT)
|——————Node:identifier Text: rxerr
|——————Node:= Text: =
|——————Node:parenthesized_expression Text: ((priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT)
|———————Node:( Text: (
|———————Node:binary_expression Text: (priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT
|————————Node:parenthesized_expression Text: (priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET) &
			XCAN_ECR_REC_MASK
|——————————Node:call_expression Text: priv->p.read_reg(&priv->p, XCAN_ECR_OFFSET)
|———————————Node:field_expression Text: priv->p.read_reg
|————————————Node:field_expression Text: priv->p
|—————————————Node:identifier Text: priv
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: p
|————————————Node:. Text: .
|————————————Node:field_identifier Text: read_reg
|———————————Node:argument_list Text: (&priv->p, XCAN_ECR_OFFSET)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &priv->p
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: priv->p
|——————————————Node:identifier Text: priv
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: p
|————————————Node:, Text: ,
|————————————Node:identifier Text: XCAN_ECR_OFFSET
|————————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:identifier Text: XCAN_ECR_REC_MASK
|—————————Node:) Text: )
|————————Node:>> Text: >>
|————————Node:identifier Text: XCAN_ESR_REC_SHIFT
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: status = priv->p.read_reg(&priv->p, XCAN_SR_OFFSET);
|—————Node:assignment_expression Text: status = priv->p.read_reg(&priv->p, XCAN_SR_OFFSET)
|——————Node:identifier Text: status
|——————Node:= Text: =
|——————Node:call_expression Text: priv->p.read_reg(&priv->p, XCAN_SR_OFFSET)
|———————Node:field_expression Text: priv->p.read_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: read_reg
|———————Node:argument_list Text: (&priv->p, XCAN_SR_OFFSET)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: XCAN_SR_OFFSET
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (isr & XCAN_IXR_BSOFF_MASK) {
		priv->can.state = CAN_STATE_BUS_OFF;
		priv->can.can_stats.bus_off++;
		/* Leave device in Config Mode in bus-off state */
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		can_bus_off(ndev);
		if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
	} else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (isr & XCAN_IXR_BSOFF_MASK)
|——————Node:( Text: (
|——————Node:binary_expression Text: isr & XCAN_IXR_BSOFF_MASK
|———————Node:identifier Text: isr
|———————Node:& Text: &
|———————Node:identifier Text: XCAN_IXR_BSOFF_MASK
|——————Node:) Text: )
|—————Node:compound_statement Text: {
		priv->can.state = CAN_STATE_BUS_OFF;
		priv->can.can_stats.bus_off++;
		/* Leave device in Config Mode in bus-off state */
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		can_bus_off(ndev);
		if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: priv->can.state = CAN_STATE_BUS_OFF;
|———————Node:assignment_expression Text: priv->can.state = CAN_STATE_BUS_OFF
|————————Node:field_expression Text: priv->can.state
|—————————Node:field_expression Text: priv->can
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can
|—————————Node:. Text: .
|—————————Node:field_identifier Text: state
|————————Node:= Text: =
|————————Node:identifier Text: CAN_STATE_BUS_OFF
|———————Node:; Text: ;
|——————Node:expression_statement Text: priv->can.can_stats.bus_off++;
|———————Node:update_expression Text: priv->can.can_stats.bus_off++
|————————Node:field_expression Text: priv->can.can_stats.bus_off
|—————————Node:field_expression Text: priv->can.can_stats
|——————————Node:field_expression Text: priv->can
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: can
|——————————Node:. Text: .
|——————————Node:field_identifier Text: can_stats
|—————————Node:. Text: .
|—————————Node:field_identifier Text: bus_off
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:comment Text: /* Leave device in Config Mode in bus-off state */
|——————Node:expression_statement Text: priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
|———————Node:call_expression Text: priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK)
|————————Node:field_expression Text: priv->p.write_reg
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write_reg
|————————Node:argument_list Text: (&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_SRR_OFFSET
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_SRR_RESET_MASK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: can_bus_off(ndev);
|———————Node:call_expression Text: can_bus_off(ndev)
|————————Node:identifier Text: can_bus_off
|————————Node:argument_list Text: (ndev)
|—————————Node:( Text: (
|—————————Node:identifier Text: ndev
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (skb)
			cf->can_id |= CAN_ERR_BUSOFF;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (skb)
|————————Node:( Text: (
|————————Node:identifier Text: skb
|————————Node:) Text: )
|———————Node:expression_statement Text: cf->can_id |= CAN_ERR_BUSOFF;
|————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_BUSOFF
|—————————Node:field_expression Text: cf->can_id
|——————————Node:identifier Text: cf
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_id
|—————————Node:|= Text: |=
|—————————Node:identifier Text: CAN_ERR_BUSOFF
|————————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|——————Node:else Text: else
|——————Node:if_statement Text: if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	} else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: (status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK
|—————————Node:parenthesized_expression Text: (status & XCAN_SR_ESTAT_MASK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: status & XCAN_SR_ESTAT_MASK
|———————————Node:identifier Text: status
|———————————Node:& Text: &
|———————————Node:identifier Text: XCAN_SR_ESTAT_MASK
|——————————Node:) Text: )
|—————————Node:== Text: ==
|—————————Node:identifier Text: XCAN_SR_ESTAT_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
		priv->can.state = CAN_STATE_ERROR_PASSIVE;
		priv->can.can_stats.error_passive++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|————————Node:{ Text: {
|————————Node:expression_statement Text: priv->can.state = CAN_STATE_ERROR_PASSIVE;
|—————————Node:assignment_expression Text: priv->can.state = CAN_STATE_ERROR_PASSIVE
|——————————Node:field_expression Text: priv->can.state
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: state
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_STATE_ERROR_PASSIVE
|—————————Node:; Text: ;
|————————Node:expression_statement Text: priv->can.can_stats.error_passive++;
|—————————Node:update_expression Text: priv->can.can_stats.error_passive++
|——————————Node:field_expression Text: priv->can.can_stats.error_passive
|———————————Node:field_expression Text: priv->can.can_stats
|————————————Node:field_expression Text: priv->can
|—————————————Node:identifier Text: priv
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can
|————————————Node:. Text: .
|————————————Node:field_identifier Text: can_stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: error_passive
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_CRTL;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_CRTL
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_CRTL
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE;
|———————————Node:assignment_expression Text: cf->data[1] = (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE
|————————————Node:subscript_expression Text: cf->data[1]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:conditional_expression Text: (rxerr > 127) ?
					CAN_ERR_CRTL_RX_PASSIVE :
					CAN_ERR_CRTL_TX_PASSIVE
|—————————————Node:parenthesized_expression Text: (rxerr > 127)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: rxerr > 127
|———————————————Node:identifier Text: rxerr
|———————————————Node:> Text: >
|———————————————Node:number_literal Text: 127
|——————————————Node:) Text: )
|—————————————Node:? Text: ?
|—————————————Node:identifier Text: CAN_ERR_CRTL_RX_PASSIVE
|—————————————Node:: Text: :
|—————————————Node:identifier Text: CAN_ERR_CRTL_TX_PASSIVE
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[6] = txerr;
|———————————Node:assignment_expression Text: cf->data[6] = txerr
|————————————Node:subscript_expression Text: cf->data[6]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 6
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: txerr
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[7] = rxerr;
|———————————Node:assignment_expression Text: cf->data[7] = rxerr
|————————————Node:subscript_expression Text: cf->data[7]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 7
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: rxerr
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|————————Node:else Text: else
|————————Node:if_statement Text: if (status & XCAN_SR_ERRWRN_MASK) {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (status & XCAN_SR_ERRWRN_MASK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: status & XCAN_SR_ERRWRN_MASK
|———————————Node:identifier Text: status
|———————————Node:& Text: &
|———————————Node:identifier Text: XCAN_SR_ERRWRN_MASK
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
		priv->can.state = CAN_STATE_ERROR_WARNING;
		priv->can.can_stats.error_warning++;
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
	}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: priv->can.state = CAN_STATE_ERROR_WARNING;
|———————————Node:assignment_expression Text: priv->can.state = CAN_STATE_ERROR_WARNING
|————————————Node:field_expression Text: priv->can.state
|—————————————Node:field_expression Text: priv->can
|——————————————Node:identifier Text: priv
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: can
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: state
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_STATE_ERROR_WARNING
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: priv->can.can_stats.error_warning++;
|———————————Node:update_expression Text: priv->can.can_stats.error_warning++
|————————————Node:field_expression Text: priv->can.can_stats.error_warning
|—————————————Node:field_expression Text: priv->can.can_stats
|——————————————Node:field_expression Text: priv->can
|———————————————Node:identifier Text: priv
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: can
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: can_stats
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: error_warning
|————————————Node:++ Text: ++
|———————————Node:; Text: ;
|——————————Node:if_statement Text: if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (skb)
|————————————Node:( Text: (
|————————————Node:identifier Text: skb
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
			cf->data[6] = txerr;
			cf->data[7] = rxerr;
		}
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: cf->can_id |= CAN_ERR_CRTL;
|—————————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_CRTL
|——————————————Node:field_expression Text: cf->can_id
|———————————————Node:identifier Text: cf
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: can_id
|——————————————Node:|= Text: |=
|——————————————Node:identifier Text: CAN_ERR_CRTL
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING;
|—————————————Node:assignment_expression Text: cf->data[1] |= (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING
|——————————————Node:subscript_expression Text: cf->data[1]
|———————————————Node:field_expression Text: cf->data
|————————————————Node:identifier Text: cf
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: data
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|——————————————Node:|= Text: |=
|——————————————Node:conditional_expression Text: (txerr > rxerr) ?
					CAN_ERR_CRTL_TX_WARNING :
					CAN_ERR_CRTL_RX_WARNING
|———————————————Node:parenthesized_expression Text: (txerr > rxerr)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: txerr > rxerr
|—————————————————Node:identifier Text: txerr
|—————————————————Node:> Text: >
|—————————————————Node:identifier Text: rxerr
|————————————————Node:) Text: )
|———————————————Node:? Text: ?
|———————————————Node:identifier Text: CAN_ERR_CRTL_TX_WARNING
|———————————————Node:: Text: :
|———————————————Node:identifier Text: CAN_ERR_CRTL_RX_WARNING
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: cf->data[6] = txerr;
|—————————————Node:assignment_expression Text: cf->data[6] = txerr
|——————————————Node:subscript_expression Text: cf->data[6]
|———————————————Node:field_expression Text: cf->data
|————————————————Node:identifier Text: cf
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: data
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 6
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:identifier Text: txerr
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: cf->data[7] = rxerr;
|—————————————Node:assignment_expression Text: cf->data[7] = rxerr
|——————————————Node:subscript_expression Text: cf->data[7]
|———————————————Node:field_expression Text: cf->data
|————————————————Node:identifier Text: cf
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: data
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 7
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:identifier Text: rxerr
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|——————————Node:} Text: }
|————Node:comment Text: /* Check for Arbitration lost interrupt */
|————Node:if_statement Text: if (isr & XCAN_IXR_ARBLST_MASK) {
		priv->can.can_stats.arbitration_lost++;
		if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
	}
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (isr & XCAN_IXR_ARBLST_MASK)
|——————Node:( Text: (
|——————Node:binary_expression Text: isr & XCAN_IXR_ARBLST_MASK
|———————Node:identifier Text: isr
|———————Node:& Text: &
|———————Node:identifier Text: XCAN_IXR_ARBLST_MASK
|——————Node:) Text: )
|—————Node:compound_statement Text: {
		priv->can.can_stats.arbitration_lost++;
		if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: priv->can.can_stats.arbitration_lost++;
|———————Node:update_expression Text: priv->can.can_stats.arbitration_lost++
|————————Node:field_expression Text: priv->can.can_stats.arbitration_lost
|—————————Node:field_expression Text: priv->can.can_stats
|——————————Node:field_expression Text: priv->can
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: can
|——————————Node:. Text: .
|——————————Node:field_identifier Text: can_stats
|—————————Node:. Text: .
|—————————Node:field_identifier Text: arbitration_lost
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:if_statement Text: if (skb) {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (skb)
|————————Node:( Text: (
|————————Node:identifier Text: skb
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			cf->can_id |= CAN_ERR_LOSTARB;
			cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: cf->can_id |= CAN_ERR_LOSTARB;
|—————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_LOSTARB
|——————————Node:field_expression Text: cf->can_id
|———————————Node:identifier Text: cf
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: can_id
|——————————Node:|= Text: |=
|——————————Node:identifier Text: CAN_ERR_LOSTARB
|—————————Node:; Text: ;
|————————Node:expression_statement Text: cf->data[0] = CAN_ERR_LOSTARB_UNSPEC;
|—————————Node:assignment_expression Text: cf->data[0] = CAN_ERR_LOSTARB_UNSPEC
|——————————Node:subscript_expression Text: cf->data[0]
|———————————Node:field_expression Text: cf->data
|————————————Node:identifier Text: cf
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: data
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 0
|———————————Node:] Text: ]
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_ERR_LOSTARB_UNSPEC
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:comment Text: /* Check for RX FIFO Overflow interrupt */
|————Node:if_statement Text: if (isr & XCAN_IXR_RXOFLW_MASK) {
		stats->rx_over_errors++;
		stats->rx_errors++;
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
	}
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (isr & XCAN_IXR_RXOFLW_MASK)
|——————Node:( Text: (
|——————Node:binary_expression Text: isr & XCAN_IXR_RXOFLW_MASK
|———————Node:identifier Text: isr
|———————Node:& Text: &
|———————Node:identifier Text: XCAN_IXR_RXOFLW_MASK
|——————Node:) Text: )
|—————Node:compound_statement Text: {
		stats->rx_over_errors++;
		stats->rx_errors++;
		priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
		if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: stats->rx_over_errors++;
|———————Node:update_expression Text: stats->rx_over_errors++
|————————Node:field_expression Text: stats->rx_over_errors
|—————————Node:identifier Text: stats
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_over_errors
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:expression_statement Text: stats->rx_errors++;
|———————Node:update_expression Text: stats->rx_errors++
|————————Node:field_expression Text: stats->rx_errors
|—————————Node:identifier Text: stats
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_errors
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:expression_statement Text: priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);
|———————Node:call_expression Text: priv->p.write_reg(&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK)
|————————Node:field_expression Text: priv->p.write_reg
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write_reg
|————————Node:argument_list Text: (&priv->p, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_SRR_OFFSET
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_SRR_RESET_MASK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (skb) {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (skb)
|————————Node:( Text: (
|————————Node:identifier Text: skb
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			cf->can_id |= CAN_ERR_CRTL;
			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: cf->can_id |= CAN_ERR_CRTL;
|—————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_CRTL
|——————————Node:field_expression Text: cf->can_id
|———————————Node:identifier Text: cf
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: can_id
|——————————Node:|= Text: |=
|——————————Node:identifier Text: CAN_ERR_CRTL
|—————————Node:; Text: ;
|————————Node:expression_statement Text: cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
|—————————Node:assignment_expression Text: cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW
|——————————Node:subscript_expression Text: cf->data[1]
|———————————Node:field_expression Text: cf->data
|————————————Node:identifier Text: cf
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: data
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:|= Text: |=
|——————————Node:identifier Text: CAN_ERR_CRTL_RX_OVERFLOW
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:comment Text: /* Check for error interrupt */
|————Node:if_statement Text: if (isr & XCAN_IXR_ERROR_MASK) {
		if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		/* Check for Ack error interrupt */
		if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}

		/* Check for Bit error interrupt */
		if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}

		/* Check for Stuff error interrupt */
		if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}

		/* Check for Form error interrupt */
		if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}

		/* Check for CRC error interrupt */
		if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
			priv->can.can_stats.bus_error++;
	}
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (isr & XCAN_IXR_ERROR_MASK)
|——————Node:( Text: (
|——————Node:binary_expression Text: isr & XCAN_IXR_ERROR_MASK
|———————Node:identifier Text: isr
|———————Node:& Text: &
|———————Node:identifier Text: XCAN_IXR_ERROR_MASK
|——————Node:) Text: )
|—————Node:compound_statement Text: {
		if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		/* Check for Ack error interrupt */
		if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}

		/* Check for Bit error interrupt */
		if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}

		/* Check for Stuff error interrupt */
		if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}

		/* Check for Form error interrupt */
		if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}

		/* Check for CRC error interrupt */
		if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
			priv->can.can_stats.bus_error++;
	}
|——————Node:{ Text: {
|——————Node:if_statement Text: if (skb)
			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (skb)
|————————Node:( Text: (
|————————Node:identifier Text: skb
|————————Node:) Text: )
|———————Node:expression_statement Text: cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
|————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR
|—————————Node:field_expression Text: cf->can_id
|——————————Node:identifier Text: cf
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_id
|—————————Node:|= Text: |=
|—————————Node:binary_expression Text: CAN_ERR_PROT | CAN_ERR_BUSERROR
|——————————Node:identifier Text: CAN_ERR_PROT
|——————————Node:| Text: |
|——————————Node:identifier Text: CAN_ERR_BUSERROR
|————————Node:; Text: ;
|——————Node:comment Text: /* Check for Ack error interrupt */
|——————Node:if_statement Text: if (err_status & XCAN_ESR_ACKER_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (err_status & XCAN_ESR_ACKER_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: err_status & XCAN_ESR_ACKER_MASK
|—————————Node:identifier Text: err_status
|—————————Node:& Text: &
|—————————Node:identifier Text: XCAN_ESR_ACKER_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: stats->tx_errors++;
|—————————Node:update_expression Text: stats->tx_errors++
|——————————Node:field_expression Text: stats->tx_errors
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: tx_errors
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
				cf->can_id |= CAN_ERR_ACK;
				cf->data[3] = CAN_ERR_PROT_LOC_ACK;
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_ACK;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_ACK
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_ACK
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[3] = CAN_ERR_PROT_LOC_ACK;
|———————————Node:assignment_expression Text: cf->data[3] = CAN_ERR_PROT_LOC_ACK
|————————————Node:subscript_expression Text: cf->data[3]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 3
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_ERR_PROT_LOC_ACK
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:comment Text: /* Check for Bit error interrupt */
|——————Node:if_statement Text: if (err_status & XCAN_ESR_BERR_MASK) {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (err_status & XCAN_ESR_BERR_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: err_status & XCAN_ESR_BERR_MASK
|—————————Node:identifier Text: err_status
|—————————Node:& Text: &
|—————————Node:identifier Text: XCAN_ESR_BERR_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			stats->tx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: stats->tx_errors++;
|—————————Node:update_expression Text: stats->tx_errors++
|——————————Node:field_expression Text: stats->tx_errors
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: tx_errors
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_BIT;
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_PROT;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_PROT
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_PROT
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[2] = CAN_ERR_PROT_BIT;
|———————————Node:assignment_expression Text: cf->data[2] = CAN_ERR_PROT_BIT
|————————————Node:subscript_expression Text: cf->data[2]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 2
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_ERR_PROT_BIT
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:comment Text: /* Check for Stuff error interrupt */
|——————Node:if_statement Text: if (err_status & XCAN_ESR_STER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (err_status & XCAN_ESR_STER_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: err_status & XCAN_ESR_STER_MASK
|—————————Node:identifier Text: err_status
|—————————Node:& Text: &
|—————————Node:identifier Text: XCAN_ESR_STER_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: stats->rx_errors++;
|—————————Node:update_expression Text: stats->rx_errors++
|——————————Node:field_expression Text: stats->rx_errors
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx_errors
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_STUFF;
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_PROT;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_PROT
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_PROT
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[2] = CAN_ERR_PROT_STUFF;
|———————————Node:assignment_expression Text: cf->data[2] = CAN_ERR_PROT_STUFF
|————————————Node:subscript_expression Text: cf->data[2]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 2
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_ERR_PROT_STUFF
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:comment Text: /* Check for Form error interrupt */
|——————Node:if_statement Text: if (err_status & XCAN_ESR_FMER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (err_status & XCAN_ESR_FMER_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: err_status & XCAN_ESR_FMER_MASK
|—————————Node:identifier Text: err_status
|—————————Node:& Text: &
|—————————Node:identifier Text: XCAN_ESR_FMER_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: stats->rx_errors++;
|—————————Node:update_expression Text: stats->rx_errors++
|——————————Node:field_expression Text: stats->rx_errors
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx_errors
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[2] = CAN_ERR_PROT_FORM;
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_PROT;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_PROT
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_PROT
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[2] = CAN_ERR_PROT_FORM;
|———————————Node:assignment_expression Text: cf->data[2] = CAN_ERR_PROT_FORM
|————————————Node:subscript_expression Text: cf->data[2]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 2
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_ERR_PROT_FORM
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:comment Text: /* Check for CRC error interrupt */
|——————Node:if_statement Text: if (err_status & XCAN_ESR_CRCER_MASK) {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (err_status & XCAN_ESR_CRCER_MASK)
|————————Node:( Text: (
|————————Node:binary_expression Text: err_status & XCAN_ESR_CRCER_MASK
|—————————Node:identifier Text: err_status
|—————————Node:& Text: &
|—————————Node:identifier Text: XCAN_ESR_CRCER_MASK
|————————Node:) Text: )
|———————Node:compound_statement Text: {
			stats->rx_errors++;
			if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: stats->rx_errors++;
|—————————Node:update_expression Text: stats->rx_errors++
|——————————Node:field_expression Text: stats->rx_errors
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx_errors
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (skb) {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (skb)
|——————————Node:( Text: (
|——————————Node:identifier Text: skb
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
				cf->can_id |= CAN_ERR_PROT;
				cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cf->can_id |= CAN_ERR_PROT;
|———————————Node:assignment_expression Text: cf->can_id |= CAN_ERR_PROT
|————————————Node:field_expression Text: cf->can_id
|—————————————Node:identifier Text: cf
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can_id
|————————————Node:|= Text: |=
|————————————Node:identifier Text: CAN_ERR_PROT
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
|———————————Node:assignment_expression Text: cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ
|————————————Node:subscript_expression Text: cf->data[3]
|—————————————Node:field_expression Text: cf->data
|——————————————Node:identifier Text: cf
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: data
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 3
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: CAN_ERR_PROT_LOC_CRC_SEQ
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:expression_statement Text: priv->can.can_stats.bus_error++;
|———————Node:update_expression Text: priv->can.can_stats.bus_error++
|————————Node:field_expression Text: priv->can.can_stats.bus_error
|—————————Node:field_expression Text: priv->can.can_stats
|——————————Node:field_expression Text: priv->can
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: can
|——————————Node:. Text: .
|——————————Node:field_identifier Text: can_stats
|—————————Node:. Text: .
|—————————Node:field_identifier Text: bus_error
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:if_statement Text: if (skb) {
		stats->rx_packets++;
		stats->rx_bytes += cf->can_dlc;
		netif_rx(skb);
	}
|—————Node:if Text: if
|—————Node:parenthesized_expression Text: (skb)
|——————Node:( Text: (
|——————Node:identifier Text: skb
|——————Node:) Text: )
|—————Node:compound_statement Text: {
		stats->rx_packets++;
		stats->rx_bytes += cf->can_dlc;
		netif_rx(skb);
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: stats->rx_packets++;
|———————Node:update_expression Text: stats->rx_packets++
|————————Node:field_expression Text: stats->rx_packets
|—————————Node:identifier Text: stats
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_packets
|————————Node:++ Text: ++
|———————Node:; Text: ;
|——————Node:expression_statement Text: stats->rx_bytes += cf->can_dlc;
|———————Node:assignment_expression Text: stats->rx_bytes += cf->can_dlc
|————————Node:field_expression Text: stats->rx_bytes
|—————————Node:identifier Text: stats
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_bytes
|————————Node:+= Text: +=
|————————Node:field_expression Text: cf->can_dlc
|—————————Node:identifier Text: cf
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: can_dlc
|———————Node:; Text: ;
|——————Node:expression_statement Text: netif_rx(skb);
|———————Node:call_expression Text: netif_rx(skb)
|————————Node:identifier Text: netif_rx
|————————Node:argument_list Text: (skb)
|—————————Node:( Text: (
|—————————Node:identifier Text: skb
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:expression_statement Text: netdev_dbg(ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET));
|—————Node:call_expression Text: netdev_dbg(ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET))
|——————Node:identifier Text: netdev_dbg
|——————Node:argument_list Text: (ndev, "%s: error status register:0x%x\n",
			__func__, priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET))
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:, Text: ,
|———————Node:string_literal Text: "%s: error status register:0x%x\n"
|————————Node:" Text: "
|————————Node:string_content Text: %s: error status register:0x%x
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:, Text: ,
|———————Node:identifier Text: __func__
|———————Node:, Text: ,
|———————Node:call_expression Text: priv->p.read_reg(&priv->p, XCAN_ESR_OFFSET)
|————————Node:field_expression Text: priv->p.read_reg
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|—————————Node:. Text: .
|—————————Node:field_identifier Text: read_reg
|————————Node:argument_list Text: (&priv->p, XCAN_ESR_OFFSET)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: XCAN_ESR_OFFSET
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:#endif Text: #endif
|—Node:comment Text: /**
 * ctucan_rx_poll - Poll routine for rx packets (NAPI)
 * @napi:	napi structure pointer
 * @quota:	Max number of rx packets to be processed.
 *
 * This is the poll routine for rx part.
 * It will process the packets maximux quota value.
 *
 * Return: number of packets received
 */
|—Node:function_definition Text: static int ctucan_rx_poll(struct napi_struct *napi, int quota)
{
	struct net_device *ndev = napi->dev;
	struct ctucan_priv *priv = netdev_priv(ndev);
	int work_done = 0;
	union ctu_can_fd_int_stat isr, iec;
	//netdev_info(ndev, "ctucan_rx_poll");

	iec.u32 = 0;
	iec.s.rbnei = 1;

	/* Get the interrupt status */
	isr = ctu_can_fd_int_sts(&priv->p);
	while (isr.s.rbnei && work_done < quota) {
		ctu_can_fd_int_clr(&priv->p, iec);
		ctucan_rx(ndev);
		work_done++;
		isr = ctu_can_fd_int_sts(&priv->p);
	}

	if (work_done)
		can_led_event(ndev, CAN_LED_EVENT_RX);

	if (work_done < quota) {
		napi_complete(napi);
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32);
	}

	return work_done;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_rx_poll(struct napi_struct *napi, int quota)
|———Node:identifier Text: ctucan_rx_poll
|———Node:parameter_list Text: (struct napi_struct *napi, int quota)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct napi_struct *napi
|—————Node:struct_specifier Text: struct napi_struct
|——————Node:struct Text: struct
|——————Node:type_identifier Text: napi_struct
|—————Node:pointer_declarator Text: *napi
|——————Node:* Text: *
|——————Node:identifier Text: napi
|————Node:, Text: ,
|————Node:parameter_declaration Text: int quota
|—————Node:primitive_type Text: int
|—————Node:identifier Text: quota
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct net_device *ndev = napi->dev;
	struct ctucan_priv *priv = netdev_priv(ndev);
	int work_done = 0;
	union ctu_can_fd_int_stat isr, iec;
	//netdev_info(ndev, "ctucan_rx_poll");

	iec.u32 = 0;
	iec.s.rbnei = 1;

	/* Get the interrupt status */
	isr = ctu_can_fd_int_sts(&priv->p);
	while (isr.s.rbnei && work_done < quota) {
		ctu_can_fd_int_clr(&priv->p, iec);
		ctucan_rx(ndev);
		work_done++;
		isr = ctu_can_fd_int_sts(&priv->p);
	}

	if (work_done)
		can_led_event(ndev, CAN_LED_EVENT_RX);

	if (work_done < quota) {
		napi_complete(napi);
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32);
	}

	return work_done;
}
|———Node:{ Text: {
|———Node:declaration Text: struct net_device *ndev = napi->dev;
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: *ndev = napi->dev
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:field_expression Text: napi->dev
|——————Node:identifier Text: napi
|——————Node:-> Text: ->
|——————Node:field_identifier Text: dev
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int work_done = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: work_done = 0
|—————Node:identifier Text: work_done
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_int_stat isr, iec;
|————Node:union_specifier Text: union ctu_can_fd_int_stat
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_int_stat
|————Node:identifier Text: isr
|————Node:, Text: ,
|————Node:identifier Text: iec
|————Node:; Text: ;
|———Node:comment Text: //netdev_info(ndev, "ctucan_rx_poll");
|———Node:expression_statement Text: iec.u32 = 0;
|————Node:assignment_expression Text: iec.u32 = 0
|—————Node:field_expression Text: iec.u32
|——————Node:identifier Text: iec
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: iec.s.rbnei = 1;
|————Node:assignment_expression Text: iec.s.rbnei = 1
|—————Node:field_expression Text: iec.s.rbnei
|——————Node:field_expression Text: iec.s
|———————Node:identifier Text: iec
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rbnei
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:comment Text: /* Get the interrupt status */
|———Node:expression_statement Text: isr = ctu_can_fd_int_sts(&priv->p);
|————Node:assignment_expression Text: isr = ctu_can_fd_int_sts(&priv->p)
|—————Node:identifier Text: isr
|—————Node:= Text: =
|—————Node:call_expression Text: ctu_can_fd_int_sts(&priv->p)
|——————Node:identifier Text: ctu_can_fd_int_sts
|——————Node:argument_list Text: (&priv->p)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:while_statement Text: while (isr.s.rbnei && work_done < quota) {
		ctu_can_fd_int_clr(&priv->p, iec);
		ctucan_rx(ndev);
		work_done++;
		isr = ctu_can_fd_int_sts(&priv->p);
	}
|————Node:while Text: while
|————Node:parenthesized_expression Text: (isr.s.rbnei && work_done < quota)
|—————Node:( Text: (
|—————Node:binary_expression Text: isr.s.rbnei && work_done < quota
|——————Node:field_expression Text: isr.s.rbnei
|———————Node:field_expression Text: isr.s
|————————Node:identifier Text: isr
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: rbnei
|——————Node:&& Text: &&
|——————Node:binary_expression Text: work_done < quota
|———————Node:identifier Text: work_done
|———————Node:< Text: <
|———————Node:identifier Text: quota
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ctu_can_fd_int_clr(&priv->p, iec);
		ctucan_rx(ndev);
		work_done++;
		isr = ctu_can_fd_int_sts(&priv->p);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ctu_can_fd_int_clr(&priv->p, iec);
|——————Node:call_expression Text: ctu_can_fd_int_clr(&priv->p, iec)
|———————Node:identifier Text: ctu_can_fd_int_clr
|———————Node:argument_list Text: (&priv->p, iec)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: iec
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctucan_rx(ndev);
|——————Node:call_expression Text: ctucan_rx(ndev)
|———————Node:identifier Text: ctucan_rx
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: work_done++;
|——————Node:update_expression Text: work_done++
|———————Node:identifier Text: work_done
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:expression_statement Text: isr = ctu_can_fd_int_sts(&priv->p);
|——————Node:assignment_expression Text: isr = ctu_can_fd_int_sts(&priv->p)
|———————Node:identifier Text: isr
|———————Node:= Text: =
|———————Node:call_expression Text: ctu_can_fd_int_sts(&priv->p)
|————————Node:identifier Text: ctu_can_fd_int_sts
|————————Node:argument_list Text: (&priv->p)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (work_done)
		can_led_event(ndev, CAN_LED_EVENT_RX);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (work_done)
|—————Node:( Text: (
|—————Node:identifier Text: work_done
|—————Node:) Text: )
|————Node:expression_statement Text: can_led_event(ndev, CAN_LED_EVENT_RX);
|—————Node:call_expression Text: can_led_event(ndev, CAN_LED_EVENT_RX)
|——————Node:identifier Text: can_led_event
|——————Node:argument_list Text: (ndev, CAN_LED_EVENT_RX)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:, Text: ,
|———————Node:identifier Text: CAN_LED_EVENT_RX
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:if_statement Text: if (work_done < quota) {
		napi_complete(napi);
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (work_done < quota)
|—————Node:( Text: (
|—————Node:binary_expression Text: work_done < quota
|——————Node:identifier Text: work_done
|——————Node:< Text: <
|——————Node:identifier Text: quota
|—————Node:) Text: )
|————Node:compound_statement Text: {
		napi_complete(napi);
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: napi_complete(napi);
|——————Node:call_expression Text: napi_complete(napi)
|———————Node:identifier Text: napi_complete
|———————Node:argument_list Text: (napi)
|————————Node:( Text: (
|————————Node:identifier Text: napi
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32);
|——————Node:call_expression Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32)
|———————Node:field_expression Text: priv->p.write_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: write_reg
|———————Node:argument_list Text: (&priv->p, CTU_CAN_FD_INT_ENA_SET, iec.u32)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: CTU_CAN_FD_INT_ENA_SET
|————————Node:, Text: ,
|————————Node:field_expression Text: iec.u32
|—————————Node:identifier Text: iec
|—————————Node:. Text: .
|—————————Node:field_identifier Text: u32
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return work_done;
|————Node:return Text: return
|————Node:identifier Text: work_done
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static void ctucan_rotate_txb_prio(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	u32 prio = priv->txb_prio;
	u32 nbuffersm1 = priv->txb_mask; /* nbuffers - 1 */

	prio = (prio << 4) | ((prio >> (nbuffersm1*4)) & 0xF);
	netdev_info(ndev, "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x", priv->txb_prio, prio);
	priv->txb_prio = prio;
	priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, prio);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_rotate_txb_prio(struct net_device *ndev)
|———Node:identifier Text: ctucan_rotate_txb_prio
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	u32 prio = priv->txb_prio;
	u32 nbuffersm1 = priv->txb_mask; /* nbuffers - 1 */

	prio = (prio << 4) | ((prio >> (nbuffersm1*4)) & 0xF);
	netdev_info(ndev, "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x", priv->txb_prio, prio);
	priv->txb_prio = prio;
	priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, prio);
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: u32 prio = priv->txb_prio;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: prio = priv->txb_prio
|—————Node:identifier Text: prio
|—————Node:= Text: =
|—————Node:field_expression Text: priv->txb_prio
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_prio
|————Node:; Text: ;
|———Node:declaration Text: u32 nbuffersm1 = priv->txb_mask;
|————Node:type_identifier Text: u32
|————Node:init_declarator Text: nbuffersm1 = priv->txb_mask
|—————Node:identifier Text: nbuffersm1
|—————Node:= Text: =
|—————Node:field_expression Text: priv->txb_mask
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_mask
|————Node:; Text: ;
|———Node:comment Text: /* nbuffers - 1 */
|———Node:expression_statement Text: prio = (prio << 4) | ((prio >> (nbuffersm1*4)) & 0xF);
|————Node:assignment_expression Text: prio = (prio << 4) | ((prio >> (nbuffersm1*4)) & 0xF)
|—————Node:identifier Text: prio
|—————Node:= Text: =
|—————Node:binary_expression Text: (prio << 4) | ((prio >> (nbuffersm1*4)) & 0xF)
|——————Node:parenthesized_expression Text: (prio << 4)
|———————Node:( Text: (
|———————Node:binary_expression Text: prio << 4
|————————Node:identifier Text: prio
|————————Node:<< Text: <<
|————————Node:number_literal Text: 4
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: ((prio >> (nbuffersm1*4)) & 0xF)
|———————Node:( Text: (
|———————Node:binary_expression Text: (prio >> (nbuffersm1*4)) & 0xF
|————————Node:parenthesized_expression Text: (prio >> (nbuffersm1*4))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: prio >> (nbuffersm1*4)
|——————————Node:identifier Text: prio
|——————————Node:>> Text: >>
|——————————Node:parenthesized_expression Text: (nbuffersm1*4)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nbuffersm1*4
|————————————Node:identifier Text: nbuffersm1
|————————————Node:* Text: *
|————————————Node:number_literal Text: 4
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0xF
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x", priv->txb_prio, prio);
|————Node:call_expression Text: netdev_info(ndev, "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x", priv->txb_prio, prio)
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x", priv->txb_prio, prio)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_rotate_txb_prio: from 0x%08x to 0x%08x"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_rotate_txb_prio: from 0x%08x to 0x%08x
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->txb_prio
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txb_prio
|——————Node:, Text: ,
|——————Node:identifier Text: prio
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_prio = prio;
|————Node:assignment_expression Text: priv->txb_prio = prio
|—————Node:field_expression Text: priv->txb_prio
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_prio
|—————Node:= Text: =
|—————Node:identifier Text: prio
|————Node:; Text: ;
|———Node:expression_statement Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, prio);
|————Node:call_expression Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_TX_PRIORITY, prio)
|—————Node:field_expression Text: priv->p.write_reg
|——————Node:field_expression Text: priv->p
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: p
|——————Node:. Text: .
|——————Node:field_identifier Text: write_reg
|—————Node:argument_list Text: (&priv->p, CTU_CAN_FD_TX_PRIORITY, prio)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: CTU_CAN_FD_TX_PRIORITY
|——————Node:, Text: ,
|——————Node:identifier Text: prio
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * xcan_tx_interrupt - Tx Done Isr
 * @ndev:	net_device pointer
 * @isr:	Interrupt status register value
 */
|—Node:function_definition Text: static void ctucan_tx_interrupt(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	netdev_info(ndev, "ctucan_tx_interrupt");

	/*
		read tx_status
		if txb[n].finished (bit 2)
			if ok -> echo
			if error / aborted -> ?? (find how to handle oneshot mode)
			txb_tail++
	*/


	while ((priv->txb_head - priv->txb_tail > 0)) {
		u32 txb_idx = priv->txb_tail & priv->txb_mask;
		u32 status = ctu_can_fd_get_tx_status(&priv->p, txb_idx);

		netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status);
		switch (status) {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
		priv->txb_tail++;

		/* Adjust priorities *before* marking the buffer as empty. */
		ctucan_rotate_txb_prio(ndev);
		ctu_can_fd_txt_set_empty(&priv->p, txb_idx);
	}
	can_led_event(ndev, CAN_LED_EVENT_TX);
	netif_wake_queue(ndev);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_tx_interrupt(struct net_device *ndev)
|———Node:identifier Text: ctucan_tx_interrupt
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	struct net_device_stats *stats = &ndev->stats;
	netdev_info(ndev, "ctucan_tx_interrupt");

	/*
		read tx_status
		if txb[n].finished (bit 2)
			if ok -> echo
			if error / aborted -> ?? (find how to handle oneshot mode)
			txb_tail++
	*/


	while ((priv->txb_head - priv->txb_tail > 0)) {
		u32 txb_idx = priv->txb_tail & priv->txb_mask;
		u32 status = ctu_can_fd_get_tx_status(&priv->p, txb_idx);

		netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status);
		switch (status) {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
		priv->txb_tail++;

		/* Adjust priorities *before* marking the buffer as empty. */
		ctucan_rotate_txb_prio(ndev);
		ctu_can_fd_txt_set_empty(&priv->p, txb_idx);
	}
	can_led_event(ndev, CAN_LED_EVENT_TX);
	netif_wake_queue(ndev);
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct net_device_stats *stats = &ndev->stats;
|————Node:struct_specifier Text: struct net_device_stats
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device_stats
|————Node:init_declarator Text: *stats = &ndev->stats
|—————Node:pointer_declarator Text: *stats
|——————Node:* Text: *
|——————Node:identifier Text: stats
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ndev->stats
|——————Node:& Text: &
|——————Node:field_expression Text: ndev->stats
|———————Node:identifier Text: ndev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stats
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_tx_interrupt");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_tx_interrupt")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_tx_interrupt")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_tx_interrupt"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_tx_interrupt
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*
		read tx_status
		if txb[n].finished (bit 2)
			if ok -> echo
			if error / aborted -> ?? (find how to handle oneshot mode)
			txb_tail++
	*/
|———Node:while_statement Text: while ((priv->txb_head - priv->txb_tail > 0)) {
		u32 txb_idx = priv->txb_tail & priv->txb_mask;
		u32 status = ctu_can_fd_get_tx_status(&priv->p, txb_idx);

		netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status);
		switch (status) {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
		priv->txb_tail++;

		/* Adjust priorities *before* marking the buffer as empty. */
		ctucan_rotate_txb_prio(ndev);
		ctu_can_fd_txt_set_empty(&priv->p, txb_idx);
	}
|————Node:while Text: while
|————Node:parenthesized_expression Text: ((priv->txb_head - priv->txb_tail > 0))
|—————Node:( Text: (
|—————Node:parenthesized_expression Text: (priv->txb_head - priv->txb_tail > 0)
|——————Node:( Text: (
|——————Node:binary_expression Text: priv->txb_head - priv->txb_tail > 0
|———————Node:binary_expression Text: priv->txb_head - priv->txb_tail
|————————Node:field_expression Text: priv->txb_head
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txb_head
|————————Node:- Text: -
|————————Node:field_expression Text: priv->txb_tail
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txb_tail
|———————Node:> Text: >
|———————Node:number_literal Text: 0
|——————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		u32 txb_idx = priv->txb_tail & priv->txb_mask;
		u32 status = ctu_can_fd_get_tx_status(&priv->p, txb_idx);

		netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status);
		switch (status) {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
		priv->txb_tail++;

		/* Adjust priorities *before* marking the buffer as empty. */
		ctucan_rotate_txb_prio(ndev);
		ctu_can_fd_txt_set_empty(&priv->p, txb_idx);
	}
|—————Node:{ Text: {
|—————Node:declaration Text: u32 txb_idx = priv->txb_tail & priv->txb_mask;
|——————Node:type_identifier Text: u32
|——————Node:init_declarator Text: txb_idx = priv->txb_tail & priv->txb_mask
|———————Node:identifier Text: txb_idx
|———————Node:= Text: =
|———————Node:binary_expression Text: priv->txb_tail & priv->txb_mask
|————————Node:field_expression Text: priv->txb_tail
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txb_tail
|————————Node:& Text: &
|————————Node:field_expression Text: priv->txb_mask
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txb_mask
|——————Node:; Text: ;
|—————Node:declaration Text: u32 status = ctu_can_fd_get_tx_status(&priv->p, txb_idx);
|——————Node:type_identifier Text: u32
|——————Node:init_declarator Text: status = ctu_can_fd_get_tx_status(&priv->p, txb_idx)
|———————Node:identifier Text: status
|———————Node:= Text: =
|———————Node:call_expression Text: ctu_can_fd_get_tx_status(&priv->p, txb_idx)
|————————Node:identifier Text: ctu_can_fd_get_tx_status
|————————Node:argument_list Text: (&priv->p, txb_idx)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &priv->p
|——————————Node:& Text: &
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|—————————Node:, Text: ,
|—————————Node:identifier Text: txb_idx
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status);
|——————Node:call_expression Text: netdev_info(ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status)
|———————Node:identifier Text: netdev_info
|———————Node:argument_list Text: (ndev, "TXI: TXB#%u: status 0x%x", txb_idx, status)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "TXI: TXB#%u: status 0x%x"
|—————————Node:" Text: "
|—————————Node:string_content Text: TXI: TXB#%u: status 0x%x
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: txb_idx
|————————Node:, Text: ,
|————————Node:identifier Text: status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:switch_statement Text: switch (status) {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
|——————Node:switch Text: switch
|——————Node:parenthesized_expression Text: (status)
|———————Node:( Text: (
|———————Node:identifier Text: status
|———————Node:) Text: )
|——————Node:compound_statement Text: {
		case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
		case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
		default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
		}
|———————Node:{ Text: {
|———————Node:case_statement Text: case TXT_TOK:
			netdev_info(ndev, "TXT_OK");
			can_get_echo_skb(ndev, txb_idx);
			stats->tx_packets++;
		break;
|————————Node:case Text: case
|————————Node:identifier Text: TXT_TOK
|————————Node:: Text: :
|————————Node:expression_statement Text: netdev_info(ndev, "TXT_OK");
|—————————Node:call_expression Text: netdev_info(ndev, "TXT_OK")
|——————————Node:identifier Text: netdev_info
|——————————Node:argument_list Text: (ndev, "TXT_OK")
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "TXT_OK"
|————————————Node:" Text: "
|————————————Node:string_content Text: TXT_OK
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: can_get_echo_skb(ndev, txb_idx);
|—————————Node:call_expression Text: can_get_echo_skb(ndev, txb_idx)
|——————————Node:identifier Text: can_get_echo_skb
|——————————Node:argument_list Text: (ndev, txb_idx)
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:identifier Text: txb_idx
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: stats->tx_packets++;
|—————————Node:update_expression Text: stats->tx_packets++
|——————————Node:field_expression Text: stats->tx_packets
|———————————Node:identifier Text: stats
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: tx_packets
|——————————Node:++ Text: ++
|—————————Node:; Text: ;
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case TXT_ERR:
			netdev_warn(ndev, "TXB in Error state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
|————————Node:case Text: case
|————————Node:identifier Text: TXT_ERR
|————————Node:: Text: :
|————————Node:expression_statement Text: netdev_warn(ndev, "TXB in Error state");
|—————————Node:call_expression Text: netdev_warn(ndev, "TXB in Error state")
|——————————Node:identifier Text: netdev_warn
|——————————Node:argument_list Text: (ndev, "TXB in Error state")
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "TXB in Error state"
|————————————Node:" Text: "
|————————————Node:string_content Text: TXB in Error state
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: can_free_echo_skb(ndev, txb_idx);
|—————————Node:call_expression Text: can_free_echo_skb(ndev, txb_idx)
|——————————Node:identifier Text: can_free_echo_skb
|——————————Node:argument_list Text: (ndev, txb_idx)
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:identifier Text: txb_idx
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: // TODO: send some error frame - but what should it contain?
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case TXT_ABT:
			netdev_warn(ndev, "TXB in Aborted state");
			can_free_echo_skb(ndev, txb_idx);
			// TODO: send some error frame - but what should it contain?
		break;
|————————Node:case Text: case
|————————Node:identifier Text: TXT_ABT
|————————Node:: Text: :
|————————Node:expression_statement Text: netdev_warn(ndev, "TXB in Aborted state");
|—————————Node:call_expression Text: netdev_warn(ndev, "TXB in Aborted state")
|——————————Node:identifier Text: netdev_warn
|——————————Node:argument_list Text: (ndev, "TXB in Aborted state")
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "TXB in Aborted state"
|————————————Node:" Text: "
|————————————Node:string_content Text: TXB in Aborted state
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: can_free_echo_skb(ndev, txb_idx);
|—————————Node:call_expression Text: can_free_echo_skb(ndev, txb_idx)
|——————————Node:identifier Text: can_free_echo_skb
|——————————Node:argument_list Text: (ndev, txb_idx)
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:identifier Text: txb_idx
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: // TODO: send some error frame - but what should it contain?
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: default:
			netdev_err(ndev, "BUG: TXB not in a finished state!");
			// what to do???
			return;
|————————Node:default Text: default
|————————Node:: Text: :
|————————Node:expression_statement Text: netdev_err(ndev, "BUG: TXB not in a finished state!");
|—————————Node:call_expression Text: netdev_err(ndev, "BUG: TXB not in a finished state!")
|——————————Node:identifier Text: netdev_err
|——————————Node:argument_list Text: (ndev, "BUG: TXB not in a finished state!")
|———————————Node:( Text: (
|———————————Node:identifier Text: ndev
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "BUG: TXB not in a finished state!"
|————————————Node:" Text: "
|————————————Node:string_content Text: BUG: TXB not in a finished state!
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: // what to do???
|————————Node:return_statement Text: return;
|—————————Node:return Text: return
|—————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: priv->txb_tail++;
|——————Node:update_expression Text: priv->txb_tail++
|———————Node:field_expression Text: priv->txb_tail
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: txb_tail
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:comment Text: /* Adjust priorities *before* marking the buffer as empty. */
|—————Node:expression_statement Text: ctucan_rotate_txb_prio(ndev);
|——————Node:call_expression Text: ctucan_rotate_txb_prio(ndev)
|———————Node:identifier Text: ctucan_rotate_txb_prio
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctu_can_fd_txt_set_empty(&priv->p, txb_idx);
|——————Node:call_expression Text: ctu_can_fd_txt_set_empty(&priv->p, txb_idx)
|———————Node:identifier Text: ctu_can_fd_txt_set_empty
|———————Node:argument_list Text: (&priv->p, txb_idx)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: txb_idx
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: can_led_event(ndev, CAN_LED_EVENT_TX);
|————Node:call_expression Text: can_led_event(ndev, CAN_LED_EVENT_TX)
|—————Node:identifier Text: can_led_event
|—————Node:argument_list Text: (ndev, CAN_LED_EVENT_TX)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_LED_EVENT_TX
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netif_wake_queue(ndev);
|————Node:call_expression Text: netif_wake_queue(ndev)
|—————Node:identifier Text: netif_wake_queue
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * xcan_interrupt - CAN Isr
 * @irq:	irq number
 * @dev_id:	device id poniter
 *
 * This is the xilinx CAN Isr. It checks for the type of interrupt
 * and invokes the corresponding ISR.
 *
 * Return:
 * IRQ_NONE - If CAN device is in sleep mode, IRQ_HANDLED otherwise
 */
|—Node:function_definition Text: static irqreturn_t ctucan_interrupt(int irq, void *dev_id)
{
	struct net_device *ndev = (struct net_device *)dev_id;
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat isr, icr;
	netdev_info(ndev, "ctucan_interrupt");

	/* Get the interrupt status */
	isr = ctu_can_fd_int_sts(&priv->p);

	if (!isr.u32)
		return IRQ_NONE;

	/* Receive Buffer Not Empty Interrupt */
	if (isr.s.rbnei) {
		netdev_info(ndev, "RXBNEI");
		icr.u32 = 0;
		icr.s.rbnei = 1;
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32);
		napi_schedule(&priv->napi);
	}
	#define CTUCANFD_INT_RI      BIT(0)
	#define CTUCANFD_INT_TI      BIT(1)
	#define CTUCANFD_INT_EI      BIT(2)
	#define CTUCANFD_INT_DOI     BIT(3)
	#define CTUCANFD_INT_EPI     BIT(4)
	#define CTUCANFD_INT_ALI     BIT(5)
	#define CTUCANFD_INT_BEI     BIT(6)
	#define CTUCANFD_INT_LFI     BIT(7)
	#define CTUCANFD_INT_RFI     BIT(8)
	#define CTUCANFD_INT_BSI     BIT(9)
	#define CTUCANFD_INT_RBNEI   BIT(10)
	#define CTUCANFD_INT_TXBHCI  BIT(11)
	#define CTUCANFD_INT_ERROR (CTUCANFD_INT_EI | CTUCANFD_INT_DOI | CTUCANFD_INT_EPI | CTUCANFD_INT_ALI | CTUCANFD_INT_BEI)

	/* TX Buffer HW Command Interrupt */
	if (isr.s.txbhci) {
		netdev_info(ndev, "TXBHCI");
		icr.u32 = 0;
		icr.s.txbhci = 1;
		ctu_can_fd_int_clr(&priv->p, icr);
		ctucan_tx_interrupt(ndev);
	}

	/* Error interrupts */
	if (isr.s.ei || isr.s.doi || isr.s.epi || isr.s.ali) {
		icr.u32 = isr.u32 & CTUCANFD_INT_ERROR;
		ctu_can_fd_int_clr(&priv->p, icr);
		netdev_warn(ndev, "err interrupt handler not implemented!");
		//ctucan_err_interrupt(ndev, isr);
	}

	/* Ignore RI, TI, LFI, RFI, BSI */

	return IRQ_HANDLED;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: irqreturn_t
|——Node:function_declarator Text: ctucan_interrupt(int irq, void *dev_id)
|———Node:identifier Text: ctucan_interrupt
|———Node:parameter_list Text: (int irq, void *dev_id)
|————Node:( Text: (
|————Node:parameter_declaration Text: int irq
|—————Node:primitive_type Text: int
|—————Node:identifier Text: irq
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *dev_id
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *dev_id
|——————Node:* Text: *
|——————Node:identifier Text: dev_id
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct net_device *ndev = (struct net_device *)dev_id;
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat isr, icr;
	netdev_info(ndev, "ctucan_interrupt");

	/* Get the interrupt status */
	isr = ctu_can_fd_int_sts(&priv->p);

	if (!isr.u32)
		return IRQ_NONE;

	/* Receive Buffer Not Empty Interrupt */
	if (isr.s.rbnei) {
		netdev_info(ndev, "RXBNEI");
		icr.u32 = 0;
		icr.s.rbnei = 1;
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32);
		napi_schedule(&priv->napi);
	}
	#define CTUCANFD_INT_RI      BIT(0)
	#define CTUCANFD_INT_TI      BIT(1)
	#define CTUCANFD_INT_EI      BIT(2)
	#define CTUCANFD_INT_DOI     BIT(3)
	#define CTUCANFD_INT_EPI     BIT(4)
	#define CTUCANFD_INT_ALI     BIT(5)
	#define CTUCANFD_INT_BEI     BIT(6)
	#define CTUCANFD_INT_LFI     BIT(7)
	#define CTUCANFD_INT_RFI     BIT(8)
	#define CTUCANFD_INT_BSI     BIT(9)
	#define CTUCANFD_INT_RBNEI   BIT(10)
	#define CTUCANFD_INT_TXBHCI  BIT(11)
	#define CTUCANFD_INT_ERROR (CTUCANFD_INT_EI | CTUCANFD_INT_DOI | CTUCANFD_INT_EPI | CTUCANFD_INT_ALI | CTUCANFD_INT_BEI)

	/* TX Buffer HW Command Interrupt */
	if (isr.s.txbhci) {
		netdev_info(ndev, "TXBHCI");
		icr.u32 = 0;
		icr.s.txbhci = 1;
		ctu_can_fd_int_clr(&priv->p, icr);
		ctucan_tx_interrupt(ndev);
	}

	/* Error interrupts */
	if (isr.s.ei || isr.s.doi || isr.s.epi || isr.s.ali) {
		icr.u32 = isr.u32 & CTUCANFD_INT_ERROR;
		ctu_can_fd_int_clr(&priv->p, icr);
		netdev_warn(ndev, "err interrupt handler not implemented!");
		//ctucan_err_interrupt(ndev, isr);
	}

	/* Ignore RI, TI, LFI, RFI, BSI */

	return IRQ_HANDLED;
}
|———Node:{ Text: {
|———Node:declaration Text: struct net_device *ndev = (struct net_device *)dev_id;
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: *ndev = (struct net_device *)dev_id
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:cast_expression Text: (struct net_device *)dev_id
|——————Node:( Text: (
|——————Node:type_descriptor Text: struct net_device *
|———————Node:struct_specifier Text: struct net_device
|————————Node:struct Text: struct
|————————Node:type_identifier Text: net_device
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: dev_id
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_int_stat isr, icr;
|————Node:union_specifier Text: union ctu_can_fd_int_stat
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_int_stat
|————Node:identifier Text: isr
|————Node:, Text: ,
|————Node:identifier Text: icr
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_interrupt");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_interrupt")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_interrupt")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_interrupt"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_interrupt
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Get the interrupt status */
|———Node:expression_statement Text: isr = ctu_can_fd_int_sts(&priv->p);
|————Node:assignment_expression Text: isr = ctu_can_fd_int_sts(&priv->p)
|—————Node:identifier Text: isr
|—————Node:= Text: =
|—————Node:call_expression Text: ctu_can_fd_int_sts(&priv->p)
|——————Node:identifier Text: ctu_can_fd_int_sts
|——————Node:argument_list Text: (&priv->p)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &priv->p
|————————Node:& Text: &
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!isr.u32)
		return IRQ_NONE;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!isr.u32)
|—————Node:( Text: (
|—————Node:unary_expression Text: !isr.u32
|——————Node:! Text: !
|——————Node:field_expression Text: isr.u32
|———————Node:identifier Text: isr
|———————Node:. Text: .
|———————Node:field_identifier Text: u32
|—————Node:) Text: )
|————Node:return_statement Text: return IRQ_NONE;
|—————Node:return Text: return
|—————Node:identifier Text: IRQ_NONE
|—————Node:; Text: ;
|———Node:comment Text: /* Receive Buffer Not Empty Interrupt */
|———Node:if_statement Text: if (isr.s.rbnei) {
		netdev_info(ndev, "RXBNEI");
		icr.u32 = 0;
		icr.s.rbnei = 1;
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32);
		napi_schedule(&priv->napi);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (isr.s.rbnei)
|—————Node:( Text: (
|—————Node:field_expression Text: isr.s.rbnei
|——————Node:field_expression Text: isr.s
|———————Node:identifier Text: isr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: rbnei
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_info(ndev, "RXBNEI");
		icr.u32 = 0;
		icr.s.rbnei = 1;
		priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32);
		napi_schedule(&priv->napi);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_info(ndev, "RXBNEI");
|——————Node:call_expression Text: netdev_info(ndev, "RXBNEI")
|———————Node:identifier Text: netdev_info
|———————Node:argument_list Text: (ndev, "RXBNEI")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "RXBNEI"
|—————————Node:" Text: "
|—————————Node:string_content Text: RXBNEI
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: icr.u32 = 0;
|——————Node:assignment_expression Text: icr.u32 = 0
|———————Node:field_expression Text: icr.u32
|————————Node:identifier Text: icr
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: icr.s.rbnei = 1;
|——————Node:assignment_expression Text: icr.s.rbnei = 1
|———————Node:field_expression Text: icr.s.rbnei
|————————Node:field_expression Text: icr.s
|—————————Node:identifier Text: icr
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: rbnei
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32);
|——————Node:call_expression Text: priv->p.write_reg(&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32)
|———————Node:field_expression Text: priv->p.write_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: write_reg
|———————Node:argument_list Text: (&priv->p, CTU_CAN_FD_INT_ENA_CLR, icr.u32)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: CTU_CAN_FD_INT_ENA_CLR
|————————Node:, Text: ,
|————————Node:field_expression Text: icr.u32
|—————————Node:identifier Text: icr
|—————————Node:. Text: .
|—————————Node:field_identifier Text: u32
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: napi_schedule(&priv->napi);
|——————Node:call_expression Text: napi_schedule(&priv->napi)
|———————Node:identifier Text: napi_schedule
|———————Node:argument_list Text: (&priv->napi)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->napi
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->napi
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: napi
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_def Text: #define CTUCANFD_INT_RI      BIT(0)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_RI
|————Node:preproc_arg Text: BIT(0)
|———Node:preproc_def Text: #define CTUCANFD_INT_TI      BIT(1)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_TI
|————Node:preproc_arg Text: BIT(1)
|———Node:preproc_def Text: #define CTUCANFD_INT_EI      BIT(2)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_EI
|————Node:preproc_arg Text: BIT(2)
|———Node:preproc_def Text: #define CTUCANFD_INT_DOI     BIT(3)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_DOI
|————Node:preproc_arg Text: BIT(3)
|———Node:preproc_def Text: #define CTUCANFD_INT_EPI     BIT(4)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_EPI
|————Node:preproc_arg Text: BIT(4)
|———Node:preproc_def Text: #define CTUCANFD_INT_ALI     BIT(5)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_ALI
|————Node:preproc_arg Text: BIT(5)
|———Node:preproc_def Text: #define CTUCANFD_INT_BEI     BIT(6)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_BEI
|————Node:preproc_arg Text: BIT(6)
|———Node:preproc_def Text: #define CTUCANFD_INT_LFI     BIT(7)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_LFI
|————Node:preproc_arg Text: BIT(7)
|———Node:preproc_def Text: #define CTUCANFD_INT_RFI     BIT(8)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_RFI
|————Node:preproc_arg Text: BIT(8)
|———Node:preproc_def Text: #define CTUCANFD_INT_BSI     BIT(9)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_BSI
|————Node:preproc_arg Text: BIT(9)
|———Node:preproc_def Text: #define CTUCANFD_INT_RBNEI   BIT(10)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_RBNEI
|————Node:preproc_arg Text: BIT(10)
|———Node:preproc_def Text: #define CTUCANFD_INT_TXBHCI  BIT(11)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_TXBHCI
|————Node:preproc_arg Text: BIT(11)
|———Node:preproc_def Text: #define CTUCANFD_INT_ERROR (CTUCANFD_INT_EI | CTUCANFD_INT_DOI | CTUCANFD_INT_EPI | CTUCANFD_INT_ALI | CTUCANFD_INT_BEI)

|————Node:#define Text: #define
|————Node:identifier Text: CTUCANFD_INT_ERROR
|————Node:preproc_arg Text: (CTUCANFD_INT_EI | CTUCANFD_INT_DOI | CTUCANFD_INT_EPI | CTUCANFD_INT_ALI | CTUCANFD_INT_BEI)
|———Node:comment Text: /* TX Buffer HW Command Interrupt */
|———Node:if_statement Text: if (isr.s.txbhci) {
		netdev_info(ndev, "TXBHCI");
		icr.u32 = 0;
		icr.s.txbhci = 1;
		ctu_can_fd_int_clr(&priv->p, icr);
		ctucan_tx_interrupt(ndev);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (isr.s.txbhci)
|—————Node:( Text: (
|—————Node:field_expression Text: isr.s.txbhci
|——————Node:field_expression Text: isr.s
|———————Node:identifier Text: isr
|———————Node:. Text: .
|———————Node:field_identifier Text: s
|——————Node:. Text: .
|——————Node:field_identifier Text: txbhci
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_info(ndev, "TXBHCI");
		icr.u32 = 0;
		icr.s.txbhci = 1;
		ctu_can_fd_int_clr(&priv->p, icr);
		ctucan_tx_interrupt(ndev);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_info(ndev, "TXBHCI");
|——————Node:call_expression Text: netdev_info(ndev, "TXBHCI")
|———————Node:identifier Text: netdev_info
|———————Node:argument_list Text: (ndev, "TXBHCI")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "TXBHCI"
|—————————Node:" Text: "
|—————————Node:string_content Text: TXBHCI
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: icr.u32 = 0;
|——————Node:assignment_expression Text: icr.u32 = 0
|———————Node:field_expression Text: icr.u32
|————————Node:identifier Text: icr
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: icr.s.txbhci = 1;
|——————Node:assignment_expression Text: icr.s.txbhci = 1
|———————Node:field_expression Text: icr.s.txbhci
|————————Node:field_expression Text: icr.s
|—————————Node:identifier Text: icr
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: txbhci
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctu_can_fd_int_clr(&priv->p, icr);
|——————Node:call_expression Text: ctu_can_fd_int_clr(&priv->p, icr)
|———————Node:identifier Text: ctu_can_fd_int_clr
|———————Node:argument_list Text: (&priv->p, icr)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: icr
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctucan_tx_interrupt(ndev);
|——————Node:call_expression Text: ctucan_tx_interrupt(ndev)
|———————Node:identifier Text: ctucan_tx_interrupt
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Error interrupts */
|———Node:if_statement Text: if (isr.s.ei || isr.s.doi || isr.s.epi || isr.s.ali) {
		icr.u32 = isr.u32 & CTUCANFD_INT_ERROR;
		ctu_can_fd_int_clr(&priv->p, icr);
		netdev_warn(ndev, "err interrupt handler not implemented!");
		//ctucan_err_interrupt(ndev, isr);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (isr.s.ei || isr.s.doi || isr.s.epi || isr.s.ali)
|—————Node:( Text: (
|—————Node:binary_expression Text: isr.s.ei || isr.s.doi || isr.s.epi || isr.s.ali
|——————Node:binary_expression Text: isr.s.ei || isr.s.doi || isr.s.epi
|———————Node:binary_expression Text: isr.s.ei || isr.s.doi
|————————Node:field_expression Text: isr.s.ei
|—————————Node:field_expression Text: isr.s
|——————————Node:identifier Text: isr
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: ei
|————————Node:|| Text: ||
|————————Node:field_expression Text: isr.s.doi
|—————————Node:field_expression Text: isr.s
|——————————Node:identifier Text: isr
|——————————Node:. Text: .
|——————————Node:field_identifier Text: s
|—————————Node:. Text: .
|—————————Node:field_identifier Text: doi
|———————Node:|| Text: ||
|———————Node:field_expression Text: isr.s.epi
|————————Node:field_expression Text: isr.s
|—————————Node:identifier Text: isr
|—————————Node:. Text: .
|—————————Node:field_identifier Text: s
|————————Node:. Text: .
|————————Node:field_identifier Text: epi
|——————Node:|| Text: ||
|——————Node:field_expression Text: isr.s.ali
|———————Node:field_expression Text: isr.s
|————————Node:identifier Text: isr
|————————Node:. Text: .
|————————Node:field_identifier Text: s
|———————Node:. Text: .
|———————Node:field_identifier Text: ali
|—————Node:) Text: )
|————Node:compound_statement Text: {
		icr.u32 = isr.u32 & CTUCANFD_INT_ERROR;
		ctu_can_fd_int_clr(&priv->p, icr);
		netdev_warn(ndev, "err interrupt handler not implemented!");
		//ctucan_err_interrupt(ndev, isr);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: icr.u32 = isr.u32 & CTUCANFD_INT_ERROR;
|——————Node:assignment_expression Text: icr.u32 = isr.u32 & CTUCANFD_INT_ERROR
|———————Node:field_expression Text: icr.u32
|————————Node:identifier Text: icr
|————————Node:. Text: .
|————————Node:field_identifier Text: u32
|———————Node:= Text: =
|———————Node:binary_expression Text: isr.u32 & CTUCANFD_INT_ERROR
|————————Node:field_expression Text: isr.u32
|—————————Node:identifier Text: isr
|—————————Node:. Text: .
|—————————Node:field_identifier Text: u32
|————————Node:& Text: &
|————————Node:identifier Text: CTUCANFD_INT_ERROR
|——————Node:; Text: ;
|—————Node:expression_statement Text: ctu_can_fd_int_clr(&priv->p, icr);
|——————Node:call_expression Text: ctu_can_fd_int_clr(&priv->p, icr)
|———————Node:identifier Text: ctu_can_fd_int_clr
|———————Node:argument_list Text: (&priv->p, icr)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &priv->p
|—————————Node:& Text: &
|—————————Node:field_expression Text: priv->p
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: p
|————————Node:, Text: ,
|————————Node:identifier Text: icr
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: netdev_warn(ndev, "err interrupt handler not implemented!");
|——————Node:call_expression Text: netdev_warn(ndev, "err interrupt handler not implemented!")
|———————Node:identifier Text: netdev_warn
|———————Node:argument_list Text: (ndev, "err interrupt handler not implemented!")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "err interrupt handler not implemented!"
|—————————Node:" Text: "
|—————————Node:string_content Text: err interrupt handler not implemented!
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: //ctucan_err_interrupt(ndev, isr);
|—————Node:} Text: }
|———Node:comment Text: /* Ignore RI, TI, LFI, RFI, BSI */
|———Node:return_statement Text: return IRQ_HANDLED;
|————Node:return Text: return
|————Node:identifier Text: IRQ_HANDLED
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_chip_stop - Driver stop routine
 * @ndev:	Pointer to net_device structure
 *
 * This is the drivers stop routine. It will disable the
 * interrupts and disable the controller.
 */
|—Node:function_definition Text: static void ctucan_chip_stop(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat ena, mask;
	netdev_info(ndev, "ctucan_chip_stop");

	ena.u32 = 0;
	mask.u32 = 0xFFFFFFFF;

	/* Disable interrupts and disable can */
	ctu_can_fd_int_ena(&priv->p, ena, mask);
	ctu_can_fd_int_mask(&priv->p, ena, mask);
	ctu_can_fd_enable(&priv->p, false);
	priv->can.state = CAN_STATE_STOPPED;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ctucan_chip_stop(struct net_device *ndev)
|———Node:identifier Text: ctucan_chip_stop
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	union ctu_can_fd_int_stat ena, mask;
	netdev_info(ndev, "ctucan_chip_stop");

	ena.u32 = 0;
	mask.u32 = 0xFFFFFFFF;

	/* Disable interrupts and disable can */
	ctu_can_fd_int_ena(&priv->p, ena, mask);
	ctu_can_fd_int_mask(&priv->p, ena, mask);
	ctu_can_fd_enable(&priv->p, false);
	priv->can.state = CAN_STATE_STOPPED;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: union ctu_can_fd_int_stat ena, mask;
|————Node:union_specifier Text: union ctu_can_fd_int_stat
|—————Node:union Text: union
|—————Node:type_identifier Text: ctu_can_fd_int_stat
|————Node:identifier Text: ena
|————Node:, Text: ,
|————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_chip_stop");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_chip_stop")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_chip_stop")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_chip_stop"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_chip_stop
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ena.u32 = 0;
|————Node:assignment_expression Text: ena.u32 = 0
|—————Node:field_expression Text: ena.u32
|——————Node:identifier Text: ena
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: mask.u32 = 0xFFFFFFFF;
|————Node:assignment_expression Text: mask.u32 = 0xFFFFFFFF
|—————Node:field_expression Text: mask.u32
|——————Node:identifier Text: mask
|——————Node:. Text: .
|——————Node:field_identifier Text: u32
|—————Node:= Text: =
|—————Node:number_literal Text: 0xFFFFFFFF
|————Node:; Text: ;
|———Node:comment Text: /* Disable interrupts and disable can */
|———Node:expression_statement Text: ctu_can_fd_int_ena(&priv->p, ena, mask);
|————Node:call_expression Text: ctu_can_fd_int_ena(&priv->p, ena, mask)
|—————Node:identifier Text: ctu_can_fd_int_ena
|—————Node:argument_list Text: (&priv->p, ena, mask)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: ena
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_int_mask(&priv->p, ena, mask);
|————Node:call_expression Text: ctu_can_fd_int_mask(&priv->p, ena, mask)
|—————Node:identifier Text: ctu_can_fd_int_mask
|—————Node:argument_list Text: (&priv->p, ena, mask)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: ena
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctu_can_fd_enable(&priv->p, false);
|————Node:call_expression Text: ctu_can_fd_enable(&priv->p, false)
|—————Node:identifier Text: ctu_can_fd_enable
|—————Node:argument_list Text: (&priv->p, false)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:false Text: false
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.state = CAN_STATE_STOPPED;
|————Node:assignment_expression Text: priv->can.state = CAN_STATE_STOPPED
|—————Node:field_expression Text: priv->can.state
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: state
|—————Node:= Text: =
|—————Node:identifier Text: CAN_STATE_STOPPED
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_open - Driver open routine
 * @ndev:	Pointer to net_device structure
 *
 * This is the driver open routine.
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_open(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	int ret;
	netdev_info(ndev, "ctucan_open");

	ret = pm_runtime_get_sync(priv->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}

	/*
	ret = ctucan_reset(ndev);
	if (ret < 0)
		goto err;
	*/

	ret = request_irq(ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev);
	if (ret < 0) {
		netdev_err(ndev, "irq allocation for CAN failed\n");
		goto err;
	}

	/* Common open */
	ret = open_candev(ndev);
	if (ret) {
		netdev_warn(ndev, "open_candev failed!\n");
		goto err_irq;
	}

	ret = ctucan_chip_start(ndev);
	if (ret < 0) {
		netdev_err(ndev, "ctucan_chip_start failed!\n");
		goto err_candev;
	}

	can_led_event(ndev, CAN_LED_EVENT_OPEN);
	napi_enable(&priv->napi);
	netif_start_queue(ndev);

	return 0;

err_candev:
	close_candev(ndev);
err_irq:
	free_irq(ndev->irq, ndev);
err:
	pm_runtime_put(priv->dev);

	return ret;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_open(struct net_device *ndev)
|———Node:identifier Text: ctucan_open
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	int ret;
	netdev_info(ndev, "ctucan_open");

	ret = pm_runtime_get_sync(priv->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}

	/*
	ret = ctucan_reset(ndev);
	if (ret < 0)
		goto err;
	*/

	ret = request_irq(ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev);
	if (ret < 0) {
		netdev_err(ndev, "irq allocation for CAN failed\n");
		goto err;
	}

	/* Common open */
	ret = open_candev(ndev);
	if (ret) {
		netdev_warn(ndev, "open_candev failed!\n");
		goto err_irq;
	}

	ret = ctucan_chip_start(ndev);
	if (ret < 0) {
		netdev_err(ndev, "ctucan_chip_start failed!\n");
		goto err_candev;
	}

	can_led_event(ndev, CAN_LED_EVENT_OPEN);
	napi_enable(&priv->napi);
	netif_start_queue(ndev);

	return 0;

err_candev:
	close_candev(ndev);
err_irq:
	free_irq(ndev->irq, ndev);
err:
	pm_runtime_put(priv->dev);

	return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int ret;
|————Node:primitive_type Text: int
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_open");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_open")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_open")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_open"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_open
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = pm_runtime_get_sync(priv->dev);
|————Node:assignment_expression Text: ret = pm_runtime_get_sync(priv->dev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: pm_runtime_get_sync(priv->dev)
|——————Node:identifier Text: pm_runtime_get_sync
|——————Node:argument_list Text: (priv->dev)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->dev
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
|——————Node:call_expression Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret)
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "%s: pm_runtime_get failed(%d)\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: %s: pm_runtime_get failed(%d)
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: __func__
|————————Node:, Text: ,
|————————Node:identifier Text: ret
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return ret;
|——————Node:return Text: return
|——————Node:identifier Text: ret
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /*
	ret = ctucan_reset(ndev);
	if (ret < 0)
		goto err;
	*/
|———Node:expression_statement Text: ret = request_irq(ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev);
|————Node:assignment_expression Text: ret = request_irq(ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: request_irq(ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev)
|——————Node:identifier Text: request_irq
|——————Node:argument_list Text: (ndev->irq, ctucan_interrupt, /*priv->irq_flags*/0,
			ndev->name, ndev)
|———————Node:( Text: (
|———————Node:field_expression Text: ndev->irq
|————————Node:identifier Text: ndev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: irq
|———————Node:, Text: ,
|———————Node:identifier Text: ctucan_interrupt
|———————Node:, Text: ,
|———————Node:comment Text: /*priv->irq_flags*/
|———————Node:number_literal Text: 0
|———————Node:, Text: ,
|———————Node:field_expression Text: ndev->name
|————————Node:identifier Text: ndev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: name
|———————Node:, Text: ,
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0) {
		netdev_err(ndev, "irq allocation for CAN failed\n");
		goto err;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "irq allocation for CAN failed\n");
		goto err;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "irq allocation for CAN failed\n");
|——————Node:call_expression Text: netdev_err(ndev, "irq allocation for CAN failed\n")
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "irq allocation for CAN failed\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "irq allocation for CAN failed\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: irq allocation for CAN failed
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Common open */
|———Node:expression_statement Text: ret = open_candev(ndev);
|————Node:assignment_expression Text: ret = open_candev(ndev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: open_candev(ndev)
|——————Node:identifier Text: open_candev
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret) {
		netdev_warn(ndev, "open_candev failed!\n");
		goto err_irq;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret)
|—————Node:( Text: (
|—————Node:identifier Text: ret
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_warn(ndev, "open_candev failed!\n");
		goto err_irq;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_warn(ndev, "open_candev failed!\n");
|——————Node:call_expression Text: netdev_warn(ndev, "open_candev failed!\n")
|———————Node:identifier Text: netdev_warn
|———————Node:argument_list Text: (ndev, "open_candev failed!\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "open_candev failed!\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: open_candev failed!
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err_irq;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err_irq
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ret = ctucan_chip_start(ndev);
|————Node:assignment_expression Text: ret = ctucan_chip_start(ndev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_chip_start(ndev)
|——————Node:identifier Text: ctucan_chip_start
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0) {
		netdev_err(ndev, "ctucan_chip_start failed!\n");
		goto err_candev;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "ctucan_chip_start failed!\n");
		goto err_candev;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "ctucan_chip_start failed!\n");
|——————Node:call_expression Text: netdev_err(ndev, "ctucan_chip_start failed!\n")
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "ctucan_chip_start failed!\n")
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "ctucan_chip_start failed!\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: ctucan_chip_start failed!
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err_candev;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err_candev
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: can_led_event(ndev, CAN_LED_EVENT_OPEN);
|————Node:call_expression Text: can_led_event(ndev, CAN_LED_EVENT_OPEN)
|—————Node:identifier Text: can_led_event
|—————Node:argument_list Text: (ndev, CAN_LED_EVENT_OPEN)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_LED_EVENT_OPEN
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: napi_enable(&priv->napi);
|————Node:call_expression Text: napi_enable(&priv->napi)
|—————Node:identifier Text: napi_enable
|—————Node:argument_list Text: (&priv->napi)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->napi
|———————Node:& Text: &
|———————Node:field_expression Text: priv->napi
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: napi
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netif_start_queue(ndev);
|————Node:call_expression Text: netif_start_queue(ndev)
|—————Node:identifier Text: netif_start_queue
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:labeled_statement Text: err_candev:
	close_candev(ndev);
|————Node:statement_identifier Text: err_candev
|————Node:: Text: :
|————Node:expression_statement Text: close_candev(ndev);
|—————Node:call_expression Text: close_candev(ndev)
|——————Node:identifier Text: close_candev
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:labeled_statement Text: err_irq:
	free_irq(ndev->irq, ndev);
|————Node:statement_identifier Text: err_irq
|————Node:: Text: :
|————Node:expression_statement Text: free_irq(ndev->irq, ndev);
|—————Node:call_expression Text: free_irq(ndev->irq, ndev)
|——————Node:identifier Text: free_irq
|——————Node:argument_list Text: (ndev->irq, ndev)
|———————Node:( Text: (
|———————Node:field_expression Text: ndev->irq
|————————Node:identifier Text: ndev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: irq
|———————Node:, Text: ,
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:labeled_statement Text: err:
	pm_runtime_put(priv->dev);
|————Node:statement_identifier Text: err
|————Node:: Text: :
|————Node:expression_statement Text: pm_runtime_put(priv->dev);
|—————Node:call_expression Text: pm_runtime_put(priv->dev)
|——————Node:identifier Text: pm_runtime_put
|——————Node:argument_list Text: (priv->dev)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->dev
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_close - Driver close routine
 * @ndev:	Pointer to net_device structure
 *
 * Return: 0 always
 */
|—Node:function_definition Text: static int ctucan_close(struct net_device *ndev)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_close");

	netif_stop_queue(ndev);
	napi_disable(&priv->napi);
	ctucan_chip_stop(ndev);
	free_irq(ndev->irq, ndev);
	close_candev(ndev);

	can_led_event(ndev, CAN_LED_EVENT_STOP);
	pm_runtime_put(priv->dev);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_close(struct net_device *ndev)
|———Node:identifier Text: ctucan_close
|———Node:parameter_list Text: (struct net_device *ndev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *ndev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_close");

	netif_stop_queue(ndev);
	napi_disable(&priv->napi);
	ctucan_chip_stop(ndev);
	free_irq(ndev->irq, ndev);
	close_candev(ndev);

	can_led_event(ndev, CAN_LED_EVENT_STOP);
	pm_runtime_put(priv->dev);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_close");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_close")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_close")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_close"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_close
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netif_stop_queue(ndev);
|————Node:call_expression Text: netif_stop_queue(ndev)
|—————Node:identifier Text: netif_stop_queue
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: napi_disable(&priv->napi);
|————Node:call_expression Text: napi_disable(&priv->napi)
|—————Node:identifier Text: napi_disable
|—————Node:argument_list Text: (&priv->napi)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->napi
|———————Node:& Text: &
|———————Node:field_expression Text: priv->napi
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: napi
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctucan_chip_stop(ndev);
|————Node:call_expression Text: ctucan_chip_stop(ndev)
|—————Node:identifier Text: ctucan_chip_stop
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: free_irq(ndev->irq, ndev);
|————Node:call_expression Text: free_irq(ndev->irq, ndev)
|—————Node:identifier Text: free_irq
|—————Node:argument_list Text: (ndev->irq, ndev)
|——————Node:( Text: (
|——————Node:field_expression Text: ndev->irq
|———————Node:identifier Text: ndev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: irq
|——————Node:, Text: ,
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: close_candev(ndev);
|————Node:call_expression Text: close_candev(ndev)
|—————Node:identifier Text: close_candev
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: can_led_event(ndev, CAN_LED_EVENT_STOP);
|————Node:call_expression Text: can_led_event(ndev, CAN_LED_EVENT_STOP)
|—————Node:identifier Text: can_led_event
|—————Node:argument_list Text: (ndev, CAN_LED_EVENT_STOP)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_LED_EVENT_STOP
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pm_runtime_put(priv->dev);
|————Node:call_expression Text: pm_runtime_put(priv->dev)
|—————Node:identifier Text: pm_runtime_put
|—————Node:argument_list Text: (priv->dev)
|——————Node:( Text: (
|——————Node:field_expression Text: priv->dev
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_get_berr_counter - error counter routine
 * @ndev:	Pointer to net_device structure
 * @bec:	Pointer to can_berr_counter structure
 *
 * This is the driver error counter routine.
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_get_berr_counter(const struct net_device *ndev,
					struct can_berr_counter *bec)
{
	struct ctucan_priv *priv = netdev_priv(ndev);
	int ret;
	netdev_info(ndev, "ctucan_get_berr_counter");

	ret = pm_runtime_get_sync(priv->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}

	ctu_can_fd_read_err_ctrs(&priv->p, bec);

	pm_runtime_put(priv->dev);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_get_berr_counter(const struct net_device *ndev,
					struct can_berr_counter *bec)
|———Node:identifier Text: ctucan_get_berr_counter
|———Node:parameter_list Text: (const struct net_device *ndev,
					struct can_berr_counter *bec)
|————Node:( Text: (
|————Node:parameter_declaration Text: const struct net_device *ndev
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can_berr_counter *bec
|—————Node:struct_specifier Text: struct can_berr_counter
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_berr_counter
|—————Node:pointer_declarator Text: *bec
|——————Node:* Text: *
|——————Node:identifier Text: bec
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct ctucan_priv *priv = netdev_priv(ndev);
	int ret;
	netdev_info(ndev, "ctucan_get_berr_counter");

	ret = pm_runtime_get_sync(priv->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}

	ctu_can_fd_read_err_ctrs(&priv->p, bec);

	pm_runtime_put(priv->dev);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int ret;
|————Node:primitive_type Text: int
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_get_berr_counter");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_get_berr_counter")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_get_berr_counter")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_get_berr_counter"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_get_berr_counter
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = pm_runtime_get_sync(priv->dev);
|————Node:assignment_expression Text: ret = pm_runtime_get_sync(priv->dev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: pm_runtime_get_sync(priv->dev)
|——————Node:identifier Text: pm_runtime_get_sync
|——————Node:argument_list Text: (priv->dev)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->dev
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
		return ret;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret);
|——————Node:call_expression Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret)
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "%s: pm_runtime_get failed(%d)\n",
				__func__, ret)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "%s: pm_runtime_get failed(%d)\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: %s: pm_runtime_get failed(%d)
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: __func__
|————————Node:, Text: ,
|————————Node:identifier Text: ret
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return ret;
|——————Node:return Text: return
|——————Node:identifier Text: ret
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ctu_can_fd_read_err_ctrs(&priv->p, bec);
|————Node:call_expression Text: ctu_can_fd_read_err_ctrs(&priv->p, bec)
|—————Node:identifier Text: ctu_can_fd_read_err_ctrs
|—————Node:argument_list Text: (&priv->p, bec)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->p
|———————Node:& Text: &
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|——————Node:, Text: ,
|——————Node:identifier Text: bec
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pm_runtime_put(priv->dev);
|————Node:call_expression Text: pm_runtime_put(priv->dev)
|—————Node:identifier Text: pm_runtime_put
|—————Node:argument_list Text: (priv->dev)
|——————Node:( Text: (
|——————Node:field_expression Text: priv->dev
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:declaration Text: static const struct net_device_ops ctucan_netdev_ops = {
	.ndo_open	= ctucan_open,
	.ndo_stop	= ctucan_close,
	.ndo_start_xmit	= ctucan_start_xmit,
	.ndo_change_mtu	= can_change_mtu,
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:struct_specifier Text: struct net_device_ops
|———Node:struct Text: struct
|———Node:type_identifier Text: net_device_ops
|——Node:init_declarator Text: ctucan_netdev_ops = {
	.ndo_open	= ctucan_open,
	.ndo_stop	= ctucan_close,
	.ndo_start_xmit	= ctucan_start_xmit,
	.ndo_change_mtu	= can_change_mtu,
}
|———Node:identifier Text: ctucan_netdev_ops
|———Node:= Text: =
|———Node:initializer_list Text: {
	.ndo_open	= ctucan_open,
	.ndo_stop	= ctucan_close,
	.ndo_start_xmit	= ctucan_start_xmit,
	.ndo_change_mtu	= can_change_mtu,
}
|————Node:{ Text: {
|————Node:initializer_pair Text: .ndo_open	= ctucan_open
|—————Node:field_designator Text: .ndo_open
|——————Node:. Text: .
|——————Node:field_identifier Text: ndo_open
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_open
|————Node:, Text: ,
|————Node:initializer_pair Text: .ndo_stop	= ctucan_close
|—————Node:field_designator Text: .ndo_stop
|——————Node:. Text: .
|——————Node:field_identifier Text: ndo_stop
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_close
|————Node:, Text: ,
|————Node:initializer_pair Text: .ndo_start_xmit	= ctucan_start_xmit
|—————Node:field_designator Text: .ndo_start_xmit
|——————Node:. Text: .
|——————Node:field_identifier Text: ndo_start_xmit
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_start_xmit
|————Node:, Text: ,
|————Node:initializer_pair Text: .ndo_change_mtu	= can_change_mtu
|—————Node:field_designator Text: .ndo_change_mtu
|——————Node:. Text: .
|——————Node:field_identifier Text: ndo_change_mtu
|—————Node:= Text: =
|—————Node:identifier Text: can_change_mtu
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:function_definition Text: static __maybe_unused int ctucan_suspend(struct device *dev)
{
	struct net_device *ndev = dev_get_drvdata(dev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_suspend");

	if (netif_running(ndev)) {
		netif_stop_queue(ndev);
		netif_device_detach(ndev);
	}

	priv->can.state = CAN_STATE_SLEEPING;

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: __maybe_unused
|——Node:ERROR Text: int
|———Node:identifier Text: int
|——Node:function_declarator Text: ctucan_suspend(struct device *dev)
|———Node:identifier Text: ctucan_suspend
|———Node:parameter_list Text: (struct device *dev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct device *dev
|—————Node:struct_specifier Text: struct device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: device
|—————Node:pointer_declarator Text: *dev
|——————Node:* Text: *
|——————Node:identifier Text: dev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct net_device *ndev = dev_get_drvdata(dev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_suspend");

	if (netif_running(ndev)) {
		netif_stop_queue(ndev);
		netif_device_detach(ndev);
	}

	priv->can.state = CAN_STATE_SLEEPING;

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct net_device *ndev = dev_get_drvdata(dev);
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: *ndev = dev_get_drvdata(dev)
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:call_expression Text: dev_get_drvdata(dev)
|——————Node:identifier Text: dev_get_drvdata
|——————Node:argument_list Text: (dev)
|———————Node:( Text: (
|———————Node:identifier Text: dev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_suspend");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_suspend")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_suspend")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_suspend"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_suspend
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (netif_running(ndev)) {
		netif_stop_queue(ndev);
		netif_device_detach(ndev);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (netif_running(ndev))
|—————Node:( Text: (
|—————Node:call_expression Text: netif_running(ndev)
|——————Node:identifier Text: netif_running
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netif_stop_queue(ndev);
		netif_device_detach(ndev);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netif_stop_queue(ndev);
|——————Node:call_expression Text: netif_stop_queue(ndev)
|———————Node:identifier Text: netif_stop_queue
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: netif_device_detach(ndev);
|——————Node:call_expression Text: netif_device_detach(ndev)
|———————Node:identifier Text: netif_device_detach
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: priv->can.state = CAN_STATE_SLEEPING;
|————Node:assignment_expression Text: priv->can.state = CAN_STATE_SLEEPING
|—————Node:field_expression Text: priv->can.state
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: state
|—————Node:= Text: =
|—————Node:identifier Text: CAN_STATE_SLEEPING
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static __maybe_unused int ctucan_resume(struct device *dev)
{
	struct net_device *ndev = dev_get_drvdata(dev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_resume");

	priv->can.state = CAN_STATE_ERROR_ACTIVE;

	if (netif_running(ndev)) {
		netif_device_attach(ndev);
		netif_start_queue(ndev);
	}

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: __maybe_unused
|——Node:ERROR Text: int
|———Node:identifier Text: int
|——Node:function_declarator Text: ctucan_resume(struct device *dev)
|———Node:identifier Text: ctucan_resume
|———Node:parameter_list Text: (struct device *dev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct device *dev
|—————Node:struct_specifier Text: struct device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: device
|—————Node:pointer_declarator Text: *dev
|——————Node:* Text: *
|——————Node:identifier Text: dev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct net_device *ndev = dev_get_drvdata(dev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_resume");

	priv->can.state = CAN_STATE_ERROR_ACTIVE;

	if (netif_running(ndev)) {
		netif_device_attach(ndev);
		netif_start_queue(ndev);
	}

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct net_device *ndev = dev_get_drvdata(dev);
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: *ndev = dev_get_drvdata(dev)
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:call_expression Text: dev_get_drvdata(dev)
|——————Node:identifier Text: dev_get_drvdata
|——————Node:argument_list Text: (dev)
|———————Node:( Text: (
|———————Node:identifier Text: dev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_resume");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_resume")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_resume")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_resume"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_resume
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.state = CAN_STATE_ERROR_ACTIVE;
|————Node:assignment_expression Text: priv->can.state = CAN_STATE_ERROR_ACTIVE
|—————Node:field_expression Text: priv->can.state
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: state
|—————Node:= Text: =
|—————Node:identifier Text: CAN_STATE_ERROR_ACTIVE
|————Node:; Text: ;
|———Node:if_statement Text: if (netif_running(ndev)) {
		netif_device_attach(ndev);
		netif_start_queue(ndev);
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (netif_running(ndev))
|—————Node:( Text: (
|—————Node:call_expression Text: netif_running(ndev)
|——————Node:identifier Text: netif_running
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netif_device_attach(ndev);
		netif_start_queue(ndev);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netif_device_attach(ndev);
|——————Node:call_expression Text: netif_device_attach(ndev)
|———————Node:identifier Text: netif_device_attach
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: netif_start_queue(ndev);
|——————Node:call_expression Text: netif_start_queue(ndev)
|———————Node:identifier Text: netif_start_queue
|———————Node:argument_list Text: (ndev)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:declaration Text: static const struct dev_pm_ops ctucan_dev_pm_ops = {
	SET_SYSTEM_SLEEP_PM_OPS(ctucan_suspend, ctucan_resume)
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:struct_specifier Text: struct dev_pm_ops
|———Node:struct Text: struct
|———Node:type_identifier Text: dev_pm_ops
|——Node:init_declarator Text: ctucan_dev_pm_ops = {
	SET_SYSTEM_SLEEP_PM_OPS(ctucan_suspend, ctucan_resume)
}
|———Node:identifier Text: ctucan_dev_pm_ops
|———Node:= Text: =
|———Node:initializer_list Text: {
	SET_SYSTEM_SLEEP_PM_OPS(ctucan_suspend, ctucan_resume)
}
|————Node:{ Text: {
|————Node:call_expression Text: SET_SYSTEM_SLEEP_PM_OPS(ctucan_suspend, ctucan_resume)
|—————Node:identifier Text: SET_SYSTEM_SLEEP_PM_OPS
|—————Node:argument_list Text: (ctucan_suspend, ctucan_resume)
|——————Node:( Text: (
|——————Node:identifier Text: ctucan_suspend
|——————Node:, Text: ,
|——————Node:identifier Text: ctucan_resume
|——————Node:) Text: )
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: /**
 * ctucan_probe - Platform registration call
 * @pdev:	Handle to the platform device structure
 *
 * This function does all the memory allocation and registration for the CAN
 * device.
 *
 * Return: 0 on success and failure value on error
 */
|—Node:function_definition Text: static int ctucan_probe(struct platform_device *pdev)
{
	struct resource *res; /* IO mem resources */
	struct net_device *ndev;
	struct ctucan_priv *priv;
	void __iomem *addr;
	int ret;
	unsigned int ntxbufs;

	/* Get the virtual base address for the device */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	addr = devm_ioremap_resource(&pdev->dev, res);
	if (IS_ERR(addr)) {
		ret = PTR_ERR(addr);
		goto err;
	}

	/*
	ret = of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth", &tx_max);
	if (ret < 0)
		goto err;
	*/
	ntxbufs = 4;

	/* Create a CAN device instance */
	ndev = alloc_candev(sizeof(struct ctucan_priv), ntxbufs);
	if (!ndev)
		return -ENOMEM;

	priv = netdev_priv(ndev);
	priv->txb_mask = ntxbufs-1;
	priv->dev = &pdev->dev;
	priv->can.bittiming_const = &ctu_can_fd_bit_timing_max;
	priv->can.data_bittiming_const = &ctu_can_fd_bit_timing_data_max;
	priv->can.do_set_mode = ctucan_do_set_mode;
	//priv->can.do_set_bittiming = ctucan_set_bittiming;
	//priv->can.do_set_data_bittiming = ctucan_set_data_bittiming;
	priv->can.do_get_berr_counter = ctucan_get_berr_counter;
	//priv->can.do_get_state = ctucan_get_state;
	priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK /*| CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_FD | CAN_CTRLMODE_PRESUME_ACK | CAN_CTRLMODE_FD_NON_ISO | CAN_CTRLMODE_ONE_SHOT*/;
	priv->p.mem_base = addr;

	/* Get IRQ for the device */
	ndev->irq = platform_get_irq(pdev, 0);
	ndev->flags |= IFF_ECHO;	/* We support local echo */

	platform_set_drvdata(pdev, ndev);
	SET_NETDEV_DEV(ndev, &pdev->dev);
	ndev->netdev_ops = &ctucan_netdev_ops;

	/* Getting the CAN can_clk info */
	priv->can_clk = devm_clk_get(&pdev->dev, NULL);
	if (IS_ERR(priv->can_clk)) {
		dev_err(&pdev->dev, "Device clock not found.\n");
		ret = PTR_ERR(priv->can_clk);
		goto err_free;
	}

	priv->p.write_reg = ctu_can_fd_write32;
	priv->p.read_reg = ctu_can_fd_read32;

	pm_runtime_enable(&pdev->dev);
	ret = pm_runtime_get_sync(&pdev->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret);
		goto err_pmdisable;
	}

	if ((priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF) != CTU_CAN_FD_ID) {
		priv->p.write_reg = ctu_can_fd_write32_be;
		priv->p.read_reg = ctu_can_fd_read32_be;
	}

	ret = ctucan_reset(ndev);
	if (ret < 0)
		goto err_pmdisable;

	priv->can.clock.freq = clk_get_rate(priv->can_clk);

	netif_napi_add(ndev, &priv->napi, ctucan_rx_poll, NAPI_POLL_WEIGHT);

	ret = register_candev(ndev);
	if (ret) {
		dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);
		goto err_disableclks;
	}

	devm_can_led_init(ndev);

	pm_runtime_put(&pdev->dev);

	netdev_dbg(ndev, "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n",
			priv->p.mem_base, ndev->irq, priv->can.clock.freq,
			priv->txb_mask);

	return 0;

err_disableclks:
	pm_runtime_put(priv->dev);
err_pmdisable:
	pm_runtime_disable(&pdev->dev);
err_free:
	free_candev(ndev);
err:
	return ret;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_probe(struct platform_device *pdev)
|———Node:identifier Text: ctucan_probe
|———Node:parameter_list Text: (struct platform_device *pdev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct platform_device *pdev
|—————Node:struct_specifier Text: struct platform_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: platform_device
|—————Node:pointer_declarator Text: *pdev
|——————Node:* Text: *
|——————Node:identifier Text: pdev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct resource *res; /* IO mem resources */
	struct net_device *ndev;
	struct ctucan_priv *priv;
	void __iomem *addr;
	int ret;
	unsigned int ntxbufs;

	/* Get the virtual base address for the device */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	addr = devm_ioremap_resource(&pdev->dev, res);
	if (IS_ERR(addr)) {
		ret = PTR_ERR(addr);
		goto err;
	}

	/*
	ret = of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth", &tx_max);
	if (ret < 0)
		goto err;
	*/
	ntxbufs = 4;

	/* Create a CAN device instance */
	ndev = alloc_candev(sizeof(struct ctucan_priv), ntxbufs);
	if (!ndev)
		return -ENOMEM;

	priv = netdev_priv(ndev);
	priv->txb_mask = ntxbufs-1;
	priv->dev = &pdev->dev;
	priv->can.bittiming_const = &ctu_can_fd_bit_timing_max;
	priv->can.data_bittiming_const = &ctu_can_fd_bit_timing_data_max;
	priv->can.do_set_mode = ctucan_do_set_mode;
	//priv->can.do_set_bittiming = ctucan_set_bittiming;
	//priv->can.do_set_data_bittiming = ctucan_set_data_bittiming;
	priv->can.do_get_berr_counter = ctucan_get_berr_counter;
	//priv->can.do_get_state = ctucan_get_state;
	priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK /*| CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_FD | CAN_CTRLMODE_PRESUME_ACK | CAN_CTRLMODE_FD_NON_ISO | CAN_CTRLMODE_ONE_SHOT*/;
	priv->p.mem_base = addr;

	/* Get IRQ for the device */
	ndev->irq = platform_get_irq(pdev, 0);
	ndev->flags |= IFF_ECHO;	/* We support local echo */

	platform_set_drvdata(pdev, ndev);
	SET_NETDEV_DEV(ndev, &pdev->dev);
	ndev->netdev_ops = &ctucan_netdev_ops;

	/* Getting the CAN can_clk info */
	priv->can_clk = devm_clk_get(&pdev->dev, NULL);
	if (IS_ERR(priv->can_clk)) {
		dev_err(&pdev->dev, "Device clock not found.\n");
		ret = PTR_ERR(priv->can_clk);
		goto err_free;
	}

	priv->p.write_reg = ctu_can_fd_write32;
	priv->p.read_reg = ctu_can_fd_read32;

	pm_runtime_enable(&pdev->dev);
	ret = pm_runtime_get_sync(&pdev->dev);
	if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret);
		goto err_pmdisable;
	}

	if ((priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF) != CTU_CAN_FD_ID) {
		priv->p.write_reg = ctu_can_fd_write32_be;
		priv->p.read_reg = ctu_can_fd_read32_be;
	}

	ret = ctucan_reset(ndev);
	if (ret < 0)
		goto err_pmdisable;

	priv->can.clock.freq = clk_get_rate(priv->can_clk);

	netif_napi_add(ndev, &priv->napi, ctucan_rx_poll, NAPI_POLL_WEIGHT);

	ret = register_candev(ndev);
	if (ret) {
		dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);
		goto err_disableclks;
	}

	devm_can_led_init(ndev);

	pm_runtime_put(&pdev->dev);

	netdev_dbg(ndev, "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n",
			priv->p.mem_base, ndev->irq, priv->can.clock.freq,
			priv->txb_mask);

	return 0;

err_disableclks:
	pm_runtime_put(priv->dev);
err_pmdisable:
	pm_runtime_disable(&pdev->dev);
err_free:
	free_candev(ndev);
err:
	return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: struct resource *res;
|————Node:struct_specifier Text: struct resource
|—————Node:struct Text: struct
|—————Node:type_identifier Text: resource
|————Node:pointer_declarator Text: *res
|—————Node:* Text: *
|—————Node:identifier Text: res
|————Node:; Text: ;
|———Node:comment Text: /* IO mem resources */
|———Node:declaration Text: struct net_device *ndev;
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:pointer_declarator Text: *ndev
|—————Node:* Text: *
|—————Node:identifier Text: ndev
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv;
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:pointer_declarator Text: *priv
|—————Node:* Text: *
|—————Node:identifier Text: priv
|————Node:; Text: ;
|———Node:declaration Text: void __iomem *addr;
|————Node:primitive_type Text: void
|————Node:ERROR Text: __iomem
|—————Node:identifier Text: __iomem
|————Node:pointer_declarator Text: *addr
|—————Node:* Text: *
|—————Node:identifier Text: addr
|————Node:; Text: ;
|———Node:declaration Text: int ret;
|————Node:primitive_type Text: int
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:declaration Text: unsigned int ntxbufs;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:identifier Text: ntxbufs
|————Node:; Text: ;
|———Node:comment Text: /* Get the virtual base address for the device */
|———Node:expression_statement Text: res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
|————Node:assignment_expression Text: res = platform_get_resource(pdev, IORESOURCE_MEM, 0)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: platform_get_resource(pdev, IORESOURCE_MEM, 0)
|——————Node:identifier Text: platform_get_resource
|——————Node:argument_list Text: (pdev, IORESOURCE_MEM, 0)
|———————Node:( Text: (
|———————Node:identifier Text: pdev
|———————Node:, Text: ,
|———————Node:identifier Text: IORESOURCE_MEM
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: addr = devm_ioremap_resource(&pdev->dev, res);
|————Node:assignment_expression Text: addr = devm_ioremap_resource(&pdev->dev, res)
|—————Node:identifier Text: addr
|—————Node:= Text: =
|—————Node:call_expression Text: devm_ioremap_resource(&pdev->dev, res)
|——————Node:identifier Text: devm_ioremap_resource
|——————Node:argument_list Text: (&pdev->dev, res)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &pdev->dev
|————————Node:& Text: &
|————————Node:field_expression Text: pdev->dev
|—————————Node:identifier Text: pdev
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: dev
|———————Node:, Text: ,
|———————Node:identifier Text: res
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (IS_ERR(addr)) {
		ret = PTR_ERR(addr);
		goto err;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (IS_ERR(addr))
|—————Node:( Text: (
|—————Node:call_expression Text: IS_ERR(addr)
|——————Node:identifier Text: IS_ERR
|——————Node:argument_list Text: (addr)
|———————Node:( Text: (
|———————Node:identifier Text: addr
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ret = PTR_ERR(addr);
		goto err;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ret = PTR_ERR(addr);
|——————Node:assignment_expression Text: ret = PTR_ERR(addr)
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:call_expression Text: PTR_ERR(addr)
|————————Node:identifier Text: PTR_ERR
|————————Node:argument_list Text: (addr)
|—————————Node:( Text: (
|—————————Node:identifier Text: addr
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /*
	ret = of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth", &tx_max);
	if (ret < 0)
		goto err;
	*/
|———Node:expression_statement Text: ntxbufs = 4;
|————Node:assignment_expression Text: ntxbufs = 4
|—————Node:identifier Text: ntxbufs
|—————Node:= Text: =
|—————Node:number_literal Text: 4
|————Node:; Text: ;
|———Node:comment Text: /* Create a CAN device instance */
|———Node:expression_statement Text: ndev = alloc_candev(sizeof(struct ctucan_priv), ntxbufs);
|————Node:assignment_expression Text: ndev = alloc_candev(sizeof(struct ctucan_priv), ntxbufs)
|—————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:call_expression Text: alloc_candev(sizeof(struct ctucan_priv), ntxbufs)
|——————Node:identifier Text: alloc_candev
|——————Node:argument_list Text: (sizeof(struct ctucan_priv), ntxbufs)
|———————Node:( Text: (
|———————Node:sizeof_expression Text: sizeof(struct ctucan_priv)
|————————Node:sizeof Text: sizeof
|————————Node:( Text: (
|————————Node:type_descriptor Text: struct ctucan_priv
|—————————Node:struct_specifier Text: struct ctucan_priv
|——————————Node:struct Text: struct
|——————————Node:type_identifier Text: ctucan_priv
|————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:identifier Text: ntxbufs
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (!ndev)
		return -ENOMEM;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!ndev)
|—————Node:( Text: (
|—————Node:unary_expression Text: !ndev
|——————Node:! Text: !
|——————Node:identifier Text: ndev
|—————Node:) Text: )
|————Node:return_statement Text: return -ENOMEM;
|—————Node:return Text: return
|—————Node:unary_expression Text: -ENOMEM
|——————Node:- Text: -
|——————Node:identifier Text: ENOMEM
|—————Node:; Text: ;
|———Node:expression_statement Text: priv = netdev_priv(ndev);
|————Node:assignment_expression Text: priv = netdev_priv(ndev)
|—————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: priv->txb_mask = ntxbufs-1;
|————Node:assignment_expression Text: priv->txb_mask = ntxbufs-1
|—————Node:field_expression Text: priv->txb_mask
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: txb_mask
|—————Node:= Text: =
|—————Node:binary_expression Text: ntxbufs-1
|——————Node:identifier Text: ntxbufs
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: priv->dev = &pdev->dev;
|————Node:assignment_expression Text: priv->dev = &pdev->dev
|—————Node:field_expression Text: priv->dev
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: dev
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pdev->dev
|——————Node:& Text: &
|——————Node:field_expression Text: pdev->dev
|———————Node:identifier Text: pdev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dev
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.bittiming_const = &ctu_can_fd_bit_timing_max;
|————Node:assignment_expression Text: priv->can.bittiming_const = &ctu_can_fd_bit_timing_max
|—————Node:field_expression Text: priv->can.bittiming_const
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: bittiming_const
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ctu_can_fd_bit_timing_max
|——————Node:& Text: &
|——————Node:identifier Text: ctu_can_fd_bit_timing_max
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.data_bittiming_const = &ctu_can_fd_bit_timing_data_max;
|————Node:assignment_expression Text: priv->can.data_bittiming_const = &ctu_can_fd_bit_timing_data_max
|—————Node:field_expression Text: priv->can.data_bittiming_const
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: data_bittiming_const
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ctu_can_fd_bit_timing_data_max
|——————Node:& Text: &
|——————Node:identifier Text: ctu_can_fd_bit_timing_data_max
|————Node:; Text: ;
|———Node:expression_statement Text: priv->can.do_set_mode = ctucan_do_set_mode;
|————Node:assignment_expression Text: priv->can.do_set_mode = ctucan_do_set_mode
|—————Node:field_expression Text: priv->can.do_set_mode
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: do_set_mode
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_do_set_mode
|————Node:; Text: ;
|———Node:comment Text: //priv->can.do_set_bittiming = ctucan_set_bittiming;
|———Node:comment Text: //priv->can.do_set_data_bittiming = ctucan_set_data_bittiming;
|———Node:expression_statement Text: priv->can.do_get_berr_counter = ctucan_get_berr_counter;
|————Node:assignment_expression Text: priv->can.do_get_berr_counter = ctucan_get_berr_counter
|—————Node:field_expression Text: priv->can.do_get_berr_counter
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: do_get_berr_counter
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_get_berr_counter
|————Node:; Text: ;
|———Node:comment Text: //priv->can.do_get_state = ctucan_get_state;
|———Node:expression_statement Text: priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK /*| CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_FD | CAN_CTRLMODE_PRESUME_ACK | CAN_CTRLMODE_FD_NON_ISO | CAN_CTRLMODE_ONE_SHOT*/;
|————Node:assignment_expression Text: priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK
|—————Node:field_expression Text: priv->can.ctrlmode_supported
|——————Node:field_expression Text: priv->can
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: can
|——————Node:. Text: .
|——————Node:field_identifier Text: ctrlmode_supported
|—————Node:= Text: =
|—————Node:identifier Text: CAN_CTRLMODE_LOOPBACK
|————Node:comment Text: /*| CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_FD | CAN_CTRLMODE_PRESUME_ACK | CAN_CTRLMODE_FD_NON_ISO | CAN_CTRLMODE_ONE_SHOT*/
|————Node:; Text: ;
|———Node:expression_statement Text: priv->p.mem_base = addr;
|————Node:assignment_expression Text: priv->p.mem_base = addr
|—————Node:field_expression Text: priv->p.mem_base
|——————Node:field_expression Text: priv->p
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: p
|——————Node:. Text: .
|——————Node:field_identifier Text: mem_base
|—————Node:= Text: =
|—————Node:identifier Text: addr
|————Node:; Text: ;
|———Node:comment Text: /* Get IRQ for the device */
|———Node:expression_statement Text: ndev->irq = platform_get_irq(pdev, 0);
|————Node:assignment_expression Text: ndev->irq = platform_get_irq(pdev, 0)
|—————Node:field_expression Text: ndev->irq
|——————Node:identifier Text: ndev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: irq
|—————Node:= Text: =
|—————Node:call_expression Text: platform_get_irq(pdev, 0)
|——————Node:identifier Text: platform_get_irq
|——————Node:argument_list Text: (pdev, 0)
|———————Node:( Text: (
|———————Node:identifier Text: pdev
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ndev->flags |= IFF_ECHO;
|————Node:assignment_expression Text: ndev->flags |= IFF_ECHO
|—————Node:field_expression Text: ndev->flags
|——————Node:identifier Text: ndev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: flags
|—————Node:|= Text: |=
|—————Node:identifier Text: IFF_ECHO
|————Node:; Text: ;
|———Node:comment Text: /* We support local echo */
|———Node:expression_statement Text: platform_set_drvdata(pdev, ndev);
|————Node:call_expression Text: platform_set_drvdata(pdev, ndev)
|—————Node:identifier Text: platform_set_drvdata
|—————Node:argument_list Text: (pdev, ndev)
|——————Node:( Text: (
|——————Node:identifier Text: pdev
|——————Node:, Text: ,
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: SET_NETDEV_DEV(ndev, &pdev->dev);
|————Node:call_expression Text: SET_NETDEV_DEV(ndev, &pdev->dev)
|—————Node:identifier Text: SET_NETDEV_DEV
|—————Node:argument_list Text: (ndev, &pdev->dev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &pdev->dev
|———————Node:& Text: &
|———————Node:field_expression Text: pdev->dev
|————————Node:identifier Text: pdev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ndev->netdev_ops = &ctucan_netdev_ops;
|————Node:assignment_expression Text: ndev->netdev_ops = &ctucan_netdev_ops
|—————Node:field_expression Text: ndev->netdev_ops
|——————Node:identifier Text: ndev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: netdev_ops
|—————Node:= Text: =
|—————Node:pointer_expression Text: &ctucan_netdev_ops
|——————Node:& Text: &
|——————Node:identifier Text: ctucan_netdev_ops
|————Node:; Text: ;
|———Node:comment Text: /* Getting the CAN can_clk info */
|———Node:expression_statement Text: priv->can_clk = devm_clk_get(&pdev->dev, NULL);
|————Node:assignment_expression Text: priv->can_clk = devm_clk_get(&pdev->dev, NULL)
|—————Node:field_expression Text: priv->can_clk
|——————Node:identifier Text: priv
|——————Node:-> Text: ->
|——————Node:field_identifier Text: can_clk
|—————Node:= Text: =
|—————Node:call_expression Text: devm_clk_get(&pdev->dev, NULL)
|——————Node:identifier Text: devm_clk_get
|——————Node:argument_list Text: (&pdev->dev, NULL)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &pdev->dev
|————————Node:& Text: &
|————————Node:field_expression Text: pdev->dev
|—————————Node:identifier Text: pdev
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: dev
|———————Node:, Text: ,
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (IS_ERR(priv->can_clk)) {
		dev_err(&pdev->dev, "Device clock not found.\n");
		ret = PTR_ERR(priv->can_clk);
		goto err_free;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (IS_ERR(priv->can_clk))
|—————Node:( Text: (
|—————Node:call_expression Text: IS_ERR(priv->can_clk)
|——————Node:identifier Text: IS_ERR
|——————Node:argument_list Text: (priv->can_clk)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->can_clk
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_clk
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		dev_err(&pdev->dev, "Device clock not found.\n");
		ret = PTR_ERR(priv->can_clk);
		goto err_free;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: dev_err(&pdev->dev, "Device clock not found.\n");
|——————Node:call_expression Text: dev_err(&pdev->dev, "Device clock not found.\n")
|———————Node:identifier Text: dev_err
|———————Node:argument_list Text: (&pdev->dev, "Device clock not found.\n")
|————————Node:( Text: (
|————————Node:pointer_expression Text: &pdev->dev
|—————————Node:& Text: &
|—————————Node:field_expression Text: pdev->dev
|——————————Node:identifier Text: pdev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: dev
|————————Node:, Text: ,
|————————Node:string_literal Text: "Device clock not found.\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: Device clock not found.
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ret = PTR_ERR(priv->can_clk);
|——————Node:assignment_expression Text: ret = PTR_ERR(priv->can_clk)
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:call_expression Text: PTR_ERR(priv->can_clk)
|————————Node:identifier Text: PTR_ERR
|————————Node:argument_list Text: (priv->can_clk)
|—————————Node:( Text: (
|—————————Node:field_expression Text: priv->can_clk
|——————————Node:identifier Text: priv
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_clk
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err_free;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err_free
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: priv->p.write_reg = ctu_can_fd_write32;
|————Node:assignment_expression Text: priv->p.write_reg = ctu_can_fd_write32
|—————Node:field_expression Text: priv->p.write_reg
|——————Node:field_expression Text: priv->p
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: p
|——————Node:. Text: .
|——————Node:field_identifier Text: write_reg
|—————Node:= Text: =
|—————Node:identifier Text: ctu_can_fd_write32
|————Node:; Text: ;
|———Node:expression_statement Text: priv->p.read_reg = ctu_can_fd_read32;
|————Node:assignment_expression Text: priv->p.read_reg = ctu_can_fd_read32
|—————Node:field_expression Text: priv->p.read_reg
|——————Node:field_expression Text: priv->p
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: p
|——————Node:. Text: .
|——————Node:field_identifier Text: read_reg
|—————Node:= Text: =
|—————Node:identifier Text: ctu_can_fd_read32
|————Node:; Text: ;
|———Node:expression_statement Text: pm_runtime_enable(&pdev->dev);
|————Node:call_expression Text: pm_runtime_enable(&pdev->dev)
|—————Node:identifier Text: pm_runtime_enable
|—————Node:argument_list Text: (&pdev->dev)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &pdev->dev
|———————Node:& Text: &
|———————Node:field_expression Text: pdev->dev
|————————Node:identifier Text: pdev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = pm_runtime_get_sync(&pdev->dev);
|————Node:assignment_expression Text: ret = pm_runtime_get_sync(&pdev->dev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: pm_runtime_get_sync(&pdev->dev)
|——————Node:identifier Text: pm_runtime_get_sync
|——————Node:argument_list Text: (&pdev->dev)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &pdev->dev
|————————Node:& Text: &
|————————Node:field_expression Text: pdev->dev
|—————————Node:identifier Text: pdev
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: dev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0) {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret);
		goto err_pmdisable;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret);
		goto err_pmdisable;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret);
|——————Node:call_expression Text: netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret)
|———————Node:identifier Text: netdev_err
|———————Node:argument_list Text: (ndev, "%s: pm_runtime_get failed(%d)\n",
			__func__, ret)
|————————Node:( Text: (
|————————Node:identifier Text: ndev
|————————Node:, Text: ,
|————————Node:string_literal Text: "%s: pm_runtime_get failed(%d)\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: %s: pm_runtime_get failed(%d)
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: __func__
|————————Node:, Text: ,
|————————Node:identifier Text: ret
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err_pmdisable;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err_pmdisable
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if ((priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF) != CTU_CAN_FD_ID) {
		priv->p.write_reg = ctu_can_fd_write32_be;
		priv->p.read_reg = ctu_can_fd_read32_be;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF) != CTU_CAN_FD_ID)
|—————Node:( Text: (
|—————Node:binary_expression Text: (priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF) != CTU_CAN_FD_ID
|——————Node:parenthesized_expression Text: (priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF)
|———————Node:( Text: (
|———————Node:binary_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID) & 0xFFFF
|————————Node:call_expression Text: priv->p.read_reg(&priv->p, CTU_CAN_FD_DEVICE_ID)
|—————————Node:field_expression Text: priv->p.read_reg
|——————————Node:field_expression Text: priv->p
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: p
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_reg
|—————————Node:argument_list Text: (&priv->p, CTU_CAN_FD_DEVICE_ID)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &priv->p
|———————————Node:& Text: &
|———————————Node:field_expression Text: priv->p
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: p
|——————————Node:, Text: ,
|——————————Node:identifier Text: CTU_CAN_FD_DEVICE_ID
|——————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0xFFFF
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: CTU_CAN_FD_ID
|—————Node:) Text: )
|————Node:compound_statement Text: {
		priv->p.write_reg = ctu_can_fd_write32_be;
		priv->p.read_reg = ctu_can_fd_read32_be;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: priv->p.write_reg = ctu_can_fd_write32_be;
|——————Node:assignment_expression Text: priv->p.write_reg = ctu_can_fd_write32_be
|———————Node:field_expression Text: priv->p.write_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: write_reg
|———————Node:= Text: =
|———————Node:identifier Text: ctu_can_fd_write32_be
|——————Node:; Text: ;
|—————Node:expression_statement Text: priv->p.read_reg = ctu_can_fd_read32_be;
|——————Node:assignment_expression Text: priv->p.read_reg = ctu_can_fd_read32_be
|———————Node:field_expression Text: priv->p.read_reg
|————————Node:field_expression Text: priv->p
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: p
|————————Node:. Text: .
|————————Node:field_identifier Text: read_reg
|———————Node:= Text: =
|———————Node:identifier Text: ctu_can_fd_read32_be
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ret = ctucan_reset(ndev);
|————Node:assignment_expression Text: ret = ctucan_reset(ndev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: ctucan_reset(ndev)
|——————Node:identifier Text: ctucan_reset
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < 0)
		goto err_pmdisable;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < 0
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:goto_statement Text: goto err_pmdisable;
|—————Node:goto Text: goto
|—————Node:statement_identifier Text: err_pmdisable
|—————Node:; Text: ;
|———Node:expression_statement Text: priv->can.clock.freq = clk_get_rate(priv->can_clk);
|————Node:assignment_expression Text: priv->can.clock.freq = clk_get_rate(priv->can_clk)
|—————Node:field_expression Text: priv->can.clock.freq
|——————Node:field_expression Text: priv->can.clock
|———————Node:field_expression Text: priv->can
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can
|———————Node:. Text: .
|———————Node:field_identifier Text: clock
|——————Node:. Text: .
|——————Node:field_identifier Text: freq
|—————Node:= Text: =
|—————Node:call_expression Text: clk_get_rate(priv->can_clk)
|——————Node:identifier Text: clk_get_rate
|——————Node:argument_list Text: (priv->can_clk)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->can_clk
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: can_clk
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netif_napi_add(ndev, &priv->napi, ctucan_rx_poll, NAPI_POLL_WEIGHT);
|————Node:call_expression Text: netif_napi_add(ndev, &priv->napi, ctucan_rx_poll, NAPI_POLL_WEIGHT)
|—————Node:identifier Text: netif_napi_add
|—————Node:argument_list Text: (ndev, &priv->napi, ctucan_rx_poll, NAPI_POLL_WEIGHT)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &priv->napi
|———————Node:& Text: &
|———————Node:field_expression Text: priv->napi
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: napi
|——————Node:, Text: ,
|——————Node:identifier Text: ctucan_rx_poll
|——————Node:, Text: ,
|——————Node:identifier Text: NAPI_POLL_WEIGHT
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = register_candev(ndev);
|————Node:assignment_expression Text: ret = register_candev(ndev)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: register_candev(ndev)
|——————Node:identifier Text: register_candev
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret) {
		dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);
		goto err_disableclks;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ret)
|—————Node:( Text: (
|—————Node:identifier Text: ret
|—————Node:) Text: )
|————Node:compound_statement Text: {
		dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);
		goto err_disableclks;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);
|——————Node:call_expression Text: dev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret)
|———————Node:identifier Text: dev_err
|———————Node:argument_list Text: (&pdev->dev, "fail to register failed (err=%d)\n", ret)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &pdev->dev
|—————————Node:& Text: &
|—————————Node:field_expression Text: pdev->dev
|——————————Node:identifier Text: pdev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: dev
|————————Node:, Text: ,
|————————Node:string_literal Text: "fail to register failed (err=%d)\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: fail to register failed (err=%d)
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: ret
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:goto_statement Text: goto err_disableclks;
|——————Node:goto Text: goto
|——————Node:statement_identifier Text: err_disableclks
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: devm_can_led_init(ndev);
|————Node:call_expression Text: devm_can_led_init(ndev)
|—————Node:identifier Text: devm_can_led_init
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pm_runtime_put(&pdev->dev);
|————Node:call_expression Text: pm_runtime_put(&pdev->dev)
|—————Node:identifier Text: pm_runtime_put
|—————Node:argument_list Text: (&pdev->dev)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &pdev->dev
|———————Node:& Text: &
|———————Node:field_expression Text: pdev->dev
|————————Node:identifier Text: pdev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_dbg(ndev, "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n",
			priv->p.mem_base, ndev->irq, priv->can.clock.freq,
			priv->txb_mask);
|————Node:call_expression Text: netdev_dbg(ndev, "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n",
			priv->p.mem_base, ndev->irq, priv->can.clock.freq,
			priv->txb_mask)
|—————Node:identifier Text: netdev_dbg
|—————Node:argument_list Text: (ndev, "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n",
			priv->p.mem_base, ndev->irq, priv->can.clock.freq,
			priv->txb_mask)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "mem_base=0x%p irq=%d clock=%d, txb mask:%d\n"
|———————Node:" Text: "
|———————Node:string_content Text: mem_base=0x%p irq=%d clock=%d, txb mask:%d
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->p.mem_base
|———————Node:field_expression Text: priv->p
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: p
|———————Node:. Text: .
|———————Node:field_identifier Text: mem_base
|——————Node:, Text: ,
|——————Node:field_expression Text: ndev->irq
|———————Node:identifier Text: ndev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: irq
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->can.clock.freq
|———————Node:field_expression Text: priv->can.clock
|————————Node:field_expression Text: priv->can
|—————————Node:identifier Text: priv
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: can
|————————Node:. Text: .
|————————Node:field_identifier Text: clock
|———————Node:. Text: .
|———————Node:field_identifier Text: freq
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->txb_mask
|———————Node:identifier Text: priv
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txb_mask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:labeled_statement Text: err_disableclks:
	pm_runtime_put(priv->dev);
|————Node:statement_identifier Text: err_disableclks
|————Node:: Text: :
|————Node:expression_statement Text: pm_runtime_put(priv->dev);
|—————Node:call_expression Text: pm_runtime_put(priv->dev)
|——————Node:identifier Text: pm_runtime_put
|——————Node:argument_list Text: (priv->dev)
|———————Node:( Text: (
|———————Node:field_expression Text: priv->dev
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:labeled_statement Text: err_pmdisable:
	pm_runtime_disable(&pdev->dev);
|————Node:statement_identifier Text: err_pmdisable
|————Node:: Text: :
|————Node:expression_statement Text: pm_runtime_disable(&pdev->dev);
|—————Node:call_expression Text: pm_runtime_disable(&pdev->dev)
|——————Node:identifier Text: pm_runtime_disable
|——————Node:argument_list Text: (&pdev->dev)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &pdev->dev
|————————Node:& Text: &
|————————Node:field_expression Text: pdev->dev
|—————————Node:identifier Text: pdev
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: dev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:labeled_statement Text: err_free:
	free_candev(ndev);
|————Node:statement_identifier Text: err_free
|————Node:: Text: :
|————Node:expression_statement Text: free_candev(ndev);
|—————Node:call_expression Text: free_candev(ndev)
|——————Node:identifier Text: free_candev
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:labeled_statement Text: err:
	return ret;
|————Node:statement_identifier Text: err
|————Node:: Text: :
|————Node:return_statement Text: return ret;
|—————Node:return Text: return
|—————Node:identifier Text: ret
|—————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * ctucan_remove - Unregister the device after releasing the resources
 * @pdev:	Handle to the platform device structure
 *
 * This function frees all the resources allocated to the device.
 * Return: 0 always
 */
|—Node:function_definition Text: static int ctucan_remove(struct platform_device *pdev)
{
	struct net_device *ndev = platform_get_drvdata(pdev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_remove");

	unregister_candev(ndev);
	pm_runtime_disable(&pdev->dev);
	netif_napi_del(&priv->napi);
	free_candev(ndev);

	return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ctucan_remove(struct platform_device *pdev)
|———Node:identifier Text: ctucan_remove
|———Node:parameter_list Text: (struct platform_device *pdev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct platform_device *pdev
|—————Node:struct_specifier Text: struct platform_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: platform_device
|—————Node:pointer_declarator Text: *pdev
|——————Node:* Text: *
|——————Node:identifier Text: pdev
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct net_device *ndev = platform_get_drvdata(pdev);
	struct ctucan_priv *priv = netdev_priv(ndev);
	netdev_info(ndev, "ctucan_remove");

	unregister_candev(ndev);
	pm_runtime_disable(&pdev->dev);
	netif_napi_del(&priv->napi);
	free_candev(ndev);

	return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: struct net_device *ndev = platform_get_drvdata(pdev);
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: *ndev = platform_get_drvdata(pdev)
|—————Node:pointer_declarator Text: *ndev
|——————Node:* Text: *
|——————Node:identifier Text: ndev
|—————Node:= Text: =
|—————Node:call_expression Text: platform_get_drvdata(pdev)
|——————Node:identifier Text: platform_get_drvdata
|——————Node:argument_list Text: (pdev)
|———————Node:( Text: (
|———————Node:identifier Text: pdev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct ctucan_priv *priv = netdev_priv(ndev);
|————Node:struct_specifier Text: struct ctucan_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: ctucan_priv
|————Node:init_declarator Text: *priv = netdev_priv(ndev)
|—————Node:pointer_declarator Text: *priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(ndev)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (ndev)
|———————Node:( Text: (
|———————Node:identifier Text: ndev
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netdev_info(ndev, "ctucan_remove");
|————Node:call_expression Text: netdev_info(ndev, "ctucan_remove")
|—————Node:identifier Text: netdev_info
|—————Node:argument_list Text: (ndev, "ctucan_remove")
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:, Text: ,
|——————Node:string_literal Text: "ctucan_remove"
|———————Node:" Text: "
|———————Node:string_content Text: ctucan_remove
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: unregister_candev(ndev);
|————Node:call_expression Text: unregister_candev(ndev)
|—————Node:identifier Text: unregister_candev
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pm_runtime_disable(&pdev->dev);
|————Node:call_expression Text: pm_runtime_disable(&pdev->dev)
|—————Node:identifier Text: pm_runtime_disable
|—————Node:argument_list Text: (&pdev->dev)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &pdev->dev
|———————Node:& Text: &
|———————Node:field_expression Text: pdev->dev
|————————Node:identifier Text: pdev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: netif_napi_del(&priv->napi);
|————Node:call_expression Text: netif_napi_del(&priv->napi)
|—————Node:identifier Text: netif_napi_del
|—————Node:argument_list Text: (&priv->napi)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &priv->napi
|———————Node:& Text: &
|———————Node:field_expression Text: priv->napi
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: napi
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: free_candev(ndev);
|————Node:call_expression Text: free_candev(ndev)
|—————Node:identifier Text: free_candev
|—————Node:argument_list Text: (ndev)
|——————Node:( Text: (
|——————Node:identifier Text: ndev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* Match table for OF platform binding */
|—Node:declaration Text: static const struct of_device_id ctucan_of_match[] = {
	{ .compatible = "ctu,canfd-1.0", },
	{ .compatible = "ctu,ctucanfd", },
	{ /* end of list */ },
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:struct_specifier Text: struct of_device_id
|———Node:struct Text: struct
|———Node:type_identifier Text: of_device_id
|——Node:init_declarator Text: ctucan_of_match[] = {
	{ .compatible = "ctu,canfd-1.0", },
	{ .compatible = "ctu,ctucanfd", },
	{ /* end of list */ },
}
|———Node:array_declarator Text: ctucan_of_match[]
|————Node:identifier Text: ctucan_of_match
|————Node:[ Text: [
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
	{ .compatible = "ctu,canfd-1.0", },
	{ .compatible = "ctu,ctucanfd", },
	{ /* end of list */ },
}
|————Node:{ Text: {
|————Node:initializer_list Text: { .compatible = "ctu,canfd-1.0", }
|—————Node:{ Text: {
|—————Node:initializer_pair Text: .compatible = "ctu,canfd-1.0"
|——————Node:field_designator Text: .compatible
|———————Node:. Text: .
|———————Node:field_identifier Text: compatible
|——————Node:= Text: =
|——————Node:string_literal Text: "ctu,canfd-1.0"
|———————Node:" Text: "
|———————Node:string_content Text: ctu,canfd-1.0
|———————Node:" Text: "
|—————Node:, Text: ,
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: { .compatible = "ctu,ctucanfd", }
|—————Node:{ Text: {
|—————Node:initializer_pair Text: .compatible = "ctu,ctucanfd"
|——————Node:field_designator Text: .compatible
|———————Node:. Text: .
|———————Node:field_identifier Text: compatible
|——————Node:= Text: =
|——————Node:string_literal Text: "ctu,ctucanfd"
|———————Node:" Text: "
|———————Node:string_content Text: ctu,ctucanfd
|———————Node:" Text: "
|—————Node:, Text: ,
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: { /* end of list */ }
|—————Node:{ Text: {
|—————Node:comment Text: /* end of list */
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:expression_statement Text: MODULE_DEVICE_TABLE(of, ctucan_of_match);
|——Node:call_expression Text: MODULE_DEVICE_TABLE(of, ctucan_of_match)
|———Node:identifier Text: MODULE_DEVICE_TABLE
|———Node:argument_list Text: (of, ctucan_of_match)
|————Node:( Text: (
|————Node:identifier Text: of
|————Node:, Text: ,
|————Node:identifier Text: ctucan_of_match
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static struct platform_driver ctucanfd_driver = {
	.probe	= ctucan_probe,
	.remove	= ctucan_remove,
	.driver	= {
		.name = DRIVER_NAME,
		.pm = &ctucan_dev_pm_ops,
		.of_match_table	= ctucan_of_match,
	},
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct platform_driver
|———Node:struct Text: struct
|———Node:type_identifier Text: platform_driver
|——Node:init_declarator Text: ctucanfd_driver = {
	.probe	= ctucan_probe,
	.remove	= ctucan_remove,
	.driver	= {
		.name = DRIVER_NAME,
		.pm = &ctucan_dev_pm_ops,
		.of_match_table	= ctucan_of_match,
	},
}
|———Node:identifier Text: ctucanfd_driver
|———Node:= Text: =
|———Node:initializer_list Text: {
	.probe	= ctucan_probe,
	.remove	= ctucan_remove,
	.driver	= {
		.name = DRIVER_NAME,
		.pm = &ctucan_dev_pm_ops,
		.of_match_table	= ctucan_of_match,
	},
}
|————Node:{ Text: {
|————Node:initializer_pair Text: .probe	= ctucan_probe
|—————Node:field_designator Text: .probe
|——————Node:. Text: .
|——————Node:field_identifier Text: probe
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_probe
|————Node:, Text: ,
|————Node:initializer_pair Text: .remove	= ctucan_remove
|—————Node:field_designator Text: .remove
|——————Node:. Text: .
|——————Node:field_identifier Text: remove
|—————Node:= Text: =
|—————Node:identifier Text: ctucan_remove
|————Node:, Text: ,
|————Node:initializer_pair Text: .driver	= {
		.name = DRIVER_NAME,
		.pm = &ctucan_dev_pm_ops,
		.of_match_table	= ctucan_of_match,
	}
|—————Node:field_designator Text: .driver
|——————Node:. Text: .
|——————Node:field_identifier Text: driver
|—————Node:= Text: =
|—————Node:initializer_list Text: {
		.name = DRIVER_NAME,
		.pm = &ctucan_dev_pm_ops,
		.of_match_table	= ctucan_of_match,
	}
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .name = DRIVER_NAME
|———————Node:field_designator Text: .name
|————————Node:. Text: .
|————————Node:field_identifier Text: name
|———————Node:= Text: =
|———————Node:identifier Text: DRIVER_NAME
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .pm = &ctucan_dev_pm_ops
|———————Node:field_designator Text: .pm
|————————Node:. Text: .
|————————Node:field_identifier Text: pm
|———————Node:= Text: =
|———————Node:pointer_expression Text: &ctucan_dev_pm_ops
|————————Node:& Text: &
|————————Node:identifier Text: ctucan_dev_pm_ops
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .of_match_table	= ctucan_of_match
|———————Node:field_designator Text: .of_match_table
|————————Node:. Text: .
|————————Node:field_identifier Text: of_match_table
|———————Node:= Text: =
|———————Node:identifier Text: ctucan_of_match
|——————Node:, Text: ,
|——————Node:} Text: }
|————Node:, Text: ,
|————Node:} Text: }
|——Node:; Text: ;
|—Node:expression_statement Text: module_platform_driver(ctucanfd_driver);
|——Node:call_expression Text: module_platform_driver(ctucanfd_driver)
|———Node:identifier Text: module_platform_driver
|———Node:argument_list Text: (ctucanfd_driver)
|————Node:( Text: (
|————Node:identifier Text: ctucanfd_driver
|————Node:) Text: )
|——Node:; Text: ;
|—Node:expression_statement Text: MODULE_LICENSE("GPL");
|——Node:call_expression Text: MODULE_LICENSE("GPL")
|———Node:identifier Text: MODULE_LICENSE
|———Node:argument_list Text: ("GPL")
|————Node:( Text: (
|————Node:string_literal Text: "GPL"
|—————Node:" Text: "
|—————Node:string_content Text: GPL
|—————Node:" Text: "
|————Node:) Text: )
|——Node:; Text: ;
|—Node:expression_statement Text: MODULE_AUTHOR("Martin Jerabek");
|——Node:call_expression Text: MODULE_AUTHOR("Martin Jerabek")
|———Node:identifier Text: MODULE_AUTHOR
|———Node:argument_list Text: ("Martin Jerabek")
|————Node:( Text: (
|————Node:string_literal Text: "Martin Jerabek"
|—————Node:" Text: "
|—————Node:string_content Text: Martin Jerabek
|—————Node:" Text: "
|————Node:) Text: )
|——Node:; Text: ;
|—Node:expression_statement Text: MODULE_DESCRIPTION("CTU CAN FD interface");
|——Node:call_expression Text: MODULE_DESCRIPTION("CTU CAN FD interface")
|———Node:identifier Text: MODULE_DESCRIPTION
|———Node:argument_list Text: ("CTU CAN FD interface")
|————Node:( Text: (
|————Node:string_literal Text: "CTU CAN FD interface"
|—————Node:" Text: "
|—————Node:string_content Text: CTU CAN FD interface
|—————Node:" Text: "
|————Node:) Text: )
|——Node:; Text: ;
