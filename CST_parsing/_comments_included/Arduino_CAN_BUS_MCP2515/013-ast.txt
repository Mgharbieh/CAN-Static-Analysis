Arduino_CAN_BUS_MCP2515-mcp_can.cpp

|Node:translation_unit
|—Node:comment Text: /*
  mcp_can.cpp
  2012 Copyright (c) Seeed Technology Inc.  All right reserved.

  Author:Loovee
  2012-4-24
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-
  1301  USA
*/
|—Node:preproc_include Text: #include "mcp_can.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "mcp_can.h"
|———Node:" Text: "
|———Node:string_content Text: mcp_can.h
|———Node:" Text: "
|—Node:preproc_def Text: #define spi_readwrite SPI.transfer

|——Node:#define Text: #define
|——Node:identifier Text: spi_readwrite
|——Node:preproc_arg Text: SPI.transfer
|—Node:preproc_function_def Text: #define spi_read() spi_readwrite(0x00)

|——Node:#define Text: #define
|——Node:identifier Text: spi_read
|——Node:preproc_params Text: ()
|———Node:( Text: (
|———Node:) Text: )
|——Node:preproc_arg Text: spi_readwrite(0x00)
|—Node:declaration Text: MCP_CAN CAN;
|——Node:type_identifier Text: MCP_CAN
|——Node:identifier Text: CAN
|——Node:; Text: ;
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_reset
** Descriptions:            reset the device
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_reset(void)                                      
{
    MCP2515_SELECT();
    spi_readwrite(MCP_RESET);
    MCP2515_UNSELECT();
    delay(10);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_reset(void)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_reset
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_reset
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    MCP2515_SELECT();
    spi_readwrite(MCP_RESET);
    MCP2515_UNSELECT();
    delay(10);
}
|———Node:{ Text: {
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_RESET);
|————Node:call_expression Text: spi_readwrite(MCP_RESET)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_RESET)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RESET
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: delay(10);
|————Node:call_expression Text: delay(10)
|—————Node:identifier Text: delay
|—————Node:argument_list Text: (10)
|——————Node:( Text: (
|——————Node:number_literal Text: 10
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_readRegister
** Descriptions:            read register
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_readRegister(const INT8U address)                                                                     
{
    INT8U ret;

    MCP2515_SELECT();
    spi_readwrite(MCP_READ);
    spi_readwrite(address);
    ret = spi_read();
    MCP2515_UNSELECT();

    return ret;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_readRegister(const INT8U address)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_readRegister
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_readRegister
|———Node:parameter_list Text: (const INT8U address)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U address
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: address
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret;

    MCP2515_SELECT();
    spi_readwrite(MCP_READ);
    spi_readwrite(address);
    ret = spi_read();
    MCP2515_UNSELECT();

    return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_READ);
|————Node:call_expression Text: spi_readwrite(MCP_READ)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_READ)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_READ
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(address);
|————Node:call_expression Text: spi_readwrite(address)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (address)
|——————Node:( Text: (
|——————Node:identifier Text: address
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = spi_read();
|————Node:assignment_expression Text: ret = spi_read()
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: spi_read()
|——————Node:identifier Text: spi_read
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_readRegisterS
** Descriptions:            read registerS
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_readRegisterS(const INT8U address, INT8U values[], const INT8U n)
{
	INT8U i;
	MCP2515_SELECT();
	spi_readwrite(MCP_READ);
	spi_readwrite(address);
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) 
    {
		values[i] = spi_read();
	}
	MCP2515_UNSELECT();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_readRegisterS(const INT8U address, INT8U values[], const INT8U n)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_readRegisterS
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_readRegisterS
|———Node:parameter_list Text: (const INT8U address, INT8U values[], const INT8U n)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U address
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: address
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U values[]
|—————Node:type_identifier Text: INT8U
|—————Node:array_declarator Text: values[]
|——————Node:identifier Text: values
|——————Node:[ Text: [
|——————Node:] Text: ]
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U n
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: n
|————Node:) Text: )
|——Node:compound_statement Text: {
	INT8U i;
	MCP2515_SELECT();
	spi_readwrite(MCP_READ);
	spi_readwrite(address);
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) 
    {
		values[i] = spi_read();
	}
	MCP2515_UNSELECT();
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U i;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_READ);
|————Node:call_expression Text: spi_readwrite(MCP_READ)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_READ)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_READ
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(address);
|————Node:call_expression Text: spi_readwrite(address)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (address)
|——————Node:( Text: (
|——————Node:identifier Text: address
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // mcp2515 has auto-increment of address-pointer
|———Node:for_statement Text: for (i=0; i<n; i++) 
    {
		values[i] = spi_read();
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<n
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: n
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		values[i] = spi_read();
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: values[i] = spi_read();
|——————Node:assignment_expression Text: values[i] = spi_read()
|———————Node:subscript_expression Text: values[i]
|————————Node:identifier Text: values
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: spi_read()
|————————Node:identifier Text: spi_read
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_setRegister
** Descriptions:            set register
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_setRegister(const INT8U address, const INT8U value)
{
    MCP2515_SELECT();
    spi_readwrite(MCP_WRITE);
    spi_readwrite(address);
    spi_readwrite(value);
    MCP2515_UNSELECT();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_setRegister(const INT8U address, const INT8U value)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_setRegister
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_setRegister
|———Node:parameter_list Text: (const INT8U address, const INT8U value)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U address
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: address
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U value
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: {
    MCP2515_SELECT();
    spi_readwrite(MCP_WRITE);
    spi_readwrite(address);
    spi_readwrite(value);
    MCP2515_UNSELECT();
}
|———Node:{ Text: {
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_WRITE);
|————Node:call_expression Text: spi_readwrite(MCP_WRITE)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_WRITE)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_WRITE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(address);
|————Node:call_expression Text: spi_readwrite(address)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (address)
|——————Node:( Text: (
|——————Node:identifier Text: address
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(value);
|————Node:call_expression Text: spi_readwrite(value)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (value)
|——————Node:( Text: (
|——————Node:identifier Text: value
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_setRegisterS
** Descriptions:            set registerS
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_setRegisterS(const INT8U address, const INT8U values[], const INT8U n)
{
    INT8U i;
    MCP2515_SELECT();
    spi_readwrite(MCP_WRITE);
    spi_readwrite(address);
       
    for (i=0; i<n; i++) 
    {
        spi_readwrite(values[i]);
    }
    MCP2515_UNSELECT();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_setRegisterS(const INT8U address, const INT8U values[], const INT8U n)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_setRegisterS
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_setRegisterS
|———Node:parameter_list Text: (const INT8U address, const INT8U values[], const INT8U n)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U address
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: address
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U values[]
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:array_declarator Text: values[]
|——————Node:identifier Text: values
|——————Node:[ Text: [
|——————Node:] Text: ]
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U n
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: n
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U i;
    MCP2515_SELECT();
    spi_readwrite(MCP_WRITE);
    spi_readwrite(address);
       
    for (i=0; i<n; i++) 
    {
        spi_readwrite(values[i]);
    }
    MCP2515_UNSELECT();
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U i;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_WRITE);
|————Node:call_expression Text: spi_readwrite(MCP_WRITE)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_WRITE)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_WRITE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(address);
|————Node:call_expression Text: spi_readwrite(address)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (address)
|——————Node:( Text: (
|——————Node:identifier Text: address
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<n; i++) 
    {
        spi_readwrite(values[i]);
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<n
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: n
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        spi_readwrite(values[i]);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: spi_readwrite(values[i]);
|——————Node:call_expression Text: spi_readwrite(values[i])
|———————Node:identifier Text: spi_readwrite
|———————Node:argument_list Text: (values[i])
|————————Node:( Text: (
|————————Node:subscript_expression Text: values[i]
|—————————Node:identifier Text: values
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_modifyRegister
** Descriptions:            set bit of one register
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_modifyRegister(const INT8U address, const INT8U mask, const INT8U data)
{
    MCP2515_SELECT();
    spi_readwrite(MCP_BITMOD);
    spi_readwrite(address);
    spi_readwrite(mask);
    spi_readwrite(data);
    MCP2515_UNSELECT();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_modifyRegister(const INT8U address, const INT8U mask, const INT8U data)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_modifyRegister
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_modifyRegister
|———Node:parameter_list Text: (const INT8U address, const INT8U mask, const INT8U data)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U address
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: address
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U mask
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U data
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    MCP2515_SELECT();
    spi_readwrite(MCP_BITMOD);
    spi_readwrite(address);
    spi_readwrite(mask);
    spi_readwrite(data);
    MCP2515_UNSELECT();
}
|———Node:{ Text: {
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_BITMOD);
|————Node:call_expression Text: spi_readwrite(MCP_BITMOD)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_BITMOD)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_BITMOD
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(address);
|————Node:call_expression Text: spi_readwrite(address)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (address)
|——————Node:( Text: (
|——————Node:identifier Text: address
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(mask);
|————Node:call_expression Text: spi_readwrite(mask)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (mask)
|——————Node:( Text: (
|——————Node:identifier Text: mask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(data);
|————Node:call_expression Text: spi_readwrite(data)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (data)
|——————Node:( Text: (
|——————Node:identifier Text: data
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_readStatus
** Descriptions:            read mcp2515's Status
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_readStatus(void)                             
{
	INT8U i;
	MCP2515_SELECT();
	spi_readwrite(MCP_READ_STATUS);
	i = spi_read();
	MCP2515_UNSELECT();
	
	return i;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_readStatus(void)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_readStatus
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_readStatus
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
	INT8U i;
	MCP2515_SELECT();
	spi_readwrite(MCP_READ_STATUS);
	i = spi_read();
	MCP2515_UNSELECT();
	
	return i;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U i;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_SELECT();
|————Node:call_expression Text: MCP2515_SELECT()
|—————Node:identifier Text: MCP2515_SELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: spi_readwrite(MCP_READ_STATUS);
|————Node:call_expression Text: spi_readwrite(MCP_READ_STATUS)
|—————Node:identifier Text: spi_readwrite
|—————Node:argument_list Text: (MCP_READ_STATUS)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_READ_STATUS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: i = spi_read();
|————Node:assignment_expression Text: i = spi_read()
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:call_expression Text: spi_read()
|——————Node:identifier Text: spi_read
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: MCP2515_UNSELECT();
|————Node:call_expression Text: MCP2515_UNSELECT()
|—————Node:identifier Text: MCP2515_UNSELECT
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return i;
|————Node:return Text: return
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_setCANCTRL_Mode
** Descriptions:            set control mode
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_setCANCTRL_Mode(const INT8U newmode)
{
    INT8U i;

    mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode);

    i = mcp2515_readRegister(MCP_CANCTRL);
    i &= MODE_MASK;

    if ( i == newmode ) 
    {
        return MCP2515_OK;
    }

    return MCP2515_FAIL;

}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_setCANCTRL_Mode(const INT8U newmode)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_setCANCTRL_Mode
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_setCANCTRL_Mode
|———Node:parameter_list Text: (const INT8U newmode)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U newmode
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: newmode
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U i;

    mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode);

    i = mcp2515_readRegister(MCP_CANCTRL);
    i &= MODE_MASK;

    if ( i == newmode ) 
    {
        return MCP2515_OK;
    }

    return MCP2515_FAIL;

}
|———Node:{ Text: {
|———Node:declaration Text: INT8U i;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode);
|————Node:call_expression Text: mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode)
|—————Node:identifier Text: mcp2515_modifyRegister
|—————Node:argument_list Text: (MCP_CANCTRL, MODE_MASK, newmode)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_CANCTRL
|——————Node:, Text: ,
|——————Node:identifier Text: MODE_MASK
|——————Node:, Text: ,
|——————Node:identifier Text: newmode
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: i = mcp2515_readRegister(MCP_CANCTRL);
|————Node:assignment_expression Text: i = mcp2515_readRegister(MCP_CANCTRL)
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readRegister(MCP_CANCTRL)
|——————Node:identifier Text: mcp2515_readRegister
|——————Node:argument_list Text: (MCP_CANCTRL)
|———————Node:( Text: (
|———————Node:identifier Text: MCP_CANCTRL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: i &= MODE_MASK;
|————Node:assignment_expression Text: i &= MODE_MASK
|—————Node:identifier Text: i
|—————Node:&= Text: &=
|—————Node:identifier Text: MODE_MASK
|————Node:; Text: ;
|———Node:if_statement Text: if ( i == newmode ) 
    {
        return MCP2515_OK;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( i == newmode )
|—————Node:( Text: (
|—————Node:binary_expression Text: i == newmode
|——————Node:identifier Text: i
|——————Node:== Text: ==
|——————Node:identifier Text: newmode
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return MCP2515_OK;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return MCP2515_OK;
|——————Node:return Text: return
|——————Node:identifier Text: MCP2515_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return MCP2515_FAIL;
|————Node:return Text: return
|————Node:identifier Text: MCP2515_FAIL
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_configRate
** Descriptions:            set boadrate
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_configRate(const INT8U canSpeed)            
{
    INT8U set, cfg1, cfg2, cfg3;
    set = 1;
    switch (canSpeed) 
    {
        case (CAN_5KBPS):
        cfg1 = MCP_16MHz_5kBPS_CFG1;
        cfg2 = MCP_16MHz_5kBPS_CFG2;
        cfg3 = MCP_16MHz_5kBPS_CFG3;
        break;

        case (CAN_10KBPS):
        cfg1 = MCP_16MHz_10kBPS_CFG1;
        cfg2 = MCP_16MHz_10kBPS_CFG2;
        cfg3 = MCP_16MHz_10kBPS_CFG3;
        break;

        case (CAN_20KBPS):
        cfg1 = MCP_16MHz_20kBPS_CFG1;
        cfg2 = MCP_16MHz_20kBPS_CFG2;
        cfg3 = MCP_16MHz_20kBPS_CFG3;
        break;

        case (CAN_40KBPS):
        cfg1 = MCP_16MHz_40kBPS_CFG1;
        cfg2 = MCP_16MHz_40kBPS_CFG2;
        cfg3 = MCP_16MHz_40kBPS_CFG3;
        break;

        case (CAN_50KBPS):
        cfg1 = MCP_16MHz_50kBPS_CFG1;
        cfg2 = MCP_16MHz_50kBPS_CFG2;
        cfg3 = MCP_16MHz_50kBPS_CFG3;
        break;

        case (CAN_80KBPS):
        cfg1 = MCP_16MHz_80kBPS_CFG1;
        cfg2 = MCP_16MHz_80kBPS_CFG2;
        cfg3 = MCP_16MHz_80kBPS_CFG3;
        break;

        case (CAN_100KBPS):                                             /* 100KBPS                  */
        cfg1 = MCP_16MHz_100kBPS_CFG1;
        cfg2 = MCP_16MHz_100kBPS_CFG2;
        cfg3 = MCP_16MHz_100kBPS_CFG3;
        break;

        case (CAN_125KBPS):
        cfg1 = MCP_16MHz_125kBPS_CFG1;
        cfg2 = MCP_16MHz_125kBPS_CFG2;
        cfg3 = MCP_16MHz_125kBPS_CFG3;
        break;

        case (CAN_200KBPS):
        cfg1 = MCP_16MHz_200kBPS_CFG1;
        cfg2 = MCP_16MHz_200kBPS_CFG2;
        cfg3 = MCP_16MHz_200kBPS_CFG3;
        break;

        case (CAN_250KBPS):
        cfg1 = MCP_16MHz_250kBPS_CFG1;
        cfg2 = MCP_16MHz_250kBPS_CFG2;
        cfg3 = MCP_16MHz_250kBPS_CFG3;
        break;

        case (CAN_500KBPS):
        cfg1 = MCP_16MHz_500kBPS_CFG1;
        cfg2 = MCP_16MHz_500kBPS_CFG2;
        cfg3 = MCP_16MHz_500kBPS_CFG3;
        break;
        
        case (CAN_1000KBPS):
        cfg1 = MCP_16MHz_1000kBPS_CFG1;
        cfg2 = MCP_16MHz_1000kBPS_CFG2;
        cfg3 = MCP_16MHz_1000kBPS_CFG3;
        break;  

        default:
        set = 0;
        break;
    }

    if (set) {
        mcp2515_setRegister(MCP_CNF1, cfg1);
        mcp2515_setRegister(MCP_CNF2, cfg2);
        mcp2515_setRegister(MCP_CNF3, cfg3);
        return MCP2515_OK;
    }
    else {
        return MCP2515_FAIL;
    }
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_configRate(const INT8U canSpeed)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_configRate
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_configRate
|———Node:parameter_list Text: (const INT8U canSpeed)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U canSpeed
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: canSpeed
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U set, cfg1, cfg2, cfg3;
    set = 1;
    switch (canSpeed) 
    {
        case (CAN_5KBPS):
        cfg1 = MCP_16MHz_5kBPS_CFG1;
        cfg2 = MCP_16MHz_5kBPS_CFG2;
        cfg3 = MCP_16MHz_5kBPS_CFG3;
        break;

        case (CAN_10KBPS):
        cfg1 = MCP_16MHz_10kBPS_CFG1;
        cfg2 = MCP_16MHz_10kBPS_CFG2;
        cfg3 = MCP_16MHz_10kBPS_CFG3;
        break;

        case (CAN_20KBPS):
        cfg1 = MCP_16MHz_20kBPS_CFG1;
        cfg2 = MCP_16MHz_20kBPS_CFG2;
        cfg3 = MCP_16MHz_20kBPS_CFG3;
        break;

        case (CAN_40KBPS):
        cfg1 = MCP_16MHz_40kBPS_CFG1;
        cfg2 = MCP_16MHz_40kBPS_CFG2;
        cfg3 = MCP_16MHz_40kBPS_CFG3;
        break;

        case (CAN_50KBPS):
        cfg1 = MCP_16MHz_50kBPS_CFG1;
        cfg2 = MCP_16MHz_50kBPS_CFG2;
        cfg3 = MCP_16MHz_50kBPS_CFG3;
        break;

        case (CAN_80KBPS):
        cfg1 = MCP_16MHz_80kBPS_CFG1;
        cfg2 = MCP_16MHz_80kBPS_CFG2;
        cfg3 = MCP_16MHz_80kBPS_CFG3;
        break;

        case (CAN_100KBPS):                                             /* 100KBPS                  */
        cfg1 = MCP_16MHz_100kBPS_CFG1;
        cfg2 = MCP_16MHz_100kBPS_CFG2;
        cfg3 = MCP_16MHz_100kBPS_CFG3;
        break;

        case (CAN_125KBPS):
        cfg1 = MCP_16MHz_125kBPS_CFG1;
        cfg2 = MCP_16MHz_125kBPS_CFG2;
        cfg3 = MCP_16MHz_125kBPS_CFG3;
        break;

        case (CAN_200KBPS):
        cfg1 = MCP_16MHz_200kBPS_CFG1;
        cfg2 = MCP_16MHz_200kBPS_CFG2;
        cfg3 = MCP_16MHz_200kBPS_CFG3;
        break;

        case (CAN_250KBPS):
        cfg1 = MCP_16MHz_250kBPS_CFG1;
        cfg2 = MCP_16MHz_250kBPS_CFG2;
        cfg3 = MCP_16MHz_250kBPS_CFG3;
        break;

        case (CAN_500KBPS):
        cfg1 = MCP_16MHz_500kBPS_CFG1;
        cfg2 = MCP_16MHz_500kBPS_CFG2;
        cfg3 = MCP_16MHz_500kBPS_CFG3;
        break;
        
        case (CAN_1000KBPS):
        cfg1 = MCP_16MHz_1000kBPS_CFG1;
        cfg2 = MCP_16MHz_1000kBPS_CFG2;
        cfg3 = MCP_16MHz_1000kBPS_CFG3;
        break;  

        default:
        set = 0;
        break;
    }

    if (set) {
        mcp2515_setRegister(MCP_CNF1, cfg1);
        mcp2515_setRegister(MCP_CNF2, cfg2);
        mcp2515_setRegister(MCP_CNF3, cfg3);
        return MCP2515_OK;
    }
    else {
        return MCP2515_FAIL;
    }
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U set, cfg1, cfg2, cfg3;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: set
|————Node:, Text: ,
|————Node:identifier Text: cfg1
|————Node:, Text: ,
|————Node:identifier Text: cfg2
|————Node:, Text: ,
|————Node:identifier Text: cfg3
|————Node:; Text: ;
|———Node:expression_statement Text: set = 1;
|————Node:assignment_expression Text: set = 1
|—————Node:identifier Text: set
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:switch_statement Text: switch (canSpeed) 
    {
        case (CAN_5KBPS):
        cfg1 = MCP_16MHz_5kBPS_CFG1;
        cfg2 = MCP_16MHz_5kBPS_CFG2;
        cfg3 = MCP_16MHz_5kBPS_CFG3;
        break;

        case (CAN_10KBPS):
        cfg1 = MCP_16MHz_10kBPS_CFG1;
        cfg2 = MCP_16MHz_10kBPS_CFG2;
        cfg3 = MCP_16MHz_10kBPS_CFG3;
        break;

        case (CAN_20KBPS):
        cfg1 = MCP_16MHz_20kBPS_CFG1;
        cfg2 = MCP_16MHz_20kBPS_CFG2;
        cfg3 = MCP_16MHz_20kBPS_CFG3;
        break;

        case (CAN_40KBPS):
        cfg1 = MCP_16MHz_40kBPS_CFG1;
        cfg2 = MCP_16MHz_40kBPS_CFG2;
        cfg3 = MCP_16MHz_40kBPS_CFG3;
        break;

        case (CAN_50KBPS):
        cfg1 = MCP_16MHz_50kBPS_CFG1;
        cfg2 = MCP_16MHz_50kBPS_CFG2;
        cfg3 = MCP_16MHz_50kBPS_CFG3;
        break;

        case (CAN_80KBPS):
        cfg1 = MCP_16MHz_80kBPS_CFG1;
        cfg2 = MCP_16MHz_80kBPS_CFG2;
        cfg3 = MCP_16MHz_80kBPS_CFG3;
        break;

        case (CAN_100KBPS):                                             /* 100KBPS                  */
        cfg1 = MCP_16MHz_100kBPS_CFG1;
        cfg2 = MCP_16MHz_100kBPS_CFG2;
        cfg3 = MCP_16MHz_100kBPS_CFG3;
        break;

        case (CAN_125KBPS):
        cfg1 = MCP_16MHz_125kBPS_CFG1;
        cfg2 = MCP_16MHz_125kBPS_CFG2;
        cfg3 = MCP_16MHz_125kBPS_CFG3;
        break;

        case (CAN_200KBPS):
        cfg1 = MCP_16MHz_200kBPS_CFG1;
        cfg2 = MCP_16MHz_200kBPS_CFG2;
        cfg3 = MCP_16MHz_200kBPS_CFG3;
        break;

        case (CAN_250KBPS):
        cfg1 = MCP_16MHz_250kBPS_CFG1;
        cfg2 = MCP_16MHz_250kBPS_CFG2;
        cfg3 = MCP_16MHz_250kBPS_CFG3;
        break;

        case (CAN_500KBPS):
        cfg1 = MCP_16MHz_500kBPS_CFG1;
        cfg2 = MCP_16MHz_500kBPS_CFG2;
        cfg3 = MCP_16MHz_500kBPS_CFG3;
        break;
        
        case (CAN_1000KBPS):
        cfg1 = MCP_16MHz_1000kBPS_CFG1;
        cfg2 = MCP_16MHz_1000kBPS_CFG2;
        cfg3 = MCP_16MHz_1000kBPS_CFG3;
        break;  

        default:
        set = 0;
        break;
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (canSpeed)
|—————Node:( Text: (
|—————Node:identifier Text: canSpeed
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case (CAN_5KBPS):
        cfg1 = MCP_16MHz_5kBPS_CFG1;
        cfg2 = MCP_16MHz_5kBPS_CFG2;
        cfg3 = MCP_16MHz_5kBPS_CFG3;
        break;

        case (CAN_10KBPS):
        cfg1 = MCP_16MHz_10kBPS_CFG1;
        cfg2 = MCP_16MHz_10kBPS_CFG2;
        cfg3 = MCP_16MHz_10kBPS_CFG3;
        break;

        case (CAN_20KBPS):
        cfg1 = MCP_16MHz_20kBPS_CFG1;
        cfg2 = MCP_16MHz_20kBPS_CFG2;
        cfg3 = MCP_16MHz_20kBPS_CFG3;
        break;

        case (CAN_40KBPS):
        cfg1 = MCP_16MHz_40kBPS_CFG1;
        cfg2 = MCP_16MHz_40kBPS_CFG2;
        cfg3 = MCP_16MHz_40kBPS_CFG3;
        break;

        case (CAN_50KBPS):
        cfg1 = MCP_16MHz_50kBPS_CFG1;
        cfg2 = MCP_16MHz_50kBPS_CFG2;
        cfg3 = MCP_16MHz_50kBPS_CFG3;
        break;

        case (CAN_80KBPS):
        cfg1 = MCP_16MHz_80kBPS_CFG1;
        cfg2 = MCP_16MHz_80kBPS_CFG2;
        cfg3 = MCP_16MHz_80kBPS_CFG3;
        break;

        case (CAN_100KBPS):                                             /* 100KBPS                  */
        cfg1 = MCP_16MHz_100kBPS_CFG1;
        cfg2 = MCP_16MHz_100kBPS_CFG2;
        cfg3 = MCP_16MHz_100kBPS_CFG3;
        break;

        case (CAN_125KBPS):
        cfg1 = MCP_16MHz_125kBPS_CFG1;
        cfg2 = MCP_16MHz_125kBPS_CFG2;
        cfg3 = MCP_16MHz_125kBPS_CFG3;
        break;

        case (CAN_200KBPS):
        cfg1 = MCP_16MHz_200kBPS_CFG1;
        cfg2 = MCP_16MHz_200kBPS_CFG2;
        cfg3 = MCP_16MHz_200kBPS_CFG3;
        break;

        case (CAN_250KBPS):
        cfg1 = MCP_16MHz_250kBPS_CFG1;
        cfg2 = MCP_16MHz_250kBPS_CFG2;
        cfg3 = MCP_16MHz_250kBPS_CFG3;
        break;

        case (CAN_500KBPS):
        cfg1 = MCP_16MHz_500kBPS_CFG1;
        cfg2 = MCP_16MHz_500kBPS_CFG2;
        cfg3 = MCP_16MHz_500kBPS_CFG3;
        break;
        
        case (CAN_1000KBPS):
        cfg1 = MCP_16MHz_1000kBPS_CFG1;
        cfg2 = MCP_16MHz_1000kBPS_CFG2;
        cfg3 = MCP_16MHz_1000kBPS_CFG3;
        break;  

        default:
        set = 0;
        break;
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case (CAN_5KBPS):
        cfg1 = MCP_16MHz_5kBPS_CFG1;
        cfg2 = MCP_16MHz_5kBPS_CFG2;
        cfg3 = MCP_16MHz_5kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_5KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_5KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_5kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_5kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_5kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_5kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_5kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_5kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_5kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_5kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_5kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_10KBPS):
        cfg1 = MCP_16MHz_10kBPS_CFG1;
        cfg2 = MCP_16MHz_10kBPS_CFG2;
        cfg3 = MCP_16MHz_10kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_10KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_10KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_10kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_10kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_10kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_10kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_10kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_10kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_10kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_10kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_10kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_20KBPS):
        cfg1 = MCP_16MHz_20kBPS_CFG1;
        cfg2 = MCP_16MHz_20kBPS_CFG2;
        cfg3 = MCP_16MHz_20kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_20KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_20KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_20kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_20kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_20kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_20kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_20kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_20kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_20kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_20kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_20kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_40KBPS):
        cfg1 = MCP_16MHz_40kBPS_CFG1;
        cfg2 = MCP_16MHz_40kBPS_CFG2;
        cfg3 = MCP_16MHz_40kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_40KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_40KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_40kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_40kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_40kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_40kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_40kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_40kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_40kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_40kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_40kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_50KBPS):
        cfg1 = MCP_16MHz_50kBPS_CFG1;
        cfg2 = MCP_16MHz_50kBPS_CFG2;
        cfg3 = MCP_16MHz_50kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_50KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_50KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_50kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_50kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_50kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_50kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_50kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_50kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_50kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_50kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_50kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_80KBPS):
        cfg1 = MCP_16MHz_80kBPS_CFG1;
        cfg2 = MCP_16MHz_80kBPS_CFG2;
        cfg3 = MCP_16MHz_80kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_80KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_80KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_80kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_80kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_80kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_80kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_80kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_80kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_80kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_80kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_80kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_100KBPS):                                             /* 100KBPS                  */
        cfg1 = MCP_16MHz_100kBPS_CFG1;
        cfg2 = MCP_16MHz_100kBPS_CFG2;
        cfg3 = MCP_16MHz_100kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_100KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_100KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:comment Text: /* 100KBPS                  */
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_100kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_100kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_100kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_100kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_100kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_100kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_100kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_100kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_100kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_125KBPS):
        cfg1 = MCP_16MHz_125kBPS_CFG1;
        cfg2 = MCP_16MHz_125kBPS_CFG2;
        cfg3 = MCP_16MHz_125kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_125KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_125KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_125kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_125kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_125kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_125kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_125kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_125kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_125kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_125kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_125kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_200KBPS):
        cfg1 = MCP_16MHz_200kBPS_CFG1;
        cfg2 = MCP_16MHz_200kBPS_CFG2;
        cfg3 = MCP_16MHz_200kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_200KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_200KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_200kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_200kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_200kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_200kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_200kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_200kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_200kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_200kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_200kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_250KBPS):
        cfg1 = MCP_16MHz_250kBPS_CFG1;
        cfg2 = MCP_16MHz_250kBPS_CFG2;
        cfg3 = MCP_16MHz_250kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_250KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_250KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_250kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_250kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_250kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_250kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_250kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_250kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_250kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_250kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_250kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_500KBPS):
        cfg1 = MCP_16MHz_500kBPS_CFG1;
        cfg2 = MCP_16MHz_500kBPS_CFG2;
        cfg3 = MCP_16MHz_500kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_500KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_500KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_500kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_500kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_500kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_500kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_500kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_500kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_500kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_500kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_500kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case (CAN_1000KBPS):
        cfg1 = MCP_16MHz_1000kBPS_CFG1;
        cfg2 = MCP_16MHz_1000kBPS_CFG2;
        cfg3 = MCP_16MHz_1000kBPS_CFG3;
        break;
|——————Node:case Text: case
|——————Node:parenthesized_expression Text: (CAN_1000KBPS)
|———————Node:( Text: (
|———————Node:identifier Text: CAN_1000KBPS
|———————Node:) Text: )
|——————Node:: Text: :
|——————Node:expression_statement Text: cfg1 = MCP_16MHz_1000kBPS_CFG1;
|———————Node:assignment_expression Text: cfg1 = MCP_16MHz_1000kBPS_CFG1
|————————Node:identifier Text: cfg1
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_1000kBPS_CFG1
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg2 = MCP_16MHz_1000kBPS_CFG2;
|———————Node:assignment_expression Text: cfg2 = MCP_16MHz_1000kBPS_CFG2
|————————Node:identifier Text: cfg2
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_1000kBPS_CFG2
|———————Node:; Text: ;
|——————Node:expression_statement Text: cfg3 = MCP_16MHz_1000kBPS_CFG3;
|———————Node:assignment_expression Text: cfg3 = MCP_16MHz_1000kBPS_CFG3
|————————Node:identifier Text: cfg3
|————————Node:= Text: =
|————————Node:identifier Text: MCP_16MHz_1000kBPS_CFG3
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
        set = 0;
        break;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: set = 0;
|———————Node:assignment_expression Text: set = 0
|————————Node:identifier Text: set
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (set) {
        mcp2515_setRegister(MCP_CNF1, cfg1);
        mcp2515_setRegister(MCP_CNF2, cfg2);
        mcp2515_setRegister(MCP_CNF3, cfg3);
        return MCP2515_OK;
    }
    else {
        return MCP2515_FAIL;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (set)
|—————Node:( Text: (
|—————Node:identifier Text: set
|—————Node:) Text: )
|————Node:compound_statement Text: {
        mcp2515_setRegister(MCP_CNF1, cfg1);
        mcp2515_setRegister(MCP_CNF2, cfg2);
        mcp2515_setRegister(MCP_CNF3, cfg3);
        return MCP2515_OK;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: mcp2515_setRegister(MCP_CNF1, cfg1);
|——————Node:call_expression Text: mcp2515_setRegister(MCP_CNF1, cfg1)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (MCP_CNF1, cfg1)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_CNF1
|————————Node:, Text: ,
|————————Node:identifier Text: cfg1
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mcp2515_setRegister(MCP_CNF2, cfg2);
|——————Node:call_expression Text: mcp2515_setRegister(MCP_CNF2, cfg2)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (MCP_CNF2, cfg2)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_CNF2
|————————Node:, Text: ,
|————————Node:identifier Text: cfg2
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mcp2515_setRegister(MCP_CNF3, cfg3);
|——————Node:call_expression Text: mcp2515_setRegister(MCP_CNF3, cfg3)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (MCP_CNF3, cfg3)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_CNF3
|————————Node:, Text: ,
|————————Node:identifier Text: cfg3
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return MCP2515_OK;
|——————Node:return Text: return
|——————Node:identifier Text: MCP2515_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        return MCP2515_FAIL;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        return MCP2515_FAIL;
    }
|——————Node:{ Text: {
|——————Node:return_statement Text: return MCP2515_FAIL;
|———————Node:return Text: return
|———————Node:identifier Text: MCP2515_FAIL
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            init canbuffers
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_initCANBuffers(void)
{
    INT8U i, a1, a2, a3;
    
    INT8U std = 0;               
    INT8U ext = 1;
    INT32U ulMask = 0x00, ulFilt = 0x00;


    mcp2515_write_id(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    mcp2515_write_id(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    
                                                                        /* Set all filters to 0         */
    mcp2515_write_id(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    mcp2515_write_id(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    mcp2515_write_id(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    mcp2515_write_id(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    mcp2515_write_id(MCP_RXF4SIDH, ext, ulFilt);
    mcp2515_write_id(MCP_RXF5SIDH, std, ulFilt);

                                                                        /* Clear, deactivate the three  */
                                                                        /* transmit buffers             */
                                                                        /* TXBnCTRL -> TXBnD7           */
    a1 = MCP_TXB0CTRL;
    a2 = MCP_TXB1CTRL;
    a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
        mcp2515_setRegister(a1, 0);
        mcp2515_setRegister(a2, 0);
        mcp2515_setRegister(a3, 0);
        a1++;
        a2++;
        a3++;
    }
    mcp2515_setRegister(MCP_RXB0CTRL, 0);
    mcp2515_setRegister(MCP_RXB1CTRL, 0);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_initCANBuffers(void)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_initCANBuffers
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_initCANBuffers
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U i, a1, a2, a3;
    
    INT8U std = 0;               
    INT8U ext = 1;
    INT32U ulMask = 0x00, ulFilt = 0x00;


    mcp2515_write_id(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    mcp2515_write_id(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    
                                                                        /* Set all filters to 0         */
    mcp2515_write_id(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    mcp2515_write_id(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    mcp2515_write_id(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    mcp2515_write_id(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    mcp2515_write_id(MCP_RXF4SIDH, ext, ulFilt);
    mcp2515_write_id(MCP_RXF5SIDH, std, ulFilt);

                                                                        /* Clear, deactivate the three  */
                                                                        /* transmit buffers             */
                                                                        /* TXBnCTRL -> TXBnD7           */
    a1 = MCP_TXB0CTRL;
    a2 = MCP_TXB1CTRL;
    a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
        mcp2515_setRegister(a1, 0);
        mcp2515_setRegister(a2, 0);
        mcp2515_setRegister(a3, 0);
        a1++;
        a2++;
        a3++;
    }
    mcp2515_setRegister(MCP_RXB0CTRL, 0);
    mcp2515_setRegister(MCP_RXB1CTRL, 0);
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U i, a1, a2, a3;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: i
|————Node:, Text: ,
|————Node:identifier Text: a1
|————Node:, Text: ,
|————Node:identifier Text: a2
|————Node:, Text: ,
|————Node:identifier Text: a3
|————Node:; Text: ;
|———Node:declaration Text: INT8U std = 0;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: std = 0
|—————Node:identifier Text: std
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: INT8U ext = 1;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ext = 1
|—————Node:identifier Text: ext
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: INT32U ulMask = 0x00, ulFilt = 0x00;
|————Node:type_identifier Text: INT32U
|————Node:init_declarator Text: ulMask = 0x00
|—————Node:identifier Text: ulMask
|—————Node:= Text: =
|—————Node:number_literal Text: 0x00
|————Node:, Text: ,
|————Node:init_declarator Text: ulFilt = 0x00
|—————Node:identifier Text: ulFilt
|—————Node:= Text: =
|—————Node:number_literal Text: 0x00
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXM0SIDH, ext, ulMask);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXM0SIDH, ext, ulMask)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXM0SIDH, ext, ulMask)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXM0SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: ulMask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*Set both masks to 0           */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXM1SIDH, ext, ulMask);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXM1SIDH, ext, ulMask)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXM1SIDH, ext, ulMask)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXM1SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: ulMask
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*Mask register ignores ext bit */
|———Node:comment Text: /* Set all filters to 0         */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF0SIDH, ext, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF0SIDH, ext, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF0SIDH, ext, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF0SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* RXB0: extended               */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF1SIDH, std, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF1SIDH, std, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF1SIDH, std, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF1SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: std
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* RXB1: standard               */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF2SIDH, ext, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF2SIDH, ext, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF2SIDH, ext, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF2SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* RXB2: extended               */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF3SIDH, std, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF3SIDH, std, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF3SIDH, std, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF3SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: std
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* RXB3: standard               */
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF4SIDH, ext, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF4SIDH, ext, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF4SIDH, ext, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF4SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_write_id(MCP_RXF5SIDH, std, ulFilt);
|————Node:call_expression Text: mcp2515_write_id(MCP_RXF5SIDH, std, ulFilt)
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (MCP_RXF5SIDH, std, ulFilt)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXF5SIDH
|——————Node:, Text: ,
|——————Node:identifier Text: std
|——————Node:, Text: ,
|——————Node:identifier Text: ulFilt
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Clear, deactivate the three  */
|———Node:comment Text: /* transmit buffers             */
|———Node:comment Text: /* TXBnCTRL -> TXBnD7           */
|———Node:expression_statement Text: a1 = MCP_TXB0CTRL;
|————Node:assignment_expression Text: a1 = MCP_TXB0CTRL
|—————Node:identifier Text: a1
|—————Node:= Text: =
|—————Node:identifier Text: MCP_TXB0CTRL
|————Node:; Text: ;
|———Node:expression_statement Text: a2 = MCP_TXB1CTRL;
|————Node:assignment_expression Text: a2 = MCP_TXB1CTRL
|—————Node:identifier Text: a2
|—————Node:= Text: =
|—————Node:identifier Text: MCP_TXB1CTRL
|————Node:; Text: ;
|———Node:expression_statement Text: a3 = MCP_TXB2CTRL;
|————Node:assignment_expression Text: a3 = MCP_TXB2CTRL
|—————Node:identifier Text: a3
|—————Node:= Text: =
|—————Node:identifier Text: MCP_TXB2CTRL
|————Node:; Text: ;
|———Node:for_statement Text: for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
        mcp2515_setRegister(a1, 0);
        mcp2515_setRegister(a2, 0);
        mcp2515_setRegister(a3, 0);
        a1++;
        a2++;
        a3++;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i = 0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i < 14
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:number_literal Text: 14
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {                                          /* in-buffer loop               */
        mcp2515_setRegister(a1, 0);
        mcp2515_setRegister(a2, 0);
        mcp2515_setRegister(a3, 0);
        a1++;
        a2++;
        a3++;
    }
|—————Node:{ Text: {
|—————Node:comment Text: /* in-buffer loop               */
|—————Node:expression_statement Text: mcp2515_setRegister(a1, 0);
|——————Node:call_expression Text: mcp2515_setRegister(a1, 0)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (a1, 0)
|————————Node:( Text: (
|————————Node:identifier Text: a1
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mcp2515_setRegister(a2, 0);
|——————Node:call_expression Text: mcp2515_setRegister(a2, 0)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (a2, 0)
|————————Node:( Text: (
|————————Node:identifier Text: a2
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mcp2515_setRegister(a3, 0);
|——————Node:call_expression Text: mcp2515_setRegister(a3, 0)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (a3, 0)
|————————Node:( Text: (
|————————Node:identifier Text: a3
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: a1++;
|——————Node:update_expression Text: a1++
|———————Node:identifier Text: a1
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:expression_statement Text: a2++;
|——————Node:update_expression Text: a2++
|———————Node:identifier Text: a2
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:expression_statement Text: a3++;
|——————Node:update_expression Text: a3++
|———————Node:identifier Text: a3
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: mcp2515_setRegister(MCP_RXB0CTRL, 0);
|————Node:call_expression Text: mcp2515_setRegister(MCP_RXB0CTRL, 0)
|—————Node:identifier Text: mcp2515_setRegister
|—————Node:argument_list Text: (MCP_RXB0CTRL, 0)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXB0CTRL
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_setRegister(MCP_RXB1CTRL, 0);
|————Node:call_expression Text: mcp2515_setRegister(MCP_RXB1CTRL, 0)
|—————Node:identifier Text: mcp2515_setRegister
|—————Node:argument_list Text: (MCP_RXB1CTRL, 0)
|——————Node:( Text: (
|——————Node:identifier Text: MCP_RXB1CTRL
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            init the device
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_init(const INT8U canSpeed)                       /* mcp2515init                  */
{

  INT8U res;

    mcp2515_reset();

    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("Enter setting mode success \r\n");
#endif

                                                                        /* set boadrate                 */
    if(mcp2515_configRate(canSpeed))
    {
#if DEBUG_MODE
      Serial.print("set rate fall!!\r\n");
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("set rate success!!\r\n");
#endif

    if ( res == MCP2515_OK ) {

                                                                        /* init canbuffers              */
        mcp2515_initCANBuffers();

                                                                        /* interrupt mode               */
        mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);

#if (DEBUG_RXANY==1)
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive any message       */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
#else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
#endif
                                                                        /* enter normal mode            */
        res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);                                                                
        if(res)
        {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }


#if DEBUG_MODE
          Serial.print("Enter Normal Mode Success!!\r\n");
#endif

    }
    return res;

}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_init(const INT8U canSpeed)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_init
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_init
|———Node:parameter_list Text: (const INT8U canSpeed)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U canSpeed
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: canSpeed
|————Node:) Text: )
|——Node:comment Text: /* mcp2515init                  */
|——Node:compound_statement Text: {

  INT8U res;

    mcp2515_reset();

    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("Enter setting mode success \r\n");
#endif

                                                                        /* set boadrate                 */
    if(mcp2515_configRate(canSpeed))
    {
#if DEBUG_MODE
      Serial.print("set rate fall!!\r\n");
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("set rate success!!\r\n");
#endif

    if ( res == MCP2515_OK ) {

                                                                        /* init canbuffers              */
        mcp2515_initCANBuffers();

                                                                        /* interrupt mode               */
        mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);

#if (DEBUG_RXANY==1)
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive any message       */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
#else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
#endif
                                                                        /* enter normal mode            */
        res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);                                                                
        if(res)
        {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }


#if DEBUG_MODE
          Serial.print("Enter Normal Mode Success!!\r\n");
#endif

    }
    return res;

}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_reset();
|————Node:call_expression Text: mcp2515_reset()
|—————Node:identifier Text: mcp2515_reset
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
|————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|——————Node:identifier Text: mcp2515_setCANCTRL_Mode
|——————Node:argument_list Text: (MODE_CONFIG)
|———————Node:( Text: (
|———————Node:identifier Text: MODE_CONFIG
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (res > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: res > 0
|——————Node:identifier Text: res
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter setting mode fall\r\n");
|———————Node:call_expression Text: Serial.print("Enter setting mode fall\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter setting mode fall\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter setting mode fall\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter setting mode fall
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("Enter setting mode success \r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("Enter setting mode success \r\n");
|—————Node:call_expression Text: Serial.print("Enter setting mode success \r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("Enter setting mode success \r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "Enter setting mode success \r\n"
|————————Node:" Text: "
|————————Node:string_content Text: Enter setting mode success 
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:comment Text: /* set boadrate                 */
|———Node:if_statement Text: if(mcp2515_configRate(canSpeed))
    {
#if DEBUG_MODE
      Serial.print("set rate fall!!\r\n");
#endif
      return res;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (mcp2515_configRate(canSpeed))
|—————Node:( Text: (
|—————Node:call_expression Text: mcp2515_configRate(canSpeed)
|——————Node:identifier Text: mcp2515_configRate
|——————Node:argument_list Text: (canSpeed)
|———————Node:( Text: (
|———————Node:identifier Text: canSpeed
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
      Serial.print("set rate fall!!\r\n");
#endif
      return res;
    }
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
      Serial.print("set rate fall!!\r\n");
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("set rate fall!!\r\n");
|———————Node:call_expression Text: Serial.print("set rate fall!!\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("set rate fall!!\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "set rate fall!!\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: set rate fall!!
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("set rate success!!\r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("set rate success!!\r\n");
|—————Node:call_expression Text: Serial.print("set rate success!!\r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("set rate success!!\r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "set rate success!!\r\n"
|————————Node:" Text: "
|————————Node:string_content Text: set rate success!!
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:if_statement Text: if ( res == MCP2515_OK ) {

                                                                        /* init canbuffers              */
        mcp2515_initCANBuffers();

                                                                        /* interrupt mode               */
        mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);

#if (DEBUG_RXANY==1)
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive any message       */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
#else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
#endif
                                                                        /* enter normal mode            */
        res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);                                                                
        if(res)
        {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }


#if DEBUG_MODE
          Serial.print("Enter Normal Mode Success!!\r\n");
#endif

    }
|————Node:if Text: if
|————Node:condition_clause Text: ( res == MCP2515_OK )
|—————Node:( Text: (
|—————Node:binary_expression Text: res == MCP2515_OK
|——————Node:identifier Text: res
|——————Node:== Text: ==
|——————Node:identifier Text: MCP2515_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {

                                                                        /* init canbuffers              */
        mcp2515_initCANBuffers();

                                                                        /* interrupt mode               */
        mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);

#if (DEBUG_RXANY==1)
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive any message       */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
#else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
#endif
                                                                        /* enter normal mode            */
        res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);                                                                
        if(res)
        {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }


#if DEBUG_MODE
          Serial.print("Enter Normal Mode Success!!\r\n");
#endif

    }
|—————Node:{ Text: {
|—————Node:comment Text: /* init canbuffers              */
|—————Node:expression_statement Text: mcp2515_initCANBuffers();
|——————Node:call_expression Text: mcp2515_initCANBuffers()
|———————Node:identifier Text: mcp2515_initCANBuffers
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* interrupt mode               */
|—————Node:expression_statement Text: mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);
|——————Node:call_expression Text: mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF)
|———————Node:identifier Text: mcp2515_setRegister
|———————Node:argument_list Text: (MCP_CANINTE, MCP_RX0IF | MCP_RX1IF)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_CANINTE
|————————Node:, Text: ,
|————————Node:binary_expression Text: MCP_RX0IF | MCP_RX1IF
|—————————Node:identifier Text: MCP_RX0IF
|—————————Node:| Text: |
|—————————Node:identifier Text: MCP_RX1IF
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:preproc_if Text: #if (DEBUG_RXANY==1)
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive any message       */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
#else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
#endif
|——————Node:#if Text: #if
|——————Node:parenthesized_expression Text: (DEBUG_RXANY==1)
|———————Node:( Text: (
|———————Node:binary_expression Text: DEBUG_RXANY==1
|————————Node:identifier Text: DEBUG_RXANY
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:
 Text: 

|——————Node:comment Text: /* enable both receive-buffers  */
|——————Node:comment Text: /* to receive any message       */
|——————Node:comment Text: /* and enable rollover          */
|——————Node:expression_statement Text: mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
|———————Node:call_expression Text: mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK)
|————————Node:identifier Text: mcp2515_modifyRegister
|————————Node:argument_list Text: (MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXB0CTRL
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK
|——————————Node:identifier Text: MCP_RXB_RX_MASK
|——————————Node:| Text: |
|——————————Node:identifier Text: MCP_RXB_BUKT_MASK
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK
|——————————Node:identifier Text: MCP_RXB_RX_ANY
|——————————Node:| Text: |
|——————————Node:identifier Text: MCP_RXB_BUKT_MASK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY);
|———————Node:call_expression Text: mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY)
|————————Node:identifier Text: mcp2515_modifyRegister
|————————Node:argument_list Text: (MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_ANY)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXB1CTRL
|—————————Node:, Text: ,
|—————————Node:identifier Text: MCP_RXB_RX_MASK
|—————————Node:, Text: ,
|—————————Node:identifier Text: MCP_RXB_RX_ANY
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:preproc_else Text: #else
                                                                        /* enable both receive-buffers  */
                                                                        /* to receive messages          */
                                                                        /* with std. and ext. identifie */
                                                                        /* rs                           */
                                                                        /* and enable rollover          */
        mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
        mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
|———————Node:#else Text: #else
|———————Node:comment Text: /* enable both receive-buffers  */
|———————Node:comment Text: /* to receive messages          */
|———————Node:comment Text: /* with std. and ext. identifie */
|———————Node:comment Text: /* rs                           */
|———————Node:comment Text: /* and enable rollover          */
|———————Node:expression_statement Text: mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
|————————Node:call_expression Text: mcp2515_modifyRegister(MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK )
|—————————Node:identifier Text: mcp2515_modifyRegister
|—————————Node:argument_list Text: (MCP_RXB0CTRL,
        MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
        MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK )
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP_RXB0CTRL
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK
|———————————Node:identifier Text: MCP_RXB_RX_MASK
|———————————Node:| Text: |
|———————————Node:identifier Text: MCP_RXB_BUKT_MASK
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK
|———————————Node:identifier Text: MCP_RXB_RX_STDEXT
|———————————Node:| Text: |
|———————————Node:identifier Text: MCP_RXB_BUKT_MASK
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT);
|————————Node:call_expression Text: mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT)
|—————————Node:identifier Text: mcp2515_modifyRegister
|—————————Node:argument_list Text: (MCP_RXB1CTRL, MCP_RXB_RX_MASK,
        MCP_RXB_RX_STDEXT)
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP_RXB1CTRL
|——————————Node:, Text: ,
|——————————Node:identifier Text: MCP_RXB_RX_MASK
|——————————Node:, Text: ,
|——————————Node:identifier Text: MCP_RXB_RX_STDEXT
|——————————Node:) Text: )
|————————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:comment Text: /* enter normal mode            */
|—————Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
|——————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|———————Node:identifier Text: res
|———————Node:= Text: =
|———————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|————————Node:identifier Text: mcp2515_setCANCTRL_Mode
|————————Node:argument_list Text: (MODE_NORMAL)
|—————————Node:( Text: (
|—————————Node:identifier Text: MODE_NORMAL
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if(res)
        {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (res)
|———————Node:( Text: (
|———————Node:identifier Text: res
|———————Node:) Text: )
|——————Node:compound_statement Text: {
#if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif           
          return res;
        }
|———————Node:{ Text: {
|———————Node:preproc_if Text: #if DEBUG_MODE        
          Serial.print("Enter Normal Mode Fall!!\r\n");
#endif
|————————Node:#if Text: #if
|————————Node:identifier Text: DEBUG_MODE
|————————Node:
 Text: 

|————————Node:expression_statement Text: Serial.print("Enter Normal Mode Fall!!\r\n");
|—————————Node:call_expression Text: Serial.print("Enter Normal Mode Fall!!\r\n")
|——————————Node:field_expression Text: Serial.print
|———————————Node:identifier Text: Serial
|———————————Node:. Text: .
|———————————Node:field_identifier Text: print
|——————————Node:argument_list Text: ("Enter Normal Mode Fall!!\r\n")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "Enter Normal Mode Fall!!\r\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: Enter Normal Mode Fall!!
|————————————Node:escape_sequence Text: \r
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:return_statement Text: return res;
|————————Node:return Text: return
|————————Node:identifier Text: res
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:preproc_if Text: #if DEBUG_MODE
          Serial.print("Enter Normal Mode Success!!\r\n");
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter Normal Mode Success!!\r\n");
|———————Node:call_expression Text: Serial.print("Enter Normal Mode Success!!\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter Normal Mode Success!!\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter Normal Mode Success!!\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter Normal Mode Success!!
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:} Text: }
|———Node:return_statement Text: return res;
|————Node:return Text: return
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_write_id
** Descriptions:            write can id
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_write_id( const INT8U mcp_addr, const INT8U ext, const INT32U id )
{
    uint16_t canid;
    INT8U tbufdata[4];

    canid = (uint16_t)(id & 0x0FFFF);

    if ( ext == 1) 
    {
        tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF);
        tbufdata[MCP_EID8] = (INT8U) (canid / 256);
        canid = (uint16_t)( id / 0x10000L );
        tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03);
        tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8);
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
        tbufdata[MCP_SIDH] = (INT8U) (canid / 32 );
    }
    else 
    {
        tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
        tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
        tbufdata[MCP_EID0] = 0;
        tbufdata[MCP_EID8] = 0;
    }
    mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_write_id( const INT8U mcp_addr, const INT8U ext, const INT32U id )
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_write_id
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_write_id
|———Node:parameter_list Text: ( const INT8U mcp_addr, const INT8U ext, const INT32U id )
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U mcp_addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: mcp_addr
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U ext
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT32U id
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: id
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint16_t canid;
    INT8U tbufdata[4];

    canid = (uint16_t)(id & 0x0FFFF);

    if ( ext == 1) 
    {
        tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF);
        tbufdata[MCP_EID8] = (INT8U) (canid / 256);
        canid = (uint16_t)( id / 0x10000L );
        tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03);
        tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8);
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
        tbufdata[MCP_SIDH] = (INT8U) (canid / 32 );
    }
    else 
    {
        tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
        tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
        tbufdata[MCP_EID0] = 0;
        tbufdata[MCP_EID8] = 0;
    }
    mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
|———Node:{ Text: {
|———Node:declaration Text: uint16_t canid;
|————Node:primitive_type Text: uint16_t
|————Node:identifier Text: canid
|————Node:; Text: ;
|———Node:declaration Text: INT8U tbufdata[4];
|————Node:type_identifier Text: INT8U
|————Node:array_declarator Text: tbufdata[4]
|—————Node:identifier Text: tbufdata
|—————Node:[ Text: [
|—————Node:number_literal Text: 4
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: canid = (uint16_t)(id & 0x0FFFF);
|————Node:assignment_expression Text: canid = (uint16_t)(id & 0x0FFFF)
|—————Node:identifier Text: canid
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint16_t)(id & 0x0FFFF)
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: )
|——————Node:parenthesized_expression Text: (id & 0x0FFFF)
|———————Node:( Text: (
|———————Node:binary_expression Text: id & 0x0FFFF
|————————Node:identifier Text: id
|————————Node:& Text: &
|————————Node:number_literal Text: 0x0FFFF
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( ext == 1) 
    {
        tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF);
        tbufdata[MCP_EID8] = (INT8U) (canid / 256);
        canid = (uint16_t)( id / 0x10000L );
        tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03);
        tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8);
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
        tbufdata[MCP_SIDH] = (INT8U) (canid / 32 );
    }
    else 
    {
        tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
        tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
        tbufdata[MCP_EID0] = 0;
        tbufdata[MCP_EID8] = 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( ext == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: ext == 1
|——————Node:identifier Text: ext
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF);
        tbufdata[MCP_EID8] = (INT8U) (canid / 256);
        canid = (uint16_t)( id / 0x10000L );
        tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03);
        tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8);
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
        tbufdata[MCP_SIDH] = (INT8U) (canid / 32 );
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF);
|——————Node:assignment_expression Text: tbufdata[MCP_EID0] = (INT8U) (canid & 0xFF)
|———————Node:subscript_expression Text: tbufdata[MCP_EID0]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_EID0]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_EID0
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: (INT8U) (canid & 0xFF)
|————————Node:parenthesized_expression Text: (INT8U)
|—————————Node:( Text: (
|—————————Node:identifier Text: INT8U
|—————————Node:) Text: )
|————————Node:argument_list Text: (canid & 0xFF)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canid & 0xFF
|——————————Node:identifier Text: canid
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xFF
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: tbufdata[MCP_EID8] = (INT8U) (canid / 256);
|——————Node:assignment_expression Text: tbufdata[MCP_EID8] = (INT8U) (canid / 256)
|———————Node:subscript_expression Text: tbufdata[MCP_EID8]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_EID8]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_EID8
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: (INT8U) (canid / 256)
|————————Node:parenthesized_expression Text: (INT8U)
|—————————Node:( Text: (
|—————————Node:identifier Text: INT8U
|—————————Node:) Text: )
|————————Node:argument_list Text: (canid / 256)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canid / 256
|——————————Node:identifier Text: canid
|——————————Node:/ Text: /
|——————————Node:number_literal Text: 256
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: canid = (uint16_t)( id / 0x10000L );
|——————Node:assignment_expression Text: canid = (uint16_t)( id / 0x10000L )
|———————Node:identifier Text: canid
|———————Node:= Text: =
|———————Node:cast_expression Text: (uint16_t)( id / 0x10000L )
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint16_t
|—————————Node:primitive_type Text: uint16_t
|————————Node:) Text: )
|————————Node:parenthesized_expression Text: ( id / 0x10000L )
|—————————Node:( Text: (
|—————————Node:binary_expression Text: id / 0x10000L
|——————————Node:identifier Text: id
|——————————Node:/ Text: /
|——————————Node:number_literal Text: 0x10000L
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03);
|——————Node:assignment_expression Text: tbufdata[MCP_SIDL] = (INT8U) (canid & 0x03)
|———————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_SIDL]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_SIDL
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: (INT8U) (canid & 0x03)
|————————Node:parenthesized_expression Text: (INT8U)
|—————————Node:( Text: (
|—————————Node:identifier Text: INT8U
|—————————Node:) Text: )
|————————Node:argument_list Text: (canid & 0x03)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canid & 0x03
|——————————Node:identifier Text: canid
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0x03
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8);
|——————Node:assignment_expression Text: tbufdata[MCP_SIDL] += (INT8U) ((canid & 0x1C )*8)
|———————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_SIDL]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_SIDL
|—————————Node:] Text: ]
|———————Node:+= Text: +=
|———————Node:call_expression Text: (INT8U) ((canid & 0x1C )*8)
|————————Node:parenthesized_expression Text: (INT8U)
|—————————Node:( Text: (
|—————————Node:identifier Text: INT8U
|—————————Node:) Text: )
|————————Node:argument_list Text: ((canid & 0x1C )*8)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (canid & 0x1C )*8
|——————————Node:parenthesized_expression Text: (canid & 0x1C )
|———————————Node:( Text: (
|———————————Node:binary_expression Text: canid & 0x1C
|————————————Node:identifier Text: canid
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x1C
|———————————Node:) Text: )
|——————————Node:* Text: *
|——————————Node:number_literal Text: 8
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
|——————Node:assignment_expression Text: tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M
|———————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_SIDL]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_SIDL
|—————————Node:] Text: ]
|———————Node:|= Text: |=
|———————Node:identifier Text: MCP_TXB_EXIDE_M
|——————Node:; Text: ;
|—————Node:expression_statement Text: tbufdata[MCP_SIDH] = (INT8U) (canid / 32 );
|——————Node:assignment_expression Text: tbufdata[MCP_SIDH] = (INT8U) (canid / 32 )
|———————Node:subscript_expression Text: tbufdata[MCP_SIDH]
|————————Node:identifier Text: tbufdata
|————————Node:subscript_argument_list Text: [MCP_SIDH]
|—————————Node:[ Text: [
|—————————Node:identifier Text: MCP_SIDH
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: (INT8U) (canid / 32 )
|————————Node:parenthesized_expression Text: (INT8U)
|—————————Node:( Text: (
|—————————Node:identifier Text: INT8U
|—————————Node:) Text: )
|————————Node:argument_list Text: (canid / 32 )
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canid / 32
|——————————Node:identifier Text: canid
|——————————Node:/ Text: /
|——————————Node:number_literal Text: 32
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else 
    {
        tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
        tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
        tbufdata[MCP_EID0] = 0;
        tbufdata[MCP_EID8] = 0;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
        tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
        tbufdata[MCP_EID0] = 0;
        tbufdata[MCP_EID8] = 0;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: tbufdata[MCP_SIDH] = (INT8U) (canid / 8 );
|———————Node:assignment_expression Text: tbufdata[MCP_SIDH] = (INT8U) (canid / 8 )
|————————Node:subscript_expression Text: tbufdata[MCP_SIDH]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_SIDH]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_SIDH
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: (INT8U) (canid / 8 )
|—————————Node:parenthesized_expression Text: (INT8U)
|——————————Node:( Text: (
|——————————Node:identifier Text: INT8U
|——————————Node:) Text: )
|—————————Node:argument_list Text: (canid / 8 )
|——————————Node:( Text: (
|——————————Node:binary_expression Text: canid / 8
|———————————Node:identifier Text: canid
|———————————Node:/ Text: /
|———————————Node:number_literal Text: 8
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5);
|———————Node:assignment_expression Text: tbufdata[MCP_SIDL] = (INT8U) ((canid & 0x07 )<<5)
|————————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_SIDL]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_SIDL
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: (INT8U) ((canid & 0x07 )<<5)
|—————————Node:parenthesized_expression Text: (INT8U)
|——————————Node:( Text: (
|——————————Node:identifier Text: INT8U
|——————————Node:) Text: )
|—————————Node:argument_list Text: ((canid & 0x07 )<<5)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (canid & 0x07 )<<5
|———————————Node:parenthesized_expression Text: (canid & 0x07 )
|————————————Node:( Text: (
|————————————Node:binary_expression Text: canid & 0x07
|—————————————Node:identifier Text: canid
|—————————————Node:& Text: &
|—————————————Node:number_literal Text: 0x07
|————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 5
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: tbufdata[MCP_EID0] = 0;
|———————Node:assignment_expression Text: tbufdata[MCP_EID0] = 0
|————————Node:subscript_expression Text: tbufdata[MCP_EID0]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_EID0]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_EID0
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: tbufdata[MCP_EID8] = 0;
|———————Node:assignment_expression Text: tbufdata[MCP_EID8] = 0
|————————Node:subscript_expression Text: tbufdata[MCP_EID8]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_EID8]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_EID8
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
|————Node:call_expression Text: mcp2515_setRegisterS( mcp_addr, tbufdata, 4 )
|—————Node:identifier Text: mcp2515_setRegisterS
|—————Node:argument_list Text: ( mcp_addr, tbufdata, 4 )
|——————Node:( Text: (
|——————Node:identifier Text: mcp_addr
|——————Node:, Text: ,
|——————Node:identifier Text: tbufdata
|——————Node:, Text: ,
|——————Node:number_literal Text: 4
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            read can id
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_read_id( const INT8U mcp_addr, INT8U* ext, INT32U* id )
{
    INT8U tbufdata[4];

    *ext = 0;
    *id = 0;

    mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );

    *id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);

    if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ) 
    {
                                                                        /* extended id                  */
        *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *id = (*id<<8) + tbufdata[MCP_EID8];
        *id = (*id<<8) + tbufdata[MCP_EID0];
        *ext = 1;
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_read_id( const INT8U mcp_addr, INT8U* ext, INT32U* id )
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_read_id
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_read_id
|———Node:parameter_list Text: ( const INT8U mcp_addr, INT8U* ext, INT32U* id )
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U mcp_addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: mcp_addr
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U* ext
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: * ext
|——————Node:* Text: *
|——————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT32U* id
|—————Node:type_identifier Text: INT32U
|—————Node:pointer_declarator Text: * id
|——————Node:* Text: *
|——————Node:identifier Text: id
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U tbufdata[4];

    *ext = 0;
    *id = 0;

    mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );

    *id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);

    if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ) 
    {
                                                                        /* extended id                  */
        *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *id = (*id<<8) + tbufdata[MCP_EID8];
        *id = (*id<<8) + tbufdata[MCP_EID0];
        *ext = 1;
    }
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U tbufdata[4];
|————Node:type_identifier Text: INT8U
|————Node:array_declarator Text: tbufdata[4]
|—————Node:identifier Text: tbufdata
|—————Node:[ Text: [
|—————Node:number_literal Text: 4
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: *ext = 0;
|————Node:assignment_expression Text: *ext = 0
|—————Node:pointer_expression Text: *ext
|——————Node:* Text: *
|——————Node:identifier Text: ext
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: *id = 0;
|————Node:assignment_expression Text: *id = 0
|—————Node:pointer_expression Text: *id
|——————Node:* Text: *
|——————Node:identifier Text: id
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
|————Node:call_expression Text: mcp2515_readRegisterS( mcp_addr, tbufdata, 4 )
|—————Node:identifier Text: mcp2515_readRegisterS
|—————Node:argument_list Text: ( mcp_addr, tbufdata, 4 )
|——————Node:( Text: (
|——————Node:identifier Text: mcp_addr
|——————Node:, Text: ,
|——————Node:identifier Text: tbufdata
|——————Node:, Text: ,
|——————Node:number_literal Text: 4
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: *id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
|————Node:assignment_expression Text: *id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5)
|—————Node:pointer_expression Text: *id
|——————Node:* Text: *
|——————Node:identifier Text: id
|—————Node:= Text: =
|—————Node:binary_expression Text: (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5)
|——————Node:parenthesized_expression Text: (tbufdata[MCP_SIDH]<<3)
|———————Node:( Text: (
|———————Node:binary_expression Text: tbufdata[MCP_SIDH]<<3
|————————Node:subscript_expression Text: tbufdata[MCP_SIDH]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_SIDH]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_SIDH
|——————————Node:] Text: ]
|————————Node:<< Text: <<
|————————Node:number_literal Text: 3
|———————Node:) Text: )
|——————Node:+ Text: +
|——————Node:parenthesized_expression Text: (tbufdata[MCP_SIDL]>>5)
|———————Node:( Text: (
|———————Node:binary_expression Text: tbufdata[MCP_SIDL]>>5
|————————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_SIDL]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_SIDL
|——————————Node:] Text: ]
|————————Node:>> Text: >>
|————————Node:number_literal Text: 5
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ) 
    {
                                                                        /* extended id                  */
        *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *id = (*id<<8) + tbufdata[MCP_EID8];
        *id = (*id<<8) + tbufdata[MCP_EID0];
        *ext = 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M )
|—————Node:( Text: (
|—————Node:binary_expression Text: (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M
|——————Node:parenthesized_expression Text: (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M)
|———————Node:( Text: (
|———————Node:binary_expression Text: tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M
|————————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_SIDL]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_SIDL
|——————————Node:] Text: ]
|————————Node:& Text: &
|————————Node:identifier Text: MCP_TXB_EXIDE_M
|———————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: MCP_TXB_EXIDE_M
|—————Node:) Text: )
|————Node:compound_statement Text: {
                                                                        /* extended id                  */
        *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *id = (*id<<8) + tbufdata[MCP_EID8];
        *id = (*id<<8) + tbufdata[MCP_EID0];
        *ext = 1;
    }
|—————Node:{ Text: {
|—————Node:comment Text: /* extended id                  */
|—————Node:expression_statement Text: *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
|——————Node:assignment_expression Text: *id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03)
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: (*id<<2) + (tbufdata[MCP_SIDL] & 0x03)
|————————Node:parenthesized_expression Text: (*id<<2)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: *id<<2
|——————————Node:pointer_expression Text: *id
|———————————Node:* Text: *
|———————————Node:identifier Text: id
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 2
|—————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:parenthesized_expression Text: (tbufdata[MCP_SIDL] & 0x03)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: tbufdata[MCP_SIDL] & 0x03
|——————————Node:subscript_expression Text: tbufdata[MCP_SIDL]
|———————————Node:identifier Text: tbufdata
|———————————Node:subscript_argument_list Text: [MCP_SIDL]
|————————————Node:[ Text: [
|————————————Node:identifier Text: MCP_SIDL
|————————————Node:] Text: ]
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0x03
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: *id = (*id<<8) + tbufdata[MCP_EID8];
|——————Node:assignment_expression Text: *id = (*id<<8) + tbufdata[MCP_EID8]
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: (*id<<8) + tbufdata[MCP_EID8]
|————————Node:parenthesized_expression Text: (*id<<8)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: *id<<8
|——————————Node:pointer_expression Text: *id
|———————————Node:* Text: *
|———————————Node:identifier Text: id
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 8
|—————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:subscript_expression Text: tbufdata[MCP_EID8]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_EID8]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_EID8
|——————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: *id = (*id<<8) + tbufdata[MCP_EID0];
|——————Node:assignment_expression Text: *id = (*id<<8) + tbufdata[MCP_EID0]
|———————Node:pointer_expression Text: *id
|————————Node:* Text: *
|————————Node:identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: (*id<<8) + tbufdata[MCP_EID0]
|————————Node:parenthesized_expression Text: (*id<<8)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: *id<<8
|——————————Node:pointer_expression Text: *id
|———————————Node:* Text: *
|———————————Node:identifier Text: id
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 8
|—————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:subscript_expression Text: tbufdata[MCP_EID0]
|—————————Node:identifier Text: tbufdata
|—————————Node:subscript_argument_list Text: [MCP_EID0]
|——————————Node:[ Text: [
|——————————Node:identifier Text: MCP_EID0
|——————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: *ext = 1;
|——————Node:assignment_expression Text: *ext = 1
|———————Node:pointer_expression Text: *ext
|————————Node:* Text: *
|————————Node:identifier Text: ext
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_write_canMsg
** Descriptions:            write msg
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_write_canMsg( const INT8U buffer_sidh_addr)
{
    INT8U mcp_addr;
    mcp_addr = buffer_sidh_addr;
    mcp2515_setRegisterS(mcp_addr+5, m_nDta, m_nDlc );                  /* write data bytes             */
    if ( m_nRtr == 1)                                                   /* if RTR set bit in byte       */
    {
        m_nDlc |= MCP_RTR_MASK;  
    }
    mcp2515_setRegister((mcp_addr+4), m_nDlc );                        /* write the RTR and DLC        */
    mcp2515_write_id(mcp_addr, m_nExtFlg, m_nID );                     /* write CAN id                 */

}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_write_canMsg( const INT8U buffer_sidh_addr)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_write_canMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_write_canMsg
|———Node:parameter_list Text: ( const INT8U buffer_sidh_addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U buffer_sidh_addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: buffer_sidh_addr
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U mcp_addr;
    mcp_addr = buffer_sidh_addr;
    mcp2515_setRegisterS(mcp_addr+5, m_nDta, m_nDlc );                  /* write data bytes             */
    if ( m_nRtr == 1)                                                   /* if RTR set bit in byte       */
    {
        m_nDlc |= MCP_RTR_MASK;  
    }
    mcp2515_setRegister((mcp_addr+4), m_nDlc );                        /* write the RTR and DLC        */
    mcp2515_write_id(mcp_addr, m_nExtFlg, m_nID );                     /* write CAN id                 */

}
|———Node:{ Text: {
|———Node:declaration Text: INT8U mcp_addr;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: mcp_addr
|————Node:; Text: ;
|———Node:expression_statement Text: mcp_addr = buffer_sidh_addr;
|————Node:assignment_expression Text: mcp_addr = buffer_sidh_addr
|—————Node:identifier Text: mcp_addr
|—————Node:= Text: =
|—————Node:identifier Text: buffer_sidh_addr
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_setRegisterS(mcp_addr+5, m_nDta, m_nDlc );
|————Node:call_expression Text: mcp2515_setRegisterS(mcp_addr+5, m_nDta, m_nDlc )
|—————Node:identifier Text: mcp2515_setRegisterS
|—————Node:argument_list Text: (mcp_addr+5, m_nDta, m_nDlc )
|——————Node:( Text: (
|——————Node:binary_expression Text: mcp_addr+5
|———————Node:identifier Text: mcp_addr
|———————Node:+ Text: +
|———————Node:number_literal Text: 5
|——————Node:, Text: ,
|——————Node:identifier Text: m_nDta
|——————Node:, Text: ,
|——————Node:identifier Text: m_nDlc
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* write data bytes             */
|———Node:if_statement Text: if ( m_nRtr == 1)                                                   /* if RTR set bit in byte       */
    {
        m_nDlc |= MCP_RTR_MASK;  
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( m_nRtr == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_nRtr == 1
|——————Node:identifier Text: m_nRtr
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:comment Text: /* if RTR set bit in byte       */
|————Node:compound_statement Text: {
        m_nDlc |= MCP_RTR_MASK;  
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_nDlc |= MCP_RTR_MASK;
|——————Node:assignment_expression Text: m_nDlc |= MCP_RTR_MASK
|———————Node:identifier Text: m_nDlc
|———————Node:|= Text: |=
|———————Node:identifier Text: MCP_RTR_MASK
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: mcp2515_setRegister((mcp_addr+4), m_nDlc );
|————Node:call_expression Text: mcp2515_setRegister((mcp_addr+4), m_nDlc )
|—————Node:identifier Text: mcp2515_setRegister
|—————Node:argument_list Text: ((mcp_addr+4), m_nDlc )
|——————Node:( Text: (
|——————Node:parenthesized_expression Text: (mcp_addr+4)
|———————Node:( Text: (
|———————Node:binary_expression Text: mcp_addr+4
|————————Node:identifier Text: mcp_addr
|————————Node:+ Text: +
|————————Node:number_literal Text: 4
|———————Node:) Text: )
|——————Node:, Text: ,
|——————Node:identifier Text: m_nDlc
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* write the RTR and DLC        */
|———Node:expression_statement Text: mcp2515_write_id(mcp_addr, m_nExtFlg, m_nID );
|————Node:call_expression Text: mcp2515_write_id(mcp_addr, m_nExtFlg, m_nID )
|—————Node:identifier Text: mcp2515_write_id
|—————Node:argument_list Text: (mcp_addr, m_nExtFlg, m_nID )
|——————Node:( Text: (
|——————Node:identifier Text: mcp_addr
|——————Node:, Text: ,
|——————Node:identifier Text: m_nExtFlg
|——————Node:, Text: ,
|——————Node:identifier Text: m_nID
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* write CAN id                 */
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            read message
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_read_canMsg( const INT8U buffer_sidh_addr)        /* read can msg                 */
{
    INT8U mcp_addr, ctrl;

    mcp_addr = buffer_sidh_addr;

    mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );

    ctrl = mcp2515_readRegister( mcp_addr-1 );
    m_nDlc = mcp2515_readRegister( mcp_addr+4 );

    if ((ctrl & 0x08)) {
        m_nRtr = 1;
    }
    else {
        m_nRtr = 0;
    }

    m_nDlc &= MCP_DLC_MASK;
    mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_read_canMsg( const INT8U buffer_sidh_addr)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_read_canMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_read_canMsg
|———Node:parameter_list Text: ( const INT8U buffer_sidh_addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U buffer_sidh_addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: buffer_sidh_addr
|————Node:) Text: )
|——Node:comment Text: /* read can msg                 */
|——Node:compound_statement Text: {
    INT8U mcp_addr, ctrl;

    mcp_addr = buffer_sidh_addr;

    mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );

    ctrl = mcp2515_readRegister( mcp_addr-1 );
    m_nDlc = mcp2515_readRegister( mcp_addr+4 );

    if ((ctrl & 0x08)) {
        m_nRtr = 1;
    }
    else {
        m_nRtr = 0;
    }

    m_nDlc &= MCP_DLC_MASK;
    mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U mcp_addr, ctrl;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: mcp_addr
|————Node:, Text: ,
|————Node:identifier Text: ctrl
|————Node:; Text: ;
|———Node:expression_statement Text: mcp_addr = buffer_sidh_addr;
|————Node:assignment_expression Text: mcp_addr = buffer_sidh_addr
|—————Node:identifier Text: mcp_addr
|—————Node:= Text: =
|—————Node:identifier Text: buffer_sidh_addr
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
|————Node:call_expression Text: mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID )
|—————Node:identifier Text: mcp2515_read_id
|—————Node:argument_list Text: ( mcp_addr, &m_nExtFlg,&m_nID )
|——————Node:( Text: (
|——————Node:identifier Text: mcp_addr
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &m_nExtFlg
|———————Node:& Text: &
|———————Node:identifier Text: m_nExtFlg
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &m_nID
|———————Node:& Text: &
|———————Node:identifier Text: m_nID
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ctrl = mcp2515_readRegister( mcp_addr-1 );
|————Node:assignment_expression Text: ctrl = mcp2515_readRegister( mcp_addr-1 )
|—————Node:identifier Text: ctrl
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readRegister( mcp_addr-1 )
|——————Node:identifier Text: mcp2515_readRegister
|——————Node:argument_list Text: ( mcp_addr-1 )
|———————Node:( Text: (
|———————Node:binary_expression Text: mcp_addr-1
|————————Node:identifier Text: mcp_addr
|————————Node:- Text: -
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_nDlc = mcp2515_readRegister( mcp_addr+4 );
|————Node:assignment_expression Text: m_nDlc = mcp2515_readRegister( mcp_addr+4 )
|—————Node:identifier Text: m_nDlc
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readRegister( mcp_addr+4 )
|——————Node:identifier Text: mcp2515_readRegister
|——————Node:argument_list Text: ( mcp_addr+4 )
|———————Node:( Text: (
|———————Node:binary_expression Text: mcp_addr+4
|————————Node:identifier Text: mcp_addr
|————————Node:+ Text: +
|————————Node:number_literal Text: 4
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((ctrl & 0x08)) {
        m_nRtr = 1;
    }
    else {
        m_nRtr = 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ((ctrl & 0x08))
|—————Node:( Text: (
|—————Node:parenthesized_expression Text: (ctrl & 0x08)
|——————Node:( Text: (
|——————Node:binary_expression Text: ctrl & 0x08
|———————Node:identifier Text: ctrl
|———————Node:& Text: &
|———————Node:number_literal Text: 0x08
|——————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        m_nRtr = 1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_nRtr = 1;
|——————Node:assignment_expression Text: m_nRtr = 1
|———————Node:identifier Text: m_nRtr
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        m_nRtr = 0;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        m_nRtr = 0;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: m_nRtr = 0;
|———————Node:assignment_expression Text: m_nRtr = 0
|————————Node:identifier Text: m_nRtr
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: m_nDlc &= MCP_DLC_MASK;
|————Node:assignment_expression Text: m_nDlc &= MCP_DLC_MASK
|—————Node:identifier Text: m_nDlc
|—————Node:&= Text: &=
|—————Node:identifier Text: MCP_DLC_MASK
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
|————Node:call_expression Text: mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc )
|—————Node:identifier Text: mcp2515_readRegisterS
|—————Node:argument_list Text: ( mcp_addr+5, &(m_nDta[0]), m_nDlc )
|——————Node:( Text: (
|——————Node:binary_expression Text: mcp_addr+5
|———————Node:identifier Text: mcp_addr
|———————Node:+ Text: +
|———————Node:number_literal Text: 5
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &(m_nDta[0])
|———————Node:& Text: &
|———————Node:parenthesized_expression Text: (m_nDta[0])
|————————Node:( Text: (
|————————Node:subscript_expression Text: m_nDta[0]
|—————————Node:identifier Text: m_nDta
|—————————Node:subscript_argument_list Text: [0]
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 0
|——————————Node:] Text: ]
|————————Node:) Text: )
|——————Node:, Text: ,
|——————Node:identifier Text: m_nDlc
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           sendMsg
** Descriptions:            send message
*********************************************************************************************************/
|—Node:function_definition Text: void MCP_CAN::mcp2515_start_transmit(const INT8U mcp_addr)              /* start transmit               */
{
    mcp2515_modifyRegister( mcp_addr-1 , MCP_TXB_TXREQ_M, MCP_TXB_TXREQ_M );
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: MCP_CAN::mcp2515_start_transmit(const INT8U mcp_addr)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_start_transmit
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_start_transmit
|———Node:parameter_list Text: (const INT8U mcp_addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INT8U mcp_addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: mcp_addr
|————Node:) Text: )
|——Node:comment Text: /* start transmit               */
|——Node:compound_statement Text: {
    mcp2515_modifyRegister( mcp_addr-1 , MCP_TXB_TXREQ_M, MCP_TXB_TXREQ_M );
}
|———Node:{ Text: {
|———Node:expression_statement Text: mcp2515_modifyRegister( mcp_addr-1 , MCP_TXB_TXREQ_M, MCP_TXB_TXREQ_M );
|————Node:call_expression Text: mcp2515_modifyRegister( mcp_addr-1 , MCP_TXB_TXREQ_M, MCP_TXB_TXREQ_M )
|—————Node:identifier Text: mcp2515_modifyRegister
|—————Node:argument_list Text: ( mcp_addr-1 , MCP_TXB_TXREQ_M, MCP_TXB_TXREQ_M )
|——————Node:( Text: (
|——————Node:binary_expression Text: mcp_addr-1
|———————Node:identifier Text: mcp_addr
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|——————Node:, Text: ,
|——————Node:identifier Text: MCP_TXB_TXREQ_M
|——————Node:, Text: ,
|——————Node:identifier Text: MCP_TXB_TXREQ_M
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           sendMsg
** Descriptions:            send message
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::mcp2515_getNextFreeTXBuf(INT8U *txbuf_n)                 /* get Next free txbuf          */
{
    INT8U res, i, ctrlval;
    INT8U ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL };

    res = MCP_ALLTXBUSY;
    *txbuf_n = 0x00;

                                                                        /* check all 3 TX-Buffers       */
    for (i=0; i<MCP_N_TXBUFFERS; i++) {
        ctrlval = mcp2515_readRegister( ctrlregs[i] );
        if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
    }
    return res;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::mcp2515_getNextFreeTXBuf(INT8U *txbuf_n)
|———Node:qualified_identifier Text: MCP_CAN::mcp2515_getNextFreeTXBuf
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: mcp2515_getNextFreeTXBuf
|———Node:parameter_list Text: (INT8U *txbuf_n)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U *txbuf_n
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *txbuf_n
|——————Node:* Text: *
|——————Node:identifier Text: txbuf_n
|————Node:) Text: )
|——Node:comment Text: /* get Next free txbuf          */
|——Node:compound_statement Text: {
    INT8U res, i, ctrlval;
    INT8U ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL };

    res = MCP_ALLTXBUSY;
    *txbuf_n = 0x00;

                                                                        /* check all 3 TX-Buffers       */
    for (i=0; i<MCP_N_TXBUFFERS; i++) {
        ctrlval = mcp2515_readRegister( ctrlregs[i] );
        if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
    }
    return res;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res, i, ctrlval;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: res
|————Node:, Text: ,
|————Node:identifier Text: i
|————Node:, Text: ,
|————Node:identifier Text: ctrlval
|————Node:; Text: ;
|———Node:declaration Text: INT8U ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL };
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL }
|—————Node:array_declarator Text: ctrlregs[MCP_N_TXBUFFERS]
|——————Node:identifier Text: ctrlregs
|——————Node:[ Text: [
|——————Node:identifier Text: MCP_N_TXBUFFERS
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL }
|——————Node:{ Text: {
|——————Node:identifier Text: MCP_TXB0CTRL
|——————Node:, Text: ,
|——————Node:identifier Text: MCP_TXB1CTRL
|——————Node:, Text: ,
|——————Node:identifier Text: MCP_TXB2CTRL
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:expression_statement Text: res = MCP_ALLTXBUSY;
|————Node:assignment_expression Text: res = MCP_ALLTXBUSY
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:identifier Text: MCP_ALLTXBUSY
|————Node:; Text: ;
|———Node:expression_statement Text: *txbuf_n = 0x00;
|————Node:assignment_expression Text: *txbuf_n = 0x00
|—————Node:pointer_expression Text: *txbuf_n
|——————Node:* Text: *
|——————Node:identifier Text: txbuf_n
|—————Node:= Text: =
|—————Node:number_literal Text: 0x00
|————Node:; Text: ;
|———Node:comment Text: /* check all 3 TX-Buffers       */
|———Node:for_statement Text: for (i=0; i<MCP_N_TXBUFFERS; i++) {
        ctrlval = mcp2515_readRegister( ctrlregs[i] );
        if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<MCP_N_TXBUFFERS
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: MCP_N_TXBUFFERS
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        ctrlval = mcp2515_readRegister( ctrlregs[i] );
        if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ctrlval = mcp2515_readRegister( ctrlregs[i] );
|——————Node:assignment_expression Text: ctrlval = mcp2515_readRegister( ctrlregs[i] )
|———————Node:identifier Text: ctrlval
|———————Node:= Text: =
|———————Node:call_expression Text: mcp2515_readRegister( ctrlregs[i] )
|————————Node:identifier Text: mcp2515_readRegister
|————————Node:argument_list Text: ( ctrlregs[i] )
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: ctrlregs[i]
|——————————Node:identifier Text: ctrlregs
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( (ctrlval & MCP_TXB_TXREQ_M) == 0 )
|———————Node:( Text: (
|———————Node:binary_expression Text: (ctrlval & MCP_TXB_TXREQ_M) == 0
|————————Node:parenthesized_expression Text: (ctrlval & MCP_TXB_TXREQ_M)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ctrlval & MCP_TXB_TXREQ_M
|——————————Node:identifier Text: ctrlval
|——————————Node:& Text: &
|——————————Node:identifier Text: MCP_TXB_TXREQ_M
|—————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            *txbuf_n = ctrlregs[i]+1;                                   /* return SIDH-address of Buffe */
                                                                        /* r                            */
            res = MCP2515_OK;
            return res;                                                 /* ! function exit              */
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: *txbuf_n = ctrlregs[i]+1;
|————————Node:assignment_expression Text: *txbuf_n = ctrlregs[i]+1
|—————————Node:pointer_expression Text: *txbuf_n
|——————————Node:* Text: *
|——————————Node:identifier Text: txbuf_n
|—————————Node:= Text: =
|—————————Node:binary_expression Text: ctrlregs[i]+1
|——————————Node:subscript_expression Text: ctrlregs[i]
|———————————Node:identifier Text: ctrlregs
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:comment Text: /* return SIDH-address of Buffe */
|———————Node:comment Text: /* r                            */
|———————Node:expression_statement Text: res = MCP2515_OK;
|————————Node:assignment_expression Text: res = MCP2515_OK
|—————————Node:identifier Text: res
|—————————Node:= Text: =
|—————————Node:identifier Text: MCP2515_OK
|————————Node:; Text: ;
|———————Node:return_statement Text: return res;
|————————Node:return Text: return
|————————Node:identifier Text: res
|————————Node:; Text: ;
|———————Node:comment Text: /* ! function exit              */
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return res;
|————Node:return Text: return
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           init
** Descriptions:            init can and set speed
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::begin(INT8U speedset)
{
    INT8U res;

    SPI.begin();
    res = mcp2515_init(speedset);
    if (res == MCP2515_OK) return CAN_OK;
    else return CAN_FAILINIT;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::begin(INT8U speedset)
|———Node:qualified_identifier Text: MCP_CAN::begin
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: begin
|———Node:parameter_list Text: (INT8U speedset)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U speedset
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: speedset
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U res;

    SPI.begin();
    res = mcp2515_init(speedset);
    if (res == MCP2515_OK) return CAN_OK;
    else return CAN_FAILINIT;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:expression_statement Text: SPI.begin();
|————Node:call_expression Text: SPI.begin()
|—————Node:field_expression Text: SPI.begin
|——————Node:identifier Text: SPI
|——————Node:. Text: .
|——————Node:field_identifier Text: begin
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: res = mcp2515_init(speedset);
|————Node:assignment_expression Text: res = mcp2515_init(speedset)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_init(speedset)
|——————Node:identifier Text: mcp2515_init
|——————Node:argument_list Text: (speedset)
|———————Node:( Text: (
|———————Node:identifier Text: speedset
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (res == MCP2515_OK) return CAN_OK;
    else return CAN_FAILINIT;
|————Node:if Text: if
|————Node:condition_clause Text: (res == MCP2515_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: res == MCP2515_OK
|——————Node:identifier Text: res
|——————Node:== Text: ==
|——————Node:identifier Text: MCP2515_OK
|—————Node:) Text: )
|————Node:return_statement Text: return CAN_OK;
|—————Node:return Text: return
|—————Node:identifier Text: CAN_OK
|—————Node:; Text: ;
|————Node:else_clause Text: else return CAN_FAILINIT;
|—————Node:else Text: else
|—————Node:return_statement Text: return CAN_FAILINIT;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_FAILINIT
|——————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           init_Mask
** Descriptions:            init canid Masks
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::init_Mask(INT8U num, INT8U ext, INT32U ulData)
{
    INT8U res = MCP2515_OK;
#if DEBUG_MODE
    Serial.print("Begin to set Mask!!\r\n");
#endif
    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter setting mode fall\r\n"); 
#endif
  return res;
}
    
    if (num == 0){
        mcp2515_write_id(MCP_RXM0SIDH, ext, ulData);

    }
    else if(num == 1){
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
    else res =  MCP2515_FAIL;
    
    res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
    if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter normal mode fall\r\n"); 
#endif
    return res;
  }
#if DEBUG_MODE
    Serial.print("set Mask success!!\r\n");
#endif
    return res;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::init_Mask(INT8U num, INT8U ext, INT32U ulData)
|———Node:qualified_identifier Text: MCP_CAN::init_Mask
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: init_Mask
|———Node:parameter_list Text: (INT8U num, INT8U ext, INT32U ulData)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U num
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: num
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U ext
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT32U ulData
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: ulData
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U res = MCP2515_OK;
#if DEBUG_MODE
    Serial.print("Begin to set Mask!!\r\n");
#endif
    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter setting mode fall\r\n"); 
#endif
  return res;
}
    
    if (num == 0){
        mcp2515_write_id(MCP_RXM0SIDH, ext, ulData);

    }
    else if(num == 1){
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
    else res =  MCP2515_FAIL;
    
    res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
    if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter normal mode fall\r\n"); 
#endif
    return res;
  }
#if DEBUG_MODE
    Serial.print("set Mask success!!\r\n");
#endif
    return res;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res = MCP2515_OK;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: res = MCP2515_OK
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:identifier Text: MCP2515_OK
|————Node:; Text: ;
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("Begin to set Mask!!\r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("Begin to set Mask!!\r\n");
|—————Node:call_expression Text: Serial.print("Begin to set Mask!!\r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("Begin to set Mask!!\r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "Begin to set Mask!!\r\n"
|————————Node:" Text: "
|————————Node:string_content Text: Begin to set Mask!!
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
|————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|——————Node:identifier Text: mcp2515_setCANCTRL_Mode
|——————Node:argument_list Text: (MODE_CONFIG)
|———————Node:( Text: (
|———————Node:identifier Text: MODE_CONFIG
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter setting mode fall\r\n"); 
#endif
  return res;
}
|————Node:if Text: if
|————Node:condition_clause Text: (res > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: res > 0
|——————Node:identifier Text: res
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
    Serial.print("Enter setting mode fall\r\n"); 
#endif
  return res;
}
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("Enter setting mode fall\r\n"); 
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter setting mode fall\r\n");
|———————Node:call_expression Text: Serial.print("Enter setting mode fall\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter setting mode fall\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter setting mode fall\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter setting mode fall
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (num == 0){
        mcp2515_write_id(MCP_RXM0SIDH, ext, ulData);

    }
    else if(num == 1){
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
    else res =  MCP2515_FAIL;
|————Node:if Text: if
|————Node:condition_clause Text: (num == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: num == 0
|——————Node:identifier Text: num
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        mcp2515_write_id(MCP_RXM0SIDH, ext, ulData);

    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: mcp2515_write_id(MCP_RXM0SIDH, ext, ulData);
|——————Node:call_expression Text: mcp2515_write_id(MCP_RXM0SIDH, ext, ulData)
|———————Node:identifier Text: mcp2515_write_id
|———————Node:argument_list Text: (MCP_RXM0SIDH, ext, ulData)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_RXM0SIDH
|————————Node:, Text: ,
|————————Node:identifier Text: ext
|————————Node:, Text: ,
|————————Node:identifier Text: ulData
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if(num == 1){
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
    else res =  MCP2515_FAIL;
|—————Node:else Text: else
|—————Node:if_statement Text: if(num == 1){
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
    else res =  MCP2515_FAIL;
|——————Node:if Text: if
|——————Node:condition_clause Text: (num == 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: num == 1
|————————Node:identifier Text: num
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: mcp2515_write_id(MCP_RXM1SIDH, ext, ulData);
|————————Node:call_expression Text: mcp2515_write_id(MCP_RXM1SIDH, ext, ulData)
|—————————Node:identifier Text: mcp2515_write_id
|—————————Node:argument_list Text: (MCP_RXM1SIDH, ext, ulData)
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP_RXM1SIDH
|——————————Node:, Text: ,
|——————————Node:identifier Text: ext
|——————————Node:, Text: ,
|——————————Node:identifier Text: ulData
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else res =  MCP2515_FAIL;
|———————Node:else Text: else
|———————Node:expression_statement Text: res =  MCP2515_FAIL;
|————————Node:assignment_expression Text: res =  MCP2515_FAIL
|—————————Node:identifier Text: res
|—————————Node:= Text: =
|—————————Node:identifier Text: MCP2515_FAIL
|————————Node:; Text: ;
|———Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
|————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|——————Node:identifier Text: mcp2515_setCANCTRL_Mode
|——————Node:argument_list Text: (MODE_NORMAL)
|———————Node:( Text: (
|———————Node:identifier Text: MODE_NORMAL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(res > 0){
#if DEBUG_MODE
    Serial.print("Enter normal mode fall\r\n"); 
#endif
    return res;
  }
|————Node:if Text: if
|————Node:condition_clause Text: (res > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: res > 0
|——————Node:identifier Text: res
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
    Serial.print("Enter normal mode fall\r\n"); 
#endif
    return res;
  }
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("Enter normal mode fall\r\n"); 
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter normal mode fall\r\n");
|———————Node:call_expression Text: Serial.print("Enter normal mode fall\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter normal mode fall\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter normal mode fall\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter normal mode fall
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("set Mask success!!\r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("set Mask success!!\r\n");
|—————Node:call_expression Text: Serial.print("set Mask success!!\r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("set Mask success!!\r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "set Mask success!!\r\n"
|————————Node:" Text: "
|————————Node:string_content Text: set Mask success!!
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:return_statement Text: return res;
|————Node:return Text: return
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           init_Filt
** Descriptions:            init canid filters
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::init_Filt(INT8U num, INT8U ext, INT32U ulData)
{
    INT8U res = MCP2515_OK;
#if DEBUG_MODE
    Serial.print("Begin to set Filter!!\r\n");
#endif
    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
    
    switch( num )
    {
        case 0:
        mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
        break;

        case 1:
        mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
        break;

        case 2:
        mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
        break;

        case 3:
        mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
        break;

        case 4:
        mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
        break;

        case 5:
        mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
        break;

        default:
        res = MCP2515_FAIL;
    }
    
    res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n"); 
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("set Filter success!!\r\n");
#endif
    
    return res;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::init_Filt(INT8U num, INT8U ext, INT32U ulData)
|———Node:qualified_identifier Text: MCP_CAN::init_Filt
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: init_Filt
|———Node:parameter_list Text: (INT8U num, INT8U ext, INT32U ulData)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U num
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: num
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U ext
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT32U ulData
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: ulData
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U res = MCP2515_OK;
#if DEBUG_MODE
    Serial.print("Begin to set Filter!!\r\n");
#endif
    res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
    
    switch( num )
    {
        case 0:
        mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
        break;

        case 1:
        mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
        break;

        case 2:
        mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
        break;

        case 3:
        mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
        break;

        case 4:
        mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
        break;

        case 5:
        mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
        break;

        default:
        res = MCP2515_FAIL;
    }
    
    res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
    if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n"); 
#endif
      return res;
    }
#if DEBUG_MODE
    Serial.print("set Filter success!!\r\n");
#endif
    
    return res;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res = MCP2515_OK;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: res = MCP2515_OK
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:identifier Text: MCP2515_OK
|————Node:; Text: ;
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("Begin to set Filter!!\r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("Begin to set Filter!!\r\n");
|—————Node:call_expression Text: Serial.print("Begin to set Filter!!\r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("Begin to set Filter!!\r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "Begin to set Filter!!\r\n"
|————————Node:" Text: "
|————————Node:string_content Text: Begin to set Filter!!
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
|————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_CONFIG)
|——————Node:identifier Text: mcp2515_setCANCTRL_Mode
|——————Node:argument_list Text: (MODE_CONFIG)
|———————Node:( Text: (
|———————Node:identifier Text: MODE_CONFIG
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (res > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: res > 0
|——————Node:identifier Text: res
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
      return res;
    }
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
      Serial.print("Enter setting mode fall\r\n"); 
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter setting mode fall\r\n");
|———————Node:call_expression Text: Serial.print("Enter setting mode fall\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter setting mode fall\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter setting mode fall\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter setting mode fall
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:switch_statement Text: switch( num )
    {
        case 0:
        mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
        break;

        case 1:
        mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
        break;

        case 2:
        mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
        break;

        case 3:
        mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
        break;

        case 4:
        mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
        break;

        case 5:
        mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
        break;

        default:
        res = MCP2515_FAIL;
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: ( num )
|—————Node:( Text: (
|—————Node:identifier Text: num
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case 0:
        mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
        break;

        case 1:
        mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
        break;

        case 2:
        mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
        break;

        case 3:
        mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
        break;

        case 4:
        mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
        break;

        case 5:
        mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
        break;

        default:
        res = MCP2515_FAIL;
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case 0:
        mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 0
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF0SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF0SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF0SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF0SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 1:
        mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 1
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF1SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF1SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF1SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF1SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 2:
        mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 2
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF2SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF2SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF2SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF2SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 3:
        mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 3
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF3SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF3SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF3SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF3SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 4:
        mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 4
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF4SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF4SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF4SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF4SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 5:
        mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
        break;
|——————Node:case Text: case
|——————Node:number_literal Text: 5
|——————Node:: Text: :
|——————Node:expression_statement Text: mcp2515_write_id(MCP_RXF5SIDH, ext, ulData);
|———————Node:call_expression Text: mcp2515_write_id(MCP_RXF5SIDH, ext, ulData)
|————————Node:identifier Text: mcp2515_write_id
|————————Node:argument_list Text: (MCP_RXF5SIDH, ext, ulData)
|—————————Node:( Text: (
|—————————Node:identifier Text: MCP_RXF5SIDH
|—————————Node:, Text: ,
|—————————Node:identifier Text: ext
|—————————Node:, Text: ,
|—————————Node:identifier Text: ulData
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
        res = MCP2515_FAIL;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: res = MCP2515_FAIL;
|———————Node:assignment_expression Text: res = MCP2515_FAIL
|————————Node:identifier Text: res
|————————Node:= Text: =
|————————Node:identifier Text: MCP2515_FAIL
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
|————Node:assignment_expression Text: res = mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_setCANCTRL_Mode(MODE_NORMAL)
|——————Node:identifier Text: mcp2515_setCANCTRL_Mode
|——————Node:argument_list Text: (MODE_NORMAL)
|———————Node:( Text: (
|———————Node:identifier Text: MODE_NORMAL
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(res > 0)
    {
#if DEBUG_MODE
      Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n"); 
#endif
      return res;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (res > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: res > 0
|——————Node:identifier Text: res
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
#if DEBUG_MODE
      Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n"); 
#endif
      return res;
    }
|—————Node:{ Text: {
|—————Node:preproc_if Text: #if DEBUG_MODE
      Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n"); 
#endif
|——————Node:#if Text: #if
|——————Node:identifier Text: DEBUG_MODE
|——————Node:
 Text: 

|——————Node:expression_statement Text: Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n");
|———————Node:call_expression Text: Serial.print("Enter normal mode fall\r\nSet filter fail!!\r\n")
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("Enter normal mode fall\r\nSet filter fail!!\r\n")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "Enter normal mode fall\r\nSet filter fail!!\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: Enter normal mode fall
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:string_content Text: Set filter fail!!
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return res;
|——————Node:return Text: return
|——————Node:identifier Text: res
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_if Text: #if DEBUG_MODE
    Serial.print("set Filter success!!\r\n");
#endif
|————Node:#if Text: #if
|————Node:identifier Text: DEBUG_MODE
|————Node:
 Text: 

|————Node:expression_statement Text: Serial.print("set Filter success!!\r\n");
|—————Node:call_expression Text: Serial.print("set Filter success!!\r\n")
|——————Node:field_expression Text: Serial.print
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: print
|——————Node:argument_list Text: ("set Filter success!!\r\n")
|———————Node:( Text: (
|———————Node:string_literal Text: "set Filter success!!\r\n"
|————————Node:" Text: "
|————————Node:string_content Text: set Filter success!!
|————————Node:escape_sequence Text: \r
|————————Node:escape_sequence Text: \n
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:return_statement Text: return res;
|————Node:return Text: return
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           setMsg
** Descriptions:            set can message, such as dlc, id, dta[] and so on
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::setMsg(INT32U id, INT8U ext, INT8U len, INT8U *pData)
{
    int i = 0;
    m_nExtFlg = ext;
    m_nID     = id;
    m_nDlc    = len;
    for(i = 0; i<MAX_CHAR_IN_MESSAGE; i++)
    m_nDta[i] = *(pData+i);
    return MCP2515_OK;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::setMsg(INT32U id, INT8U ext, INT8U len, INT8U *pData)
|———Node:qualified_identifier Text: MCP_CAN::setMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: setMsg
|———Node:parameter_list Text: (INT32U id, INT8U ext, INT8U len, INT8U *pData)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT32U id
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U ext
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U len
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U *pData
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *pData
|——————Node:* Text: *
|——————Node:identifier Text: pData
|————Node:) Text: )
|——Node:compound_statement Text: {
    int i = 0;
    m_nExtFlg = ext;
    m_nID     = id;
    m_nDlc    = len;
    for(i = 0; i<MAX_CHAR_IN_MESSAGE; i++)
    m_nDta[i] = *(pData+i);
    return MCP2515_OK;
}
|———Node:{ Text: {
|———Node:declaration Text: int i = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: i = 0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_nExtFlg = ext;
|————Node:assignment_expression Text: m_nExtFlg = ext
|—————Node:identifier Text: m_nExtFlg
|—————Node:= Text: =
|—————Node:identifier Text: ext
|————Node:; Text: ;
|———Node:expression_statement Text: m_nID     = id;
|————Node:assignment_expression Text: m_nID     = id
|—————Node:identifier Text: m_nID
|—————Node:= Text: =
|—————Node:identifier Text: id
|————Node:; Text: ;
|———Node:expression_statement Text: m_nDlc    = len;
|————Node:assignment_expression Text: m_nDlc    = len
|—————Node:identifier Text: m_nDlc
|—————Node:= Text: =
|—————Node:identifier Text: len
|————Node:; Text: ;
|———Node:for_statement Text: for(i = 0; i<MAX_CHAR_IN_MESSAGE; i++)
    m_nDta[i] = *(pData+i);
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i = 0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<MAX_CHAR_IN_MESSAGE
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: MAX_CHAR_IN_MESSAGE
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:expression_statement Text: m_nDta[i] = *(pData+i);
|—————Node:assignment_expression Text: m_nDta[i] = *(pData+i)
|——————Node:subscript_expression Text: m_nDta[i]
|———————Node:identifier Text: m_nDta
|———————Node:subscript_argument_list Text: [i]
|————————Node:[ Text: [
|————————Node:identifier Text: i
|————————Node:] Text: ]
|——————Node:= Text: =
|——————Node:pointer_expression Text: *(pData+i)
|———————Node:* Text: *
|———————Node:parenthesized_expression Text: (pData+i)
|————————Node:( Text: (
|————————Node:binary_expression Text: pData+i
|—————————Node:identifier Text: pData
|—————————Node:+ Text: +
|—————————Node:identifier Text: i
|————————Node:) Text: )
|—————Node:; Text: ;
|———Node:return_statement Text: return MCP2515_OK;
|————Node:return Text: return
|————Node:identifier Text: MCP2515_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           clearMsg
** Descriptions:            set all message to zero
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::clearMsg()
{
    m_nID       = 0;
    m_nDlc      = 0;
    m_nExtFlg   = 0;
    m_nRtr      = 0;
    m_nfilhit   = 0;
    for(int i = 0; i<m_nDlc; i++ )
      m_nDta[i] = 0x00;

    return MCP2515_OK;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::clearMsg()
|———Node:qualified_identifier Text: MCP_CAN::clearMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: clearMsg
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    m_nID       = 0;
    m_nDlc      = 0;
    m_nExtFlg   = 0;
    m_nRtr      = 0;
    m_nfilhit   = 0;
    for(int i = 0; i<m_nDlc; i++ )
      m_nDta[i] = 0x00;

    return MCP2515_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_nID       = 0;
|————Node:assignment_expression Text: m_nID       = 0
|—————Node:identifier Text: m_nID
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_nDlc      = 0;
|————Node:assignment_expression Text: m_nDlc      = 0
|—————Node:identifier Text: m_nDlc
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_nExtFlg   = 0;
|————Node:assignment_expression Text: m_nExtFlg   = 0
|—————Node:identifier Text: m_nExtFlg
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_nRtr      = 0;
|————Node:assignment_expression Text: m_nRtr      = 0
|—————Node:identifier Text: m_nRtr
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_nfilhit   = 0;
|————Node:assignment_expression Text: m_nfilhit   = 0
|—————Node:identifier Text: m_nfilhit
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:for_statement Text: for(int i = 0; i<m_nDlc; i++ )
      m_nDta[i] = 0x00;
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i<m_nDlc
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: m_nDlc
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:expression_statement Text: m_nDta[i] = 0x00;
|—————Node:assignment_expression Text: m_nDta[i] = 0x00
|——————Node:subscript_expression Text: m_nDta[i]
|———————Node:identifier Text: m_nDta
|———————Node:subscript_argument_list Text: [i]
|————————Node:[ Text: [
|————————Node:identifier Text: i
|————————Node:] Text: ]
|——————Node:= Text: =
|——————Node:number_literal Text: 0x00
|—————Node:; Text: ;
|———Node:return_statement Text: return MCP2515_OK;
|————Node:return Text: return
|————Node:identifier Text: MCP2515_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           sendMsg
** Descriptions:            send message
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::sendMsg()
{
    INT8U res, res1, txbuf_n;
    uint16_t uiTimeOut = 0;

    do {
        res = mcp2515_getNextFreeTXBuf(&txbuf_n);                       /* info = addr.                 */
        uiTimeOut++;
    } while (res == MCP_ALLTXBUSY && (uiTimeOut < TIMEOUTVALUE));

    if(uiTimeOut == TIMEOUTVALUE) 
    {   
        return CAN_GETTXBFTIMEOUT;                                      /* get tx buff time out         */
    }
    uiTimeOut = 0;
    mcp2515_write_canMsg( txbuf_n);
    mcp2515_start_transmit( txbuf_n );
    do
    {
        uiTimeOut++;        
        res1= CAN.mcp2515_readRegister(txbuf_n);  			                /* read send buff ctrl reg 	*/
        res1 = res1 & 0x08;                               		
    }while(res1 && (uiTimeOut < TIMEOUTVALUE));   
    if(uiTimeOut == TIMEOUTVALUE)                                       /* send msg timeout             */	
    {
        return CAN_SENDMSGTIMEOUT;
    }
    return CAN_OK;

}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::sendMsg()
|———Node:qualified_identifier Text: MCP_CAN::sendMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: sendMsg
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U res, res1, txbuf_n;
    uint16_t uiTimeOut = 0;

    do {
        res = mcp2515_getNextFreeTXBuf(&txbuf_n);                       /* info = addr.                 */
        uiTimeOut++;
    } while (res == MCP_ALLTXBUSY && (uiTimeOut < TIMEOUTVALUE));

    if(uiTimeOut == TIMEOUTVALUE) 
    {   
        return CAN_GETTXBFTIMEOUT;                                      /* get tx buff time out         */
    }
    uiTimeOut = 0;
    mcp2515_write_canMsg( txbuf_n);
    mcp2515_start_transmit( txbuf_n );
    do
    {
        uiTimeOut++;        
        res1= CAN.mcp2515_readRegister(txbuf_n);  			                /* read send buff ctrl reg 	*/
        res1 = res1 & 0x08;                               		
    }while(res1 && (uiTimeOut < TIMEOUTVALUE));   
    if(uiTimeOut == TIMEOUTVALUE)                                       /* send msg timeout             */	
    {
        return CAN_SENDMSGTIMEOUT;
    }
    return CAN_OK;

}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res, res1, txbuf_n;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: res
|————Node:, Text: ,
|————Node:identifier Text: res1
|————Node:, Text: ,
|————Node:identifier Text: txbuf_n
|————Node:; Text: ;
|———Node:declaration Text: uint16_t uiTimeOut = 0;
|————Node:primitive_type Text: uint16_t
|————Node:init_declarator Text: uiTimeOut = 0
|—————Node:identifier Text: uiTimeOut
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:do_statement Text: do {
        res = mcp2515_getNextFreeTXBuf(&txbuf_n);                       /* info = addr.                 */
        uiTimeOut++;
    } while (res == MCP_ALLTXBUSY && (uiTimeOut < TIMEOUTVALUE));
|————Node:do Text: do
|————Node:compound_statement Text: {
        res = mcp2515_getNextFreeTXBuf(&txbuf_n);                       /* info = addr.                 */
        uiTimeOut++;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: res = mcp2515_getNextFreeTXBuf(&txbuf_n);
|——————Node:assignment_expression Text: res = mcp2515_getNextFreeTXBuf(&txbuf_n)
|———————Node:identifier Text: res
|———————Node:= Text: =
|———————Node:call_expression Text: mcp2515_getNextFreeTXBuf(&txbuf_n)
|————————Node:identifier Text: mcp2515_getNextFreeTXBuf
|————————Node:argument_list Text: (&txbuf_n)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &txbuf_n
|——————————Node:& Text: &
|——————————Node:identifier Text: txbuf_n
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* info = addr.                 */
|—————Node:expression_statement Text: uiTimeOut++;
|——————Node:update_expression Text: uiTimeOut++
|———————Node:identifier Text: uiTimeOut
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (res == MCP_ALLTXBUSY && (uiTimeOut < TIMEOUTVALUE))
|—————Node:( Text: (
|—————Node:binary_expression Text: res == MCP_ALLTXBUSY && (uiTimeOut < TIMEOUTVALUE)
|——————Node:binary_expression Text: res == MCP_ALLTXBUSY
|———————Node:identifier Text: res
|———————Node:== Text: ==
|———————Node:identifier Text: MCP_ALLTXBUSY
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (uiTimeOut < TIMEOUTVALUE)
|———————Node:( Text: (
|———————Node:binary_expression Text: uiTimeOut < TIMEOUTVALUE
|————————Node:identifier Text: uiTimeOut
|————————Node:< Text: <
|————————Node:identifier Text: TIMEOUTVALUE
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(uiTimeOut == TIMEOUTVALUE) 
    {   
        return CAN_GETTXBFTIMEOUT;                                      /* get tx buff time out         */
    }
|————Node:if Text: if
|————Node:condition_clause Text: (uiTimeOut == TIMEOUTVALUE)
|—————Node:( Text: (
|—————Node:binary_expression Text: uiTimeOut == TIMEOUTVALUE
|——————Node:identifier Text: uiTimeOut
|——————Node:== Text: ==
|——————Node:identifier Text: TIMEOUTVALUE
|—————Node:) Text: )
|————Node:compound_statement Text: {   
        return CAN_GETTXBFTIMEOUT;                                      /* get tx buff time out         */
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return CAN_GETTXBFTIMEOUT;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_GETTXBFTIMEOUT
|——————Node:; Text: ;
|—————Node:comment Text: /* get tx buff time out         */
|—————Node:} Text: }
|———Node:expression_statement Text: uiTimeOut = 0;
|————Node:assignment_expression Text: uiTimeOut = 0
|—————Node:identifier Text: uiTimeOut
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_write_canMsg( txbuf_n);
|————Node:call_expression Text: mcp2515_write_canMsg( txbuf_n)
|—————Node:identifier Text: mcp2515_write_canMsg
|—————Node:argument_list Text: ( txbuf_n)
|——————Node:( Text: (
|——————Node:identifier Text: txbuf_n
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mcp2515_start_transmit( txbuf_n );
|————Node:call_expression Text: mcp2515_start_transmit( txbuf_n )
|—————Node:identifier Text: mcp2515_start_transmit
|—————Node:argument_list Text: ( txbuf_n )
|——————Node:( Text: (
|——————Node:identifier Text: txbuf_n
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:do_statement Text: do
    {
        uiTimeOut++;        
        res1= CAN.mcp2515_readRegister(txbuf_n);  			                /* read send buff ctrl reg 	*/
        res1 = res1 & 0x08;                               		
    }while(res1 && (uiTimeOut < TIMEOUTVALUE));
|————Node:do Text: do
|————Node:compound_statement Text: {
        uiTimeOut++;        
        res1= CAN.mcp2515_readRegister(txbuf_n);  			                /* read send buff ctrl reg 	*/
        res1 = res1 & 0x08;                               		
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: uiTimeOut++;
|——————Node:update_expression Text: uiTimeOut++
|———————Node:identifier Text: uiTimeOut
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:expression_statement Text: res1= CAN.mcp2515_readRegister(txbuf_n);
|——————Node:assignment_expression Text: res1= CAN.mcp2515_readRegister(txbuf_n)
|———————Node:identifier Text: res1
|———————Node:= Text: =
|———————Node:call_expression Text: CAN.mcp2515_readRegister(txbuf_n)
|————————Node:field_expression Text: CAN.mcp2515_readRegister
|—————————Node:identifier Text: CAN
|—————————Node:. Text: .
|—————————Node:field_identifier Text: mcp2515_readRegister
|————————Node:argument_list Text: (txbuf_n)
|—————————Node:( Text: (
|—————————Node:identifier Text: txbuf_n
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* read send buff ctrl reg 	*/
|—————Node:expression_statement Text: res1 = res1 & 0x08;
|——————Node:assignment_expression Text: res1 = res1 & 0x08
|———————Node:identifier Text: res1
|———————Node:= Text: =
|———————Node:binary_expression Text: res1 & 0x08
|————————Node:identifier Text: res1
|————————Node:& Text: &
|————————Node:number_literal Text: 0x08
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (res1 && (uiTimeOut < TIMEOUTVALUE))
|—————Node:( Text: (
|—————Node:binary_expression Text: res1 && (uiTimeOut < TIMEOUTVALUE)
|——————Node:identifier Text: res1
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (uiTimeOut < TIMEOUTVALUE)
|———————Node:( Text: (
|———————Node:binary_expression Text: uiTimeOut < TIMEOUTVALUE
|————————Node:identifier Text: uiTimeOut
|————————Node:< Text: <
|————————Node:identifier Text: TIMEOUTVALUE
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(uiTimeOut == TIMEOUTVALUE)                                       /* send msg timeout             */	
    {
        return CAN_SENDMSGTIMEOUT;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (uiTimeOut == TIMEOUTVALUE)
|—————Node:( Text: (
|—————Node:binary_expression Text: uiTimeOut == TIMEOUTVALUE
|——————Node:identifier Text: uiTimeOut
|——————Node:== Text: ==
|——————Node:identifier Text: TIMEOUTVALUE
|—————Node:) Text: )
|————Node:comment Text: /* send msg timeout             */
|————Node:compound_statement Text: {
        return CAN_SENDMSGTIMEOUT;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return CAN_SENDMSGTIMEOUT;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_SENDMSGTIMEOUT
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return CAN_OK;
|————Node:return Text: return
|————Node:identifier Text: CAN_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           sendMsgBuf
** Descriptions:            send buf
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::sendMsgBuf(INT32U id, INT8U ext, INT8U len, INT8U *buf)
{
    setMsg(id, ext, len, buf);
    sendMsg();
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::sendMsgBuf(INT32U id, INT8U ext, INT8U len, INT8U *buf)
|———Node:qualified_identifier Text: MCP_CAN::sendMsgBuf
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: sendMsgBuf
|———Node:parameter_list Text: (INT32U id, INT8U ext, INT8U len, INT8U *buf)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT32U id
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U ext
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U len
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U *buf
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *buf
|——————Node:* Text: *
|——————Node:identifier Text: buf
|————Node:) Text: )
|——Node:compound_statement Text: {
    setMsg(id, ext, len, buf);
    sendMsg();
}
|———Node:{ Text: {
|———Node:expression_statement Text: setMsg(id, ext, len, buf);
|————Node:call_expression Text: setMsg(id, ext, len, buf)
|—————Node:identifier Text: setMsg
|—————Node:argument_list Text: (id, ext, len, buf)
|——————Node:( Text: (
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:identifier Text: ext
|——————Node:, Text: ,
|——————Node:identifier Text: len
|——————Node:, Text: ,
|——————Node:identifier Text: buf
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sendMsg();
|————Node:call_expression Text: sendMsg()
|—————Node:identifier Text: sendMsg
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            read message
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::readMsg()
{
    INT8U stat, res;

    stat = mcp2515_readStatus();

    if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_0);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
        res = CAN_OK;
    }
    else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
    else 
    {
        res = CAN_NOMSG;
    }
    return res;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::readMsg()
|———Node:qualified_identifier Text: MCP_CAN::readMsg
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: readMsg
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U stat, res;

    stat = mcp2515_readStatus();

    if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_0);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
        res = CAN_OK;
    }
    else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
    else 
    {
        res = CAN_NOMSG;
    }
    return res;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U stat, res;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: stat
|————Node:, Text: ,
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:expression_statement Text: stat = mcp2515_readStatus();
|————Node:assignment_expression Text: stat = mcp2515_readStatus()
|—————Node:identifier Text: stat
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readStatus()
|——————Node:identifier Text: mcp2515_readStatus
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_0);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
        res = CAN_OK;
    }
    else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
    else 
    {
        res = CAN_NOMSG;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( stat & MCP_STAT_RX0IF )
|—————Node:( Text: (
|—————Node:binary_expression Text: stat & MCP_STAT_RX0IF
|——————Node:identifier Text: stat
|——————Node:& Text: &
|——————Node:identifier Text: MCP_STAT_RX0IF
|—————Node:) Text: )
|————Node:comment Text: /* Msg in Buffer 0              */
|————Node:compound_statement Text: {
        mcp2515_read_canMsg( MCP_RXBUF_0);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
        res = CAN_OK;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: mcp2515_read_canMsg( MCP_RXBUF_0);
|——————Node:call_expression Text: mcp2515_read_canMsg( MCP_RXBUF_0)
|———————Node:identifier Text: mcp2515_read_canMsg
|———————Node:argument_list Text: ( MCP_RXBUF_0)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_RXBUF_0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
|——————Node:call_expression Text: mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0)
|———————Node:identifier Text: mcp2515_modifyRegister
|———————Node:argument_list Text: (MCP_CANINTF, MCP_RX0IF, 0)
|————————Node:( Text: (
|————————Node:identifier Text: MCP_CANINTF
|————————Node:, Text: ,
|————————Node:identifier Text: MCP_RX0IF
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: res = CAN_OK;
|——————Node:assignment_expression Text: res = CAN_OK
|———————Node:identifier Text: res
|———————Node:= Text: =
|———————Node:identifier Text: CAN_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
    else 
    {
        res = CAN_NOMSG;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
    else 
    {
        res = CAN_NOMSG;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( stat & MCP_STAT_RX1IF )
|———————Node:( Text: (
|———————Node:binary_expression Text: stat & MCP_STAT_RX1IF
|————————Node:identifier Text: stat
|————————Node:& Text: &
|————————Node:identifier Text: MCP_STAT_RX1IF
|———————Node:) Text: )
|——————Node:comment Text: /* Msg in Buffer 1              */
|——————Node:compound_statement Text: {
        mcp2515_read_canMsg( MCP_RXBUF_1);
        mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
        res = CAN_OK;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: mcp2515_read_canMsg( MCP_RXBUF_1);
|————————Node:call_expression Text: mcp2515_read_canMsg( MCP_RXBUF_1)
|—————————Node:identifier Text: mcp2515_read_canMsg
|—————————Node:argument_list Text: ( MCP_RXBUF_1)
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP_RXBUF_1
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
|————————Node:call_expression Text: mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0)
|—————————Node:identifier Text: mcp2515_modifyRegister
|—————————Node:argument_list Text: (MCP_CANINTF, MCP_RX1IF, 0)
|——————————Node:( Text: (
|——————————Node:identifier Text: MCP_CANINTF
|——————————Node:, Text: ,
|——————————Node:identifier Text: MCP_RX1IF
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: res = CAN_OK;
|————————Node:assignment_expression Text: res = CAN_OK
|—————————Node:identifier Text: res
|—————————Node:= Text: =
|—————————Node:identifier Text: CAN_OK
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else 
    {
        res = CAN_NOMSG;
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
        res = CAN_NOMSG;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: res = CAN_NOMSG;
|—————————Node:assignment_expression Text: res = CAN_NOMSG
|——————————Node:identifier Text: res
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_NOMSG
|—————————Node:; Text: ;
|————————Node:} Text: }
|———Node:return_statement Text: return res;
|————Node:return Text: return
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            read message buf
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::readMsgBuf(INT8U *len, INT8U buf[])
{
    readMsg();
    *len = m_nDlc;
    for(int i = 0; i<m_nDlc; i++)
    {
      buf[i] = m_nDta[i];
    }
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::readMsgBuf(INT8U *len, INT8U buf[])
|———Node:qualified_identifier Text: MCP_CAN::readMsgBuf
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: readMsgBuf
|———Node:parameter_list Text: (INT8U *len, INT8U buf[])
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U *len
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *len
|——————Node:* Text: *
|——————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U buf[]
|—————Node:type_identifier Text: INT8U
|—————Node:array_declarator Text: buf[]
|——————Node:identifier Text: buf
|——————Node:[ Text: [
|——————Node:] Text: ]
|————Node:) Text: )
|——Node:compound_statement Text: {
    readMsg();
    *len = m_nDlc;
    for(int i = 0; i<m_nDlc; i++)
    {
      buf[i] = m_nDta[i];
    }
}
|———Node:{ Text: {
|———Node:expression_statement Text: readMsg();
|————Node:call_expression Text: readMsg()
|—————Node:identifier Text: readMsg
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: *len = m_nDlc;
|————Node:assignment_expression Text: *len = m_nDlc
|—————Node:pointer_expression Text: *len
|——————Node:* Text: *
|——————Node:identifier Text: len
|—————Node:= Text: =
|—————Node:identifier Text: m_nDlc
|————Node:; Text: ;
|———Node:for_statement Text: for(int i = 0; i<m_nDlc; i++)
    {
      buf[i] = m_nDta[i];
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i<m_nDlc
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: m_nDlc
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
      buf[i] = m_nDta[i];
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: buf[i] = m_nDta[i];
|——————Node:assignment_expression Text: buf[i] = m_nDta[i]
|———————Node:subscript_expression Text: buf[i]
|————————Node:identifier Text: buf
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: m_nDta[i]
|————————Node:identifier Text: m_nDta
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           checkReceive
** Descriptions:            check if got something
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::checkReceive(void)
{
    INT8U res;
    res = mcp2515_readStatus();                                         /* RXnIF in Bit 1 and 0         */
    if ( res & MCP_STAT_RXIF_MASK ) 
    {
        return CAN_MSGAVAIL;
    }
    else 
    {
        return CAN_NOMSG;
    }
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::checkReceive(void)
|———Node:qualified_identifier Text: MCP_CAN::checkReceive
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: checkReceive
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U res;
    res = mcp2515_readStatus();                                         /* RXnIF in Bit 1 and 0         */
    if ( res & MCP_STAT_RXIF_MASK ) 
    {
        return CAN_MSGAVAIL;
    }
    else 
    {
        return CAN_NOMSG;
    }
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U res;
|————Node:type_identifier Text: INT8U
|————Node:identifier Text: res
|————Node:; Text: ;
|———Node:expression_statement Text: res = mcp2515_readStatus();
|————Node:assignment_expression Text: res = mcp2515_readStatus()
|—————Node:identifier Text: res
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readStatus()
|——————Node:identifier Text: mcp2515_readStatus
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* RXnIF in Bit 1 and 0         */
|———Node:if_statement Text: if ( res & MCP_STAT_RXIF_MASK ) 
    {
        return CAN_MSGAVAIL;
    }
    else 
    {
        return CAN_NOMSG;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( res & MCP_STAT_RXIF_MASK )
|—————Node:( Text: (
|—————Node:binary_expression Text: res & MCP_STAT_RXIF_MASK
|——————Node:identifier Text: res
|——————Node:& Text: &
|——————Node:identifier Text: MCP_STAT_RXIF_MASK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return CAN_MSGAVAIL;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return CAN_MSGAVAIL;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_MSGAVAIL
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else 
    {
        return CAN_NOMSG;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        return CAN_NOMSG;
    }
|——————Node:{ Text: {
|——————Node:return_statement Text: return CAN_NOMSG;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_NOMSG
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           checkError
** Descriptions:            if something error
*********************************************************************************************************/
|—Node:function_definition Text: INT8U MCP_CAN::checkError(void)
{
    INT8U eflg = mcp2515_readRegister(MCP_EFLG);

    if ( eflg & MCP_EFLG_ERRORMASK ) 
    {
        return CAN_CTRLERROR;
    }
    else 
    {
        return CAN_OK;
    }
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: MCP_CAN::checkError(void)
|———Node:qualified_identifier Text: MCP_CAN::checkError
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: checkError
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U eflg = mcp2515_readRegister(MCP_EFLG);

    if ( eflg & MCP_EFLG_ERRORMASK ) 
    {
        return CAN_CTRLERROR;
    }
    else 
    {
        return CAN_OK;
    }
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U eflg = mcp2515_readRegister(MCP_EFLG);
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: eflg = mcp2515_readRegister(MCP_EFLG)
|—————Node:identifier Text: eflg
|—————Node:= Text: =
|—————Node:call_expression Text: mcp2515_readRegister(MCP_EFLG)
|——————Node:identifier Text: mcp2515_readRegister
|——————Node:argument_list Text: (MCP_EFLG)
|———————Node:( Text: (
|———————Node:identifier Text: MCP_EFLG
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( eflg & MCP_EFLG_ERRORMASK ) 
    {
        return CAN_CTRLERROR;
    }
    else 
    {
        return CAN_OK;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( eflg & MCP_EFLG_ERRORMASK )
|—————Node:( Text: (
|—————Node:binary_expression Text: eflg & MCP_EFLG_ERRORMASK
|——————Node:identifier Text: eflg
|——————Node:& Text: &
|——————Node:identifier Text: MCP_EFLG_ERRORMASK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return CAN_CTRLERROR;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return CAN_CTRLERROR;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_CTRLERROR
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else 
    {
        return CAN_OK;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        return CAN_OK;
    }
|——————Node:{ Text: {
|——————Node:return_statement Text: return CAN_OK;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_OK
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
** Function name:           getCanId
** Descriptions:            when receive something ,u can get the can id!!
*********************************************************************************************************/
|—Node:function_definition Text: INT32U MCP_CAN::getCanId(void)
{
    return m_nID;
}
|——Node:type_identifier Text: INT32U
|——Node:function_declarator Text: MCP_CAN::getCanId(void)
|———Node:qualified_identifier Text: MCP_CAN::getCanId
|————Node:namespace_identifier Text: MCP_CAN
|————Node::: Text: ::
|————Node:identifier Text: getCanId
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    return m_nID;
}
|———Node:{ Text: {
|———Node:return_statement Text: return m_nID;
|————Node:return Text: return
|————Node:identifier Text: m_nID
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*********************************************************************************************************
  END FILE
*********************************************************************************************************/
