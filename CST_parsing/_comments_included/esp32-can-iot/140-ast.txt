esp32-can-iot-Coding\fw\lib\Lawicel\Lawicel.cpp

|Node:translation_unit
|—Node:comment Text: /***************************************************************************************************
  (c) NewTec GmbH 2020   -   www.newtec.de
  $URL: https://github.com/NewTec-GmbH/esp32-can-iot $
***************************************************************************************************/
|—Node:comment Text: /**
@addtogroup Lawicel
@{
@file       Lawicel.cpp

Driver for Lawicel Protocol @ref Lawicel.h

* @}
***************************************************************************************************/
|—Node:comment Text: /* INCLUDES ***************************************************************************************/
|—Node:preproc_include Text: #include <Lawicel.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <Lawicel.h>
|—Node:comment Text: /* C-Interface ************************************************************************************/
|—Node:linkage_specification Text: extern "C"
{
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:declaration_list Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:comment Text: /* CONSTANTS **************************************************************************************/
|—Node:comment Text: /* MACROS *****************************************************************************************/
|—Node:comment Text: /* TYPES ******************************************************************************************/
|—Node:comment Text: /* PROTOTYPES *************************************************************************************/
|—Node:comment Text: /* VARIABLES **************************************************************************************/
|—Node:comment Text: /* PUBLIC METHODES ********************************************************************************/
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: bool Lawicel::handler()
{

    if (autoPolling)
    {
        if (Autopoll() == 0)
        {
            m_selectedSerial->print(serialReturn);
        }
        serialReturn = "";
    }

    serialReturn = "";
    serialInput = "";
    serialInput = m_selectedSerial->read();
    _length = serialInput.length();

    if (_length == 0)
    {
        return true;
    }

    m_selectedSerial->print(_length);
    m_selectedSerial->print(serialInput);

    uint8_t CMD_status = receiveCommand();

    if (serialInput.charAt(0) == POLL_SINGLE)
    {
        if (CMD_status == 2)
        {
            CMD_status = 0;
        }
    }

    if (CMD_status != 0)
    {
        serialReturn += (char)BELL;
        m_selectedSerial->print(serialReturn);
        return false ;
    }

    if (serialInput.charAt(0) == VERSION)
    {
        serialReturn += X_VERSION;
    }
    else if (serialInput.charAt(0) == SERIAL_NUMBER)
    {
        serialReturn += X_SERIAL_NUMBER;
    }

    serialReturn += (char)CR;

    m_selectedSerial->print(serialReturn);

    return true;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: Lawicel::handler()
|———Node:qualified_identifier Text: Lawicel::handler
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: handler
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {

    if (autoPolling)
    {
        if (Autopoll() == 0)
        {
            m_selectedSerial->print(serialReturn);
        }
        serialReturn = "";
    }

    serialReturn = "";
    serialInput = "";
    serialInput = m_selectedSerial->read();
    _length = serialInput.length();

    if (_length == 0)
    {
        return true;
    }

    m_selectedSerial->print(_length);
    m_selectedSerial->print(serialInput);

    uint8_t CMD_status = receiveCommand();

    if (serialInput.charAt(0) == POLL_SINGLE)
    {
        if (CMD_status == 2)
        {
            CMD_status = 0;
        }
    }

    if (CMD_status != 0)
    {
        serialReturn += (char)BELL;
        m_selectedSerial->print(serialReturn);
        return false ;
    }

    if (serialInput.charAt(0) == VERSION)
    {
        serialReturn += X_VERSION;
    }
    else if (serialInput.charAt(0) == SERIAL_NUMBER)
    {
        serialReturn += X_SERIAL_NUMBER;
    }

    serialReturn += (char)CR;

    m_selectedSerial->print(serialReturn);

    return true;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (autoPolling)
    {
        if (Autopoll() == 0)
        {
            m_selectedSerial->print(serialReturn);
        }
        serialReturn = "";
    }
|————Node:if Text: if
|————Node:condition_clause Text: (autoPolling)
|—————Node:( Text: (
|—————Node:identifier Text: autoPolling
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (Autopoll() == 0)
        {
            m_selectedSerial->print(serialReturn);
        }
        serialReturn = "";
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (Autopoll() == 0)
        {
            m_selectedSerial->print(serialReturn);
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (Autopoll() == 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: Autopoll() == 0
|————————Node:call_expression Text: Autopoll()
|—————————Node:identifier Text: Autopoll
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            m_selectedSerial->print(serialReturn);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: m_selectedSerial->print(serialReturn);
|————————Node:call_expression Text: m_selectedSerial->print(serialReturn)
|—————————Node:field_expression Text: m_selectedSerial->print
|——————————Node:identifier Text: m_selectedSerial
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: print
|—————————Node:argument_list Text: (serialReturn)
|——————————Node:( Text: (
|——————————Node:identifier Text: serialReturn
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: serialReturn = "";
|——————Node:assignment_expression Text: serialReturn = ""
|———————Node:identifier Text: serialReturn
|———————Node:= Text: =
|———————Node:string_literal Text: ""
|————————Node:" Text: "
|————————Node:" Text: "
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: serialReturn = "";
|————Node:assignment_expression Text: serialReturn = ""
|—————Node:identifier Text: serialReturn
|—————Node:= Text: =
|—————Node:string_literal Text: ""
|——————Node:" Text: "
|——————Node:" Text: "
|————Node:; Text: ;
|———Node:expression_statement Text: serialInput = "";
|————Node:assignment_expression Text: serialInput = ""
|—————Node:identifier Text: serialInput
|—————Node:= Text: =
|—————Node:string_literal Text: ""
|——————Node:" Text: "
|——————Node:" Text: "
|————Node:; Text: ;
|———Node:expression_statement Text: serialInput = m_selectedSerial->read();
|————Node:assignment_expression Text: serialInput = m_selectedSerial->read()
|—————Node:identifier Text: serialInput
|—————Node:= Text: =
|—————Node:call_expression Text: m_selectedSerial->read()
|——————Node:field_expression Text: m_selectedSerial->read
|———————Node:identifier Text: m_selectedSerial
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: _length = serialInput.length();
|————Node:assignment_expression Text: _length = serialInput.length()
|—————Node:identifier Text: _length
|—————Node:= Text: =
|—————Node:call_expression Text: serialInput.length()
|——————Node:field_expression Text: serialInput.length
|———————Node:identifier Text: serialInput
|———————Node:. Text: .
|———————Node:field_identifier Text: length
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (_length == 0)
    {
        return true;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length == 0
|——————Node:identifier Text: _length
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return true;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return true;
|——————Node:return Text: return
|——————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: m_selectedSerial->print(_length);
|————Node:call_expression Text: m_selectedSerial->print(_length)
|—————Node:field_expression Text: m_selectedSerial->print
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: (_length)
|——————Node:( Text: (
|——————Node:identifier Text: _length
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedSerial->print(serialInput);
|————Node:call_expression Text: m_selectedSerial->print(serialInput)
|—————Node:field_expression Text: m_selectedSerial->print
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: (serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint8_t CMD_status = receiveCommand();
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: CMD_status = receiveCommand()
|—————Node:identifier Text: CMD_status
|—————Node:= Text: =
|—————Node:call_expression Text: receiveCommand()
|——————Node:identifier Text: receiveCommand
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (serialInput.charAt(0) == POLL_SINGLE)
    {
        if (CMD_status == 2)
        {
            CMD_status = 0;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (serialInput.charAt(0) == POLL_SINGLE)
|—————Node:( Text: (
|—————Node:binary_expression Text: serialInput.charAt(0) == POLL_SINGLE
|——————Node:call_expression Text: serialInput.charAt(0)
|———————Node:field_expression Text: serialInput.charAt
|————————Node:identifier Text: serialInput
|————————Node:. Text: .
|————————Node:field_identifier Text: charAt
|———————Node:argument_list Text: (0)
|————————Node:( Text: (
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: POLL_SINGLE
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (CMD_status == 2)
        {
            CMD_status = 0;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (CMD_status == 2)
        {
            CMD_status = 0;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (CMD_status == 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: CMD_status == 2
|————————Node:identifier Text: CMD_status
|————————Node:== Text: ==
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            CMD_status = 0;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: CMD_status = 0;
|————————Node:assignment_expression Text: CMD_status = 0
|—————————Node:identifier Text: CMD_status
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:if_statement Text: if (CMD_status != 0)
    {
        serialReturn += (char)BELL;
        m_selectedSerial->print(serialReturn);
        return false ;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (CMD_status != 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: CMD_status != 0
|——————Node:identifier Text: CMD_status
|——————Node:!= Text: !=
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        serialReturn += (char)BELL;
        m_selectedSerial->print(serialReturn);
        return false ;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: serialReturn += (char)BELL;
|——————Node:assignment_expression Text: serialReturn += (char)BELL
|———————Node:identifier Text: serialReturn
|———————Node:+= Text: +=
|———————Node:cast_expression Text: (char)BELL
|————————Node:( Text: (
|————————Node:type_descriptor Text: char
|—————————Node:primitive_type Text: char
|————————Node:) Text: )
|————————Node:identifier Text: BELL
|——————Node:; Text: ;
|—————Node:expression_statement Text: m_selectedSerial->print(serialReturn);
|——————Node:call_expression Text: m_selectedSerial->print(serialReturn)
|———————Node:field_expression Text: m_selectedSerial->print
|————————Node:identifier Text: m_selectedSerial
|————————Node:-> Text: ->
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (serialReturn)
|————————Node:( Text: (
|————————Node:identifier Text: serialReturn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return false ;
|——————Node:return Text: return
|——————Node:false Text: false
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (serialInput.charAt(0) == VERSION)
    {
        serialReturn += X_VERSION;
    }
    else if (serialInput.charAt(0) == SERIAL_NUMBER)
    {
        serialReturn += X_SERIAL_NUMBER;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (serialInput.charAt(0) == VERSION)
|—————Node:( Text: (
|—————Node:binary_expression Text: serialInput.charAt(0) == VERSION
|——————Node:call_expression Text: serialInput.charAt(0)
|———————Node:field_expression Text: serialInput.charAt
|————————Node:identifier Text: serialInput
|————————Node:. Text: .
|————————Node:field_identifier Text: charAt
|———————Node:argument_list Text: (0)
|————————Node:( Text: (
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: VERSION
|—————Node:) Text: )
|————Node:compound_statement Text: {
        serialReturn += X_VERSION;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: serialReturn += X_VERSION;
|——————Node:assignment_expression Text: serialReturn += X_VERSION
|———————Node:identifier Text: serialReturn
|———————Node:+= Text: +=
|———————Node:identifier Text: X_VERSION
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (serialInput.charAt(0) == SERIAL_NUMBER)
    {
        serialReturn += X_SERIAL_NUMBER;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (serialInput.charAt(0) == SERIAL_NUMBER)
    {
        serialReturn += X_SERIAL_NUMBER;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (serialInput.charAt(0) == SERIAL_NUMBER)
|———————Node:( Text: (
|———————Node:binary_expression Text: serialInput.charAt(0) == SERIAL_NUMBER
|————————Node:call_expression Text: serialInput.charAt(0)
|—————————Node:field_expression Text: serialInput.charAt
|——————————Node:identifier Text: serialInput
|——————————Node:. Text: .
|——————————Node:field_identifier Text: charAt
|—————————Node:argument_list Text: (0)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:identifier Text: SERIAL_NUMBER
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        serialReturn += X_SERIAL_NUMBER;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: serialReturn += X_SERIAL_NUMBER;
|————————Node:assignment_expression Text: serialReturn += X_SERIAL_NUMBER
|—————————Node:identifier Text: serialReturn
|—————————Node:+= Text: +=
|—————————Node:identifier Text: X_SERIAL_NUMBER
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:expression_statement Text: serialReturn += (char)CR;
|————Node:assignment_expression Text: serialReturn += (char)CR
|—————Node:identifier Text: serialReturn
|—————Node:+= Text: +=
|—————Node:cast_expression Text: (char)CR
|——————Node:( Text: (
|——————Node:type_descriptor Text: char
|———————Node:primitive_type Text: char
|——————Node:) Text: )
|——————Node:identifier Text: CR
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedSerial->print(serialReturn);
|————Node:call_expression Text: m_selectedSerial->print(serialReturn)
|—————Node:field_expression Text: m_selectedSerial->print
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: (serialReturn)
|——————Node:( Text: (
|——————Node:identifier Text: serialReturn
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return true;
|————Node:return Text: return
|————Node:true Text: true
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: void Lawicel::begin()
{
    String var;

    m_selectedNVM->begin();

    serialInput = m_selectedNVM->readString(INIT_SERIAL_BAUD);
    receiveCommand();

    m_selectedSerial->begin();

    _timestamp = m_selectedNVM->read(INIT_TIMESTAMP);

    _autostart = m_selectedNVM->read(INIT_AUTO_START);

    if (_autostart != 0)
    {
        autoPolling = true;

        serialInput = m_selectedNVM->readString(INIT_CAN_BAUD);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_MODE);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_ACN);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_AMN);
        receiveCommand();
    }

    if (_autostart == 1)
    {
        serialInput = "O";
        receiveCommand();
    }
    else if (_autostart == 2)
    {
        serialInput = "L";
        receiveCommand();
    }

    m_selectedSerial->print("System initated Correctly");
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Lawicel::begin()
|———Node:qualified_identifier Text: Lawicel::begin
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: begin
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    String var;

    m_selectedNVM->begin();

    serialInput = m_selectedNVM->readString(INIT_SERIAL_BAUD);
    receiveCommand();

    m_selectedSerial->begin();

    _timestamp = m_selectedNVM->read(INIT_TIMESTAMP);

    _autostart = m_selectedNVM->read(INIT_AUTO_START);

    if (_autostart != 0)
    {
        autoPolling = true;

        serialInput = m_selectedNVM->readString(INIT_CAN_BAUD);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_MODE);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_ACN);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_AMN);
        receiveCommand();
    }

    if (_autostart == 1)
    {
        serialInput = "O";
        receiveCommand();
    }
    else if (_autostart == 2)
    {
        serialInput = "L";
        receiveCommand();
    }

    m_selectedSerial->print("System initated Correctly");
}
|———Node:{ Text: {
|———Node:declaration Text: String var;
|————Node:type_identifier Text: String
|————Node:identifier Text: var
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedNVM->begin();
|————Node:call_expression Text: m_selectedNVM->begin()
|—————Node:field_expression Text: m_selectedNVM->begin
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: begin
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: serialInput = m_selectedNVM->readString(INIT_SERIAL_BAUD);
|————Node:assignment_expression Text: serialInput = m_selectedNVM->readString(INIT_SERIAL_BAUD)
|—————Node:identifier Text: serialInput
|—————Node:= Text: =
|—————Node:call_expression Text: m_selectedNVM->readString(INIT_SERIAL_BAUD)
|——————Node:field_expression Text: m_selectedNVM->readString
|———————Node:identifier Text: m_selectedNVM
|———————Node:-> Text: ->
|———————Node:field_identifier Text: readString
|——————Node:argument_list Text: (INIT_SERIAL_BAUD)
|———————Node:( Text: (
|———————Node:identifier Text: INIT_SERIAL_BAUD
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: receiveCommand();
|————Node:call_expression Text: receiveCommand()
|—————Node:identifier Text: receiveCommand
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedSerial->begin();
|————Node:call_expression Text: m_selectedSerial->begin()
|—————Node:field_expression Text: m_selectedSerial->begin
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: begin
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: _timestamp = m_selectedNVM->read(INIT_TIMESTAMP);
|————Node:assignment_expression Text: _timestamp = m_selectedNVM->read(INIT_TIMESTAMP)
|—————Node:identifier Text: _timestamp
|—————Node:= Text: =
|—————Node:call_expression Text: m_selectedNVM->read(INIT_TIMESTAMP)
|——————Node:field_expression Text: m_selectedNVM->read
|———————Node:identifier Text: m_selectedNVM
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read
|——————Node:argument_list Text: (INIT_TIMESTAMP)
|———————Node:( Text: (
|———————Node:identifier Text: INIT_TIMESTAMP
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: _autostart = m_selectedNVM->read(INIT_AUTO_START);
|————Node:assignment_expression Text: _autostart = m_selectedNVM->read(INIT_AUTO_START)
|—————Node:identifier Text: _autostart
|—————Node:= Text: =
|—————Node:call_expression Text: m_selectedNVM->read(INIT_AUTO_START)
|——————Node:field_expression Text: m_selectedNVM->read
|———————Node:identifier Text: m_selectedNVM
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read
|——————Node:argument_list Text: (INIT_AUTO_START)
|———————Node:( Text: (
|———————Node:identifier Text: INIT_AUTO_START
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (_autostart != 0)
    {
        autoPolling = true;

        serialInput = m_selectedNVM->readString(INIT_CAN_BAUD);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_MODE);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_ACN);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_AMN);
        receiveCommand();
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_autostart != 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: _autostart != 0
|——————Node:identifier Text: _autostart
|——————Node:!= Text: !=
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        autoPolling = true;

        serialInput = m_selectedNVM->readString(INIT_CAN_BAUD);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_MODE);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_ACN);
        receiveCommand();

        serialInput = m_selectedNVM->readString(INIT_FILTER_AMN);
        receiveCommand();
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: autoPolling = true;
|——————Node:assignment_expression Text: autoPolling = true
|———————Node:identifier Text: autoPolling
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:expression_statement Text: serialInput = m_selectedNVM->readString(INIT_CAN_BAUD);
|——————Node:assignment_expression Text: serialInput = m_selectedNVM->readString(INIT_CAN_BAUD)
|———————Node:identifier Text: serialInput
|———————Node:= Text: =
|———————Node:call_expression Text: m_selectedNVM->readString(INIT_CAN_BAUD)
|————————Node:field_expression Text: m_selectedNVM->readString
|—————————Node:identifier Text: m_selectedNVM
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: readString
|————————Node:argument_list Text: (INIT_CAN_BAUD)
|—————————Node:( Text: (
|—————————Node:identifier Text: INIT_CAN_BAUD
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: receiveCommand();
|——————Node:call_expression Text: receiveCommand()
|———————Node:identifier Text: receiveCommand
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: serialInput = m_selectedNVM->readString(INIT_FILTER_MODE);
|——————Node:assignment_expression Text: serialInput = m_selectedNVM->readString(INIT_FILTER_MODE)
|———————Node:identifier Text: serialInput
|———————Node:= Text: =
|———————Node:call_expression Text: m_selectedNVM->readString(INIT_FILTER_MODE)
|————————Node:field_expression Text: m_selectedNVM->readString
|—————————Node:identifier Text: m_selectedNVM
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: readString
|————————Node:argument_list Text: (INIT_FILTER_MODE)
|—————————Node:( Text: (
|—————————Node:identifier Text: INIT_FILTER_MODE
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: receiveCommand();
|——————Node:call_expression Text: receiveCommand()
|———————Node:identifier Text: receiveCommand
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: serialInput = m_selectedNVM->readString(INIT_FILTER_ACN);
|——————Node:assignment_expression Text: serialInput = m_selectedNVM->readString(INIT_FILTER_ACN)
|———————Node:identifier Text: serialInput
|———————Node:= Text: =
|———————Node:call_expression Text: m_selectedNVM->readString(INIT_FILTER_ACN)
|————————Node:field_expression Text: m_selectedNVM->readString
|—————————Node:identifier Text: m_selectedNVM
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: readString
|————————Node:argument_list Text: (INIT_FILTER_ACN)
|—————————Node:( Text: (
|—————————Node:identifier Text: INIT_FILTER_ACN
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: receiveCommand();
|——————Node:call_expression Text: receiveCommand()
|———————Node:identifier Text: receiveCommand
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: serialInput = m_selectedNVM->readString(INIT_FILTER_AMN);
|——————Node:assignment_expression Text: serialInput = m_selectedNVM->readString(INIT_FILTER_AMN)
|———————Node:identifier Text: serialInput
|———————Node:= Text: =
|———————Node:call_expression Text: m_selectedNVM->readString(INIT_FILTER_AMN)
|————————Node:field_expression Text: m_selectedNVM->readString
|—————————Node:identifier Text: m_selectedNVM
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: readString
|————————Node:argument_list Text: (INIT_FILTER_AMN)
|—————————Node:( Text: (
|—————————Node:identifier Text: INIT_FILTER_AMN
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: receiveCommand();
|——————Node:call_expression Text: receiveCommand()
|———————Node:identifier Text: receiveCommand
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_autostart == 1)
    {
        serialInput = "O";
        receiveCommand();
    }
    else if (_autostart == 2)
    {
        serialInput = "L";
        receiveCommand();
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_autostart == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _autostart == 1
|——————Node:identifier Text: _autostart
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        serialInput = "O";
        receiveCommand();
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: serialInput = "O";
|——————Node:assignment_expression Text: serialInput = "O"
|———————Node:identifier Text: serialInput
|———————Node:= Text: =
|———————Node:string_literal Text: "O"
|————————Node:" Text: "
|————————Node:string_content Text: O
|————————Node:" Text: "
|——————Node:; Text: ;
|—————Node:expression_statement Text: receiveCommand();
|——————Node:call_expression Text: receiveCommand()
|———————Node:identifier Text: receiveCommand
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_autostart == 2)
    {
        serialInput = "L";
        receiveCommand();
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_autostart == 2)
    {
        serialInput = "L";
        receiveCommand();
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_autostart == 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _autostart == 2
|————————Node:identifier Text: _autostart
|————————Node:== Text: ==
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        serialInput = "L";
        receiveCommand();
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: serialInput = "L";
|————————Node:assignment_expression Text: serialInput = "L"
|—————————Node:identifier Text: serialInput
|—————————Node:= Text: =
|—————————Node:string_literal Text: "L"
|——————————Node:" Text: "
|——————————Node:string_content Text: L
|——————————Node:" Text: "
|————————Node:; Text: ;
|———————Node:expression_statement Text: receiveCommand();
|————————Node:call_expression Text: receiveCommand()
|—————————Node:identifier Text: receiveCommand
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:expression_statement Text: m_selectedSerial->print("System initated Correctly");
|————Node:call_expression Text: m_selectedSerial->print("System initated Correctly")
|—————Node:field_expression Text: m_selectedSerial->print
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: ("System initated Correctly")
|——————Node:( Text: (
|——————Node:string_literal Text: "System initated Correctly"
|———————Node:" Text: "
|———————Node:string_content Text: System initated Correctly
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: void Lawicel::end()
{
    m_selectedSerial->end();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Lawicel::end()
|———Node:qualified_identifier Text: Lawicel::end
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: end
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    m_selectedSerial->end();
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_selectedSerial->end();
|————Node:call_expression Text: m_selectedSerial->end()
|—————Node:field_expression Text: m_selectedSerial->end
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: end
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* PROTECTED METHODES *****************************************************************************/
|—Node:comment Text: /* PRIVATE METHODES *******************************************************************************/
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::charToByte(char MSB, char LSB)
{
    uint8_t result = -10;
    if (MSB >= 48 && MSB <= 57)
    {
        result = (MSB - 48) * 16;
    }
    else if (MSB >= 65 && MSB <= 70)
    {
        result = (MSB - 55) * 16;
    }
    else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }

    if (LSB >= 48 && LSB <= 57)
    {
        result = result + (LSB - 48);
    }
    else if (LSB >= 65 && LSB <= 70)
    {
        result = result + (LSB - 55);
    }
    else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }

    return result;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::charToByte(char MSB, char LSB)
|———Node:qualified_identifier Text: Lawicel::charToByte
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: charToByte
|———Node:parameter_list Text: (char MSB, char LSB)
|————Node:( Text: (
|————Node:parameter_declaration Text: char MSB
|—————Node:primitive_type Text: char
|—————Node:identifier Text: MSB
|————Node:, Text: ,
|————Node:parameter_declaration Text: char LSB
|—————Node:primitive_type Text: char
|—————Node:identifier Text: LSB
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t result = -10;
    if (MSB >= 48 && MSB <= 57)
    {
        result = (MSB - 48) * 16;
    }
    else if (MSB >= 65 && MSB <= 70)
    {
        result = (MSB - 55) * 16;
    }
    else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }

    if (LSB >= 48 && LSB <= 57)
    {
        result = result + (LSB - 48);
    }
    else if (LSB >= 65 && LSB <= 70)
    {
        result = result + (LSB - 55);
    }
    else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }

    return result;
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t result = -10;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: result = -10
|—————Node:identifier Text: result
|—————Node:= Text: =
|—————Node:number_literal Text: -10
|————Node:; Text: ;
|———Node:if_statement Text: if (MSB >= 48 && MSB <= 57)
    {
        result = (MSB - 48) * 16;
    }
    else if (MSB >= 65 && MSB <= 70)
    {
        result = (MSB - 55) * 16;
    }
    else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (MSB >= 48 && MSB <= 57)
|—————Node:( Text: (
|—————Node:binary_expression Text: MSB >= 48 && MSB <= 57
|——————Node:binary_expression Text: MSB >= 48
|———————Node:identifier Text: MSB
|———————Node:>= Text: >=
|———————Node:number_literal Text: 48
|——————Node:&& Text: &&
|——————Node:binary_expression Text: MSB <= 57
|———————Node:identifier Text: MSB
|———————Node:<= Text: <=
|———————Node:number_literal Text: 57
|—————Node:) Text: )
|————Node:compound_statement Text: {
        result = (MSB - 48) * 16;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: result = (MSB - 48) * 16;
|——————Node:assignment_expression Text: result = (MSB - 48) * 16
|———————Node:identifier Text: result
|———————Node:= Text: =
|———————Node:binary_expression Text: (MSB - 48) * 16
|————————Node:parenthesized_expression Text: (MSB - 48)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: MSB - 48
|——————————Node:identifier Text: MSB
|——————————Node:- Text: -
|——————————Node:number_literal Text: 48
|—————————Node:) Text: )
|————————Node:* Text: *
|————————Node:number_literal Text: 16
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (MSB >= 65 && MSB <= 70)
    {
        result = (MSB - 55) * 16;
    }
    else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (MSB >= 65 && MSB <= 70)
    {
        result = (MSB - 55) * 16;
    }
    else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (MSB >= 65 && MSB <= 70)
|———————Node:( Text: (
|———————Node:binary_expression Text: MSB >= 65 && MSB <= 70
|————————Node:binary_expression Text: MSB >= 65
|—————————Node:identifier Text: MSB
|—————————Node:>= Text: >=
|—————————Node:number_literal Text: 65
|————————Node:&& Text: &&
|————————Node:binary_expression Text: MSB <= 70
|—————————Node:identifier Text: MSB
|—————————Node:<= Text: <=
|—————————Node:number_literal Text: 70
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        result = (MSB - 55) * 16;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: result = (MSB - 55) * 16;
|————————Node:assignment_expression Text: result = (MSB - 55) * 16
|—————————Node:identifier Text: result
|—————————Node:= Text: =
|—————————Node:binary_expression Text: (MSB - 55) * 16
|——————————Node:parenthesized_expression Text: (MSB - 55)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: MSB - 55
|————————————Node:identifier Text: MSB
|————————————Node:- Text: -
|————————————Node:number_literal Text: 55
|———————————Node:) Text: )
|——————————Node:* Text: *
|——————————Node:number_literal Text: 16
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if (MSB >= 97 && MSB <= 102)
    {
        result = (MSB - 87) * 16;
    }
|————————Node:if Text: if
|————————Node:condition_clause Text: (MSB >= 97 && MSB <= 102)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: MSB >= 97 && MSB <= 102
|——————————Node:binary_expression Text: MSB >= 97
|———————————Node:identifier Text: MSB
|———————————Node:>= Text: >=
|———————————Node:number_literal Text: 97
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: MSB <= 102
|———————————Node:identifier Text: MSB
|———————————Node:<= Text: <=
|———————————Node:number_literal Text: 102
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        result = (MSB - 87) * 16;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: result = (MSB - 87) * 16;
|——————————Node:assignment_expression Text: result = (MSB - 87) * 16
|———————————Node:identifier Text: result
|———————————Node:= Text: =
|———————————Node:binary_expression Text: (MSB - 87) * 16
|————————————Node:parenthesized_expression Text: (MSB - 87)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: MSB - 87
|——————————————Node:identifier Text: MSB
|——————————————Node:- Text: -
|——————————————Node:number_literal Text: 87
|—————————————Node:) Text: )
|————————————Node:* Text: *
|————————————Node:number_literal Text: 16
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:if_statement Text: if (LSB >= 48 && LSB <= 57)
    {
        result = result + (LSB - 48);
    }
    else if (LSB >= 65 && LSB <= 70)
    {
        result = result + (LSB - 55);
    }
    else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (LSB >= 48 && LSB <= 57)
|—————Node:( Text: (
|—————Node:binary_expression Text: LSB >= 48 && LSB <= 57
|——————Node:binary_expression Text: LSB >= 48
|———————Node:identifier Text: LSB
|———————Node:>= Text: >=
|———————Node:number_literal Text: 48
|——————Node:&& Text: &&
|——————Node:binary_expression Text: LSB <= 57
|———————Node:identifier Text: LSB
|———————Node:<= Text: <=
|———————Node:number_literal Text: 57
|—————Node:) Text: )
|————Node:compound_statement Text: {
        result = result + (LSB - 48);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: result = result + (LSB - 48);
|——————Node:assignment_expression Text: result = result + (LSB - 48)
|———————Node:identifier Text: result
|———————Node:= Text: =
|———————Node:binary_expression Text: result + (LSB - 48)
|————————Node:identifier Text: result
|————————Node:+ Text: +
|————————Node:parenthesized_expression Text: (LSB - 48)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: LSB - 48
|——————————Node:identifier Text: LSB
|——————————Node:- Text: -
|——————————Node:number_literal Text: 48
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (LSB >= 65 && LSB <= 70)
    {
        result = result + (LSB - 55);
    }
    else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (LSB >= 65 && LSB <= 70)
    {
        result = result + (LSB - 55);
    }
    else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (LSB >= 65 && LSB <= 70)
|———————Node:( Text: (
|———————Node:binary_expression Text: LSB >= 65 && LSB <= 70
|————————Node:binary_expression Text: LSB >= 65
|—————————Node:identifier Text: LSB
|—————————Node:>= Text: >=
|—————————Node:number_literal Text: 65
|————————Node:&& Text: &&
|————————Node:binary_expression Text: LSB <= 70
|—————————Node:identifier Text: LSB
|—————————Node:<= Text: <=
|—————————Node:number_literal Text: 70
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        result = result + (LSB - 55);
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: result = result + (LSB - 55);
|————————Node:assignment_expression Text: result = result + (LSB - 55)
|—————————Node:identifier Text: result
|—————————Node:= Text: =
|—————————Node:binary_expression Text: result + (LSB - 55)
|——————————Node:identifier Text: result
|——————————Node:+ Text: +
|——————————Node:parenthesized_expression Text: (LSB - 55)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: LSB - 55
|————————————Node:identifier Text: LSB
|————————————Node:- Text: -
|————————————Node:number_literal Text: 55
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if (LSB >= 97 && LSB <= 102)
    {
        result = result + (LSB - 87);
    }
|————————Node:if Text: if
|————————Node:condition_clause Text: (LSB >= 97 && LSB <= 102)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: LSB >= 97 && LSB <= 102
|——————————Node:binary_expression Text: LSB >= 97
|———————————Node:identifier Text: LSB
|———————————Node:>= Text: >=
|———————————Node:number_literal Text: 97
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: LSB <= 102
|———————————Node:identifier Text: LSB
|———————————Node:<= Text: <=
|———————————Node:number_literal Text: 102
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        result = result + (LSB - 87);
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: result = result + (LSB - 87);
|——————————Node:assignment_expression Text: result = result + (LSB - 87)
|———————————Node:identifier Text: result
|———————————Node:= Text: =
|———————————Node:binary_expression Text: result + (LSB - 87)
|————————————Node:identifier Text: result
|————————————Node:+ Text: +
|————————————Node:parenthesized_expression Text: (LSB - 87)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: LSB - 87
|——————————————Node:identifier Text: LSB
|——————————————Node:- Text: -
|——————————————Node:number_literal Text: 87
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:return_statement Text: return result;
|————Node:return Text: return
|————Node:identifier Text: result
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::charToInt(char num_symbol)
{
    uint8_t result = 0;
    if (num_symbol < 48 || num_symbol > 57)
    {
        return -10;
    }

    result = num_symbol;
    result -= 48;

    return result;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::charToInt(char num_symbol)
|———Node:qualified_identifier Text: Lawicel::charToInt
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: charToInt
|———Node:parameter_list Text: (char num_symbol)
|————Node:( Text: (
|————Node:parameter_declaration Text: char num_symbol
|—————Node:primitive_type Text: char
|—————Node:identifier Text: num_symbol
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint8_t result = 0;
    if (num_symbol < 48 || num_symbol > 57)
    {
        return -10;
    }

    result = num_symbol;
    result -= 48;

    return result;
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t result = 0;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: result = 0
|—————Node:identifier Text: result
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (num_symbol < 48 || num_symbol > 57)
    {
        return -10;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (num_symbol < 48 || num_symbol > 57)
|—————Node:( Text: (
|—————Node:binary_expression Text: num_symbol < 48 || num_symbol > 57
|——————Node:binary_expression Text: num_symbol < 48
|———————Node:identifier Text: num_symbol
|———————Node:< Text: <
|———————Node:number_literal Text: 48
|——————Node:|| Text: ||
|——————Node:binary_expression Text: num_symbol > 57
|———————Node:identifier Text: num_symbol
|———————Node:> Text: >
|———————Node:number_literal Text: 57
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return -10;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return -10;
|——————Node:return Text: return
|——————Node:number_literal Text: -10
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: result = num_symbol;
|————Node:assignment_expression Text: result = num_symbol
|—————Node:identifier Text: result
|—————Node:= Text: =
|—————Node:identifier Text: num_symbol
|————Node:; Text: ;
|———Node:expression_statement Text: result -= 48;
|————Node:assignment_expression Text: result -= 48
|—————Node:identifier Text: result
|—————Node:-= Text: -=
|—————Node:number_literal Text: 48
|————Node:; Text: ;
|———Node:return_statement Text: return result;
|————Node:return Text: return
|————Node:identifier Text: result
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint32_t Lawicel::IdDecode(bool extended)
{
    uint32_t result = 0;
    char _IdBuffer[8];

    uint8_t _IdLength = 3;

    if (extended)
    {
        _IdLength = 8;
        _IdBuffer[0] = serialInput.charAt(8);
        _IdBuffer[1] = serialInput.charAt(7);
        _IdBuffer[2] = serialInput.charAt(6);
        _IdBuffer[3] = serialInput.charAt(5);
        _IdBuffer[4] = serialInput.charAt(4);
        _IdBuffer[5] = serialInput.charAt(3);
        _IdBuffer[6] = serialInput.charAt(2);
        _IdBuffer[7] = serialInput.charAt(1);
    }
    else
    {
        _IdBuffer[0] = serialInput.charAt(3);
        _IdBuffer[1] = serialInput.charAt(2);
        _IdBuffer[2] = serialInput.charAt(1);
    }

    for (int counter = 0; counter < _IdLength; counter++)
    {
        if (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
        {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
    }

    return result;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: Lawicel::IdDecode(bool extended)
|———Node:qualified_identifier Text: Lawicel::IdDecode
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: IdDecode
|———Node:parameter_list Text: (bool extended)
|————Node:( Text: (
|————Node:parameter_declaration Text: bool extended
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: extended
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t result = 0;
    char _IdBuffer[8];

    uint8_t _IdLength = 3;

    if (extended)
    {
        _IdLength = 8;
        _IdBuffer[0] = serialInput.charAt(8);
        _IdBuffer[1] = serialInput.charAt(7);
        _IdBuffer[2] = serialInput.charAt(6);
        _IdBuffer[3] = serialInput.charAt(5);
        _IdBuffer[4] = serialInput.charAt(4);
        _IdBuffer[5] = serialInput.charAt(3);
        _IdBuffer[6] = serialInput.charAt(2);
        _IdBuffer[7] = serialInput.charAt(1);
    }
    else
    {
        _IdBuffer[0] = serialInput.charAt(3);
        _IdBuffer[1] = serialInput.charAt(2);
        _IdBuffer[2] = serialInput.charAt(1);
    }

    for (int counter = 0; counter < _IdLength; counter++)
    {
        if (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
        {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
    }

    return result;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t result = 0;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: result = 0
|—————Node:identifier Text: result
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: char _IdBuffer[8];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: _IdBuffer[8]
|—————Node:identifier Text: _IdBuffer
|—————Node:[ Text: [
|—————Node:number_literal Text: 8
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: uint8_t _IdLength = 3;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: _IdLength = 3
|—————Node:identifier Text: _IdLength
|—————Node:= Text: =
|—————Node:number_literal Text: 3
|————Node:; Text: ;
|———Node:if_statement Text: if (extended)
    {
        _IdLength = 8;
        _IdBuffer[0] = serialInput.charAt(8);
        _IdBuffer[1] = serialInput.charAt(7);
        _IdBuffer[2] = serialInput.charAt(6);
        _IdBuffer[3] = serialInput.charAt(5);
        _IdBuffer[4] = serialInput.charAt(4);
        _IdBuffer[5] = serialInput.charAt(3);
        _IdBuffer[6] = serialInput.charAt(2);
        _IdBuffer[7] = serialInput.charAt(1);
    }
    else
    {
        _IdBuffer[0] = serialInput.charAt(3);
        _IdBuffer[1] = serialInput.charAt(2);
        _IdBuffer[2] = serialInput.charAt(1);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (extended)
|—————Node:( Text: (
|—————Node:identifier Text: extended
|—————Node:) Text: )
|————Node:compound_statement Text: {
        _IdLength = 8;
        _IdBuffer[0] = serialInput.charAt(8);
        _IdBuffer[1] = serialInput.charAt(7);
        _IdBuffer[2] = serialInput.charAt(6);
        _IdBuffer[3] = serialInput.charAt(5);
        _IdBuffer[4] = serialInput.charAt(4);
        _IdBuffer[5] = serialInput.charAt(3);
        _IdBuffer[6] = serialInput.charAt(2);
        _IdBuffer[7] = serialInput.charAt(1);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: _IdLength = 8;
|——————Node:assignment_expression Text: _IdLength = 8
|———————Node:identifier Text: _IdLength
|———————Node:= Text: =
|———————Node:number_literal Text: 8
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[0] = serialInput.charAt(8);
|——————Node:assignment_expression Text: _IdBuffer[0] = serialInput.charAt(8)
|———————Node:subscript_expression Text: _IdBuffer[0]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [0]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(8)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (8)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 8
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[1] = serialInput.charAt(7);
|——————Node:assignment_expression Text: _IdBuffer[1] = serialInput.charAt(7)
|———————Node:subscript_expression Text: _IdBuffer[1]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [1]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(7)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (7)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 7
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[2] = serialInput.charAt(6);
|——————Node:assignment_expression Text: _IdBuffer[2] = serialInput.charAt(6)
|———————Node:subscript_expression Text: _IdBuffer[2]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [2]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 2
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(6)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (6)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 6
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[3] = serialInput.charAt(5);
|——————Node:assignment_expression Text: _IdBuffer[3] = serialInput.charAt(5)
|———————Node:subscript_expression Text: _IdBuffer[3]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [3]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 3
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(5)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (5)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 5
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[4] = serialInput.charAt(4);
|——————Node:assignment_expression Text: _IdBuffer[4] = serialInput.charAt(4)
|———————Node:subscript_expression Text: _IdBuffer[4]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [4]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 4
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[5] = serialInput.charAt(3);
|——————Node:assignment_expression Text: _IdBuffer[5] = serialInput.charAt(3)
|———————Node:subscript_expression Text: _IdBuffer[5]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [5]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 5
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(3)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (3)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 3
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[6] = serialInput.charAt(2);
|——————Node:assignment_expression Text: _IdBuffer[6] = serialInput.charAt(2)
|———————Node:subscript_expression Text: _IdBuffer[6]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [6]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 6
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(2)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (2)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _IdBuffer[7] = serialInput.charAt(1);
|——————Node:assignment_expression Text: _IdBuffer[7] = serialInput.charAt(1)
|———————Node:subscript_expression Text: _IdBuffer[7]
|————————Node:identifier Text: _IdBuffer
|————————Node:subscript_argument_list Text: [7]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 7
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        _IdBuffer[0] = serialInput.charAt(3);
        _IdBuffer[1] = serialInput.charAt(2);
        _IdBuffer[2] = serialInput.charAt(1);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        _IdBuffer[0] = serialInput.charAt(3);
        _IdBuffer[1] = serialInput.charAt(2);
        _IdBuffer[2] = serialInput.charAt(1);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: _IdBuffer[0] = serialInput.charAt(3);
|———————Node:assignment_expression Text: _IdBuffer[0] = serialInput.charAt(3)
|————————Node:subscript_expression Text: _IdBuffer[0]
|—————————Node:identifier Text: _IdBuffer
|—————————Node:subscript_argument_list Text: [0]
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 0
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: serialInput.charAt(3)
|—————————Node:field_expression Text: serialInput.charAt
|——————————Node:identifier Text: serialInput
|——————————Node:. Text: .
|——————————Node:field_identifier Text: charAt
|—————————Node:argument_list Text: (3)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 3
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: _IdBuffer[1] = serialInput.charAt(2);
|———————Node:assignment_expression Text: _IdBuffer[1] = serialInput.charAt(2)
|————————Node:subscript_expression Text: _IdBuffer[1]
|—————————Node:identifier Text: _IdBuffer
|—————————Node:subscript_argument_list Text: [1]
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 1
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: serialInput.charAt(2)
|—————————Node:field_expression Text: serialInput.charAt
|——————————Node:identifier Text: serialInput
|——————————Node:. Text: .
|——————————Node:field_identifier Text: charAt
|—————————Node:argument_list Text: (2)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 2
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: _IdBuffer[2] = serialInput.charAt(1);
|———————Node:assignment_expression Text: _IdBuffer[2] = serialInput.charAt(1)
|————————Node:subscript_expression Text: _IdBuffer[2]
|—————————Node:identifier Text: _IdBuffer
|—————————Node:subscript_argument_list Text: [2]
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 2
|——————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: serialInput.charAt(1)
|—————————Node:field_expression Text: serialInput.charAt
|——————————Node:identifier Text: serialInput
|——————————Node:. Text: .
|——————————Node:field_identifier Text: charAt
|—————————Node:argument_list Text: (1)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 1
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:for_statement Text: for (int counter = 0; counter < _IdLength; counter++)
    {
        if (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
        {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int counter = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: counter = 0
|——————Node:identifier Text: counter
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: counter < _IdLength
|—————Node:identifier Text: counter
|—————Node:< Text: <
|—————Node:identifier Text: _IdLength
|————Node:; Text: ;
|————Node:update_expression Text: counter++
|—————Node:identifier Text: counter
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
        {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
        {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57)
|———————Node:( Text: (
|———————Node:binary_expression Text: _IdBuffer[counter] >= 48 && _IdBuffer[counter] <= 57
|————————Node:binary_expression Text: _IdBuffer[counter] >= 48
|—————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————Node:identifier Text: _IdBuffer
|——————————Node:subscript_argument_list Text: [counter]
|———————————Node:[ Text: [
|———————————Node:identifier Text: counter
|———————————Node:] Text: ]
|—————————Node:>= Text: >=
|—————————Node:number_literal Text: 48
|————————Node:&& Text: &&
|————————Node:binary_expression Text: _IdBuffer[counter] <= 57
|—————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————Node:identifier Text: _IdBuffer
|——————————Node:subscript_argument_list Text: [counter]
|———————————Node:[ Text: [
|———————————Node:identifier Text: counter
|———————————Node:] Text: ]
|—————————Node:<= Text: <=
|—————————Node:number_literal Text: 57
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter);
|————————Node:assignment_expression Text: result = result + (_IdBuffer[counter] - 48) * pow(16.0, counter)
|—————————Node:identifier Text: result
|—————————Node:= Text: =
|—————————Node:binary_expression Text: result + (_IdBuffer[counter] - 48) * pow(16.0, counter)
|——————————Node:identifier Text: result
|——————————Node:+ Text: +
|——————————Node:binary_expression Text: (_IdBuffer[counter] - 48) * pow(16.0, counter)
|———————————Node:parenthesized_expression Text: (_IdBuffer[counter] - 48)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: _IdBuffer[counter] - 48
|—————————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————————Node:identifier Text: _IdBuffer
|——————————————Node:subscript_argument_list Text: [counter]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: counter
|———————————————Node:] Text: ]
|—————————————Node:- Text: -
|—————————————Node:number_literal Text: 48
|————————————Node:) Text: )
|———————————Node:* Text: *
|———————————Node:call_expression Text: pow(16.0, counter)
|————————————Node:identifier Text: pow
|————————————Node:argument_list Text: (16.0, counter)
|—————————————Node:( Text: (
|—————————————Node:number_literal Text: 16.0
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: counter
|—————————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|———————Node:else Text: else
|———————Node:if_statement Text: if (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
        {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
        else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|————————Node:if Text: if
|————————Node:condition_clause Text: (_IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: _IdBuffer[counter] >= 65 && _IdBuffer[counter] <= 70
|——————————Node:binary_expression Text: _IdBuffer[counter] >= 65
|———————————Node:subscript_expression Text: _IdBuffer[counter]
|————————————Node:identifier Text: _IdBuffer
|————————————Node:subscript_argument_list Text: [counter]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: counter
|—————————————Node:] Text: ]
|———————————Node:>= Text: >=
|———————————Node:number_literal Text: 65
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: _IdBuffer[counter] <= 70
|———————————Node:subscript_expression Text: _IdBuffer[counter]
|————————————Node:identifier Text: _IdBuffer
|————————————Node:subscript_argument_list Text: [counter]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: counter
|—————————————Node:] Text: ]
|———————————Node:<= Text: <=
|———————————Node:number_literal Text: 70
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter);
|——————————Node:assignment_expression Text: result = result + (_IdBuffer[counter] - 55) * pow(16.0, counter)
|———————————Node:identifier Text: result
|———————————Node:= Text: =
|———————————Node:binary_expression Text: result + (_IdBuffer[counter] - 55) * pow(16.0, counter)
|————————————Node:identifier Text: result
|————————————Node:+ Text: +
|————————————Node:binary_expression Text: (_IdBuffer[counter] - 55) * pow(16.0, counter)
|—————————————Node:parenthesized_expression Text: (_IdBuffer[counter] - 55)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: _IdBuffer[counter] - 55
|———————————————Node:subscript_expression Text: _IdBuffer[counter]
|————————————————Node:identifier Text: _IdBuffer
|————————————————Node:subscript_argument_list Text: [counter]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: counter
|—————————————————Node:] Text: ]
|———————————————Node:- Text: -
|———————————————Node:number_literal Text: 55
|——————————————Node:) Text: )
|—————————————Node:* Text: *
|—————————————Node:call_expression Text: pow(16.0, counter)
|——————————————Node:identifier Text: pow
|——————————————Node:argument_list Text: (16.0, counter)
|———————————————Node:( Text: (
|———————————————Node:number_literal Text: 16.0
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: counter
|———————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
        {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (_IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: _IdBuffer[counter] >= 97 && _IdBuffer[counter] <= 102
|————————————Node:binary_expression Text: _IdBuffer[counter] >= 97
|—————————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————————Node:identifier Text: _IdBuffer
|——————————————Node:subscript_argument_list Text: [counter]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: counter
|———————————————Node:] Text: ]
|—————————————Node:>= Text: >=
|—————————————Node:number_literal Text: 97
|————————————Node:&& Text: &&
|————————————Node:binary_expression Text: _IdBuffer[counter] <= 102
|—————————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————————Node:identifier Text: _IdBuffer
|——————————————Node:subscript_argument_list Text: [counter]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: counter
|———————————————Node:] Text: ]
|—————————————Node:<= Text: <=
|—————————————Node:number_literal Text: 102
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
            result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
        }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter);
|————————————Node:assignment_expression Text: result = result + (_IdBuffer[counter] - 87) * pow(16.0, counter)
|—————————————Node:identifier Text: result
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: result + (_IdBuffer[counter] - 87) * pow(16.0, counter)
|——————————————Node:identifier Text: result
|——————————————Node:+ Text: +
|——————————————Node:binary_expression Text: (_IdBuffer[counter] - 87) * pow(16.0, counter)
|———————————————Node:parenthesized_expression Text: (_IdBuffer[counter] - 87)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: _IdBuffer[counter] - 87
|—————————————————Node:subscript_expression Text: _IdBuffer[counter]
|——————————————————Node:identifier Text: _IdBuffer
|——————————————————Node:subscript_argument_list Text: [counter]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: counter
|———————————————————Node:] Text: ]
|—————————————————Node:- Text: -
|—————————————————Node:number_literal Text: 87
|————————————————Node:) Text: )
|———————————————Node:* Text: *
|———————————————Node:call_expression Text: pow(16.0, counter)
|————————————————Node:identifier Text: pow
|————————————————Node:argument_list Text: (16.0, counter)
|—————————————————Node:( Text: (
|—————————————————Node:number_literal Text: 16.0
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: counter
|—————————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return result;
|————Node:return Text: return
|————Node:identifier Text: result
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::receiveCommand()
{
    switch (serialInput.charAt(0))
    {
    case SET_BAUDRATE:
    {
        return CMD_Set_Baudrate();
    }

    case SET_BTR:
    {
        return CMD_Set_BTR();
    }

    case OPEN_NORMAL:
    {
        return CMD_Open_Normal();
    }

    case OPEN_LISTEN_ONLY:
    {
        return CMD_Open_Listen_Only();
    }

    case CLOSE:
    {
        return CMD_Close();
    }

    case TX_STD:
    {
        return CMD_Tx_Std();
    }

    case TX_EXT:
    {
        return CMD_Tx_Ext();
    }

    case TX_STD_RTR:
    {
        return CMD_Tx_Std_RTR();
    }

    case TX_EXT_RTR:
    {
        return CMD_Tx_Ext_RTR();
    }

    case POLL_SINGLE:
    {
        return CMD_Poll_Single();
    }

    case POLL_ALL:
    {
        return CMD_Poll_All();
    }

    case POLL_AUTO:
    {
        return CMD_Poll_Auto();
    }

    case STATUS_FLAGS:
    {
        return CMD_Flags();
    }

    case FILTER_MODE:
    {
        return CMD_Set_Filter_Mode();
    }

    case ACN_REGISTER:
    {
        return CMD_Set_ACn();
    }

    case AMN_REGISTER:
    {
        return CMD_Set_AMn();
    }

    case SERIAL_BAUDRATE:
    {
        return CMD_Set_Serial_Baudrate();
    }

    case VERSION:
    {
        return CMD_Version();
    }

    case SERIAL_NUMBER:
    {
        return CMD_Serial_Number();
    }

    case TOGGLE_TIMESTAMP:
    {
        return CMD_Timestamp();
    }

    case AUTO_START:
    {
        return CMD_Auto_Start();
    }

    default:
    {
        return 1;
    }
    }
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::receiveCommand()
|———Node:qualified_identifier Text: Lawicel::receiveCommand
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: receiveCommand
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    switch (serialInput.charAt(0))
    {
    case SET_BAUDRATE:
    {
        return CMD_Set_Baudrate();
    }

    case SET_BTR:
    {
        return CMD_Set_BTR();
    }

    case OPEN_NORMAL:
    {
        return CMD_Open_Normal();
    }

    case OPEN_LISTEN_ONLY:
    {
        return CMD_Open_Listen_Only();
    }

    case CLOSE:
    {
        return CMD_Close();
    }

    case TX_STD:
    {
        return CMD_Tx_Std();
    }

    case TX_EXT:
    {
        return CMD_Tx_Ext();
    }

    case TX_STD_RTR:
    {
        return CMD_Tx_Std_RTR();
    }

    case TX_EXT_RTR:
    {
        return CMD_Tx_Ext_RTR();
    }

    case POLL_SINGLE:
    {
        return CMD_Poll_Single();
    }

    case POLL_ALL:
    {
        return CMD_Poll_All();
    }

    case POLL_AUTO:
    {
        return CMD_Poll_Auto();
    }

    case STATUS_FLAGS:
    {
        return CMD_Flags();
    }

    case FILTER_MODE:
    {
        return CMD_Set_Filter_Mode();
    }

    case ACN_REGISTER:
    {
        return CMD_Set_ACn();
    }

    case AMN_REGISTER:
    {
        return CMD_Set_AMn();
    }

    case SERIAL_BAUDRATE:
    {
        return CMD_Set_Serial_Baudrate();
    }

    case VERSION:
    {
        return CMD_Version();
    }

    case SERIAL_NUMBER:
    {
        return CMD_Serial_Number();
    }

    case TOGGLE_TIMESTAMP:
    {
        return CMD_Timestamp();
    }

    case AUTO_START:
    {
        return CMD_Auto_Start();
    }

    default:
    {
        return 1;
    }
    }
}
|———Node:{ Text: {
|———Node:switch_statement Text: switch (serialInput.charAt(0))
    {
    case SET_BAUDRATE:
    {
        return CMD_Set_Baudrate();
    }

    case SET_BTR:
    {
        return CMD_Set_BTR();
    }

    case OPEN_NORMAL:
    {
        return CMD_Open_Normal();
    }

    case OPEN_LISTEN_ONLY:
    {
        return CMD_Open_Listen_Only();
    }

    case CLOSE:
    {
        return CMD_Close();
    }

    case TX_STD:
    {
        return CMD_Tx_Std();
    }

    case TX_EXT:
    {
        return CMD_Tx_Ext();
    }

    case TX_STD_RTR:
    {
        return CMD_Tx_Std_RTR();
    }

    case TX_EXT_RTR:
    {
        return CMD_Tx_Ext_RTR();
    }

    case POLL_SINGLE:
    {
        return CMD_Poll_Single();
    }

    case POLL_ALL:
    {
        return CMD_Poll_All();
    }

    case POLL_AUTO:
    {
        return CMD_Poll_Auto();
    }

    case STATUS_FLAGS:
    {
        return CMD_Flags();
    }

    case FILTER_MODE:
    {
        return CMD_Set_Filter_Mode();
    }

    case ACN_REGISTER:
    {
        return CMD_Set_ACn();
    }

    case AMN_REGISTER:
    {
        return CMD_Set_AMn();
    }

    case SERIAL_BAUDRATE:
    {
        return CMD_Set_Serial_Baudrate();
    }

    case VERSION:
    {
        return CMD_Version();
    }

    case SERIAL_NUMBER:
    {
        return CMD_Serial_Number();
    }

    case TOGGLE_TIMESTAMP:
    {
        return CMD_Timestamp();
    }

    case AUTO_START:
    {
        return CMD_Auto_Start();
    }

    default:
    {
        return 1;
    }
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (serialInput.charAt(0))
|—————Node:( Text: (
|—————Node:call_expression Text: serialInput.charAt(0)
|——————Node:field_expression Text: serialInput.charAt
|———————Node:identifier Text: serialInput
|———————Node:. Text: .
|———————Node:field_identifier Text: charAt
|——————Node:argument_list Text: (0)
|———————Node:( Text: (
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case SET_BAUDRATE:
    {
        return CMD_Set_Baudrate();
    }

    case SET_BTR:
    {
        return CMD_Set_BTR();
    }

    case OPEN_NORMAL:
    {
        return CMD_Open_Normal();
    }

    case OPEN_LISTEN_ONLY:
    {
        return CMD_Open_Listen_Only();
    }

    case CLOSE:
    {
        return CMD_Close();
    }

    case TX_STD:
    {
        return CMD_Tx_Std();
    }

    case TX_EXT:
    {
        return CMD_Tx_Ext();
    }

    case TX_STD_RTR:
    {
        return CMD_Tx_Std_RTR();
    }

    case TX_EXT_RTR:
    {
        return CMD_Tx_Ext_RTR();
    }

    case POLL_SINGLE:
    {
        return CMD_Poll_Single();
    }

    case POLL_ALL:
    {
        return CMD_Poll_All();
    }

    case POLL_AUTO:
    {
        return CMD_Poll_Auto();
    }

    case STATUS_FLAGS:
    {
        return CMD_Flags();
    }

    case FILTER_MODE:
    {
        return CMD_Set_Filter_Mode();
    }

    case ACN_REGISTER:
    {
        return CMD_Set_ACn();
    }

    case AMN_REGISTER:
    {
        return CMD_Set_AMn();
    }

    case SERIAL_BAUDRATE:
    {
        return CMD_Set_Serial_Baudrate();
    }

    case VERSION:
    {
        return CMD_Version();
    }

    case SERIAL_NUMBER:
    {
        return CMD_Serial_Number();
    }

    case TOGGLE_TIMESTAMP:
    {
        return CMD_Timestamp();
    }

    case AUTO_START:
    {
        return CMD_Auto_Start();
    }

    default:
    {
        return 1;
    }
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case SET_BAUDRATE:
    {
        return CMD_Set_Baudrate();
    }
|——————Node:case Text: case
|——————Node:identifier Text: SET_BAUDRATE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_Baudrate();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_Baudrate();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_Baudrate()
|—————————Node:identifier Text: CMD_Set_Baudrate
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case SET_BTR:
    {
        return CMD_Set_BTR();
    }
|——————Node:case Text: case
|——————Node:identifier Text: SET_BTR
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_BTR();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_BTR();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_BTR()
|—————————Node:identifier Text: CMD_Set_BTR
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case OPEN_NORMAL:
    {
        return CMD_Open_Normal();
    }
|——————Node:case Text: case
|——————Node:identifier Text: OPEN_NORMAL
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Open_Normal();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Open_Normal();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Open_Normal()
|—————————Node:identifier Text: CMD_Open_Normal
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case OPEN_LISTEN_ONLY:
    {
        return CMD_Open_Listen_Only();
    }
|——————Node:case Text: case
|——————Node:identifier Text: OPEN_LISTEN_ONLY
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Open_Listen_Only();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Open_Listen_Only();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Open_Listen_Only()
|—————————Node:identifier Text: CMD_Open_Listen_Only
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CLOSE:
    {
        return CMD_Close();
    }
|——————Node:case Text: case
|——————Node:identifier Text: CLOSE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Close();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Close();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Close()
|—————————Node:identifier Text: CMD_Close
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case TX_STD:
    {
        return CMD_Tx_Std();
    }
|——————Node:case Text: case
|——————Node:identifier Text: TX_STD
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Tx_Std();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Tx_Std();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Tx_Std()
|—————————Node:identifier Text: CMD_Tx_Std
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case TX_EXT:
    {
        return CMD_Tx_Ext();
    }
|——————Node:case Text: case
|——————Node:identifier Text: TX_EXT
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Tx_Ext();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Tx_Ext();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Tx_Ext()
|—————————Node:identifier Text: CMD_Tx_Ext
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case TX_STD_RTR:
    {
        return CMD_Tx_Std_RTR();
    }
|——————Node:case Text: case
|——————Node:identifier Text: TX_STD_RTR
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Tx_Std_RTR();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Tx_Std_RTR();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Tx_Std_RTR()
|—————————Node:identifier Text: CMD_Tx_Std_RTR
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case TX_EXT_RTR:
    {
        return CMD_Tx_Ext_RTR();
    }
|——————Node:case Text: case
|——————Node:identifier Text: TX_EXT_RTR
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Tx_Ext_RTR();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Tx_Ext_RTR();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Tx_Ext_RTR()
|—————————Node:identifier Text: CMD_Tx_Ext_RTR
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case POLL_SINGLE:
    {
        return CMD_Poll_Single();
    }
|——————Node:case Text: case
|——————Node:identifier Text: POLL_SINGLE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Poll_Single();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Poll_Single();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Poll_Single()
|—————————Node:identifier Text: CMD_Poll_Single
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case POLL_ALL:
    {
        return CMD_Poll_All();
    }
|——————Node:case Text: case
|——————Node:identifier Text: POLL_ALL
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Poll_All();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Poll_All();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Poll_All()
|—————————Node:identifier Text: CMD_Poll_All
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case POLL_AUTO:
    {
        return CMD_Poll_Auto();
    }
|——————Node:case Text: case
|——————Node:identifier Text: POLL_AUTO
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Poll_Auto();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Poll_Auto();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Poll_Auto()
|—————————Node:identifier Text: CMD_Poll_Auto
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case STATUS_FLAGS:
    {
        return CMD_Flags();
    }
|——————Node:case Text: case
|——————Node:identifier Text: STATUS_FLAGS
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Flags();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Flags();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Flags()
|—————————Node:identifier Text: CMD_Flags
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case FILTER_MODE:
    {
        return CMD_Set_Filter_Mode();
    }
|——————Node:case Text: case
|——————Node:identifier Text: FILTER_MODE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_Filter_Mode();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_Filter_Mode();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_Filter_Mode()
|—————————Node:identifier Text: CMD_Set_Filter_Mode
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case ACN_REGISTER:
    {
        return CMD_Set_ACn();
    }
|——————Node:case Text: case
|——————Node:identifier Text: ACN_REGISTER
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_ACn();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_ACn();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_ACn()
|—————————Node:identifier Text: CMD_Set_ACn
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case AMN_REGISTER:
    {
        return CMD_Set_AMn();
    }
|——————Node:case Text: case
|——————Node:identifier Text: AMN_REGISTER
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_AMn();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_AMn();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_AMn()
|—————————Node:identifier Text: CMD_Set_AMn
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case SERIAL_BAUDRATE:
    {
        return CMD_Set_Serial_Baudrate();
    }
|——————Node:case Text: case
|——————Node:identifier Text: SERIAL_BAUDRATE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Set_Serial_Baudrate();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Set_Serial_Baudrate();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Set_Serial_Baudrate()
|—————————Node:identifier Text: CMD_Set_Serial_Baudrate
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case VERSION:
    {
        return CMD_Version();
    }
|——————Node:case Text: case
|——————Node:identifier Text: VERSION
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Version();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Version();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Version()
|—————————Node:identifier Text: CMD_Version
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case SERIAL_NUMBER:
    {
        return CMD_Serial_Number();
    }
|——————Node:case Text: case
|——————Node:identifier Text: SERIAL_NUMBER
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Serial_Number();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Serial_Number();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Serial_Number()
|—————————Node:identifier Text: CMD_Serial_Number
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case TOGGLE_TIMESTAMP:
    {
        return CMD_Timestamp();
    }
|——————Node:case Text: case
|——————Node:identifier Text: TOGGLE_TIMESTAMP
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Timestamp();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Timestamp();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Timestamp()
|—————————Node:identifier Text: CMD_Timestamp
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case AUTO_START:
    {
        return CMD_Auto_Start();
    }
|——————Node:case Text: case
|——————Node:identifier Text: AUTO_START
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return CMD_Auto_Start();
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return CMD_Auto_Start();
|————————Node:return Text: return
|————————Node:call_expression Text: CMD_Auto_Start()
|—————————Node:identifier Text: CMD_Auto_Start
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: default:
    {
        return 1;
    }
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_Baudrate()
{
    long _baudrate = 0;

    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 10E3;
        break;
    }
    case '1':
    {
        _baudrate = 20E3;
        break;
    }
    case '2':
    {
        _baudrate = 50E3;
        break;
    }
    case '3':
    {
        _baudrate = 100E3;
        break;
    }
    case '4':
    {
        _baudrate = 125E3;
        break;
    }
    case '5':
    {
        _baudrate = 250E3;
        break;
    }
    case '6':
    {
        _baudrate = 500E3;
        break;
    }
    case '7':
    {
        _baudrate = 800E3;
        break;
    }
    case '8':
    {
        _baudrate = 1000E3;
        break;
    }
    default:
    {
        return 1;
    }
    }

    m_selectedNVM->saveString(INIT_CAN_BAUD, serialInput);

    return m_selectedCAN->setBaudrate(_baudrate);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_Baudrate()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_Baudrate
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_Baudrate
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    long _baudrate = 0;

    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 10E3;
        break;
    }
    case '1':
    {
        _baudrate = 20E3;
        break;
    }
    case '2':
    {
        _baudrate = 50E3;
        break;
    }
    case '3':
    {
        _baudrate = 100E3;
        break;
    }
    case '4':
    {
        _baudrate = 125E3;
        break;
    }
    case '5':
    {
        _baudrate = 250E3;
        break;
    }
    case '6':
    {
        _baudrate = 500E3;
        break;
    }
    case '7':
    {
        _baudrate = 800E3;
        break;
    }
    case '8':
    {
        _baudrate = 1000E3;
        break;
    }
    default:
    {
        return 1;
    }
    }

    m_selectedNVM->saveString(INIT_CAN_BAUD, serialInput);

    return m_selectedCAN->setBaudrate(_baudrate);
}
|———Node:{ Text: {
|———Node:declaration Text: long _baudrate = 0;
|————Node:sized_type_specifier Text: long
|—————Node:long Text: long
|————Node:init_declarator Text: _baudrate = 0
|—————Node:identifier Text: _baudrate
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 2)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 2
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:switch_statement Text: switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 10E3;
        break;
    }
    case '1':
    {
        _baudrate = 20E3;
        break;
    }
    case '2':
    {
        _baudrate = 50E3;
        break;
    }
    case '3':
    {
        _baudrate = 100E3;
        break;
    }
    case '4':
    {
        _baudrate = 125E3;
        break;
    }
    case '5':
    {
        _baudrate = 250E3;
        break;
    }
    case '6':
    {
        _baudrate = 500E3;
        break;
    }
    case '7':
    {
        _baudrate = 800E3;
        break;
    }
    case '8':
    {
        _baudrate = 1000E3;
        break;
    }
    default:
    {
        return 1;
    }
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (serialInput.charAt(1))
|—————Node:( Text: (
|—————Node:call_expression Text: serialInput.charAt(1)
|——————Node:field_expression Text: serialInput.charAt
|———————Node:identifier Text: serialInput
|———————Node:. Text: .
|———————Node:field_identifier Text: charAt
|——————Node:argument_list Text: (1)
|———————Node:( Text: (
|———————Node:number_literal Text: 1
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case '0':
    {
        _baudrate = 10E3;
        break;
    }
    case '1':
    {
        _baudrate = 20E3;
        break;
    }
    case '2':
    {
        _baudrate = 50E3;
        break;
    }
    case '3':
    {
        _baudrate = 100E3;
        break;
    }
    case '4':
    {
        _baudrate = 125E3;
        break;
    }
    case '5':
    {
        _baudrate = 250E3;
        break;
    }
    case '6':
    {
        _baudrate = 500E3;
        break;
    }
    case '7':
    {
        _baudrate = 800E3;
        break;
    }
    case '8':
    {
        _baudrate = 1000E3;
        break;
    }
    default:
    {
        return 1;
    }
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case '0':
    {
        _baudrate = 10E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '0'
|———————Node:' Text: '
|———————Node:character Text: 0
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 10E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 10E3;
|————————Node:assignment_expression Text: _baudrate = 10E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 10E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '1':
    {
        _baudrate = 20E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '1'
|———————Node:' Text: '
|———————Node:character Text: 1
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 20E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 20E3;
|————————Node:assignment_expression Text: _baudrate = 20E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 20E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '2':
    {
        _baudrate = 50E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '2'
|———————Node:' Text: '
|———————Node:character Text: 2
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 50E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 50E3;
|————————Node:assignment_expression Text: _baudrate = 50E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 50E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '3':
    {
        _baudrate = 100E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '3'
|———————Node:' Text: '
|———————Node:character Text: 3
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 100E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 100E3;
|————————Node:assignment_expression Text: _baudrate = 100E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 100E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '4':
    {
        _baudrate = 125E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '4'
|———————Node:' Text: '
|———————Node:character Text: 4
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 125E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 125E3;
|————————Node:assignment_expression Text: _baudrate = 125E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 125E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '5':
    {
        _baudrate = 250E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '5'
|———————Node:' Text: '
|———————Node:character Text: 5
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 250E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 250E3;
|————————Node:assignment_expression Text: _baudrate = 250E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 250E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '6':
    {
        _baudrate = 500E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '6'
|———————Node:' Text: '
|———————Node:character Text: 6
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 500E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 500E3;
|————————Node:assignment_expression Text: _baudrate = 500E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 500E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '7':
    {
        _baudrate = 800E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '7'
|———————Node:' Text: '
|———————Node:character Text: 7
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 800E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 800E3;
|————————Node:assignment_expression Text: _baudrate = 800E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 800E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '8':
    {
        _baudrate = 1000E3;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '8'
|———————Node:' Text: '
|———————Node:character Text: 8
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 1000E3;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 1000E3;
|————————Node:assignment_expression Text: _baudrate = 1000E3
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 1000E3
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: default:
    {
        return 1;
    }
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: m_selectedNVM->saveString(INIT_CAN_BAUD, serialInput);
|————Node:call_expression Text: m_selectedNVM->saveString(INIT_CAN_BAUD, serialInput)
|—————Node:field_expression Text: m_selectedNVM->saveString
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: saveString
|—————Node:argument_list Text: (INIT_CAN_BAUD, serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_CAN_BAUD
|——————Node:, Text: ,
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return m_selectedCAN->setBaudrate(_baudrate);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setBaudrate(_baudrate)
|—————Node:field_expression Text: m_selectedCAN->setBaudrate
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setBaudrate
|—————Node:argument_list Text: (_baudrate)
|——————Node:( Text: (
|——————Node:identifier Text: _baudrate
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_BTR()
{
    if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t BTR0 = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    uint8_t BTR1 = charToByte(serialInput.charAt(3), serialInput.charAt(4));

    return m_selectedCAN->setBTR(BTR0, BTR1);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_BTR()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_BTR
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_BTR
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t BTR0 = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    uint8_t BTR1 = charToByte(serialInput.charAt(3), serialInput.charAt(4));

    return m_selectedCAN->setBTR(BTR0, BTR1);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 5)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 5
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 5
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 5)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 5)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 5)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 5
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 5
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: uint8_t BTR0 = charToByte(serialInput.charAt(1), serialInput.charAt(2));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: BTR0 = charToByte(serialInput.charAt(1), serialInput.charAt(2))
|—————Node:identifier Text: BTR0
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(1), serialInput.charAt(2))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(1), serialInput.charAt(2))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(2)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (2)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint8_t BTR1 = charToByte(serialInput.charAt(3), serialInput.charAt(4));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: BTR1 = charToByte(serialInput.charAt(3), serialInput.charAt(4))
|—————Node:identifier Text: BTR1
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(3), serialInput.charAt(4))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(3), serialInput.charAt(4))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(3)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (3)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 3
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return m_selectedCAN->setBTR(BTR0, BTR1);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setBTR(BTR0, BTR1)
|—————Node:field_expression Text: m_selectedCAN->setBTR
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setBTR
|—————Node:argument_list Text: (BTR0, BTR1)
|——————Node:( Text: (
|——————Node:identifier Text: BTR0
|——————Node:, Text: ,
|——————Node:identifier Text: BTR1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Open_Normal()
{
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::NORMAL);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Open_Normal()
|———Node:qualified_identifier Text: Lawicel::CMD_Open_Normal
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Open_Normal
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::NORMAL);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->setState(CANInterface::NORMAL);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setState(CANInterface::NORMAL)
|—————Node:field_expression Text: m_selectedCAN->setState
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setState
|—————Node:argument_list Text: (CANInterface::NORMAL)
|——————Node:( Text: (
|——————Node:qualified_identifier Text: CANInterface::NORMAL
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: NORMAL
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Open_Listen_Only()
{
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::LISTEN_ONLY);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Open_Listen_Only()
|———Node:qualified_identifier Text: Lawicel::CMD_Open_Listen_Only
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Open_Listen_Only
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::LISTEN_ONLY);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->setState(CANInterface::LISTEN_ONLY);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setState(CANInterface::LISTEN_ONLY)
|—————Node:field_expression Text: m_selectedCAN->setState
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setState
|—————Node:argument_list Text: (CANInterface::LISTEN_ONLY)
|——————Node:( Text: (
|——————Node:qualified_identifier Text: CANInterface::LISTEN_ONLY
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: LISTEN_ONLY
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Close()
{
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::CLOSED);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Close()
|———Node:qualified_identifier Text: Lawicel::CMD_Close
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Close
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    return m_selectedCAN->setState(CANInterface::CLOSED);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->setState(CANInterface::CLOSED);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setState(CANInterface::CLOSED)
|—————Node:field_expression Text: m_selectedCAN->setState
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setState
|—————Node:argument_list Text: (CANInterface::CLOSED)
|——————Node:( Text: (
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Tx_Std()
{
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(4));
    int32_t _id = IdDecode(0);
    int frameposition = 0;

    frame.ID = _id;
    frame.DLC = _dlc;

    if (_length > ((2 * _dlc) + 5))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 5))
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    for (int bufferPosition = 5; bufferPosition < (_dlc * 2 + 4); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }

    return m_selectedCAN->send(frame);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Tx_Std()
|———Node:qualified_identifier Text: Lawicel::CMD_Tx_Std
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Tx_Std
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(4));
    int32_t _id = IdDecode(0);
    int frameposition = 0;

    frame.ID = _id;
    frame.DLC = _dlc;

    if (_length > ((2 * _dlc) + 5))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 5))
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    for (int bufferPosition = 5; bufferPosition < (_dlc * 2 + 4); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }

    return m_selectedCAN->send(frame);
}
|———Node:{ Text: {
|———Node:declaration Text: CANInterface::Frame frame;
|————Node:qualified_identifier Text: CANInterface::Frame
|—————Node:namespace_identifier Text: CANInterface
|—————Node::: Text: ::
|—————Node:type_identifier Text: Frame
|————Node:identifier Text: frame
|————Node:; Text: ;
|———Node:declaration Text: uint8_t _dlc = charToInt(serialInput.charAt(4));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: _dlc = charToInt(serialInput.charAt(4))
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(4))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(4))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int32_t _id = IdDecode(0);
|————Node:primitive_type Text: int32_t
|————Node:init_declarator Text: _id = IdDecode(0)
|—————Node:identifier Text: _id
|—————Node:= Text: =
|—————Node:call_expression Text: IdDecode(0)
|——————Node:identifier Text: IdDecode
|——————Node:argument_list Text: (0)
|———————Node:( Text: (
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int frameposition = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: frameposition = 0
|—————Node:identifier Text: frameposition
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: frame.ID = _id;
|————Node:assignment_expression Text: frame.ID = _id
|—————Node:field_expression Text: frame.ID
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: ID
|—————Node:= Text: =
|—————Node:identifier Text: _id
|————Node:; Text: ;
|———Node:expression_statement Text: frame.DLC = _dlc;
|————Node:assignment_expression Text: frame.DLC = _dlc
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|—————Node:= Text: =
|—————Node:identifier Text: _dlc
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > ((2 * _dlc) + 5))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 5))
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > ((2 * _dlc) + 5))
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > ((2 * _dlc) + 5)
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:parenthesized_expression Text: ((2 * _dlc) + 5)
|———————Node:( Text: (
|———————Node:binary_expression Text: (2 * _dlc) + 5
|————————Node:parenthesized_expression Text: (2 * _dlc)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 2 * _dlc
|——————————Node:number_literal Text: 2
|——————————Node:* Text: *
|——————————Node:identifier Text: _dlc
|—————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:number_literal Text: 5
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < ((2 * _dlc) + 5))
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < ((2 * _dlc) + 5))
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < ((2 * _dlc) + 5))
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < ((2 * _dlc) + 5)
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:parenthesized_expression Text: ((2 * _dlc) + 5)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (2 * _dlc) + 5
|——————————Node:parenthesized_expression Text: (2 * _dlc)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 2 * _dlc
|————————————Node:number_literal Text: 2
|————————————Node:* Text: *
|————————————Node:identifier Text: _dlc
|———————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 5
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::NORMAL
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::NORMAL
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: NORMAL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:for_statement Text: for (int bufferPosition = 5; bufferPosition < (_dlc * 2 + 4); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int bufferPosition = 5;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: bufferPosition = 5
|——————Node:identifier Text: bufferPosition
|——————Node:= Text: =
|——————Node:number_literal Text: 5
|—————Node:; Text: ;
|————Node:binary_expression Text: bufferPosition < (_dlc * 2 + 4)
|—————Node:identifier Text: bufferPosition
|—————Node:< Text: <
|—————Node:parenthesized_expression Text: (_dlc * 2 + 4)
|——————Node:( Text: (
|——————Node:binary_expression Text: _dlc * 2 + 4
|———————Node:binary_expression Text: _dlc * 2
|————————Node:identifier Text: _dlc
|————————Node:* Text: *
|————————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 4
|——————Node:) Text: )
|————Node:; Text: ;
|————Node:comma_expression Text: bufferPosition += 2, frameposition++
|—————Node:assignment_expression Text: bufferPosition += 2
|——————Node:identifier Text: bufferPosition
|——————Node:+= Text: +=
|——————Node:number_literal Text: 2
|—————Node:, Text: ,
|—————Node:update_expression Text: frameposition++
|——————Node:identifier Text: frameposition
|——————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
|——————Node:assignment_expression Text: frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)))
|———————Node:subscript_expression Text: frame.Data[frameposition]
|————————Node:field_expression Text: frame.Data
|—————————Node:identifier Text: frame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Data
|————————Node:subscript_argument_list Text: [frameposition]
|—————————Node:[ Text: [
|—————————Node:identifier Text: frameposition
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)))
|————————Node:( Text: (
|————————Node:call_expression Text: charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1))
|—————————Node:identifier Text: charToByte
|—————————Node:argument_list Text: (serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1))
|——————————Node:( Text: (
|——————————Node:call_expression Text: serialInput.charAt(bufferPosition)
|———————————Node:field_expression Text: serialInput.charAt
|————————————Node:identifier Text: serialInput
|————————————Node:. Text: .
|————————————Node:field_identifier Text: charAt
|———————————Node:argument_list Text: (bufferPosition)
|————————————Node:( Text: (
|————————————Node:identifier Text: bufferPosition
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: serialInput.charAt(bufferPosition + 1)
|———————————Node:field_expression Text: serialInput.charAt
|————————————Node:identifier Text: serialInput
|————————————Node:. Text: .
|————————————Node:field_identifier Text: charAt
|———————————Node:argument_list Text: (bufferPosition + 1)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: bufferPosition + 1
|—————————————Node:identifier Text: bufferPosition
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->send(frame);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->send(frame)
|—————Node:field_expression Text: m_selectedCAN->send
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: send
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Tx_Ext()
{
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(9));
    int32_t _id = IdDecode(1);
    int frameposition = 0;

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.Extended = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > ((2 * _dlc) + 10))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 10))
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    for (int bufferPosition = 10; bufferPosition < (_dlc * 2 + 9); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }

    return m_selectedCAN->send(frame);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Tx_Ext()
|———Node:qualified_identifier Text: Lawicel::CMD_Tx_Ext
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Tx_Ext
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(9));
    int32_t _id = IdDecode(1);
    int frameposition = 0;

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.Extended = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > ((2 * _dlc) + 10))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 10))
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    for (int bufferPosition = 10; bufferPosition < (_dlc * 2 + 9); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }

    return m_selectedCAN->send(frame);
}
|———Node:{ Text: {
|———Node:declaration Text: CANInterface::Frame frame;
|————Node:qualified_identifier Text: CANInterface::Frame
|—————Node:namespace_identifier Text: CANInterface
|—————Node::: Text: ::
|—————Node:type_identifier Text: Frame
|————Node:identifier Text: frame
|————Node:; Text: ;
|———Node:declaration Text: uint8_t _dlc = charToInt(serialInput.charAt(9));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: _dlc = charToInt(serialInput.charAt(9))
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(9))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(9))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(9)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (9)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 9
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int32_t _id = IdDecode(1);
|————Node:primitive_type Text: int32_t
|————Node:init_declarator Text: _id = IdDecode(1)
|—————Node:identifier Text: _id
|—————Node:= Text: =
|—————Node:call_expression Text: IdDecode(1)
|——————Node:identifier Text: IdDecode
|——————Node:argument_list Text: (1)
|———————Node:( Text: (
|———————Node:number_literal Text: 1
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int frameposition = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: frameposition = 0
|—————Node:identifier Text: frameposition
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: frame.ID = _id;
|————Node:assignment_expression Text: frame.ID = _id
|—————Node:field_expression Text: frame.ID
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: ID
|—————Node:= Text: =
|—————Node:identifier Text: _id
|————Node:; Text: ;
|———Node:expression_statement Text: frame.DLC = _dlc;
|————Node:assignment_expression Text: frame.DLC = _dlc
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|—————Node:= Text: =
|—————Node:identifier Text: _dlc
|————Node:; Text: ;
|———Node:expression_statement Text: frame.Extended = true;
|————Node:assignment_expression Text: frame.Extended = true
|—————Node:field_expression Text: frame.Extended
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: Extended
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: frame.Data = new uint8_t[_dlc];
|————Node:assignment_expression Text: frame.Data = new uint8_t[_dlc]
|—————Node:field_expression Text: frame.Data
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: Data
|—————Node:= Text: =
|—————Node:new_expression Text: new uint8_t[_dlc]
|——————Node:new Text: new
|——————Node:primitive_type Text: uint8_t
|——————Node:new_declarator Text: [_dlc]
|———————Node:[ Text: [
|———————Node:identifier Text: _dlc
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > ((2 * _dlc) + 10))
    {
        return 1;
    }
    else if (_length < ((2 * _dlc) + 10))
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > ((2 * _dlc) + 10))
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > ((2 * _dlc) + 10)
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:parenthesized_expression Text: ((2 * _dlc) + 10)
|———————Node:( Text: (
|———————Node:binary_expression Text: (2 * _dlc) + 10
|————————Node:parenthesized_expression Text: (2 * _dlc)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 2 * _dlc
|——————————Node:number_literal Text: 2
|——————————Node:* Text: *
|——————————Node:identifier Text: _dlc
|—————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:number_literal Text: 10
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < ((2 * _dlc) + 10))
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < ((2 * _dlc) + 10))
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < ((2 * _dlc) + 10))
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < ((2 * _dlc) + 10)
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:parenthesized_expression Text: ((2 * _dlc) + 10)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (2 * _dlc) + 10
|——————————Node:parenthesized_expression Text: (2 * _dlc)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 2 * _dlc
|————————————Node:number_literal Text: 2
|————————————Node:* Text: *
|————————————Node:identifier Text: _dlc
|———————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 10
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::NORMAL
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::NORMAL
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: NORMAL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:for_statement Text: for (int bufferPosition = 10; bufferPosition < (_dlc * 2 + 9); bufferPosition += 2, frameposition++)
    {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int bufferPosition = 10;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: bufferPosition = 10
|——————Node:identifier Text: bufferPosition
|——————Node:= Text: =
|——————Node:number_literal Text: 10
|—————Node:; Text: ;
|————Node:binary_expression Text: bufferPosition < (_dlc * 2 + 9)
|—————Node:identifier Text: bufferPosition
|—————Node:< Text: <
|—————Node:parenthesized_expression Text: (_dlc * 2 + 9)
|——————Node:( Text: (
|——————Node:binary_expression Text: _dlc * 2 + 9
|———————Node:binary_expression Text: _dlc * 2
|————————Node:identifier Text: _dlc
|————————Node:* Text: *
|————————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 9
|——————Node:) Text: )
|————Node:; Text: ;
|————Node:comma_expression Text: bufferPosition += 2, frameposition++
|—————Node:assignment_expression Text: bufferPosition += 2
|——————Node:identifier Text: bufferPosition
|——————Node:+= Text: +=
|——————Node:number_literal Text: 2
|—————Node:, Text: ,
|—————Node:update_expression Text: frameposition++
|——————Node:identifier Text: frameposition
|——————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)));
|——————Node:assignment_expression Text: frame.Data[frameposition] = (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)))
|———————Node:subscript_expression Text: frame.Data[frameposition]
|————————Node:field_expression Text: frame.Data
|—————————Node:identifier Text: frame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Data
|————————Node:subscript_argument_list Text: [frameposition]
|—————————Node:[ Text: [
|—————————Node:identifier Text: frameposition
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: (charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1)))
|————————Node:( Text: (
|————————Node:call_expression Text: charToByte(serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1))
|—————————Node:identifier Text: charToByte
|—————————Node:argument_list Text: (serialInput.charAt(bufferPosition), serialInput.charAt(bufferPosition + 1))
|——————————Node:( Text: (
|——————————Node:call_expression Text: serialInput.charAt(bufferPosition)
|———————————Node:field_expression Text: serialInput.charAt
|————————————Node:identifier Text: serialInput
|————————————Node:. Text: .
|————————————Node:field_identifier Text: charAt
|———————————Node:argument_list Text: (bufferPosition)
|————————————Node:( Text: (
|————————————Node:identifier Text: bufferPosition
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: serialInput.charAt(bufferPosition + 1)
|———————————Node:field_expression Text: serialInput.charAt
|————————————Node:identifier Text: serialInput
|————————————Node:. Text: .
|————————————Node:field_identifier Text: charAt
|———————————Node:argument_list Text: (bufferPosition + 1)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: bufferPosition + 1
|—————————————Node:identifier Text: bufferPosition
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->send(frame);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->send(frame)
|—————Node:field_expression Text: m_selectedCAN->send
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: send
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Tx_Std_RTR()
{
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(4));
    int32_t _id = IdDecode(0);

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.RTR = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    return m_selectedCAN->send(frame);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Tx_Std_RTR()
|———Node:qualified_identifier Text: Lawicel::CMD_Tx_Std_RTR
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Tx_Std_RTR
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(4));
    int32_t _id = IdDecode(0);

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.RTR = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    return m_selectedCAN->send(frame);
}
|———Node:{ Text: {
|———Node:declaration Text: CANInterface::Frame frame;
|————Node:qualified_identifier Text: CANInterface::Frame
|—————Node:namespace_identifier Text: CANInterface
|—————Node::: Text: ::
|—————Node:type_identifier Text: Frame
|————Node:identifier Text: frame
|————Node:; Text: ;
|———Node:declaration Text: uint8_t _dlc = charToInt(serialInput.charAt(4));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: _dlc = charToInt(serialInput.charAt(4))
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(4))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(4))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int32_t _id = IdDecode(0);
|————Node:primitive_type Text: int32_t
|————Node:init_declarator Text: _id = IdDecode(0)
|—————Node:identifier Text: _id
|—————Node:= Text: =
|—————Node:call_expression Text: IdDecode(0)
|——————Node:identifier Text: IdDecode
|——————Node:argument_list Text: (0)
|———————Node:( Text: (
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: frame.ID = _id;
|————Node:assignment_expression Text: frame.ID = _id
|—————Node:field_expression Text: frame.ID
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: ID
|—————Node:= Text: =
|—————Node:identifier Text: _id
|————Node:; Text: ;
|———Node:expression_statement Text: frame.DLC = _dlc;
|————Node:assignment_expression Text: frame.DLC = _dlc
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|—————Node:= Text: =
|—————Node:identifier Text: _dlc
|————Node:; Text: ;
|———Node:expression_statement Text: frame.RTR = true;
|————Node:assignment_expression Text: frame.RTR = true
|—————Node:field_expression Text: frame.RTR
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: RTR
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: frame.Data = new uint8_t[_dlc];
|————Node:assignment_expression Text: frame.Data = new uint8_t[_dlc]
|—————Node:field_expression Text: frame.Data
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: Data
|—————Node:= Text: =
|—————Node:new_expression Text: new uint8_t[_dlc]
|——————Node:new Text: new
|——————Node:primitive_type Text: uint8_t
|——————Node:new_declarator Text: [_dlc]
|———————Node:[ Text: [
|———————Node:identifier Text: _dlc
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > 5)
    {
        return 1;
    }
    else if (_length < 5)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 5)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 5
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 5
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 5)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 5)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 5)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 5
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 5
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::NORMAL
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::NORMAL
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: NORMAL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->send(frame);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->send(frame)
|—————Node:field_expression Text: m_selectedCAN->send
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: send
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Tx_Ext_RTR()
{
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(9));
    int32_t _id = IdDecode(1);

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.Extended = true;
    frame.RTR = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > 10)
    {
        return 1;
    }
    else if (_length < 10)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    return m_selectedCAN->send(frame);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Tx_Ext_RTR()
|———Node:qualified_identifier Text: Lawicel::CMD_Tx_Ext_RTR
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Tx_Ext_RTR
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    CANInterface::Frame frame;
    uint8_t _dlc = charToInt(serialInput.charAt(9));
    int32_t _id = IdDecode(1);

    frame.ID = _id;
    frame.DLC = _dlc;
    frame.Extended = true;
    frame.RTR = true;
    frame.Data = new uint8_t[_dlc];

    if (_length > 10)
    {
        return 1;
    }
    else if (_length < 10)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }

    return m_selectedCAN->send(frame);
}
|———Node:{ Text: {
|———Node:declaration Text: CANInterface::Frame frame;
|————Node:qualified_identifier Text: CANInterface::Frame
|—————Node:namespace_identifier Text: CANInterface
|—————Node::: Text: ::
|—————Node:type_identifier Text: Frame
|————Node:identifier Text: frame
|————Node:; Text: ;
|———Node:declaration Text: uint8_t _dlc = charToInt(serialInput.charAt(9));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: _dlc = charToInt(serialInput.charAt(9))
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(9))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(9))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(9)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (9)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 9
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int32_t _id = IdDecode(1);
|————Node:primitive_type Text: int32_t
|————Node:init_declarator Text: _id = IdDecode(1)
|—————Node:identifier Text: _id
|—————Node:= Text: =
|—————Node:call_expression Text: IdDecode(1)
|——————Node:identifier Text: IdDecode
|——————Node:argument_list Text: (1)
|———————Node:( Text: (
|———————Node:number_literal Text: 1
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: frame.ID = _id;
|————Node:assignment_expression Text: frame.ID = _id
|—————Node:field_expression Text: frame.ID
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: ID
|—————Node:= Text: =
|—————Node:identifier Text: _id
|————Node:; Text: ;
|———Node:expression_statement Text: frame.DLC = _dlc;
|————Node:assignment_expression Text: frame.DLC = _dlc
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|—————Node:= Text: =
|—————Node:identifier Text: _dlc
|————Node:; Text: ;
|———Node:expression_statement Text: frame.Extended = true;
|————Node:assignment_expression Text: frame.Extended = true
|—————Node:field_expression Text: frame.Extended
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: Extended
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: frame.RTR = true;
|————Node:assignment_expression Text: frame.RTR = true
|—————Node:field_expression Text: frame.RTR
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: RTR
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: frame.Data = new uint8_t[_dlc];
|————Node:assignment_expression Text: frame.Data = new uint8_t[_dlc]
|—————Node:field_expression Text: frame.Data
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: Data
|—————Node:= Text: =
|—————Node:new_expression Text: new uint8_t[_dlc]
|——————Node:new Text: new
|——————Node:primitive_type Text: uint8_t
|——————Node:new_declarator Text: [_dlc]
|———————Node:[ Text: [
|———————Node:identifier Text: _dlc
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > 10)
    {
        return 1;
    }
    else if (_length < 10)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 10)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 10
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 10
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 10)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 10)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 10)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 10
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 10
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::NORMAL)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::NORMAL
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::NORMAL
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: NORMAL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return m_selectedCAN->send(frame);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->send(frame)
|—————Node:field_expression Text: m_selectedCAN->send
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: send
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Poll_Single()
{
    char cmd = 't';
    int _id_length = 3;

    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    CANInterface::Frame frame = m_selectedCAN->pollSingle();

    if (frame.ID == 0xFFF)
    {
        return 2;
    }

    if (frame.Extended == true && frame.RTR == false)
    {
        cmd = 'T';
        _id_length = 8;
    }
    else if (frame.Extended == false && frame.RTR == true)
    {
        cmd = 'r';
    }
    else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }

    serialReturn += cmd;

    String _ID = String(frame.ID, HEX);
    for (int i = 0; i < _id_length - _ID.length(); i++)
    {
        serialReturn += '0';
    }
    serialReturn += _ID;

    int _dlc = frame.DLC;
    serialReturn += frame.DLC;

    if (frame.RTR == false)
    {
        for (int i = 0; i < _dlc; i++)
        {
            serialReturn += String(frame.Data[i], HEX);
        }
    }

    if (_timestamp)
    {
        serialReturn += String(getTimestamp(), HEX);
    }

    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Poll_Single()
|———Node:qualified_identifier Text: Lawicel::CMD_Poll_Single
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Poll_Single
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    char cmd = 't';
    int _id_length = 3;

    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    CANInterface::Frame frame = m_selectedCAN->pollSingle();

    if (frame.ID == 0xFFF)
    {
        return 2;
    }

    if (frame.Extended == true && frame.RTR == false)
    {
        cmd = 'T';
        _id_length = 8;
    }
    else if (frame.Extended == false && frame.RTR == true)
    {
        cmd = 'r';
    }
    else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }

    serialReturn += cmd;

    String _ID = String(frame.ID, HEX);
    for (int i = 0; i < _id_length - _ID.length(); i++)
    {
        serialReturn += '0';
    }
    serialReturn += _ID;

    int _dlc = frame.DLC;
    serialReturn += frame.DLC;

    if (frame.RTR == false)
    {
        for (int i = 0; i < _dlc; i++)
        {
            serialReturn += String(frame.Data[i], HEX);
        }
    }

    if (_timestamp)
    {
        serialReturn += String(getTimestamp(), HEX);
    }

    return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: char cmd = 't';
|————Node:primitive_type Text: char
|————Node:init_declarator Text: cmd = 't'
|—————Node:identifier Text: cmd
|—————Node:= Text: =
|—————Node:char_literal Text: 't'
|——————Node:' Text: '
|——————Node:character Text: t
|——————Node:' Text: '
|————Node:; Text: ;
|———Node:declaration Text: int _id_length = 3;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: _id_length = 3
|—————Node:identifier Text: _id_length
|—————Node:= Text: =
|—————Node:number_literal Text: 3
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 1
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: CANInterface::Frame frame = m_selectedCAN->pollSingle();
|————Node:qualified_identifier Text: CANInterface::Frame
|—————Node:namespace_identifier Text: CANInterface
|—————Node::: Text: ::
|—————Node:type_identifier Text: Frame
|————Node:init_declarator Text: frame = m_selectedCAN->pollSingle()
|—————Node:identifier Text: frame
|—————Node:= Text: =
|—————Node:call_expression Text: m_selectedCAN->pollSingle()
|——————Node:field_expression Text: m_selectedCAN->pollSingle
|———————Node:identifier Text: m_selectedCAN
|———————Node:-> Text: ->
|———————Node:field_identifier Text: pollSingle
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (frame.ID == 0xFFF)
    {
        return 2;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (frame.ID == 0xFFF)
|—————Node:( Text: (
|—————Node:binary_expression Text: frame.ID == 0xFFF
|——————Node:field_expression Text: frame.ID
|———————Node:identifier Text: frame
|———————Node:. Text: .
|———————Node:field_identifier Text: ID
|——————Node:== Text: ==
|——————Node:number_literal Text: 0xFFF
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 2;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 2;
|——————Node:return Text: return
|——————Node:number_literal Text: 2
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (frame.Extended == true && frame.RTR == false)
    {
        cmd = 'T';
        _id_length = 8;
    }
    else if (frame.Extended == false && frame.RTR == true)
    {
        cmd = 'r';
    }
    else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (frame.Extended == true && frame.RTR == false)
|—————Node:( Text: (
|—————Node:binary_expression Text: frame.Extended == true && frame.RTR == false
|——————Node:binary_expression Text: frame.Extended == true
|———————Node:field_expression Text: frame.Extended
|————————Node:identifier Text: frame
|————————Node:. Text: .
|————————Node:field_identifier Text: Extended
|———————Node:== Text: ==
|———————Node:true Text: true
|——————Node:&& Text: &&
|——————Node:binary_expression Text: frame.RTR == false
|———————Node:field_expression Text: frame.RTR
|————————Node:identifier Text: frame
|————————Node:. Text: .
|————————Node:field_identifier Text: RTR
|———————Node:== Text: ==
|———————Node:false Text: false
|—————Node:) Text: )
|————Node:compound_statement Text: {
        cmd = 'T';
        _id_length = 8;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: cmd = 'T';
|——————Node:assignment_expression Text: cmd = 'T'
|———————Node:identifier Text: cmd
|———————Node:= Text: =
|———————Node:char_literal Text: 'T'
|————————Node:' Text: '
|————————Node:character Text: T
|————————Node:' Text: '
|——————Node:; Text: ;
|—————Node:expression_statement Text: _id_length = 8;
|——————Node:assignment_expression Text: _id_length = 8
|———————Node:identifier Text: _id_length
|———————Node:= Text: =
|———————Node:number_literal Text: 8
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (frame.Extended == false && frame.RTR == true)
    {
        cmd = 'r';
    }
    else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (frame.Extended == false && frame.RTR == true)
    {
        cmd = 'r';
    }
    else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (frame.Extended == false && frame.RTR == true)
|———————Node:( Text: (
|———————Node:binary_expression Text: frame.Extended == false && frame.RTR == true
|————————Node:binary_expression Text: frame.Extended == false
|—————————Node:field_expression Text: frame.Extended
|——————————Node:identifier Text: frame
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Extended
|—————————Node:== Text: ==
|—————————Node:false Text: false
|————————Node:&& Text: &&
|————————Node:binary_expression Text: frame.RTR == true
|—————————Node:field_expression Text: frame.RTR
|——————————Node:identifier Text: frame
|——————————Node:. Text: .
|——————————Node:field_identifier Text: RTR
|—————————Node:== Text: ==
|—————————Node:true Text: true
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        cmd = 'r';
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: cmd = 'r';
|————————Node:assignment_expression Text: cmd = 'r'
|—————————Node:identifier Text: cmd
|—————————Node:= Text: =
|—————————Node:char_literal Text: 'r'
|——————————Node:' Text: '
|——————————Node:character Text: r
|——————————Node:' Text: '
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if (frame.Extended == true && frame.RTR == true)
    {
        cmd = 'R';
        _id_length = 8;
    }
|————————Node:if Text: if
|————————Node:condition_clause Text: (frame.Extended == true && frame.RTR == true)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: frame.Extended == true && frame.RTR == true
|——————————Node:binary_expression Text: frame.Extended == true
|———————————Node:field_expression Text: frame.Extended
|————————————Node:identifier Text: frame
|————————————Node:. Text: .
|————————————Node:field_identifier Text: Extended
|———————————Node:== Text: ==
|———————————Node:true Text: true
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: frame.RTR == true
|———————————Node:field_expression Text: frame.RTR
|————————————Node:identifier Text: frame
|————————————Node:. Text: .
|————————————Node:field_identifier Text: RTR
|———————————Node:== Text: ==
|———————————Node:true Text: true
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        cmd = 'R';
        _id_length = 8;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: cmd = 'R';
|——————————Node:assignment_expression Text: cmd = 'R'
|———————————Node:identifier Text: cmd
|———————————Node:= Text: =
|———————————Node:char_literal Text: 'R'
|————————————Node:' Text: '
|————————————Node:character Text: R
|————————————Node:' Text: '
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: _id_length = 8;
|——————————Node:assignment_expression Text: _id_length = 8
|———————————Node:identifier Text: _id_length
|———————————Node:= Text: =
|———————————Node:number_literal Text: 8
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:expression_statement Text: serialReturn += cmd;
|————Node:assignment_expression Text: serialReturn += cmd
|—————Node:identifier Text: serialReturn
|—————Node:+= Text: +=
|—————Node:identifier Text: cmd
|————Node:; Text: ;
|———Node:declaration Text: String _ID = String(frame.ID, HEX);
|————Node:type_identifier Text: String
|————Node:init_declarator Text: _ID = String(frame.ID, HEX)
|—————Node:identifier Text: _ID
|—————Node:= Text: =
|—————Node:call_expression Text: String(frame.ID, HEX)
|——————Node:identifier Text: String
|——————Node:argument_list Text: (frame.ID, HEX)
|———————Node:( Text: (
|———————Node:field_expression Text: frame.ID
|————————Node:identifier Text: frame
|————————Node:. Text: .
|————————Node:field_identifier Text: ID
|———————Node:, Text: ,
|———————Node:identifier Text: HEX
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (int i = 0; i < _id_length - _ID.length(); i++)
    {
        serialReturn += '0';
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < _id_length - _ID.length()
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:binary_expression Text: _id_length - _ID.length()
|——————Node:identifier Text: _id_length
|——————Node:- Text: -
|——————Node:call_expression Text: _ID.length()
|———————Node:field_expression Text: _ID.length
|————————Node:identifier Text: _ID
|————————Node:. Text: .
|————————Node:field_identifier Text: length
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        serialReturn += '0';
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: serialReturn += '0';
|——————Node:assignment_expression Text: serialReturn += '0'
|———————Node:identifier Text: serialReturn
|———————Node:+= Text: +=
|———————Node:char_literal Text: '0'
|————————Node:' Text: '
|————————Node:character Text: 0
|————————Node:' Text: '
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: serialReturn += _ID;
|————Node:assignment_expression Text: serialReturn += _ID
|—————Node:identifier Text: serialReturn
|—————Node:+= Text: +=
|—————Node:identifier Text: _ID
|————Node:; Text: ;
|———Node:declaration Text: int _dlc = frame.DLC;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: _dlc = frame.DLC
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|————Node:; Text: ;
|———Node:expression_statement Text: serialReturn += frame.DLC;
|————Node:assignment_expression Text: serialReturn += frame.DLC
|—————Node:identifier Text: serialReturn
|—————Node:+= Text: +=
|—————Node:field_expression Text: frame.DLC
|——————Node:identifier Text: frame
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|————Node:; Text: ;
|———Node:if_statement Text: if (frame.RTR == false)
    {
        for (int i = 0; i < _dlc; i++)
        {
            serialReturn += String(frame.Data[i], HEX);
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (frame.RTR == false)
|—————Node:( Text: (
|—————Node:binary_expression Text: frame.RTR == false
|——————Node:field_expression Text: frame.RTR
|———————Node:identifier Text: frame
|———————Node:. Text: .
|———————Node:field_identifier Text: RTR
|——————Node:== Text: ==
|——————Node:false Text: false
|—————Node:) Text: )
|————Node:compound_statement Text: {
        for (int i = 0; i < _dlc; i++)
        {
            serialReturn += String(frame.Data[i], HEX);
        }
    }
|—————Node:{ Text: {
|—————Node:for_statement Text: for (int i = 0; i < _dlc; i++)
        {
            serialReturn += String(frame.Data[i], HEX);
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: int i = 0;
|———————Node:primitive_type Text: int
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < _dlc
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: _dlc
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            serialReturn += String(frame.Data[i], HEX);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: serialReturn += String(frame.Data[i], HEX);
|————————Node:assignment_expression Text: serialReturn += String(frame.Data[i], HEX)
|—————————Node:identifier Text: serialReturn
|—————————Node:+= Text: +=
|—————————Node:call_expression Text: String(frame.Data[i], HEX)
|——————————Node:identifier Text: String
|——————————Node:argument_list Text: (frame.Data[i], HEX)
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: frame.Data[i]
|————————————Node:field_expression Text: frame.Data
|—————————————Node:identifier Text: frame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: Data
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:identifier Text: HEX
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:if_statement Text: if (_timestamp)
    {
        serialReturn += String(getTimestamp(), HEX);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_timestamp)
|—————Node:( Text: (
|—————Node:identifier Text: _timestamp
|—————Node:) Text: )
|————Node:compound_statement Text: {
        serialReturn += String(getTimestamp(), HEX);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: serialReturn += String(getTimestamp(), HEX);
|——————Node:assignment_expression Text: serialReturn += String(getTimestamp(), HEX)
|———————Node:identifier Text: serialReturn
|———————Node:+= Text: +=
|———————Node:call_expression Text: String(getTimestamp(), HEX)
|————————Node:identifier Text: String
|————————Node:argument_list Text: (getTimestamp(), HEX)
|—————————Node:( Text: (
|—————————Node:call_expression Text: getTimestamp()
|——————————Node:identifier Text: getTimestamp
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: HEX
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Poll_All()
{

    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    while (CMD_Poll_Single() == 0)
    {
        m_selectedSerial->print(serialReturn);
        serialReturn = "";
    }

    serialReturn += 'A';
    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Poll_All()
|———Node:qualified_identifier Text: Lawicel::CMD_Poll_All
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Poll_All
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {

    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    while (CMD_Poll_Single() == 0)
    {
        m_selectedSerial->print(serialReturn);
        serialReturn = "";
    }

    serialReturn += 'A';
    return 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 1
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:while_statement Text: while (CMD_Poll_Single() == 0)
    {
        m_selectedSerial->print(serialReturn);
        serialReturn = "";
    }
|————Node:while Text: while
|————Node:condition_clause Text: (CMD_Poll_Single() == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: CMD_Poll_Single() == 0
|——————Node:call_expression Text: CMD_Poll_Single()
|———————Node:identifier Text: CMD_Poll_Single
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        m_selectedSerial->print(serialReturn);
        serialReturn = "";
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_selectedSerial->print(serialReturn);
|——————Node:call_expression Text: m_selectedSerial->print(serialReturn)
|———————Node:field_expression Text: m_selectedSerial->print
|————————Node:identifier Text: m_selectedSerial
|————————Node:-> Text: ->
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (serialReturn)
|————————Node:( Text: (
|————————Node:identifier Text: serialReturn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: serialReturn = "";
|——————Node:assignment_expression Text: serialReturn = ""
|———————Node:identifier Text: serialReturn
|———————Node:= Text: =
|———————Node:string_literal Text: ""
|————————Node:" Text: "
|————————Node:" Text: "
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: serialReturn += 'A';
|————Node:assignment_expression Text: serialReturn += 'A'
|—————Node:identifier Text: serialReturn
|—————Node:+= Text: +=
|—————Node:char_literal Text: 'A'
|——————Node:' Text: '
|——————Node:character Text: A
|——————Node:' Text: '
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Poll_Auto()
{
    if (_length > 2)
    {
        return 1;
    }
    if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    if (serialInput.charAt(1) == '0')
    {
        autoPolling = false;
    }
    else if (serialInput.charAt(1) == '1')
    {
        autoPolling = true;
    }
    else
    {
        return 1;
    }

    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Poll_Auto()
|———Node:qualified_identifier Text: Lawicel::CMD_Poll_Auto
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Poll_Auto
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 2)
    {
        return 1;
    }
    if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    if (serialInput.charAt(1) == '0')
    {
        autoPolling = false;
    }
    else if (serialInput.charAt(1) == '1')
    {
        autoPolling = true;
    }
    else
    {
        return 1;
    }

    return 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 2
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (serialInput.charAt(1) == '0')
    {
        autoPolling = false;
    }
    else if (serialInput.charAt(1) == '1')
    {
        autoPolling = true;
    }
    else
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (serialInput.charAt(1) == '0')
|—————Node:( Text: (
|—————Node:binary_expression Text: serialInput.charAt(1) == '0'
|——————Node:call_expression Text: serialInput.charAt(1)
|———————Node:field_expression Text: serialInput.charAt
|————————Node:identifier Text: serialInput
|————————Node:. Text: .
|————————Node:field_identifier Text: charAt
|———————Node:argument_list Text: (1)
|————————Node:( Text: (
|————————Node:number_literal Text: 1
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:char_literal Text: '0'
|———————Node:' Text: '
|———————Node:character Text: 0
|———————Node:' Text: '
|—————Node:) Text: )
|————Node:compound_statement Text: {
        autoPolling = false;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: autoPolling = false;
|——————Node:assignment_expression Text: autoPolling = false
|———————Node:identifier Text: autoPolling
|———————Node:= Text: =
|———————Node:false Text: false
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (serialInput.charAt(1) == '1')
    {
        autoPolling = true;
    }
    else
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (serialInput.charAt(1) == '1')
    {
        autoPolling = true;
    }
    else
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (serialInput.charAt(1) == '1')
|———————Node:( Text: (
|———————Node:binary_expression Text: serialInput.charAt(1) == '1'
|————————Node:call_expression Text: serialInput.charAt(1)
|—————————Node:field_expression Text: serialInput.charAt
|——————————Node:identifier Text: serialInput
|——————————Node:. Text: .
|——————————Node:field_identifier Text: charAt
|—————————Node:argument_list Text: (1)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 1
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:char_literal Text: '1'
|—————————Node:' Text: '
|—————————Node:character Text: 1
|—————————Node:' Text: '
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        autoPolling = true;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: autoPolling = true;
|————————Node:assignment_expression Text: autoPolling = true
|—————————Node:identifier Text: autoPolling
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
    {
        return 1;
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
        return 1;
    }
|————————Node:{ Text: {
|————————Node:return_statement Text: return 1;
|—————————Node:return Text: return
|—————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Flags()
{
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    bool flags[8] = {};
    if (m_selectedCAN->getStatusFlags(flags) == 1)
    {
        return 1;
    }

    uint8_t statusCode = 0;

    for (int position = 0; position < 8; position++)
    {
        statusCode += flags[position] * pow(16.0, position);
    }

    return 1;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Flags()
|———Node:qualified_identifier Text: Lawicel::CMD_Flags
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Flags
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    bool flags[8] = {};
    if (m_selectedCAN->getStatusFlags(flags) == 1)
    {
        return 1;
    }

    uint8_t statusCode = 0;

    for (int position = 0; position < 8; position++)
    {
        statusCode += flags[position] * pow(16.0, position);
    }

    return 1;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 1
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: bool flags[8] = {};
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: flags[8] = {}
|—————Node:array_declarator Text: flags[8]
|——————Node:identifier Text: flags
|——————Node:[ Text: [
|——————Node:number_literal Text: 8
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {}
|——————Node:{ Text: {
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:if_statement Text: if (m_selectedCAN->getStatusFlags(flags) == 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getStatusFlags(flags) == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getStatusFlags(flags) == 1
|——————Node:call_expression Text: m_selectedCAN->getStatusFlags(flags)
|———————Node:field_expression Text: m_selectedCAN->getStatusFlags
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getStatusFlags
|———————Node:argument_list Text: (flags)
|————————Node:( Text: (
|————————Node:identifier Text: flags
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: uint8_t statusCode = 0;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: statusCode = 0
|—————Node:identifier Text: statusCode
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:for_statement Text: for (int position = 0; position < 8; position++)
    {
        statusCode += flags[position] * pow(16.0, position);
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int position = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: position = 0
|——————Node:identifier Text: position
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: position < 8
|—————Node:identifier Text: position
|—————Node:< Text: <
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|————Node:update_expression Text: position++
|—————Node:identifier Text: position
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        statusCode += flags[position] * pow(16.0, position);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: statusCode += flags[position] * pow(16.0, position);
|——————Node:assignment_expression Text: statusCode += flags[position] * pow(16.0, position)
|———————Node:identifier Text: statusCode
|———————Node:+= Text: +=
|———————Node:binary_expression Text: flags[position] * pow(16.0, position)
|————————Node:subscript_expression Text: flags[position]
|—————————Node:identifier Text: flags
|—————————Node:subscript_argument_list Text: [position]
|——————————Node:[ Text: [
|——————————Node:identifier Text: position
|——————————Node:] Text: ]
|————————Node:* Text: *
|————————Node:call_expression Text: pow(16.0, position)
|—————————Node:identifier Text: pow
|—————————Node:argument_list Text: (16.0, position)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 16.0
|——————————Node:, Text: ,
|——————————Node:identifier Text: position
|——————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_Filter_Mode()
{
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
    bool filterMode = false;
    if (serialInput.charAt(1) == '1')
    {
        filterMode = true;
    }

    m_selectedNVM->saveString(INIT_FILTER_MODE, serialInput);

    return m_selectedCAN->setFilterMode(filterMode);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_Filter_Mode()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_Filter_Mode
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_Filter_Mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
    bool filterMode = false;
    if (serialInput.charAt(1) == '1')
    {
        filterMode = true;
    }

    m_selectedNVM->saveString(INIT_FILTER_MODE, serialInput);

    return m_selectedCAN->setFilterMode(filterMode);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 2)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 2
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: bool filterMode = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: filterMode = false
|—————Node:identifier Text: filterMode
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (serialInput.charAt(1) == '1')
    {
        filterMode = true;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (serialInput.charAt(1) == '1')
|—————Node:( Text: (
|—————Node:binary_expression Text: serialInput.charAt(1) == '1'
|——————Node:call_expression Text: serialInput.charAt(1)
|———————Node:field_expression Text: serialInput.charAt
|————————Node:identifier Text: serialInput
|————————Node:. Text: .
|————————Node:field_identifier Text: charAt
|———————Node:argument_list Text: (1)
|————————Node:( Text: (
|————————Node:number_literal Text: 1
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:char_literal Text: '1'
|———————Node:' Text: '
|———————Node:character Text: 1
|———————Node:' Text: '
|—————Node:) Text: )
|————Node:compound_statement Text: {
        filterMode = true;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: filterMode = true;
|——————Node:assignment_expression Text: filterMode = true
|———————Node:identifier Text: filterMode
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: m_selectedNVM->saveString(INIT_FILTER_MODE, serialInput);
|————Node:call_expression Text: m_selectedNVM->saveString(INIT_FILTER_MODE, serialInput)
|—————Node:field_expression Text: m_selectedNVM->saveString
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: saveString
|—————Node:argument_list Text: (INIT_FILTER_MODE, serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_FILTER_MODE
|——————Node:, Text: ,
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return m_selectedCAN->setFilterMode(filterMode);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setFilterMode(filterMode)
|—————Node:field_expression Text: m_selectedCAN->setFilterMode
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setFilterMode
|—————Node:argument_list Text: (filterMode)
|——————Node:( Text: (
|——————Node:identifier Text: filterMode
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_ACn()
{
    if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t ACn[4];

    ACn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    ACn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
    ACn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
    ACn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));

    m_selectedNVM->saveString(INIT_FILTER_ACN, serialInput);

    return m_selectedCAN->setACn(ACn);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_ACn()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_ACn
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_ACn
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t ACn[4];

    ACn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    ACn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
    ACn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
    ACn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));

    m_selectedNVM->saveString(INIT_FILTER_ACN, serialInput);

    return m_selectedCAN->setACn(ACn);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 9)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 9
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 9
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 9)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 9)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 9)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 9
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 9
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: uint8_t ACn[4];
|————Node:primitive_type Text: uint8_t
|————Node:array_declarator Text: ACn[4]
|—————Node:identifier Text: ACn
|—————Node:[ Text: [
|—————Node:number_literal Text: 4
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: ACn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
|————Node:assignment_expression Text: ACn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2))
|—————Node:subscript_expression Text: ACn[0]
|——————Node:identifier Text: ACn
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(1), serialInput.charAt(2))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(1), serialInput.charAt(2))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(2)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (2)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ACn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
|————Node:assignment_expression Text: ACn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4))
|—————Node:subscript_expression Text: ACn[1]
|——————Node:identifier Text: ACn
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(3), serialInput.charAt(4))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(3), serialInput.charAt(4))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(3)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (3)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 3
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ACn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
|————Node:assignment_expression Text: ACn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6))
|—————Node:subscript_expression Text: ACn[2]
|——————Node:identifier Text: ACn
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(5), serialInput.charAt(6))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(5), serialInput.charAt(6))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(5)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (5)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 5
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(6)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (6)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 6
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ACn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));
|————Node:assignment_expression Text: ACn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8))
|—————Node:subscript_expression Text: ACn[3]
|——————Node:identifier Text: ACn
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(7), serialInput.charAt(8))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(7), serialInput.charAt(8))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(7)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (7)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 7
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(8)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (8)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 8
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedNVM->saveString(INIT_FILTER_ACN, serialInput);
|————Node:call_expression Text: m_selectedNVM->saveString(INIT_FILTER_ACN, serialInput)
|—————Node:field_expression Text: m_selectedNVM->saveString
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: saveString
|—————Node:argument_list Text: (INIT_FILTER_ACN, serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_FILTER_ACN
|——————Node:, Text: ,
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return m_selectedCAN->setACn(ACn);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setACn(ACn)
|—————Node:field_expression Text: m_selectedCAN->setACn
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setACn
|—————Node:argument_list Text: (ACn)
|——————Node:( Text: (
|——————Node:identifier Text: ACn
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_AMn()
{
    if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t AMn[4];

    AMn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    AMn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
    AMn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
    AMn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));

    m_selectedNVM->saveString(INIT_FILTER_AMN, serialInput);

    return m_selectedCAN->setAMn(AMn);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_AMn()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_AMn
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_AMn
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t AMn[4];

    AMn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
    AMn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
    AMn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
    AMn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));

    m_selectedNVM->saveString(INIT_FILTER_AMN, serialInput);

    return m_selectedCAN->setAMn(AMn);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 9)
    {
        return 1;
    }
    else if (_length < 9)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 9)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 9
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 9
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 9)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 9)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 9)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 9
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 9
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: uint8_t AMn[4];
|————Node:primitive_type Text: uint8_t
|————Node:array_declarator Text: AMn[4]
|—————Node:identifier Text: AMn
|—————Node:[ Text: [
|—————Node:number_literal Text: 4
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: AMn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2));
|————Node:assignment_expression Text: AMn[0] = charToByte(serialInput.charAt(1), serialInput.charAt(2))
|—————Node:subscript_expression Text: AMn[0]
|——————Node:identifier Text: AMn
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(1), serialInput.charAt(2))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(1), serialInput.charAt(2))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(2)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (2)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: AMn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4));
|————Node:assignment_expression Text: AMn[1] = charToByte(serialInput.charAt(3), serialInput.charAt(4))
|—————Node:subscript_expression Text: AMn[1]
|——————Node:identifier Text: AMn
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(3), serialInput.charAt(4))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(3), serialInput.charAt(4))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(3)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (3)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 3
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(4)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (4)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: AMn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6));
|————Node:assignment_expression Text: AMn[2] = charToByte(serialInput.charAt(5), serialInput.charAt(6))
|—————Node:subscript_expression Text: AMn[2]
|——————Node:identifier Text: AMn
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(5), serialInput.charAt(6))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(5), serialInput.charAt(6))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(5)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (5)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 5
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(6)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (6)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 6
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: AMn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8));
|————Node:assignment_expression Text: AMn[3] = charToByte(serialInput.charAt(7), serialInput.charAt(8))
|—————Node:subscript_expression Text: AMn[3]
|——————Node:identifier Text: AMn
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: charToByte(serialInput.charAt(7), serialInput.charAt(8))
|——————Node:identifier Text: charToByte
|——————Node:argument_list Text: (serialInput.charAt(7), serialInput.charAt(8))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(7)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (7)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 7
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:call_expression Text: serialInput.charAt(8)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (8)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 8
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedNVM->saveString(INIT_FILTER_AMN, serialInput);
|————Node:call_expression Text: m_selectedNVM->saveString(INIT_FILTER_AMN, serialInput)
|—————Node:field_expression Text: m_selectedNVM->saveString
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: saveString
|—————Node:argument_list Text: (INIT_FILTER_AMN, serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_FILTER_AMN
|——————Node:, Text: ,
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return m_selectedCAN->setAMn(AMn);
|————Node:return Text: return
|————Node:call_expression Text: m_selectedCAN->setAMn(AMn)
|—————Node:field_expression Text: m_selectedCAN->setAMn
|——————Node:identifier Text: m_selectedCAN
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setAMn
|—————Node:argument_list Text: (AMn)
|——————Node:( Text: (
|——————Node:identifier Text: AMn
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Set_Serial_Baudrate()
{
    long _baudrate = 0;

    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 230400;
        break;
    }
    case '1':
    {
        _baudrate = 115200;
        break;
    }
    case '2':
    {
        _baudrate = 57600;
        break;
    }
    case '3':
    {
        _baudrate = 38400;
        break;
    }
    case '4':
    {
        _baudrate = 19200;
        break;
    }
    case '5':
    {
        _baudrate = 9600;
        break;
    }
    case '6':
    {
        _baudrate = 2400;
        break;
    }
    default:
    {
        return 1;
    }
    }

    m_selectedNVM->saveString(INIT_SERIAL_BAUD, serialInput);

    m_selectedSerial->setBaudrate(_baudrate);

    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Set_Serial_Baudrate()
|———Node:qualified_identifier Text: Lawicel::CMD_Set_Serial_Baudrate
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Set_Serial_Baudrate
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    long _baudrate = 0;

    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 230400;
        break;
    }
    case '1':
    {
        _baudrate = 115200;
        break;
    }
    case '2':
    {
        _baudrate = 57600;
        break;
    }
    case '3':
    {
        _baudrate = 38400;
        break;
    }
    case '4':
    {
        _baudrate = 19200;
        break;
    }
    case '5':
    {
        _baudrate = 9600;
        break;
    }
    case '6':
    {
        _baudrate = 2400;
        break;
    }
    default:
    {
        return 1;
    }
    }

    m_selectedNVM->saveString(INIT_SERIAL_BAUD, serialInput);

    m_selectedSerial->setBaudrate(_baudrate);

    return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: long _baudrate = 0;
|————Node:sized_type_specifier Text: long
|—————Node:long Text: long
|————Node:init_declarator Text: _baudrate = 0
|—————Node:identifier Text: _baudrate
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 2)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 2
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:switch_statement Text: switch (serialInput.charAt(1))
    {
    case '0':
    {
        _baudrate = 230400;
        break;
    }
    case '1':
    {
        _baudrate = 115200;
        break;
    }
    case '2':
    {
        _baudrate = 57600;
        break;
    }
    case '3':
    {
        _baudrate = 38400;
        break;
    }
    case '4':
    {
        _baudrate = 19200;
        break;
    }
    case '5':
    {
        _baudrate = 9600;
        break;
    }
    case '6':
    {
        _baudrate = 2400;
        break;
    }
    default:
    {
        return 1;
    }
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (serialInput.charAt(1))
|—————Node:( Text: (
|—————Node:call_expression Text: serialInput.charAt(1)
|——————Node:field_expression Text: serialInput.charAt
|———————Node:identifier Text: serialInput
|———————Node:. Text: .
|———————Node:field_identifier Text: charAt
|——————Node:argument_list Text: (1)
|———————Node:( Text: (
|———————Node:number_literal Text: 1
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case '0':
    {
        _baudrate = 230400;
        break;
    }
    case '1':
    {
        _baudrate = 115200;
        break;
    }
    case '2':
    {
        _baudrate = 57600;
        break;
    }
    case '3':
    {
        _baudrate = 38400;
        break;
    }
    case '4':
    {
        _baudrate = 19200;
        break;
    }
    case '5':
    {
        _baudrate = 9600;
        break;
    }
    case '6':
    {
        _baudrate = 2400;
        break;
    }
    default:
    {
        return 1;
    }
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case '0':
    {
        _baudrate = 230400;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '0'
|———————Node:' Text: '
|———————Node:character Text: 0
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 230400;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 230400;
|————————Node:assignment_expression Text: _baudrate = 230400
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 230400
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '1':
    {
        _baudrate = 115200;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '1'
|———————Node:' Text: '
|———————Node:character Text: 1
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 115200;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 115200;
|————————Node:assignment_expression Text: _baudrate = 115200
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 115200
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '2':
    {
        _baudrate = 57600;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '2'
|———————Node:' Text: '
|———————Node:character Text: 2
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 57600;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 57600;
|————————Node:assignment_expression Text: _baudrate = 57600
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 57600
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '3':
    {
        _baudrate = 38400;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '3'
|———————Node:' Text: '
|———————Node:character Text: 3
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 38400;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 38400;
|————————Node:assignment_expression Text: _baudrate = 38400
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 38400
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '4':
    {
        _baudrate = 19200;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '4'
|———————Node:' Text: '
|———————Node:character Text: 4
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 19200;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 19200;
|————————Node:assignment_expression Text: _baudrate = 19200
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 19200
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '5':
    {
        _baudrate = 9600;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '5'
|———————Node:' Text: '
|———————Node:character Text: 5
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 9600;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 9600;
|————————Node:assignment_expression Text: _baudrate = 9600
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 9600
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case '6':
    {
        _baudrate = 2400;
        break;
    }
|——————Node:case Text: case
|——————Node:char_literal Text: '6'
|———————Node:' Text: '
|———————Node:character Text: 6
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        _baudrate = 2400;
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _baudrate = 2400;
|————————Node:assignment_expression Text: _baudrate = 2400
|—————————Node:identifier Text: _baudrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 2400
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: default:
    {
        return 1;
    }
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: m_selectedNVM->saveString(INIT_SERIAL_BAUD, serialInput);
|————Node:call_expression Text: m_selectedNVM->saveString(INIT_SERIAL_BAUD, serialInput)
|—————Node:field_expression Text: m_selectedNVM->saveString
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: saveString
|—————Node:argument_list Text: (INIT_SERIAL_BAUD, serialInput)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_SERIAL_BAUD
|——————Node:, Text: ,
|——————Node:identifier Text: serialInput
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedSerial->setBaudrate(_baudrate);
|————Node:call_expression Text: m_selectedSerial->setBaudrate(_baudrate)
|—————Node:field_expression Text: m_selectedSerial->setBaudrate
|——————Node:identifier Text: m_selectedSerial
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setBaudrate
|—————Node:argument_list Text: (_baudrate)
|——————Node:( Text: (
|——————Node:identifier Text: _baudrate
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Version()
{
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Version()
|———Node:qualified_identifier Text: Lawicel::CMD_Version
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Version
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    return 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 1
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Serial_Number()
{
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    return 0;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Serial_Number()
|———Node:qualified_identifier Text: Lawicel::CMD_Serial_Number
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Serial_Number
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 1)
    {
        return 1;
    }
    if (_length < 1)
    {
        return 1;
    }

    return 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 1
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_length < 1)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length < 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length < 1
|——————Node:identifier Text: _length
|——————Node:< Text: <
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Timestamp()
{
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t var = charToInt(serialInput.charAt(1));

    m_selectedNVM->save(INIT_TIMESTAMP, var);

    if (var == 0)
    {
        _timestamp = false;
        return 0;
    }
    else if (var == 1)
    {
        _timestamp = true;
        return 0;
    }

    return 1;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Timestamp()
|———Node:qualified_identifier Text: Lawicel::CMD_Timestamp
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Timestamp
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }

    uint8_t var = charToInt(serialInput.charAt(1));

    m_selectedNVM->save(INIT_TIMESTAMP, var);

    if (var == 0)
    {
        _timestamp = false;
        return 0;
    }
    else if (var == 1)
    {
        _timestamp = true;
        return 0;
    }

    return 1;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 2)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 2
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() != CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() != CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: uint8_t var = charToInt(serialInput.charAt(1));
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: var = charToInt(serialInput.charAt(1))
|—————Node:identifier Text: var
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(1))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(1))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_selectedNVM->save(INIT_TIMESTAMP, var);
|————Node:call_expression Text: m_selectedNVM->save(INIT_TIMESTAMP, var)
|—————Node:field_expression Text: m_selectedNVM->save
|——————Node:identifier Text: m_selectedNVM
|——————Node:-> Text: ->
|——————Node:field_identifier Text: save
|—————Node:argument_list Text: (INIT_TIMESTAMP, var)
|——————Node:( Text: (
|——————Node:identifier Text: INIT_TIMESTAMP
|——————Node:, Text: ,
|——————Node:identifier Text: var
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (var == 0)
    {
        _timestamp = false;
        return 0;
    }
    else if (var == 1)
    {
        _timestamp = true;
        return 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (var == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: var == 0
|——————Node:identifier Text: var
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        _timestamp = false;
        return 0;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: _timestamp = false;
|——————Node:assignment_expression Text: _timestamp = false
|———————Node:identifier Text: _timestamp
|———————Node:= Text: =
|———————Node:false Text: false
|——————Node:; Text: ;
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (var == 1)
    {
        _timestamp = true;
        return 0;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (var == 1)
    {
        _timestamp = true;
        return 0;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (var == 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: var == 1
|————————Node:identifier Text: var
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        _timestamp = true;
        return 0;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _timestamp = true;
|————————Node:assignment_expression Text: _timestamp = true
|—————————Node:identifier Text: _timestamp
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:return_statement Text: return 0;
|————————Node:return Text: return
|————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::CMD_Auto_Start()
{
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    int var = charToInt(serialInput.charAt(1));

    if (var <= 2)
    {
        _autostart = var;
        m_selectedNVM->save(INIT_AUTO_START, var);
        return 0;
    }

    return 1;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::CMD_Auto_Start()
|———Node:qualified_identifier Text: Lawicel::CMD_Auto_Start
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: CMD_Auto_Start
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }

    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }

    int var = charToInt(serialInput.charAt(1));

    if (var <= 2)
    {
        _autostart = var;
        m_selectedNVM->save(INIT_AUTO_START, var);
        return 0;
    }

    return 1;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_length > 2)
    {
        return 1;
    }
    else if (_length < 2)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (_length > 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: _length > 2
|——————Node:identifier Text: _length
|——————Node:> Text: >
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (_length < 2)
    {
        return 1;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (_length < 2)
    {
        return 1;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (_length < 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: _length < 2
|————————Node:identifier Text: _length
|————————Node:< Text: <
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        return 1;
    }
|———————Node:{ Text: {
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: int var = charToInt(serialInput.charAt(1));
|————Node:primitive_type Text: int
|————Node:init_declarator Text: var = charToInt(serialInput.charAt(1))
|—————Node:identifier Text: var
|—————Node:= Text: =
|—————Node:call_expression Text: charToInt(serialInput.charAt(1))
|——————Node:identifier Text: charToInt
|——————Node:argument_list Text: (serialInput.charAt(1))
|———————Node:( Text: (
|———————Node:call_expression Text: serialInput.charAt(1)
|————————Node:field_expression Text: serialInput.charAt
|—————————Node:identifier Text: serialInput
|—————————Node:. Text: .
|—————————Node:field_identifier Text: charAt
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (var <= 2)
    {
        _autostart = var;
        m_selectedNVM->save(INIT_AUTO_START, var);
        return 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (var <= 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: var <= 2
|——————Node:identifier Text: var
|——————Node:<= Text: <=
|——————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:compound_statement Text: {
        _autostart = var;
        m_selectedNVM->save(INIT_AUTO_START, var);
        return 0;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: _autostart = var;
|——————Node:assignment_expression Text: _autostart = var
|———————Node:identifier Text: _autostart
|———————Node:= Text: =
|———————Node:identifier Text: var
|——————Node:; Text: ;
|—————Node:expression_statement Text: m_selectedNVM->save(INIT_AUTO_START, var);
|——————Node:call_expression Text: m_selectedNVM->save(INIT_AUTO_START, var)
|———————Node:field_expression Text: m_selectedNVM->save
|————————Node:identifier Text: m_selectedNVM
|————————Node:-> Text: ->
|————————Node:field_identifier Text: save
|———————Node:argument_list Text: (INIT_AUTO_START, var)
|————————Node:( Text: (
|————————Node:identifier Text: INIT_AUTO_START
|————————Node:, Text: ,
|————————Node:identifier Text: var
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: uint8_t Lawicel::Autopoll()
{
    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
    else
    {
        CANInterface::Frame frame = m_selectedCAN->pollSingle();
        char cmd = 't';
        int _id_length = 3;

        if (frame.ID == 0xFFF)
        {
            return 1;
        }

        if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }

        serialReturn += cmd;
        String _ID = String(frame.ID, HEX);
        for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
        serialReturn += _ID;

        long _dlc = frame.DLC;
        serialReturn += frame.DLC;

        if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }

        if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
        return 0;
    }
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: Lawicel::Autopoll()
|———Node:qualified_identifier Text: Lawicel::Autopoll
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: Autopoll
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
    else
    {
        CANInterface::Frame frame = m_selectedCAN->pollSingle();
        char cmd = 't';
        int _id_length = 3;

        if (frame.ID == 0xFFF)
        {
            return 1;
        }

        if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }

        serialReturn += cmd;
        String _ID = String(frame.ID, HEX);
        for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
        serialReturn += _ID;

        long _dlc = frame.DLC;
        serialReturn += frame.DLC;

        if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }

        if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
        return 0;
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
    {
        return 1;
    }
    else
    {
        CANInterface::Frame frame = m_selectedCAN->pollSingle();
        char cmd = 't';
        int _id_length = 3;

        if (frame.ID == 0xFFF)
        {
            return 1;
        }

        if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }

        serialReturn += cmd;
        String _ID = String(frame.ID, HEX);
        for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
        serialReturn += _ID;

        long _dlc = frame.DLC;
        serialReturn += frame.DLC;

        if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }

        if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
        return 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (m_selectedCAN->getChannelState() == CANInterface::CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_selectedCAN->getChannelState() == CANInterface::CLOSED
|——————Node:call_expression Text: m_selectedCAN->getChannelState()
|———————Node:field_expression Text: m_selectedCAN->getChannelState
|————————Node:identifier Text: m_selectedCAN
|————————Node:-> Text: ->
|————————Node:field_identifier Text: getChannelState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:qualified_identifier Text: CANInterface::CLOSED
|———————Node:namespace_identifier Text: CANInterface
|———————Node::: Text: ::
|———————Node:identifier Text: CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return 1;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        CANInterface::Frame frame = m_selectedCAN->pollSingle();
        char cmd = 't';
        int _id_length = 3;

        if (frame.ID == 0xFFF)
        {
            return 1;
        }

        if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }

        serialReturn += cmd;
        String _ID = String(frame.ID, HEX);
        for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
        serialReturn += _ID;

        long _dlc = frame.DLC;
        serialReturn += frame.DLC;

        if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }

        if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
        return 0;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        CANInterface::Frame frame = m_selectedCAN->pollSingle();
        char cmd = 't';
        int _id_length = 3;

        if (frame.ID == 0xFFF)
        {
            return 1;
        }

        if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }

        serialReturn += cmd;
        String _ID = String(frame.ID, HEX);
        for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
        serialReturn += _ID;

        long _dlc = frame.DLC;
        serialReturn += frame.DLC;

        if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }

        if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
        return 0;
    }
|——————Node:{ Text: {
|——————Node:declaration Text: CANInterface::Frame frame = m_selectedCAN->pollSingle();
|———————Node:qualified_identifier Text: CANInterface::Frame
|————————Node:namespace_identifier Text: CANInterface
|————————Node::: Text: ::
|————————Node:type_identifier Text: Frame
|———————Node:init_declarator Text: frame = m_selectedCAN->pollSingle()
|————————Node:identifier Text: frame
|————————Node:= Text: =
|————————Node:call_expression Text: m_selectedCAN->pollSingle()
|—————————Node:field_expression Text: m_selectedCAN->pollSingle
|——————————Node:identifier Text: m_selectedCAN
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: pollSingle
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:declaration Text: char cmd = 't';
|———————Node:primitive_type Text: char
|———————Node:init_declarator Text: cmd = 't'
|————————Node:identifier Text: cmd
|————————Node:= Text: =
|————————Node:char_literal Text: 't'
|—————————Node:' Text: '
|—————————Node:character Text: t
|—————————Node:' Text: '
|———————Node:; Text: ;
|——————Node:declaration Text: int _id_length = 3;
|———————Node:primitive_type Text: int
|———————Node:init_declarator Text: _id_length = 3
|————————Node:identifier Text: _id_length
|————————Node:= Text: =
|————————Node:number_literal Text: 3
|———————Node:; Text: ;
|——————Node:if_statement Text: if (frame.ID == 0xFFF)
        {
            return 1;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (frame.ID == 0xFFF)
|————————Node:( Text: (
|————————Node:binary_expression Text: frame.ID == 0xFFF
|—————————Node:field_expression Text: frame.ID
|——————————Node:identifier Text: frame
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ID
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 0xFFF
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            return 1;
        }
|————————Node:{ Text: {
|————————Node:return_statement Text: return 1;
|—————————Node:return Text: return
|—————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:if_statement Text: if (frame.Extended == true && frame.RTR == false)
        {
            cmd = 'T';
            _id_length = 8;
        }
        else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (frame.Extended == true && frame.RTR == false)
|————————Node:( Text: (
|————————Node:binary_expression Text: frame.Extended == true && frame.RTR == false
|—————————Node:binary_expression Text: frame.Extended == true
|——————————Node:field_expression Text: frame.Extended
|———————————Node:identifier Text: frame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Extended
|——————————Node:== Text: ==
|——————————Node:true Text: true
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: frame.RTR == false
|——————————Node:field_expression Text: frame.RTR
|———————————Node:identifier Text: frame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: RTR
|——————————Node:== Text: ==
|——————————Node:false Text: false
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            cmd = 'T';
            _id_length = 8;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: cmd = 'T';
|—————————Node:assignment_expression Text: cmd = 'T'
|——————————Node:identifier Text: cmd
|——————————Node:= Text: =
|——————————Node:char_literal Text: 'T'
|———————————Node:' Text: '
|———————————Node:character Text: T
|———————————Node:' Text: '
|—————————Node:; Text: ;
|————————Node:expression_statement Text: _id_length = 8;
|—————————Node:assignment_expression Text: _id_length = 8
|——————————Node:identifier Text: _id_length
|——————————Node:= Text: =
|——————————Node:number_literal Text: 8
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }
|————————Node:else Text: else
|————————Node:if_statement Text: if (frame.Extended == false && frame.RTR == true)
        {
            cmd = 'r';
        }
        else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (frame.Extended == false && frame.RTR == true)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: frame.Extended == false && frame.RTR == true
|———————————Node:binary_expression Text: frame.Extended == false
|————————————Node:field_expression Text: frame.Extended
|—————————————Node:identifier Text: frame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: Extended
|————————————Node:== Text: ==
|————————————Node:false Text: false
|———————————Node:&& Text: &&
|———————————Node:binary_expression Text: frame.RTR == true
|————————————Node:field_expression Text: frame.RTR
|—————————————Node:identifier Text: frame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: RTR
|————————————Node:== Text: ==
|————————————Node:true Text: true
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
            cmd = 'r';
        }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: cmd = 'r';
|———————————Node:assignment_expression Text: cmd = 'r'
|————————————Node:identifier Text: cmd
|————————————Node:= Text: =
|————————————Node:char_literal Text: 'r'
|—————————————Node:' Text: '
|—————————————Node:character Text: r
|—————————————Node:' Text: '
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (frame.Extended == true && frame.RTR == true)
        {
            cmd = 'R';
            _id_length = 8;
        }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (frame.Extended == true && frame.RTR == true)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: frame.Extended == true && frame.RTR == true
|—————————————Node:binary_expression Text: frame.Extended == true
|——————————————Node:field_expression Text: frame.Extended
|———————————————Node:identifier Text: frame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: Extended
|——————————————Node:== Text: ==
|——————————————Node:true Text: true
|—————————————Node:&& Text: &&
|—————————————Node:binary_expression Text: frame.RTR == true
|——————————————Node:field_expression Text: frame.RTR
|———————————————Node:identifier Text: frame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: RTR
|——————————————Node:== Text: ==
|——————————————Node:true Text: true
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
            cmd = 'R';
            _id_length = 8;
        }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: cmd = 'R';
|—————————————Node:assignment_expression Text: cmd = 'R'
|——————————————Node:identifier Text: cmd
|——————————————Node:= Text: =
|——————————————Node:char_literal Text: 'R'
|———————————————Node:' Text: '
|———————————————Node:character Text: R
|———————————————Node:' Text: '
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: _id_length = 8;
|—————————————Node:assignment_expression Text: _id_length = 8
|——————————————Node:identifier Text: _id_length
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 8
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|——————Node:expression_statement Text: serialReturn += cmd;
|———————Node:assignment_expression Text: serialReturn += cmd
|————————Node:identifier Text: serialReturn
|————————Node:+= Text: +=
|————————Node:identifier Text: cmd
|———————Node:; Text: ;
|——————Node:declaration Text: String _ID = String(frame.ID, HEX);
|———————Node:type_identifier Text: String
|———————Node:init_declarator Text: _ID = String(frame.ID, HEX)
|————————Node:identifier Text: _ID
|————————Node:= Text: =
|————————Node:call_expression Text: String(frame.ID, HEX)
|—————————Node:identifier Text: String
|—————————Node:argument_list Text: (frame.ID, HEX)
|——————————Node:( Text: (
|——————————Node:field_expression Text: frame.ID
|———————————Node:identifier Text: frame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ID
|——————————Node:, Text: ,
|——————————Node:identifier Text: HEX
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:for_statement Text: for (int i = 0; i < _id_length - _ID.length(); i++)
        {
            serialReturn += '0';
        }
|———————Node:for Text: for
|———————Node:( Text: (
|———————Node:declaration Text: int i = 0;
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: i = 0
|—————————Node:identifier Text: i
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:binary_expression Text: i < _id_length - _ID.length()
|————————Node:identifier Text: i
|————————Node:< Text: <
|————————Node:binary_expression Text: _id_length - _ID.length()
|—————————Node:identifier Text: _id_length
|—————————Node:- Text: -
|—————————Node:call_expression Text: _ID.length()
|——————————Node:field_expression Text: _ID.length
|———————————Node:identifier Text: _ID
|———————————Node:. Text: .
|———————————Node:field_identifier Text: length
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|———————Node:; Text: ;
|———————Node:update_expression Text: i++
|————————Node:identifier Text: i
|————————Node:++ Text: ++
|———————Node:) Text: )
|———————Node:compound_statement Text: {
            serialReturn += '0';
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: serialReturn += '0';
|—————————Node:assignment_expression Text: serialReturn += '0'
|——————————Node:identifier Text: serialReturn
|——————————Node:+= Text: +=
|——————————Node:char_literal Text: '0'
|———————————Node:' Text: '
|———————————Node:character Text: 0
|———————————Node:' Text: '
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: serialReturn += _ID;
|———————Node:assignment_expression Text: serialReturn += _ID
|————————Node:identifier Text: serialReturn
|————————Node:+= Text: +=
|————————Node:identifier Text: _ID
|———————Node:; Text: ;
|——————Node:declaration Text: long _dlc = frame.DLC;
|———————Node:sized_type_specifier Text: long
|————————Node:long Text: long
|———————Node:init_declarator Text: _dlc = frame.DLC
|————————Node:identifier Text: _dlc
|————————Node:= Text: =
|————————Node:field_expression Text: frame.DLC
|—————————Node:identifier Text: frame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|———————Node:; Text: ;
|——————Node:expression_statement Text: serialReturn += frame.DLC;
|———————Node:assignment_expression Text: serialReturn += frame.DLC
|————————Node:identifier Text: serialReturn
|————————Node:+= Text: +=
|————————Node:field_expression Text: frame.DLC
|—————————Node:identifier Text: frame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|———————Node:; Text: ;
|——————Node:if_statement Text: if (frame.RTR == false)
        {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (frame.RTR == false)
|————————Node:( Text: (
|————————Node:binary_expression Text: frame.RTR == false
|—————————Node:field_expression Text: frame.RTR
|——————————Node:identifier Text: frame
|——————————Node:. Text: .
|——————————Node:field_identifier Text: RTR
|—————————Node:== Text: ==
|—————————Node:false Text: false
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
        }
|————————Node:{ Text: {
|————————Node:for_statement Text: for (int i = 0; i < _dlc; i++)
            {
                serialReturn += String(frame.Data[i], HEX);
            }
|—————————Node:for Text: for
|—————————Node:( Text: (
|—————————Node:declaration Text: int i = 0;
|——————————Node:primitive_type Text: int
|——————————Node:init_declarator Text: i = 0
|———————————Node:identifier Text: i
|———————————Node:= Text: =
|———————————Node:number_literal Text: 0
|——————————Node:; Text: ;
|—————————Node:binary_expression Text: i < _dlc
|——————————Node:identifier Text: i
|——————————Node:< Text: <
|——————————Node:identifier Text: _dlc
|—————————Node:; Text: ;
|—————————Node:update_expression Text: i++
|——————————Node:identifier Text: i
|——————————Node:++ Text: ++
|—————————Node:) Text: )
|—————————Node:compound_statement Text: {
                serialReturn += String(frame.Data[i], HEX);
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: serialReturn += String(frame.Data[i], HEX);
|———————————Node:assignment_expression Text: serialReturn += String(frame.Data[i], HEX)
|————————————Node:identifier Text: serialReturn
|————————————Node:+= Text: +=
|————————————Node:call_expression Text: String(frame.Data[i], HEX)
|—————————————Node:identifier Text: String
|—————————————Node:argument_list Text: (frame.Data[i], HEX)
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: frame.Data[i]
|———————————————Node:field_expression Text: frame.Data
|————————————————Node:identifier Text: frame
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: Data
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: HEX
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|——————Node:if_statement Text: if (_timestamp)
        {
            serialReturn += String(getTimestamp(), HEX);
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (_timestamp)
|————————Node:( Text: (
|————————Node:identifier Text: _timestamp
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            serialReturn += String(getTimestamp(), HEX);
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: serialReturn += String(getTimestamp(), HEX);
|—————————Node:assignment_expression Text: serialReturn += String(getTimestamp(), HEX)
|——————————Node:identifier Text: serialReturn
|——————————Node:+= Text: +=
|——————————Node:call_expression Text: String(getTimestamp(), HEX)
|———————————Node:identifier Text: String
|———————————Node:argument_list Text: (getTimestamp(), HEX)
|————————————Node:( Text: (
|————————————Node:call_expression Text: getTimestamp()
|—————————————Node:identifier Text: getTimestamp
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:identifier Text: HEX
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**************************************************************************************************/
|—Node:function_definition Text: int Lawicel::getTimestamp()
{
    return millis() % MAX_TIMESTAMP;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: Lawicel::getTimestamp()
|———Node:qualified_identifier Text: Lawicel::getTimestamp
|————Node:namespace_identifier Text: Lawicel
|————Node::: Text: ::
|————Node:identifier Text: getTimestamp
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    return millis() % MAX_TIMESTAMP;
}
|———Node:{ Text: {
|———Node:return_statement Text: return millis() % MAX_TIMESTAMP;
|————Node:return Text: return
|————Node:binary_expression Text: millis() % MAX_TIMESTAMP
|—————Node:call_expression Text: millis()
|——————Node:identifier Text: millis
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:% Text: %
|—————Node:identifier Text: MAX_TIMESTAMP
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* EXTERNAL FUNCTIONS *****************************************************************************/
|—Node:comment Text: /* INTERNAL FUNCTIONS *****************************************************************************/
