can4linux-can4linux\ems_pci.c

|Node:translation_unit
|—Node:comment Text: /* EMS CPC-PCI card handling
 * 
 * This still is old-style handling
 * walking through the list of PCI devices manually
 * This has to be replaced by pci_register_driver()
 * and the pci_probe function()
 */
|—Node:preproc_include Text: #include "defs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "defs.h"
|———Node:" Text: "
|———Node:string_content Text: defs.h
|———Node:" Text: "
|—Node:preproc_include Text: #include <linux/pci.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/pci.h>
|—Node:preproc_ifdef Text: #ifdef CAN4LINUX_PCI
# ifndef CONFIG_PCI
#   error "trying to compile a PCI driver for a kernel without CONFIG_PCI"
# endif

#ifdef CAN4LINUX_PCI


int Can_RequestIrq(int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)(int, void *))
#else
    irqreturn_t (*handler)(int, void *, struct pt_regs *))
#endif
{
int err = 0;

    DBGin();
    /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif


    if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
    DBGout(); return err;
}


int Can_FreeIrq(int minor, int irq )
{
    DBGin();
    IRQ_requested[minor] = 0;
    /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
    free_irq(irq, &Can_minors[minor]);
    DBGout();
    return 0;
}

/*
 * Perform Vendor-Init, that means sometimes CAN controller
 * or only board manufacturer specific initialization.
 *
 * Mainly it gets needed IO and IRQ ressources and initilaizes 
 * special hardware functions.
 *
 */

int CAN_VendorInit (int minor)
{
    DBGin();
    can_range[minor] = CAN_RANGE;
    
    /* PCI scan for CPC-PCI (or others ) has already remapped the address */
    /* printk(" assign address direct\n"); */
    can_base[minor] = (void __iomem *)Base[minor];

    /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */ 

    /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
    if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
    DBGout(); return 0;
}








/* reset both CAN controllers on the EMS-Wnsche CPC-PCI Board */
/* writing to the control range at BAR1 of the PCI board */
void reset_CPC_PCI(unsigned long address)
{
unsigned long ptr = (unsigned long)ioremap(address, 32);
    writeb(0x01, (void __iomem *)ptr);
}

/* check memory region if there is a CAN controller
*  assume the controller was resetted before testing 
*
*  The check for an avaliable controller is difficult !
*  After an Hardware Reset (or power on) the Conroller 
*  is in the so-called 'BasicCAN' mode.
*     we can check for: 
*         adress  name      value
*	    0x00  mode       0x21
*           0x02  status     0xc0
*           0x03  interrupt  0xe0
* Once loaded the driver switches into 'PeliCAN' mode and things are getting
* difficult, because we now have only a 'soft reset' with not so  unique
* values. The values have to be masked before comparing.
*         adress  name       mask   value
*	    0x00  mode               
*           0x01  command    0xff    0x00
*           0x02  status     0x37    0x34
*           0x03  interrupt  0xfb    0x00
*
*/
int controller_available(upointer_t address, int offset)
{
/* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
void __iomem *ptr = ioremap(address, CAN_RANGE);


#if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif


    if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
}
#endif




#define PCI_BASE_ADDRESS0(dev) (dev->resource[0].start)
#define PCI_BASE_ADDRESS1(dev) (dev->resource[1].start)
#define PCI_BASE_ADDRESS2(dev) (dev->resource[2].start)
#define PCI_BASE_ADDRESS3(dev) (dev->resource[3].start)

/* used for storing the global pci register address */
upointer_t Can_pitapci_control[MAX_CHANNELS];

# if defined(CPC_PCI)



#ifndef PCI_DEVICE_ID_PLX_9030
#define PCI_DEVICE_ID_PLX_9030 0x9030
#endif

#if 0
static struct pci_device_id  ems_pci_tbl[] = {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
};
#endif

int register_new_cpcpci(struct pci_dev *pdev, int i)
{
void __iomem *ptr;		/* ptr to PCI control registers*/
void __iomem *cptr;		/* ptr to start of CAN control registers*/
int j;				/* loop through possible CAN controllers */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    	                 /* dev, bar, size */
    ptr		= pci_iomap(pdev, 0, 128);
    cptr	= pci_iomap(pdev, 2, 2048);


    printk("cptr= %p \n", cptr);

    /* look for a CAN controllers starting at 0x400 */
    for(j = 0; j < 4; j++) {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
    /* enable IRQ in PLX 9030 */
    writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR);
    DBGout();
    return i;	/* returns last CAN controller number found */
}



/* check if the pci device is a valid old style CPC-PCI and 
gett all the hardware information nneded and fill in the board information
the device itself is already registered  pci_enable_device()
*/
int register_old_cpcpci(struct pci_dev *pdev, int i)
{
unsigned long ptr;		/* ptr to PITA control */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    err("int i ist %d", i);

    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
    /* enable memory access */
    /* printk("write to pita\n"); */
    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
    Can_pitapci_control[i] = ptr;

    /* printk("        pita ptr %lx\n", ptr); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

    /* PCI_BASE_ADDRESS1:
     * at address 0 are some EMS control registers
     * at address 0x400 the first controller area 
     * at address 0x600 the second controller area 
     * registers are read as 32bit
     *
     * at adress 0 we can verify the card
     * 0x55 0xaa 0x01 0xcb
*/
    {
	void __iomem *sigptr; /* ptr to EMS signature  */
	unsigned long signature = 0;
	sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
	/* printk("        signature  %lx\n", signature); */
	if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
    }
    /* we are now sure to have the right board,
       reset the CAN controller(s) */
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

    /* enable interrupts Int_0 */
    /* write to PITAs ICR register */
    writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR);

    err("int i ist %d", i);
    /* look for a CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }

    err("int i ist %d", i);
    /* look for a second CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }

    err("int i ist %d", i);
    DBGout();
    return i;
}

int new_pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;			/* number of devices found */
int	minor = -1;			/* to make DBGin() happy */

    DBGin();
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
#endif
    DBGout();
    return 0;
}


/* Should be replaced by  new_pcimod_scan() soon
 * to be able to handle both kinds of CPC-PCI
 * hopefully for both boards with the same driver
 * and if possible for the Kvaser PCI as well
 */
int pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;				/* number of devices found */
unsigned long ptr;				/* ptr to PITA control */

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
#endif
    return 0;
}


void board_clear_interrupts(int minor)
{

/* old  Siemens PITA */
    /* Interrupt_0_Enable (bit 17) + Int_0_Reset (bit 1) */
    /*  
     Uttenthaler:
      nur 
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
      als letzte Anweisung in der ISR
     Schoett:
      bei Eintritt
        writel(0x00000000, Can_pitapci_control[minor] + 0x0);
      am ende
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
    */
    writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0);
    writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0);

/* new */

    writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR);

}
# endif 	/* defined(CPC_PCI) */

#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: CAN4LINUX_PCI
|——Node:preproc_ifdef Text: # ifndef CONFIG_PCI
#   error "trying to compile a PCI driver for a kernel without CONFIG_PCI"
# endif
|———Node:#ifndef Text: # ifndef
|———Node:identifier Text: CONFIG_PCI
|———Node:preproc_call Text: #   error "trying to compile a PCI driver for a kernel without CONFIG_PCI"

|————Node:preproc_directive Text: #   error
|————Node:preproc_arg Text: "trying to compile a PCI driver for a kernel without CONFIG_PCI"
|———Node:#endif Text: # endif
|——Node:preproc_ifdef Text: #ifdef CAN4LINUX_PCI


int Can_RequestIrq(int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)(int, void *))
#else
    irqreturn_t (*handler)(int, void *, struct pt_regs *))
#endif
{
int err = 0;

    DBGin();
    /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif


    if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
    DBGout(); return err;
}


int Can_FreeIrq(int minor, int irq )
{
    DBGin();
    IRQ_requested[minor] = 0;
    /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
    free_irq(irq, &Can_minors[minor]);
    DBGout();
    return 0;
}

/*
 * Perform Vendor-Init, that means sometimes CAN controller
 * or only board manufacturer specific initialization.
 *
 * Mainly it gets needed IO and IRQ ressources and initilaizes 
 * special hardware functions.
 *
 */

int CAN_VendorInit (int minor)
{
    DBGin();
    can_range[minor] = CAN_RANGE;
    
    /* PCI scan for CPC-PCI (or others ) has already remapped the address */
    /* printk(" assign address direct\n"); */
    can_base[minor] = (void __iomem *)Base[minor];

    /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */ 

    /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
    if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
    DBGout(); return 0;
}








/* reset both CAN controllers on the EMS-Wnsche CPC-PCI Board */
/* writing to the control range at BAR1 of the PCI board */
void reset_CPC_PCI(unsigned long address)
{
unsigned long ptr = (unsigned long)ioremap(address, 32);
    writeb(0x01, (void __iomem *)ptr);
}

/* check memory region if there is a CAN controller
*  assume the controller was resetted before testing 
*
*  The check for an avaliable controller is difficult !
*  After an Hardware Reset (or power on) the Conroller 
*  is in the so-called 'BasicCAN' mode.
*     we can check for: 
*         adress  name      value
*	    0x00  mode       0x21
*           0x02  status     0xc0
*           0x03  interrupt  0xe0
* Once loaded the driver switches into 'PeliCAN' mode and things are getting
* difficult, because we now have only a 'soft reset' with not so  unique
* values. The values have to be masked before comparing.
*         adress  name       mask   value
*	    0x00  mode               
*           0x01  command    0xff    0x00
*           0x02  status     0x37    0x34
*           0x03  interrupt  0xfb    0x00
*
*/
int controller_available(upointer_t address, int offset)
{
/* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
void __iomem *ptr = ioremap(address, CAN_RANGE);


#if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif


    if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
}
#endif
|———Node:#ifdef Text: #ifdef
|———Node:identifier Text: CAN4LINUX_PCI
|———Node:ERROR Text: int Can_RequestIrq(int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)(int, void *))
|————Node:primitive_type Text: int
|————Node:function_declarator Text: Can_RequestIrq(int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)(int, void *)
|—————Node:function_declarator Text: Can_RequestIrq(int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)
|——————Node:identifier Text: Can_RequestIrq
|——————Node:parameter_list Text: (int minor, int irq,
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: int minor
|————————Node:primitive_type Text: int
|————————Node:identifier Text: minor
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: int irq
|————————Node:primitive_type Text: int
|————————Node:identifier Text: irq
|———————Node:, Text: ,
|———————Node:ERROR Text: #if
|————————Node:#if Text: #if
|———————Node:parameter_declaration Text: LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    irqreturn_t (*handler
|————————Node:type_identifier Text: LINUX_VERSION_CODE
|————————Node:ERROR Text: > KERNEL_VERSION(2,6,18) 
    irqreturn_t (
|—————————Node:> Text: >
|—————————Node:identifier Text: KERNEL_VERSION
|—————————Node:parameter_list Text: (2,6,18)
|——————————Node:( Text: (
|——————————Node:ERROR Text: 2,6,18
|———————————Node:number_literal Text: 2
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 6
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 18
|——————————Node:) Text: )
|—————————Node:identifier Text: irqreturn_t
|—————————Node:( Text: (
|————————Node:pointer_declarator Text: *handler
|—————————Node:* Text: *
|—————————Node:identifier Text: handler
|———————Node:) Text: )
|—————Node:parameter_list Text: (int, void *)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: int
|———————Node:primitive_type Text: int
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: void *
|———————Node:primitive_type Text: void
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|————Node:) Text: )
|———Node:preproc_else Text: #else
    irqreturn_t (*handler)(int, void *, struct pt_regs *))
#endif
{
int err = 0;

    DBGin();
    /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif


    if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
    DBGout(); return err;
}


int Can_FreeIrq(int minor, int irq )
{
    DBGin();
    IRQ_requested[minor] = 0;
    /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
    free_irq(irq, &Can_minors[minor]);
    DBGout();
    return 0;
}

/*
 * Perform Vendor-Init, that means sometimes CAN controller
 * or only board manufacturer specific initialization.
 *
 * Mainly it gets needed IO and IRQ ressources and initilaizes 
 * special hardware functions.
 *
 */

int CAN_VendorInit (int minor)
{
    DBGin();
    can_range[minor] = CAN_RANGE;
    
    /* PCI scan for CPC-PCI (or others ) has already remapped the address */
    /* printk(" assign address direct\n"); */
    can_base[minor] = (void __iomem *)Base[minor];

    /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */ 

    /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
    if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
    DBGout(); return 0;
}








/* reset both CAN controllers on the EMS-Wnsche CPC-PCI Board */
/* writing to the control range at BAR1 of the PCI board */
void reset_CPC_PCI(unsigned long address)
{
unsigned long ptr = (unsigned long)ioremap(address, 32);
    writeb(0x01, (void __iomem *)ptr);
}

/* check memory region if there is a CAN controller
*  assume the controller was resetted before testing 
*
*  The check for an avaliable controller is difficult !
*  After an Hardware Reset (or power on) the Conroller 
*  is in the so-called 'BasicCAN' mode.
*     we can check for: 
*         adress  name      value
*	    0x00  mode       0x21
*           0x02  status     0xc0
*           0x03  interrupt  0xe0
* Once loaded the driver switches into 'PeliCAN' mode and things are getting
* difficult, because we now have only a 'soft reset' with not so  unique
* values. The values have to be masked before comparing.
*         adress  name       mask   value
*	    0x00  mode               
*           0x01  command    0xff    0x00
*           0x02  status     0x37    0x34
*           0x03  interrupt  0xfb    0x00
*
*/
int controller_available(upointer_t address, int offset)
{
/* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
void __iomem *ptr = ioremap(address, CAN_RANGE);


#if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif


    if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
}
|————Node:#else Text: #else
|————Node:function_definition Text: irqreturn_t (*handler)(int, void *, struct pt_regs *))
#endif
{
int err = 0;

    DBGin();
    /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif


    if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
    DBGout(); return err;
}
|—————Node:type_identifier Text: irqreturn_t
|—————Node:function_declarator Text: (*handler)(int, void *, struct pt_regs *)
|——————Node:parenthesized_declarator Text: (*handler)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *handler
|————————Node:* Text: *
|————————Node:identifier Text: handler
|———————Node:) Text: )
|——————Node:parameter_list Text: (int, void *, struct pt_regs *)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: int
|————————Node:primitive_type Text: int
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: void *
|————————Node:primitive_type Text: void
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: struct pt_regs *
|————————Node:struct_specifier Text: struct pt_regs
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: pt_regs
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|—————Node:ERROR Text: )
#endif
|——————Node:) Text: )
|——————Node:#endif Text: #endif
|—————Node:compound_statement Text: {
int err = 0;

    DBGin();
    /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif


    if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
    DBGout(); return err;
}
|——————Node:{ Text: {
|——————Node:declaration Text: int err = 0;
|———————Node:primitive_type Text: int
|———————Node:init_declarator Text: err = 0
|————————Node:identifier Text: err
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: DBGin();
|———————Node:call_expression Text: DBGin()
|————————Node:identifier Text: DBGin
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: /*

    int request_irq(unsigned int irq,			// interrupt number  
              void (*handler)(int, void *, struct pt_regs *), // pointer to ISR
		              irq, dev_id, registers on stack
              unsigned long irqflags, const char *devname,
              void *dev_id);

       dev_id - The device ID of this handler (see below).       
       This parameter is usually set to NULL,
       but should be non-null if you wish to do  IRQ  sharing.
       This  doesn't  matter when hooking the
       interrupt, but is required so  that,  when  free_irq()  is
       called,  the  correct driver is unhooked.  Since this is a
       void *, it can point to anything (such  as  a  device-spe-
       cific  structure,  or even empty space), but make sure you
       pass the same pointer to free_irq().

    */
|——————Node:preproc_if Text: #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) 
    err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
#else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
#endif
|———————Node:#if Text: #if
|———————Node:binary_expression Text: LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
|————————Node:identifier Text: LINUX_VERSION_CODE
|————————Node:> Text: >
|————————Node:call_expression Text: KERNEL_VERSION(2,6,18)
|—————————Node:identifier Text: KERNEL_VERSION
|—————————Node:argument_list Text: (2,6,18)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 2
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 6
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 18
|——————————Node:) Text: )
|———————Node:
 Text: 

|———————Node:expression_statement Text: err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor]);
|————————Node:assignment_expression Text: err = request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor])
|—————————Node:identifier Text: err
|—————————Node:= Text: =
|—————————Node:call_expression Text: request_irq(irq, handler, IRQF_SHARED, "Can", &Can_minors[minor])
|——————————Node:identifier Text: request_irq
|——————————Node:argument_list Text: (irq, handler, IRQF_SHARED, "Can", &Can_minors[minor])
|———————————Node:( Text: (
|———————————Node:identifier Text: irq
|———————————Node:, Text: ,
|———————————Node:identifier Text: handler
|———————————Node:, Text: ,
|———————————Node:identifier Text: IRQF_SHARED
|———————————Node:, Text: ,
|———————————Node:string_literal Text: "Can"
|————————————Node:" Text: "
|————————————Node:string_content Text: Can
|————————————Node:" Text: "
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &Can_minors[minor]
|————————————Node:& Text: &
|————————————Node:subscript_expression Text: Can_minors[minor]
|—————————————Node:identifier Text: Can_minors
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: minor
|—————————————Node:] Text: ]
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:preproc_else Text: #else
    err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
|————————Node:#else Text: #else
|————————Node:expression_statement Text: err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor]);
|—————————Node:assignment_expression Text: err = request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor])
|——————————Node:identifier Text: err
|——————————Node:= Text: =
|——————————Node:call_expression Text: request_irq(irq, handler, SA_SHIRQ, "Can", &Can_minors[minor])
|———————————Node:identifier Text: request_irq
|———————————Node:argument_list Text: (irq, handler, SA_SHIRQ, "Can", &Can_minors[minor])
|————————————Node:( Text: (
|————————————Node:identifier Text: irq
|————————————Node:, Text: ,
|————————————Node:identifier Text: handler
|————————————Node:, Text: ,
|————————————Node:identifier Text: SA_SHIRQ
|————————————Node:, Text: ,
|————————————Node:string_literal Text: "Can"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: Can
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:pointer_expression Text: &Can_minors[minor]
|—————————————Node:& Text: &
|—————————————Node:subscript_expression Text: Can_minors[minor]
|——————————————Node:identifier Text: Can_minors
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: minor
|——————————————Node:] Text: ]
|————————————Node:) Text: )
|—————————Node:; Text: ;
|———————Node:#endif Text: #endif
|——————Node:if_statement Text: if( !err ){
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ( !err )
|————————Node:( Text: (
|————————Node:unary_expression Text: !err
|—————————Node:! Text: !
|—————————Node:identifier Text: err
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
      IRQ_requested[minor] = 1;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler));
|—————————Node:call_expression Text: DBGprint(DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler))
|——————————Node:identifier Text: DBGprint
|——————————Node:argument_list Text: (DBG_BRANCH,("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler))
|———————————Node:( Text: (
|———————————Node:identifier Text: DBG_BRANCH
|———————————Node:, Text: ,
|———————————Node:parenthesized_expression Text: ("Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler)
|————————————Node:( Text: (
|————————————Node:comma_expression Text: "Requested IRQ: %d @ 0x%lx",
      				irq, (unsigned long)handler
|—————————————Node:string_literal Text: "Requested IRQ: %d @ 0x%lx"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: Requested IRQ: %d @ 0x%lx
|——————————————Node:" Text: "
|—————————————Node:, Text: ,
|—————————————Node:comma_expression Text: irq, (unsigned long)handler
|——————————————Node:identifier Text: irq
|——————————————Node:, Text: ,
|——————————————Node:cast_expression Text: (unsigned long)handler
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: unsigned long
|————————————————Node:sized_type_specifier Text: unsigned long
|—————————————————Node:unsigned Text: unsigned
|—————————————————Node:long Text: long
|———————————————Node:) Text: )
|———————————————Node:identifier Text: handler
|————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: IRQ_requested[minor] = 1;
|—————————Node:assignment_expression Text: IRQ_requested[minor] = 1
|——————————Node:subscript_expression Text: IRQ_requested[minor]
|———————————Node:identifier Text: IRQ_requested
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: DBGout();
|———————Node:call_expression Text: DBGout()
|————————Node:identifier Text: DBGout
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:return_statement Text: return err;
|———————Node:return Text: return
|———————Node:identifier Text: err
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:function_definition Text: int Can_FreeIrq(int minor, int irq )
{
    DBGin();
    IRQ_requested[minor] = 0;
    /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
    free_irq(irq, &Can_minors[minor]);
    DBGout();
    return 0;
}
|—————Node:primitive_type Text: int
|—————Node:function_declarator Text: Can_FreeIrq(int minor, int irq )
|——————Node:identifier Text: Can_FreeIrq
|——————Node:parameter_list Text: (int minor, int irq )
|———————Node:( Text: (
|———————Node:parameter_declaration Text: int minor
|————————Node:primitive_type Text: int
|————————Node:identifier Text: minor
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: int irq
|————————Node:primitive_type Text: int
|————————Node:identifier Text: irq
|———————Node:) Text: )
|—————Node:compound_statement Text: {
    DBGin();
    IRQ_requested[minor] = 0;
    /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
    free_irq(irq, &Can_minors[minor]);
    DBGout();
    return 0;
}
|——————Node:{ Text: {
|——————Node:expression_statement Text: DBGin();
|———————Node:call_expression Text: DBGin()
|————————Node:identifier Text: DBGin
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: IRQ_requested[minor] = 0;
|———————Node:assignment_expression Text: IRQ_requested[minor] = 0
|————————Node:subscript_expression Text: IRQ_requested[minor]
|—————————Node:identifier Text: IRQ_requested
|—————————Node:[ Text: [
|—————————Node:identifier Text: minor
|—————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:comment Text: /* printk(" Free IRQ %d  minor %d\n", irq, minor);  */
|——————Node:expression_statement Text: free_irq(irq, &Can_minors[minor]);
|———————Node:call_expression Text: free_irq(irq, &Can_minors[minor])
|————————Node:identifier Text: free_irq
|————————Node:argument_list Text: (irq, &Can_minors[minor])
|—————————Node:( Text: (
|—————————Node:identifier Text: irq
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &Can_minors[minor]
|——————————Node:& Text: &
|——————————Node:subscript_expression Text: Can_minors[minor]
|———————————Node:identifier Text: Can_minors
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: DBGout();
|———————Node:call_expression Text: DBGout()
|————————Node:identifier Text: DBGout
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment Text: /*
 * Perform Vendor-Init, that means sometimes CAN controller
 * or only board manufacturer specific initialization.
 *
 * Mainly it gets needed IO and IRQ ressources and initilaizes 
 * special hardware functions.
 *
 */
|————Node:function_definition Text: int CAN_VendorInit (int minor)
{
    DBGin();
    can_range[minor] = CAN_RANGE;
    
    /* PCI scan for CPC-PCI (or others ) has already remapped the address */
    /* printk(" assign address direct\n"); */
    can_base[minor] = (void __iomem *)Base[minor];

    /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */ 

    /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
    if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
    DBGout(); return 0;
}
|—————Node:primitive_type Text: int
|—————Node:function_declarator Text: CAN_VendorInit (int minor)
|——————Node:identifier Text: CAN_VendorInit
|——————Node:parameter_list Text: (int minor)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: int minor
|————————Node:primitive_type Text: int
|————————Node:identifier Text: minor
|———————Node:) Text: )
|—————Node:compound_statement Text: {
    DBGin();
    can_range[minor] = CAN_RANGE;
    
    /* PCI scan for CPC-PCI (or others ) has already remapped the address */
    /* printk(" assign address direct\n"); */
    can_base[minor] = (void __iomem *)Base[minor];

    /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */ 

    /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
    if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
    DBGout(); return 0;
}
|——————Node:{ Text: {
|——————Node:expression_statement Text: DBGin();
|———————Node:call_expression Text: DBGin()
|————————Node:identifier Text: DBGin
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: can_range[minor] = CAN_RANGE;
|———————Node:assignment_expression Text: can_range[minor] = CAN_RANGE
|————————Node:subscript_expression Text: can_range[minor]
|—————————Node:identifier Text: can_range
|—————————Node:[ Text: [
|—————————Node:identifier Text: minor
|—————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:identifier Text: CAN_RANGE
|———————Node:; Text: ;
|——————Node:comment Text: /* PCI scan for CPC-PCI (or others ) has already remapped the address */
|——————Node:comment Text: /* printk(" assign address direct\n"); */
|——————Node:expression_statement Text: can_base[minor] = (void __iomem *)Base[minor];
|———————Node:assignment_expression Text: can_base[minor] = (void __iomem *)Base[minor]
|————————Node:subscript_expression Text: can_base[minor]
|—————————Node:identifier Text: can_base
|—————————Node:[ Text: [
|—————————Node:identifier Text: minor
|—————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:cast_expression Text: (void __iomem *)Base[minor]
|—————————Node:( Text: (
|—————————Node:ERROR Text: void
|——————————Node:primitive_type Text: void
|—————————Node:type_descriptor Text: __iomem *
|——————————Node:type_identifier Text: __iomem
|——————————Node:abstract_pointer_declarator Text: *
|———————————Node:* Text: *
|—————————Node:) Text: )
|—————————Node:subscript_expression Text: Base[minor]
|——————————Node:identifier Text: Base
|——————————Node:[ Text: [
|——————————Node:identifier Text: minor
|——————————Node:] Text: ]
|———————Node:; Text: ;
|——————Node:comment Text: /* The Interrupt Line is alrady requestes by th PC CARD Services
     * (in case of CPC-Card: cpc-card_cs.c) 
    */
|——————Node:comment Text: /* printk("MAX_IRQNUMBER %d/IRQ %d\n", MAX_IRQNUMBER, IRQ[minor]); */
|——————Node:if_statement Text: if( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER ){
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    } else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ( IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER )
|————————Node:( Text: (
|————————Node:binary_expression Text: IRQ[minor] > 0 && IRQ[minor] < MAX_IRQNUMBER
|—————————Node:binary_expression Text: IRQ[minor] > 0
|——————————Node:subscript_expression Text: IRQ[minor]
|———————————Node:identifier Text: IRQ
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|——————————Node:> Text: >
|——————————Node:number_literal Text: 0
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: IRQ[minor] < MAX_IRQNUMBER
|——————————Node:subscript_expression Text: IRQ[minor]
|———————————Node:identifier Text: IRQ
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|——————————Node:< Text: <
|——————————Node:identifier Text: MAX_IRQNUMBER
|————————Node:) Text: )
|———————Node:compound_statement Text: {
        if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
    }
|————————Node:{ Text: {
|————————Node:if_statement Text: if( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) ) {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: ( Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt) )
|——————————Node:( Text: (
|——————————Node:call_expression Text: Can_RequestIrq( minor, IRQ[minor] , CAN_Interrupt)
|———————————Node:identifier Text: Can_RequestIrq
|———————————Node:argument_list Text: ( minor, IRQ[minor] , CAN_Interrupt)
|————————————Node:( Text: (
|————————————Node:identifier Text: minor
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: IRQ[minor]
|—————————————Node:identifier Text: IRQ
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: minor
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:identifier Text: CAN_Interrupt
|————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
	     printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
	     DBGout(); return -EBUSY;
        }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor]);
|———————————Node:call_expression Text: printk("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor])
|————————————Node:identifier Text: printk
|————————————Node:argument_list Text: ("Can[%d]: Can't request IRQ %d \n", minor, IRQ[minor])
|—————————————Node:( Text: (
|—————————————Node:string_literal Text: "Can[%d]: Can't request IRQ %d \n"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: Can[%d]: Can't request IRQ %d 
|——————————————Node:escape_sequence Text: \n
|——————————————Node:" Text: "
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: minor
|—————————————Node:, Text: ,
|—————————————Node:subscript_expression Text: IRQ[minor]
|——————————————Node:identifier Text: IRQ
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: minor
|——————————————Node:] Text: ]
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: DBGout();
|———————————Node:call_expression Text: DBGout()
|————————————Node:identifier Text: DBGout
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:return_statement Text: return -EBUSY;
|———————————Node:return Text: return
|———————————Node:unary_expression Text: -EBUSY
|————————————Node:- Text: -
|————————————Node:identifier Text: EBUSY
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
	/* Invalid IRQ number in /proc/.../IRQ */
	DBGout(); return -EINVAL;
    }
|—————————Node:{ Text: {
|—————————Node:comment Text: /* Invalid IRQ number in /proc/.../IRQ */
|—————————Node:expression_statement Text: DBGout();
|——————————Node:call_expression Text: DBGout()
|———————————Node:identifier Text: DBGout
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -EINVAL;
|——————————Node:return Text: return
|——————————Node:unary_expression Text: -EINVAL
|———————————Node:- Text: -
|———————————Node:identifier Text: EINVAL
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:expression_statement Text: DBGout();
|———————Node:call_expression Text: DBGout()
|————————Node:identifier Text: DBGout
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment Text: /* reset both CAN controllers on the EMS-Wnsche CPC-PCI Board */
|————Node:comment Text: /* writing to the control range at BAR1 of the PCI board */
|————Node:function_definition Text: void reset_CPC_PCI(unsigned long address)
{
unsigned long ptr = (unsigned long)ioremap(address, 32);
    writeb(0x01, (void __iomem *)ptr);
}
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: reset_CPC_PCI(unsigned long address)
|——————Node:identifier Text: reset_CPC_PCI
|——————Node:parameter_list Text: (unsigned long address)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: unsigned long address
|————————Node:sized_type_specifier Text: unsigned long
|—————————Node:unsigned Text: unsigned
|—————————Node:long Text: long
|————————Node:identifier Text: address
|———————Node:) Text: )
|—————Node:compound_statement Text: {
unsigned long ptr = (unsigned long)ioremap(address, 32);
    writeb(0x01, (void __iomem *)ptr);
}
|——————Node:{ Text: {
|——————Node:declaration Text: unsigned long ptr = (unsigned long)ioremap(address, 32);
|———————Node:sized_type_specifier Text: unsigned long
|————————Node:unsigned Text: unsigned
|————————Node:long Text: long
|———————Node:init_declarator Text: ptr = (unsigned long)ioremap(address, 32)
|————————Node:identifier Text: ptr
|————————Node:= Text: =
|————————Node:cast_expression Text: (unsigned long)ioremap(address, 32)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: unsigned long
|——————————Node:sized_type_specifier Text: unsigned long
|———————————Node:unsigned Text: unsigned
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:call_expression Text: ioremap(address, 32)
|——————————Node:identifier Text: ioremap
|——————————Node:argument_list Text: (address, 32)
|———————————Node:( Text: (
|———————————Node:identifier Text: address
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 32
|———————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeb(0x01, (void __iomem *)ptr);
|———————Node:call_expression Text: writeb(0x01, (void __iomem *)ptr)
|————————Node:identifier Text: writeb
|————————Node:argument_list Text: (0x01, (void __iomem *)ptr)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:cast_expression Text: (void __iomem *)ptr
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:identifier Text: ptr
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment Text: /* check memory region if there is a CAN controller
*  assume the controller was resetted before testing 
*
*  The check for an avaliable controller is difficult !
*  After an Hardware Reset (or power on) the Conroller 
*  is in the so-called 'BasicCAN' mode.
*     we can check for: 
*         adress  name      value
*	    0x00  mode       0x21
*           0x02  status     0xc0
*           0x03  interrupt  0xe0
* Once loaded the driver switches into 'PeliCAN' mode and things are getting
* difficult, because we now have only a 'soft reset' with not so  unique
* values. The values have to be masked before comparing.
*         adress  name       mask   value
*	    0x00  mode               
*           0x01  command    0xff    0x00
*           0x02  status     0x37    0x34
*           0x03  interrupt  0xfb    0x00
*
*/
|————Node:function_definition Text: int controller_available(upointer_t address, int offset)
{
/* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
void __iomem *ptr = ioremap(address, CAN_RANGE);


#if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif


    if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
}
|—————Node:primitive_type Text: int
|—————Node:function_declarator Text: controller_available(upointer_t address, int offset)
|——————Node:identifier Text: controller_available
|——————Node:parameter_list Text: (upointer_t address, int offset)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: upointer_t address
|————————Node:type_identifier Text: upointer_t
|————————Node:identifier Text: address
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: int offset
|————————Node:primitive_type Text: int
|————————Node:identifier Text: offset
|———————Node:) Text: )
|—————Node:compound_statement Text: {
/* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
void __iomem *ptr = ioremap(address, CAN_RANGE);


#if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif


    if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
}
|——————Node:{ Text: {
|——————Node:comment Text: /* unsigned long ptr = (unsigned long)ioremap(address, 32 * offset); */
|——————Node:declaration Text: void __iomem *ptr = ioremap(address, CAN_RANGE);
|———————Node:primitive_type Text: void
|———————Node:ERROR Text: __iomem
|————————Node:identifier Text: __iomem
|———————Node:init_declarator Text: *ptr = ioremap(address, CAN_RANGE)
|————————Node:pointer_declarator Text: *ptr
|—————————Node:* Text: *
|—————————Node:identifier Text: ptr
|————————Node:= Text: =
|————————Node:call_expression Text: ioremap(address, CAN_RANGE)
|—————————Node:identifier Text: ioremap
|—————————Node:argument_list Text: (address, CAN_RANGE)
|——————————Node:( Text: (
|——————————Node:identifier Text: address
|——————————Node:, Text: ,
|——————————Node:identifier Text: CAN_RANGE
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:preproc_if Text: #if 0     /* debugging */
    printk("controller_available 0x%0lx\n", address);

    printk("0x%0x, ", readb(ptr) );
    printk("0x%0x, ", readb(ptr + (2 * offset)) );
    printk("0x%0x\n", readb(ptr + (3 * offset)) );

    /* return 1; */

#endif
|———————Node:#if Text: #if
|———————Node:number_literal Text: 0
|———————Node:comment Text: /* debugging */
|———————Node:
 Text: 

|———————Node:expression_statement Text: printk("controller_available 0x%0lx\n", address);
|————————Node:call_expression Text: printk("controller_available 0x%0lx\n", address)
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: ("controller_available 0x%0lx\n", address)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "controller_available 0x%0lx\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: controller_available 0x%0lx
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: address
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: printk("0x%0x, ", readb(ptr) );
|————————Node:call_expression Text: printk("0x%0x, ", readb(ptr) )
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: ("0x%0x, ", readb(ptr) )
|——————————Node:( Text: (
|——————————Node:string_literal Text: "0x%0x, "
|———————————Node:" Text: "
|———————————Node:string_content Text: 0x%0x, 
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:call_expression Text: readb(ptr)
|———————————Node:identifier Text: readb
|———————————Node:argument_list Text: (ptr)
|————————————Node:( Text: (
|————————————Node:identifier Text: ptr
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: printk("0x%0x, ", readb(ptr + (2 * offset)) );
|————————Node:call_expression Text: printk("0x%0x, ", readb(ptr + (2 * offset)) )
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: ("0x%0x, ", readb(ptr + (2 * offset)) )
|——————————Node:( Text: (
|——————————Node:string_literal Text: "0x%0x, "
|———————————Node:" Text: "
|———————————Node:string_content Text: 0x%0x, 
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:call_expression Text: readb(ptr + (2 * offset))
|———————————Node:identifier Text: readb
|———————————Node:argument_list Text: (ptr + (2 * offset))
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ptr + (2 * offset)
|—————————————Node:identifier Text: ptr
|—————————————Node:+ Text: +
|—————————————Node:parenthesized_expression Text: (2 * offset)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: 2 * offset
|———————————————Node:number_literal Text: 2
|———————————————Node:* Text: *
|———————————————Node:identifier Text: offset
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: printk("0x%0x\n", readb(ptr + (3 * offset)) );
|————————Node:call_expression Text: printk("0x%0x\n", readb(ptr + (3 * offset)) )
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: ("0x%0x\n", readb(ptr + (3 * offset)) )
|——————————Node:( Text: (
|——————————Node:string_literal Text: "0x%0x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: 0x%0x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:call_expression Text: readb(ptr + (3 * offset))
|———————————Node:identifier Text: readb
|———————————Node:argument_list Text: (ptr + (3 * offset))
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ptr + (3 * offset)
|—————————————Node:identifier Text: ptr
|—————————————Node:+ Text: +
|—————————————Node:parenthesized_expression Text: (3 * offset)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: 3 * offset
|———————————————Node:number_literal Text: 3
|———————————————Node:* Text: *
|———————————————Node:identifier Text: offset
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: /* return 1; */
|———————Node:#endif Text: #endif
|——————Node:if_statement Text: if ( 0x21 == readb(ptr))  {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ( 0x21 == readb(ptr))
|————————Node:( Text: (
|————————Node:binary_expression Text: 0x21 == readb(ptr)
|—————————Node:number_literal Text: 0x21
|—————————Node:== Text: ==
|—————————Node:call_expression Text: readb(ptr)
|——————————Node:identifier Text: readb
|——————————Node:argument_list Text: (ptr)
|———————————Node:( Text: (
|———————————Node:identifier Text: ptr
|———————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
	/* compare reset values of status and interrupt register */
	if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
    }
|————————Node:{ Text: {
|————————Node:comment Text: /* compare reset values of status and interrupt register */
|————————Node:if_statement Text: if(   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) ) {
	    return 1;
	} else {
	    return 0;
	}
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (   0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset)) )
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 0x0c == readb(ptr + (2 * offset))
	   && 0xe0 == readb(ptr + (3 * offset))
|———————————Node:binary_expression Text: 0x0c == readb(ptr + (2 * offset))
|————————————Node:number_literal Text: 0x0c
|————————————Node:== Text: ==
|————————————Node:call_expression Text: readb(ptr + (2 * offset))
|—————————————Node:identifier Text: readb
|—————————————Node:argument_list Text: (ptr + (2 * offset))
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: ptr + (2 * offset)
|———————————————Node:identifier Text: ptr
|———————————————Node:+ Text: +
|———————————————Node:parenthesized_expression Text: (2 * offset)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 2 * offset
|—————————————————Node:number_literal Text: 2
|—————————————————Node:* Text: *
|—————————————————Node:identifier Text: offset
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|———————————Node:&& Text: &&
|———————————Node:binary_expression Text: 0xe0 == readb(ptr + (3 * offset))
|————————————Node:number_literal Text: 0xe0
|————————————Node:== Text: ==
|————————————Node:call_expression Text: readb(ptr + (3 * offset))
|—————————————Node:identifier Text: readb
|—————————————Node:argument_list Text: (ptr + (3 * offset))
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: ptr + (3 * offset)
|———————————————Node:identifier Text: ptr
|———————————————Node:+ Text: +
|———————————————Node:parenthesized_expression Text: (3 * offset)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: 3 * offset
|—————————————————Node:number_literal Text: 3
|—————————————————Node:* Text: *
|—————————————————Node:identifier Text: offset
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
	    return 1;
	}
|——————————Node:{ Text: {
|——————————Node:return_statement Text: return 1;
|———————————Node:return Text: return
|———————————Node:number_literal Text: 1
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else {
	    return 0;
	}
|——————————Node:else Text: else
|——————————Node:compound_statement Text: {
	    return 0;
	}
|———————————Node:{ Text: {
|———————————Node:return_statement Text: return 0;
|————————————Node:return Text: return
|————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
	/* may be called after a 'soft reset' in 'PeliCAN' mode */
	/*   value     address                     mask    */
	if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}

    }
|—————————Node:{ Text: {
|—————————Node:comment Text: /* may be called after a 'soft reset' in 'PeliCAN' mode */
|—————————Node:comment Text: /*   value     address                     mask    */
|—————————Node:if_statement Text: if(   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  ) {
	    return 1;
	} else {
	    return 0;
	}
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (   0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
	  )
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
	   && 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
|————————————Node:binary_expression Text: 0x00 ==  readb(ptr + (1 * offset))
	   && 0x34 == (readb(ptr + (2 * offset))    & 0x37)
|—————————————Node:binary_expression Text: 0x00 ==  readb(ptr + (1 * offset))
|——————————————Node:number_literal Text: 0x00
|——————————————Node:== Text: ==
|——————————————Node:call_expression Text: readb(ptr + (1 * offset))
|———————————————Node:identifier Text: readb
|———————————————Node:argument_list Text: (ptr + (1 * offset))
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: ptr + (1 * offset)
|—————————————————Node:identifier Text: ptr
|—————————————————Node:+ Text: +
|—————————————————Node:parenthesized_expression Text: (1 * offset)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: 1 * offset
|———————————————————Node:number_literal Text: 1
|———————————————————Node:* Text: *
|———————————————————Node:identifier Text: offset
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|—————————————Node:&& Text: &&
|—————————————Node:binary_expression Text: 0x34 == (readb(ptr + (2 * offset))    & 0x37)
|——————————————Node:number_literal Text: 0x34
|——————————————Node:== Text: ==
|——————————————Node:parenthesized_expression Text: (readb(ptr + (2 * offset))    & 0x37)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: readb(ptr + (2 * offset))    & 0x37
|————————————————Node:call_expression Text: readb(ptr + (2 * offset))
|—————————————————Node:identifier Text: readb
|—————————————————Node:argument_list Text: (ptr + (2 * offset))
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: ptr + (2 * offset)
|———————————————————Node:identifier Text: ptr
|———————————————————Node:+ Text: +
|———————————————————Node:parenthesized_expression Text: (2 * offset)
|————————————————————Node:( Text: (
|————————————————————Node:binary_expression Text: 2 * offset
|—————————————————————Node:number_literal Text: 2
|—————————————————————Node:* Text: *
|—————————————————————Node:identifier Text: offset
|————————————————————Node:) Text: )
|——————————————————Node:) Text: )
|————————————————Node:& Text: &
|————————————————Node:number_literal Text: 0x37
|———————————————Node:) Text: )
|————————————Node:&& Text: &&
|————————————Node:binary_expression Text: 0x00 == (readb(ptr + (3 * offset))    & 0xfb)
|—————————————Node:number_literal Text: 0x00
|—————————————Node:== Text: ==
|—————————————Node:parenthesized_expression Text: (readb(ptr + (3 * offset))    & 0xfb)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: readb(ptr + (3 * offset))    & 0xfb
|———————————————Node:call_expression Text: readb(ptr + (3 * offset))
|————————————————Node:identifier Text: readb
|————————————————Node:argument_list Text: (ptr + (3 * offset))
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: ptr + (3 * offset)
|——————————————————Node:identifier Text: ptr
|——————————————————Node:+ Text: +
|——————————————————Node:parenthesized_expression Text: (3 * offset)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: 3 * offset
|————————————————————Node:number_literal Text: 3
|————————————————————Node:* Text: *
|————————————————————Node:identifier Text: offset
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0xfb
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
	    return 1;
	}
|———————————Node:{ Text: {
|———————————Node:return_statement Text: return 1;
|————————————Node:return Text: return
|————————————Node:number_literal Text: 1
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
	    return 0;
	}
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
	    return 0;
	}
|————————————Node:{ Text: {
|————————————Node:return_statement Text: return 0;
|—————————————Node:return Text: return
|—————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:} Text: }
|——————Node:} Text: }
|———Node:#endif Text: #endif
|——Node:preproc_function_def Text: #define PCI_BASE_ADDRESS0(dev) (dev->resource[0].start)

|———Node:#define Text: #define
|———Node:identifier Text: PCI_BASE_ADDRESS0
|———Node:preproc_params Text: (dev)
|————Node:( Text: (
|————Node:identifier Text: dev
|————Node:) Text: )
|———Node:preproc_arg Text: (dev->resource[0].start)
|——Node:preproc_function_def Text: #define PCI_BASE_ADDRESS1(dev) (dev->resource[1].start)

|———Node:#define Text: #define
|———Node:identifier Text: PCI_BASE_ADDRESS1
|———Node:preproc_params Text: (dev)
|————Node:( Text: (
|————Node:identifier Text: dev
|————Node:) Text: )
|———Node:preproc_arg Text: (dev->resource[1].start)
|——Node:preproc_function_def Text: #define PCI_BASE_ADDRESS2(dev) (dev->resource[2].start)

|———Node:#define Text: #define
|———Node:identifier Text: PCI_BASE_ADDRESS2
|———Node:preproc_params Text: (dev)
|————Node:( Text: (
|————Node:identifier Text: dev
|————Node:) Text: )
|———Node:preproc_arg Text: (dev->resource[2].start)
|——Node:preproc_function_def Text: #define PCI_BASE_ADDRESS3(dev) (dev->resource[3].start)

|———Node:#define Text: #define
|———Node:identifier Text: PCI_BASE_ADDRESS3
|———Node:preproc_params Text: (dev)
|————Node:( Text: (
|————Node:identifier Text: dev
|————Node:) Text: )
|———Node:preproc_arg Text: (dev->resource[3].start)
|——Node:comment Text: /* used for storing the global pci register address */
|——Node:declaration Text: upointer_t Can_pitapci_control[MAX_CHANNELS];
|———Node:type_identifier Text: upointer_t
|———Node:array_declarator Text: Can_pitapci_control[MAX_CHANNELS]
|————Node:identifier Text: Can_pitapci_control
|————Node:[ Text: [
|————Node:identifier Text: MAX_CHANNELS
|————Node:] Text: ]
|———Node:; Text: ;
|——Node:preproc_if Text: # if defined(CPC_PCI)



#ifndef PCI_DEVICE_ID_PLX_9030
#define PCI_DEVICE_ID_PLX_9030 0x9030
#endif

#if 0
static struct pci_device_id  ems_pci_tbl[] = {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
};
#endif

int register_new_cpcpci(struct pci_dev *pdev, int i)
{
void __iomem *ptr;		/* ptr to PCI control registers*/
void __iomem *cptr;		/* ptr to start of CAN control registers*/
int j;				/* loop through possible CAN controllers */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    	                 /* dev, bar, size */
    ptr		= pci_iomap(pdev, 0, 128);
    cptr	= pci_iomap(pdev, 2, 2048);


    printk("cptr= %p \n", cptr);

    /* look for a CAN controllers starting at 0x400 */
    for(j = 0; j < 4; j++) {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
    /* enable IRQ in PLX 9030 */
    writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR);
    DBGout();
    return i;	/* returns last CAN controller number found */
}



/* check if the pci device is a valid old style CPC-PCI and 
gett all the hardware information nneded and fill in the board information
the device itself is already registered  pci_enable_device()
*/
int register_old_cpcpci(struct pci_dev *pdev, int i)
{
unsigned long ptr;		/* ptr to PITA control */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    err("int i ist %d", i);

    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
    /* enable memory access */
    /* printk("write to pita\n"); */
    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
    Can_pitapci_control[i] = ptr;

    /* printk("        pita ptr %lx\n", ptr); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

    /* PCI_BASE_ADDRESS1:
     * at address 0 are some EMS control registers
     * at address 0x400 the first controller area 
     * at address 0x600 the second controller area 
     * registers are read as 32bit
     *
     * at adress 0 we can verify the card
     * 0x55 0xaa 0x01 0xcb
*/
    {
	void __iomem *sigptr; /* ptr to EMS signature  */
	unsigned long signature = 0;
	sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
	/* printk("        signature  %lx\n", signature); */
	if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
    }
    /* we are now sure to have the right board,
       reset the CAN controller(s) */
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

    /* enable interrupts Int_0 */
    /* write to PITAs ICR register */
    writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR);

    err("int i ist %d", i);
    /* look for a CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }

    err("int i ist %d", i);
    /* look for a second CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }

    err("int i ist %d", i);
    DBGout();
    return i;
}

int new_pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;			/* number of devices found */
int	minor = -1;			/* to make DBGin() happy */

    DBGin();
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
#endif
    DBGout();
    return 0;
}


/* Should be replaced by  new_pcimod_scan() soon
 * to be able to handle both kinds of CPC-PCI
 * hopefully for both boards with the same driver
 * and if possible for the Kvaser PCI as well
 */
int pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;				/* number of devices found */
unsigned long ptr;				/* ptr to PITA control */

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
#endif
    return 0;
}


void board_clear_interrupts(int minor)
{

/* old  Siemens PITA */
    /* Interrupt_0_Enable (bit 17) + Int_0_Reset (bit 1) */
    /*  
     Uttenthaler:
      nur 
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
      als letzte Anweisung in der ISR
     Schoett:
      bei Eintritt
        writel(0x00000000, Can_pitapci_control[minor] + 0x0);
      am ende
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
    */
    writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0);
    writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0);

/* new */

    writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR);

}
# endif
|———Node:#if Text: # if
|———Node:preproc_defined Text: defined(CPC_PCI)
|————Node:defined Text: defined
|————Node:( Text: (
|————Node:identifier Text: CPC_PCI
|————Node:) Text: )
|———Node:
 Text: 




|———Node:preproc_ifdef Text: #ifndef PCI_DEVICE_ID_PLX_9030
#define PCI_DEVICE_ID_PLX_9030 0x9030
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: PCI_DEVICE_ID_PLX_9030
|————Node:preproc_def Text: #define PCI_DEVICE_ID_PLX_9030 0x9030

|—————Node:#define Text: #define
|—————Node:identifier Text: PCI_DEVICE_ID_PLX_9030
|—————Node:preproc_arg Text: 0x9030
|————Node:#endif Text: #endif
|———Node:preproc_if Text: #if 0
static struct pci_device_id  ems_pci_tbl[] = {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
};
#endif
|————Node:#if Text: #if
|————Node:number_literal Text: 0
|————Node:
 Text: 

|————Node:declaration Text: static struct pci_device_id  ems_pci_tbl[] = {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
};
|—————Node:storage_class_specifier Text: static
|——————Node:static Text: static
|—————Node:struct_specifier Text: struct pci_device_id
|——————Node:struct Text: struct
|——————Node:type_identifier Text: pci_device_id
|—————Node:init_declarator Text: ems_pci_tbl[] = {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
}
|——————Node:array_declarator Text: ems_pci_tbl[]
|———————Node:identifier Text: ems_pci_tbl
|———————Node:[ Text: [
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:initializer_list Text: {
      { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), },
      { 0, },                 /* End of list */
}
|———————Node:{ Text: {
|———————Node:initializer_list Text: { PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030), }
|————————Node:{ Text: {
|————————Node:call_expression Text: PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030)
|—————————Node:identifier Text: PCI_DEVICE
|—————————Node:argument_list Text: (PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030)
|——————————Node:( Text: (
|——————————Node:identifier Text: PCI_VENDOR_ID_PLX
|——————————Node:, Text: ,
|——————————Node:identifier Text: PCI_DEVICE_ID_PLX_9030
|——————————Node:) Text: )
|————————Node:, Text: ,
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { 0, }
|————————Node:{ Text: {
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:comment Text: /* End of list */
|———————Node:} Text: }
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:function_definition Text: int register_new_cpcpci(struct pci_dev *pdev, int i)
{
void __iomem *ptr;		/* ptr to PCI control registers*/
void __iomem *cptr;		/* ptr to start of CAN control registers*/
int j;				/* loop through possible CAN controllers */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    	                 /* dev, bar, size */
    ptr		= pci_iomap(pdev, 0, 128);
    cptr	= pci_iomap(pdev, 2, 2048);


    printk("cptr= %p \n", cptr);

    /* look for a CAN controllers starting at 0x400 */
    for(j = 0; j < 4; j++) {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
    /* enable IRQ in PLX 9030 */
    writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR);
    DBGout();
    return i;	/* returns last CAN controller number found */
}
|————Node:primitive_type Text: int
|————Node:function_declarator Text: register_new_cpcpci(struct pci_dev *pdev, int i)
|—————Node:identifier Text: register_new_cpcpci
|—————Node:parameter_list Text: (struct pci_dev *pdev, int i)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: struct pci_dev *pdev
|———————Node:struct_specifier Text: struct pci_dev
|————————Node:struct Text: struct
|————————Node:type_identifier Text: pci_dev
|———————Node:pointer_declarator Text: *pdev
|————————Node:* Text: *
|————————Node:identifier Text: pdev
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: int i
|———————Node:primitive_type Text: int
|———————Node:identifier Text: i
|——————Node:) Text: )
|————Node:compound_statement Text: {
void __iomem *ptr;		/* ptr to PCI control registers*/
void __iomem *cptr;		/* ptr to start of CAN control registers*/
int j;				/* loop through possible CAN controllers */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    	                 /* dev, bar, size */
    ptr		= pci_iomap(pdev, 0, 128);
    cptr	= pci_iomap(pdev, 2, 2048);


    printk("cptr= %p \n", cptr);

    /* look for a CAN controllers starting at 0x400 */
    for(j = 0; j < 4; j++) {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
    /* enable IRQ in PLX 9030 */
    writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR);
    DBGout();
    return i;	/* returns last CAN controller number found */
}
|—————Node:{ Text: {
|—————Node:declaration Text: void __iomem *ptr;
|——————Node:primitive_type Text: void
|——————Node:ERROR Text: __iomem
|———————Node:identifier Text: __iomem
|——————Node:pointer_declarator Text: *ptr
|———————Node:* Text: *
|———————Node:identifier Text: ptr
|——————Node:; Text: ;
|—————Node:comment Text: /* ptr to PCI control registers*/
|—————Node:declaration Text: void __iomem *cptr;
|——————Node:primitive_type Text: void
|——————Node:ERROR Text: __iomem
|———————Node:identifier Text: __iomem
|——————Node:pointer_declarator Text: *cptr
|———————Node:* Text: *
|———————Node:identifier Text: cptr
|——————Node:; Text: ;
|—————Node:comment Text: /* ptr to start of CAN control registers*/
|—————Node:declaration Text: int j;
|——————Node:primitive_type Text: int
|——————Node:identifier Text: j
|——————Node:; Text: ;
|—————Node:comment Text: /* loop through possible CAN controllers */
|—————Node:declaration Text: int minor = -1;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: minor = -1
|———————Node:identifier Text: minor
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:comment Text: /* to make DBGin() happy */
|—————Node:expression_statement Text: DBGin();
|——————Node:call_expression Text: DBGin()
|———————Node:identifier Text: DBGin
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* dev, bar, size */
|—————Node:expression_statement Text: ptr		= pci_iomap(pdev, 0, 128);
|——————Node:assignment_expression Text: ptr		= pci_iomap(pdev, 0, 128)
|———————Node:identifier Text: ptr
|———————Node:= Text: =
|———————Node:call_expression Text: pci_iomap(pdev, 0, 128)
|————————Node:identifier Text: pci_iomap
|————————Node:argument_list Text: (pdev, 0, 128)
|—————————Node:( Text: (
|—————————Node:identifier Text: pdev
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 128
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: cptr	= pci_iomap(pdev, 2, 2048);
|——————Node:assignment_expression Text: cptr	= pci_iomap(pdev, 2, 2048)
|———————Node:identifier Text: cptr
|———————Node:= Text: =
|———————Node:call_expression Text: pci_iomap(pdev, 2, 2048)
|————————Node:identifier Text: pci_iomap
|————————Node:argument_list Text: (pdev, 2, 2048)
|—————————Node:( Text: (
|—————————Node:identifier Text: pdev
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 2
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 2048
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: printk("cptr= %p \n", cptr);
|——————Node:call_expression Text: printk("cptr= %p \n", cptr)
|———————Node:identifier Text: printk
|———————Node:argument_list Text: ("cptr= %p \n", cptr)
|————————Node:( Text: (
|————————Node:string_literal Text: "cptr= %p \n"
|—————————Node:" Text: "
|—————————Node:string_content Text: cptr= %p 
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: cptr
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* look for a CAN controllers starting at 0x400 */
|—————Node:for_statement Text: for(j = 0; j < 4; j++) {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: j = 0
|———————Node:identifier Text: j
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: j < 4
|———————Node:identifier Text: j
|———————Node:< Text: <
|———————Node:number_literal Text: 4
|——————Node:; Text: ;
|——————Node:update_expression Text: j++
|———————Node:identifier Text: j
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {   
	if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if(controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)) {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1))
|—————————Node:( Text: (
|—————————Node:call_expression Text: controller_available(PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)
|——————————Node:identifier Text: controller_available
|——————————Node:argument_list Text: (PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j), 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: PCI_BASE_ADDRESS2(pdev) 
					+ 0x400 + (0x200 * j)
|————————————Node:binary_expression Text: PCI_BASE_ADDRESS2(pdev) 
					+ 0x400
|—————————————Node:call_expression Text: PCI_BASE_ADDRESS2(pdev)
|——————————————Node:identifier Text: PCI_BASE_ADDRESS2
|——————————————Node:argument_list Text: (pdev)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: pdev
|———————————————Node:) Text: )
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 0x400
|————————————Node:+ Text: +
|————————————Node:parenthesized_expression Text: (0x200 * j)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 0x200 * j
|——————————————Node:number_literal Text: 0x200
|——————————————Node:* Text: *
|——————————————Node:identifier Text: j
|—————————————Node:) Text: )
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
	    err(" CAN controller %d. at pos %d\n", i + 1, j);
	    if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
	    IOModel[i]	= 'm';
	    IRQ[i]	= pdev->irq;
	    Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
#ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
	    Can_pitapci_control[i] = (upointer_t)ptr;/* store pointer to control reg */
	    i++;
	}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: err(" CAN controller %d. at pos %d\n", i + 1, j);
|——————————Node:call_expression Text: err(" CAN controller %d. at pos %d\n", i + 1, j)
|———————————Node:identifier Text: err
|———————————Node:argument_list Text: (" CAN controller %d. at pos %d\n", i + 1, j)
|————————————Node:( Text: (
|————————————Node:string_literal Text: " CAN controller %d. at pos %d\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text:  CAN controller %d. at pos %d
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: i + 1
|—————————————Node:identifier Text: i
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:, Text: ,
|————————————Node:identifier Text: j
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if(i > MAX_CHANNELS) {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (i > MAX_CHANNELS)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: i > MAX_CHANNELS
|————————————Node:identifier Text: i
|————————————Node:> Text: >
|————————————Node:identifier Text: MAX_CHANNELS
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
		err("only %d devices supported\n", MAX_CHANNELS);
		break; /* the devices scan loop */
	    }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: err("only %d devices supported\n", MAX_CHANNELS);
|————————————Node:call_expression Text: err("only %d devices supported\n", MAX_CHANNELS)
|—————————————Node:identifier Text: err
|—————————————Node:argument_list Text: ("only %d devices supported\n", MAX_CHANNELS)
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "only %d devices supported\n"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: only %d devices supported
|———————————————Node:escape_sequence Text: \n
|———————————————Node:" Text: "
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: MAX_CHANNELS
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:break_statement Text: break;
|————————————Node:break Text: break
|————————————Node:; Text: ;
|———————————Node:comment Text: /* the devices scan loop */
|———————————Node:} Text: }
|—————————Node:expression_statement Text: IOModel[i]	= 'm';
|——————————Node:assignment_expression Text: IOModel[i]	= 'm'
|———————————Node:subscript_expression Text: IOModel[i]
|————————————Node:identifier Text: IOModel
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:char_literal Text: 'm'
|————————————Node:' Text: '
|————————————Node:character Text: m
|————————————Node:' Text: '
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: IRQ[i]	= pdev->irq;
|——————————Node:assignment_expression Text: IRQ[i]	= pdev->irq
|———————————Node:subscript_expression Text: IRQ[i]
|————————————Node:identifier Text: IRQ
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:field_expression Text: pdev->irq
|————————————Node:identifier Text: pdev
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: irq
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j);
|——————————Node:assignment_expression Text: Base[i]	= (upointer_t) cptr + 0x400 + (0x200 * j)
|———————————Node:subscript_expression Text: Base[i]
|————————————Node:identifier Text: Base
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:binary_expression Text: (upointer_t) cptr + 0x400 + (0x200 * j)
|————————————Node:binary_expression Text: (upointer_t) cptr + 0x400
|—————————————Node:cast_expression Text: (upointer_t) cptr
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: upointer_t
|———————————————Node:type_identifier Text: upointer_t
|——————————————Node:) Text: )
|——————————————Node:identifier Text: cptr
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 0x400
|————————————Node:+ Text: +
|————————————Node:parenthesized_expression Text: (0x200 * j)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 0x200 * j
|——————————————Node:number_literal Text: 0x200
|——————————————Node:* Text: *
|——————————————Node:identifier Text: j
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:preproc_ifdef Text: #ifdef __x86_64__
	    err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
#else
	    err("Base %lx", Base[i]);
#endif
|——————————Node:#ifdef Text: #ifdef
|——————————Node:identifier Text: __x86_64__
|——————————Node:expression_statement Text: err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i]);
|———————————Node:call_expression Text: err("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i])
|————————————Node:identifier Text: err
|————————————Node:argument_list Text: ("Base %llx/%lld",
	    	(long long unsigned)Base[i], (long long unsigned)Base[i])
|—————————————Node:( Text: (
|—————————————Node:string_literal Text: "Base %llx/%lld"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: Base %llx/%lld
|——————————————Node:" Text: "
|—————————————Node:, Text: ,
|—————————————Node:cast_expression Text: (long long unsigned)Base[i]
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: long long unsigned
|———————————————Node:sized_type_specifier Text: long long unsigned
|————————————————Node:long Text: long
|————————————————Node:long Text: long
|————————————————Node:unsigned Text: unsigned
|——————————————Node:) Text: )
|——————————————Node:subscript_expression Text: Base[i]
|———————————————Node:identifier Text: Base
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:, Text: ,
|—————————————Node:cast_expression Text: (long long unsigned)Base[i]
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: long long unsigned
|———————————————Node:sized_type_specifier Text: long long unsigned
|————————————————Node:long Text: long
|————————————————Node:long Text: long
|————————————————Node:unsigned Text: unsigned
|——————————————Node:) Text: )
|——————————————Node:subscript_expression Text: Base[i]
|———————————————Node:identifier Text: Base
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:preproc_else Text: #else
	    err("Base %lx", Base[i]);
|———————————Node:#else Text: #else
|———————————Node:expression_statement Text: err("Base %lx", Base[i]);
|————————————Node:call_expression Text: err("Base %lx", Base[i])
|—————————————Node:identifier Text: err
|—————————————Node:argument_list Text: ("Base %lx", Base[i])
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "Base %lx"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: Base %lx
|———————————————Node:" Text: "
|——————————————Node:, Text: ,
|——————————————Node:subscript_expression Text: Base[i]
|———————————————Node:identifier Text: Base
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|——————————Node:#endif Text: #endif
|—————————Node:expression_statement Text: Can_pitapci_control[i] = (upointer_t)ptr;
|——————————Node:assignment_expression Text: Can_pitapci_control[i] = (upointer_t)ptr
|———————————Node:subscript_expression Text: Can_pitapci_control[i]
|————————————Node:identifier Text: Can_pitapci_control
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:cast_expression Text: (upointer_t)ptr
|————————————Node:( Text: (
|————————————Node:type_descriptor Text: upointer_t
|—————————————Node:type_identifier Text: upointer_t
|————————————Node:) Text: )
|————————————Node:identifier Text: ptr
|——————————Node:; Text: ;
|—————————Node:comment Text: /* store pointer to control reg */
|—————————Node:expression_statement Text: i++;
|——————————Node:update_expression Text: i++
|———————————Node:identifier Text: i
|———————————Node:++ Text: ++
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:comment Text: /* enable IRQ in PLX 9030 */
|—————Node:expression_statement Text: writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR);
|——————Node:call_expression Text: writel(PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (PLX9030_ICR_ENABLE_IRQ0, ptr + PLX9030_ICR)
|————————Node:( Text: (
|————————Node:identifier Text: PLX9030_ICR_ENABLE_IRQ0
|————————Node:, Text: ,
|————————Node:binary_expression Text: ptr + PLX9030_ICR
|—————————Node:identifier Text: ptr
|—————————Node:+ Text: +
|—————————Node:identifier Text: PLX9030_ICR
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: DBGout();
|——————Node:call_expression Text: DBGout()
|———————Node:identifier Text: DBGout
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return i;
|——————Node:return Text: return
|——————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:comment Text: /* returns last CAN controller number found */
|—————Node:} Text: }
|———Node:comment Text: /* check if the pci device is a valid old style CPC-PCI and 
gett all the hardware information nneded and fill in the board information
the device itself is already registered  pci_enable_device()
*/
|———Node:function_definition Text: int register_old_cpcpci(struct pci_dev *pdev, int i)
{
unsigned long ptr;		/* ptr to PITA control */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    err("int i ist %d", i);

    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
    /* enable memory access */
    /* printk("write to pita\n"); */
    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
    Can_pitapci_control[i] = ptr;

    /* printk("        pita ptr %lx\n", ptr); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

    /* PCI_BASE_ADDRESS1:
     * at address 0 are some EMS control registers
     * at address 0x400 the first controller area 
     * at address 0x600 the second controller area 
     * registers are read as 32bit
     *
     * at adress 0 we can verify the card
     * 0x55 0xaa 0x01 0xcb
*/
    {
	void __iomem *sigptr; /* ptr to EMS signature  */
	unsigned long signature = 0;
	sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
	/* printk("        signature  %lx\n", signature); */
	if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
    }
    /* we are now sure to have the right board,
       reset the CAN controller(s) */
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

    /* enable interrupts Int_0 */
    /* write to PITAs ICR register */
    writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR);

    err("int i ist %d", i);
    /* look for a CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }

    err("int i ist %d", i);
    /* look for a second CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }

    err("int i ist %d", i);
    DBGout();
    return i;
}
|————Node:primitive_type Text: int
|————Node:function_declarator Text: register_old_cpcpci(struct pci_dev *pdev, int i)
|—————Node:identifier Text: register_old_cpcpci
|—————Node:parameter_list Text: (struct pci_dev *pdev, int i)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: struct pci_dev *pdev
|———————Node:struct_specifier Text: struct pci_dev
|————————Node:struct Text: struct
|————————Node:type_identifier Text: pci_dev
|———————Node:pointer_declarator Text: *pdev
|————————Node:* Text: *
|————————Node:identifier Text: pdev
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: int i
|———————Node:primitive_type Text: int
|———————Node:identifier Text: i
|——————Node:) Text: )
|————Node:compound_statement Text: {
unsigned long ptr;		/* ptr to PITA control */
int minor = -1;			/* to make DBGin() happy */

    DBGin();

    err("int i ist %d", i);

    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
    /* enable memory access */
    /* printk("write to pita\n"); */
    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
    Can_pitapci_control[i] = ptr;

    /* printk("        pita ptr %lx\n", ptr); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
    /* printk("---------------\n"); */
    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

    /* PCI_BASE_ADDRESS1:
     * at address 0 are some EMS control registers
     * at address 0x400 the first controller area 
     * at address 0x600 the second controller area 
     * registers are read as 32bit
     *
     * at adress 0 we can verify the card
     * 0x55 0xaa 0x01 0xcb
*/
    {
	void __iomem *sigptr; /* ptr to EMS signature  */
	unsigned long signature = 0;
	sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
	/* printk("        signature  %lx\n", signature); */
	if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
    }
    /* we are now sure to have the right board,
       reset the CAN controller(s) */
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

    /* enable interrupts Int_0 */
    /* write to PITAs ICR register */
    writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR);

    err("int i ist %d", i);
    /* look for a CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }

    err("int i ist %d", i);
    /* look for a second CAN controller at 0x400 */
    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }

    err("int i ist %d", i);
    DBGout();
    return i;
}
|—————Node:{ Text: {
|—————Node:declaration Text: unsigned long ptr;
|——————Node:sized_type_specifier Text: unsigned long
|———————Node:unsigned Text: unsigned
|———————Node:long Text: long
|——————Node:identifier Text: ptr
|——————Node:; Text: ;
|—————Node:comment Text: /* ptr to PITA control */
|—————Node:declaration Text: int minor = -1;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: minor = -1
|———————Node:identifier Text: minor
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:comment Text: /* to make DBGin() happy */
|—————Node:expression_statement Text: DBGin();
|——————Node:call_expression Text: DBGin()
|———————Node:identifier Text: DBGin
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: err("int i ist %d", i);
|——————Node:call_expression Text: err("int i ist %d", i)
|———————Node:identifier Text: err
|———————Node:argument_list Text: ("int i ist %d", i)
|————————Node:( Text: (
|————————Node:string_literal Text: "int i ist %d"
|—————————Node:" Text: "
|—————————Node:string_content Text: int i ist %d
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: i
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
|——————Node:assignment_expression Text: ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|———————Node:identifier Text: ptr
|———————Node:= Text: =
|———————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|————————Node:( Text: (
|————————Node:type_descriptor Text: unsigned long
|—————————Node:sized_type_specifier Text: unsigned long
|——————————Node:unsigned Text: unsigned
|——————————Node:long Text: long
|————————Node:) Text: )
|————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|—————————Node:identifier Text: ioremap
|—————————Node:argument_list Text: (PCI_BASE_ADDRESS0(pdev), 256)
|——————————Node:( Text: (
|——————————Node:call_expression Text: PCI_BASE_ADDRESS0(pdev)
|———————————Node:identifier Text: PCI_BASE_ADDRESS0
|———————————Node:argument_list Text: (pdev)
|————————————Node:( Text: (
|————————————Node:identifier Text: pdev
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 256
|——————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* enable memory access */
|—————Node:comment Text: /* printk("write to pita\n"); */
|—————Node:expression_statement Text: writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
|——————Node:call_expression Text: writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC)
|————————Node:( Text: (
|————————Node:identifier Text: PITA2_MISC_CONFIG
|————————Node:, Text: ,
|————————Node:binary_expression Text: (void __iomem *)ptr + PITA2_MISC
|—————————Node:cast_expression Text: (void __iomem *)ptr
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:identifier Text: ptr
|—————————Node:+ Text: +
|—————————Node:identifier Text: PITA2_MISC
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: Can_pitapci_control[i] = ptr;
|——————Node:assignment_expression Text: Can_pitapci_control[i] = ptr
|———————Node:subscript_expression Text: Can_pitapci_control[i]
|————————Node:identifier Text: Can_pitapci_control
|————————Node:[ Text: [
|————————Node:identifier Text: i
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:identifier Text: ptr
|——————Node:; Text: ;
|—————Node:comment Text: /* printk("        pita ptr %lx\n", ptr); */
|—————Node:comment Text: /* printk("---------------\n"); */
|—————Node:comment Text: /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
|—————Node:comment Text: /* printk("---------------\n"); */
|—————Node:comment Text: /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */
|—————Node:comment Text: /* PCI_BASE_ADDRESS1:
     * at address 0 are some EMS control registers
     * at address 0x400 the first controller area 
     * at address 0x600 the second controller area 
     * registers are read as 32bit
     *
     * at adress 0 we can verify the card
     * 0x55 0xaa 0x01 0xcb
*/
|—————Node:compound_statement Text: {
	void __iomem *sigptr; /* ptr to EMS signature  */
	unsigned long signature = 0;
	sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
	/* printk("        signature  %lx\n", signature); */
	if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
    }
|——————Node:{ Text: {
|——————Node:declaration Text: void __iomem *sigptr;
|———————Node:primitive_type Text: void
|———————Node:ERROR Text: __iomem
|————————Node:identifier Text: __iomem
|———————Node:pointer_declarator Text: *sigptr
|————————Node:* Text: *
|————————Node:identifier Text: sigptr
|———————Node:; Text: ;
|——————Node:comment Text: /* ptr to EMS signature  */
|——————Node:declaration Text: unsigned long signature = 0;
|———————Node:sized_type_specifier Text: unsigned long
|————————Node:unsigned Text: unsigned
|————————Node:long Text: long
|———————Node:init_declarator Text: signature = 0
|————————Node:identifier Text: signature
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
|———————Node:assignment_expression Text: sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|————————Node:identifier Text: sigptr
|————————Node:= Text: =
|————————Node:cast_expression Text: (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|—————————Node:( Text: (
|—————————Node:ERROR Text: void
|——————————Node:primitive_type Text: void
|—————————Node:type_descriptor Text: __iomem *
|——————————Node:type_identifier Text: __iomem
|——————————Node:abstract_pointer_declarator Text: *
|———————————Node:* Text: *
|—————————Node:) Text: )
|—————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|——————————Node:identifier Text: ioremap
|——————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev), 256)
|———————————Node:( Text: (
|———————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|————————————Node:identifier Text: PCI_BASE_ADDRESS1
|————————————Node:argument_list Text: (pdev)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: pdev
|—————————————Node:) Text: )
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 256
|———————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12);
|———————Node:assignment_expression Text: signature =
		  (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12)
|————————Node:identifier Text: signature
|————————Node:= Text: =
|————————Node:binary_expression Text: (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
		+  readb(sigptr + 12)
|—————————Node:binary_expression Text: (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
		+ (readb(sigptr +  8) <<  8)
|——————————Node:binary_expression Text: (readb(sigptr)      << 24)
		+ (readb(sigptr +  4) << 16)
|———————————Node:parenthesized_expression Text: (readb(sigptr)      << 24)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: readb(sigptr)      << 24
|—————————————Node:call_expression Text: readb(sigptr)
|——————————————Node:identifier Text: readb
|——————————————Node:argument_list Text: (sigptr)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: sigptr
|———————————————Node:) Text: )
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 24
|————————————Node:) Text: )
|———————————Node:+ Text: +
|———————————Node:parenthesized_expression Text: (readb(sigptr +  4) << 16)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: readb(sigptr +  4) << 16
|—————————————Node:call_expression Text: readb(sigptr +  4)
|——————————————Node:identifier Text: readb
|——————————————Node:argument_list Text: (sigptr +  4)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: sigptr +  4
|————————————————Node:identifier Text: sigptr
|————————————————Node:+ Text: +
|————————————————Node:number_literal Text: 4
|———————————————Node:) Text: )
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 16
|————————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:parenthesized_expression Text: (readb(sigptr +  8) <<  8)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: readb(sigptr +  8) <<  8
|————————————Node:call_expression Text: readb(sigptr +  8)
|—————————————Node:identifier Text: readb
|—————————————Node:argument_list Text: (sigptr +  8)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: sigptr +  8
|———————————————Node:identifier Text: sigptr
|———————————————Node:+ Text: +
|———————————————Node:number_literal Text: 8
|——————————————Node:) Text: )
|————————————Node:<< Text: <<
|————————————Node:number_literal Text: 8
|———————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:call_expression Text: readb(sigptr + 12)
|——————————Node:identifier Text: readb
|——————————Node:argument_list Text: (sigptr + 12)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: sigptr + 12
|————————————Node:identifier Text: sigptr
|————————————Node:+ Text: +
|————————————Node:number_literal Text: 12
|———————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: /* printk("        signature  %lx\n", signature); */
|——————Node:if_statement Text: if( 0x55aa01cb != signature) {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ( 0x55aa01cb != signature)
|————————Node:( Text: (
|————————Node:binary_expression Text: 0x55aa01cb != signature
|—————————Node:number_literal Text: 0x55aa01cb
|—————————Node:!= Text: !=
|—————————Node:identifier Text: signature
|————————Node:) Text: )
|———————Node:compound_statement Text: {
	    printk(" wrong signature -- no EMS CPC-PCI board\n");
	    return -ENODEV;
	}
|————————Node:{ Text: {
|————————Node:expression_statement Text: printk(" wrong signature -- no EMS CPC-PCI board\n");
|—————————Node:call_expression Text: printk(" wrong signature -- no EMS CPC-PCI board\n")
|——————————Node:identifier Text: printk
|——————————Node:argument_list Text: (" wrong signature -- no EMS CPC-PCI board\n")
|———————————Node:( Text: (
|———————————Node:string_literal Text: " wrong signature -- no EMS CPC-PCI board\n"
|————————————Node:" Text: "
|————————————Node:string_content Text:  wrong signature -- no EMS CPC-PCI board
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:return_statement Text: return -ENODEV;
|—————————Node:return Text: return
|—————————Node:unary_expression Text: -ENODEV
|——————————Node:- Text: -
|——————————Node:identifier Text: ENODEV
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|—————Node:comment Text: /* we are now sure to have the right board,
       reset the CAN controller(s) */
|—————Node:expression_statement Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
|——————Node:call_expression Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400)
|———————Node:identifier Text: reset_CPC_PCI
|———————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400)
|————————Node:( Text: (
|————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|—————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|——————————Node:identifier Text: PCI_BASE_ADDRESS1
|——————————Node:argument_list Text: (pdev)
|———————————Node:( Text: (
|———————————Node:identifier Text: pdev
|———————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 0x400
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);
|——————Node:call_expression Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600)
|———————Node:identifier Text: reset_CPC_PCI
|———————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600)
|————————Node:( Text: (
|————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|—————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|——————————Node:identifier Text: PCI_BASE_ADDRESS1
|——————————Node:argument_list Text: (pdev)
|———————————Node:( Text: (
|———————————Node:identifier Text: pdev
|———————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 0x600
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* enable interrupts Int_0 */
|—————Node:comment Text: /* write to PITAs ICR register */
|—————Node:expression_statement Text: writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR);
|——————Node:call_expression Text: writel(PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (PITA2_ICR_INT0_EN,
    (void __iomem *)Can_pitapci_control[i] + PITA2_ICR)
|————————Node:( Text: (
|————————Node:identifier Text: PITA2_ICR_INT0_EN
|————————Node:, Text: ,
|————————Node:binary_expression Text: (void __iomem *)Can_pitapci_control[i] + PITA2_ICR
|—————————Node:cast_expression Text: (void __iomem *)Can_pitapci_control[i]
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: Can_pitapci_control[i]
|———————————Node:identifier Text: Can_pitapci_control
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:identifier Text: PITA2_ICR
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: err("int i ist %d", i);
|——————Node:call_expression Text: err("int i ist %d", i)
|———————Node:identifier Text: err
|———————Node:argument_list Text: ("int i ist %d", i)
|————————Node:( Text: (
|————————Node:string_literal Text: "int i ist %d"
|—————————Node:" Text: "
|—————————Node:string_content Text: int i ist %d
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: i
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* look for a CAN controller at 0x400 */
|—————Node:if_statement Text: if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4))
|———————Node:( Text: (
|———————Node:call_expression Text: controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)
|————————Node:identifier Text: controller_available
|————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400, 4)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|——————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|———————————Node:identifier Text: PCI_BASE_ADDRESS1
|———————————Node:argument_list Text: (pdev)
|————————————Node:( Text: (
|————————————Node:identifier Text: pdev
|————————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 0x400
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
	printk(" CAN: %d. at pos 1\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: printk(" CAN: %d. at pos 1\n", i);
|————————Node:call_expression Text: printk(" CAN: %d. at pos 1\n", i)
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: (" CAN: %d. at pos 1\n", i)
|——————————Node:( Text: (
|——————————Node:string_literal Text: " CAN: %d. at pos 1\n"
|———————————Node:" Text: "
|———————————Node:string_content Text:  CAN: %d. at pos 1
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: i
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (i > MAX_CHANNELS)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: i > MAX_CHANNELS
|——————————Node:identifier Text: i
|——————————Node:> Text: >
|——————————Node:identifier Text: MAX_CHANNELS
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS);
|——————————Node:call_expression Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS)
|———————————Node:identifier Text: printk
|———————————Node:argument_list Text: ("CAN: only %d devices supported\n", MAX_CHANNELS)
|————————————Node:( Text: (
|————————————Node:string_literal Text: "CAN: only %d devices supported\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: CAN: only %d devices supported
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:identifier Text: MAX_CHANNELS
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return i;
|——————————Node:return Text: return
|——————————Node:identifier Text: i
|——————————Node:; Text: ;
|—————————Node:comment Text: /* the devices scan loop */
|—————————Node:} Text: }
|———————Node:expression_statement Text: Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
|————————Node:assignment_expression Text: Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|—————————Node:subscript_expression Text: Base[i]
|——————————Node:identifier Text: Base
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: unsigned long
|———————————Node:sized_type_specifier Text: unsigned long
|————————————Node:unsigned Text: unsigned
|————————————Node:long Text: long
|——————————Node:) Text: )
|——————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|———————————Node:identifier Text: ioremap
|———————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|—————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|——————————————Node:identifier Text: PCI_BASE_ADDRESS1
|——————————————Node:argument_list Text: (pdev)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: pdev
|———————————————Node:) Text: )
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 0x400
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: 32*4
|—————————————Node:number_literal Text: 32
|—————————————Node:* Text: *
|—————————————Node:number_literal Text: 4
|————————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: IOModel[i] = 'm';
|————————Node:assignment_expression Text: IOModel[i] = 'm'
|—————————Node:subscript_expression Text: IOModel[i]
|——————————Node:identifier Text: IOModel
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:char_literal Text: 'm'
|——————————Node:' Text: '
|——————————Node:character Text: m
|——————————Node:' Text: '
|————————Node:; Text: ;
|———————Node:expression_statement Text: IRQ[i] = pdev->irq;
|————————Node:assignment_expression Text: IRQ[i] = pdev->irq
|—————————Node:subscript_expression Text: IRQ[i]
|——————————Node:identifier Text: IRQ
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:field_expression Text: pdev->irq
|——————————Node:identifier Text: pdev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: irq
|————————Node:; Text: ;
|———————Node:expression_statement Text: i++;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
	/* printk(" CAN: NO at pos 1\n"); */
	;
    }
|————————Node:{ Text: {
|————————Node:comment Text: /* printk(" CAN: NO at pos 1\n"); */
|————————Node:expression_statement Text: ;
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:expression_statement Text: err("int i ist %d", i);
|——————Node:call_expression Text: err("int i ist %d", i)
|———————Node:identifier Text: err
|———————Node:argument_list Text: ("int i ist %d", i)
|————————Node:( Text: (
|————————Node:string_literal Text: "int i ist %d"
|—————————Node:" Text: "
|—————————Node:string_content Text: int i ist %d
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: i
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* look for a second CAN controller at 0x400 */
|—————Node:if_statement Text: if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    } else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4))
|———————Node:( Text: (
|———————Node:call_expression Text: controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)
|————————Node:identifier Text: controller_available
|————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600, 4)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|——————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|———————————Node:identifier Text: PCI_BASE_ADDRESS1
|———————————Node:argument_list Text: (pdev)
|————————————Node:( Text: (
|————————————Node:identifier Text: pdev
|————————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 0x600
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 4
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
	printk(" CAN: %d. at pos 2\n", i);
	if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
	/* share the board control register with prev ch */
	Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
	Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
	IOModel[i] = 'm';
	IRQ[i] = pdev->irq;
	i++;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: printk(" CAN: %d. at pos 2\n", i);
|————————Node:call_expression Text: printk(" CAN: %d. at pos 2\n", i)
|—————————Node:identifier Text: printk
|—————————Node:argument_list Text: (" CAN: %d. at pos 2\n", i)
|——————————Node:( Text: (
|——————————Node:string_literal Text: " CAN: %d. at pos 2\n"
|———————————Node:" Text: "
|———————————Node:string_content Text:  CAN: %d. at pos 2
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: i
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if(i > MAX_CHANNELS) {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (i > MAX_CHANNELS)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: i > MAX_CHANNELS
|——————————Node:identifier Text: i
|——————————Node:> Text: >
|——————————Node:identifier Text: MAX_CHANNELS
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
	    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
	    return i; /* the devices scan loop */
	}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS);
|——————————Node:call_expression Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS)
|———————————Node:identifier Text: printk
|———————————Node:argument_list Text: ("CAN: only %d devices supported\n", MAX_CHANNELS)
|————————————Node:( Text: (
|————————————Node:string_literal Text: "CAN: only %d devices supported\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: CAN: only %d devices supported
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:identifier Text: MAX_CHANNELS
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return i;
|——————————Node:return Text: return
|——————————Node:identifier Text: i
|——————————Node:; Text: ;
|—————————Node:comment Text: /* the devices scan loop */
|—————————Node:} Text: }
|———————Node:comment Text: /* share the board control register with prev ch */
|———————Node:expression_statement Text: Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1];
|————————Node:assignment_expression Text: Can_pitapci_control[i] = 
	    Can_pitapci_control[i - 1]
|—————————Node:subscript_expression Text: Can_pitapci_control[i]
|——————————Node:identifier Text: Can_pitapci_control
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:subscript_expression Text: Can_pitapci_control[i - 1]
|——————————Node:identifier Text: Can_pitapci_control
|——————————Node:[ Text: [
|——————————Node:binary_expression Text: i - 1
|———————————Node:identifier Text: i
|———————————Node:- Text: -
|———————————Node:number_literal Text: 1
|——————————Node:] Text: ]
|————————Node:; Text: ;
|———————Node:expression_statement Text: Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
|————————Node:assignment_expression Text: Base[i]
	= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|—————————Node:subscript_expression Text: Base[i]
|——————————Node:identifier Text: Base
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: unsigned long
|———————————Node:sized_type_specifier Text: unsigned long
|————————————Node:unsigned Text: unsigned
|————————————Node:long Text: long
|——————————Node:) Text: )
|——————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|———————————Node:identifier Text: ioremap
|———————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|—————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|——————————————Node:identifier Text: PCI_BASE_ADDRESS1
|——————————————Node:argument_list Text: (pdev)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: pdev
|———————————————Node:) Text: )
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 0x600
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: 32*4
|—————————————Node:number_literal Text: 32
|—————————————Node:* Text: *
|—————————————Node:number_literal Text: 4
|————————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: IOModel[i] = 'm';
|————————Node:assignment_expression Text: IOModel[i] = 'm'
|—————————Node:subscript_expression Text: IOModel[i]
|——————————Node:identifier Text: IOModel
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:char_literal Text: 'm'
|——————————Node:' Text: '
|——————————Node:character Text: m
|——————————Node:' Text: '
|————————Node:; Text: ;
|———————Node:expression_statement Text: IRQ[i] = pdev->irq;
|————————Node:assignment_expression Text: IRQ[i] = pdev->irq
|—————————Node:subscript_expression Text: IRQ[i]
|——————————Node:identifier Text: IRQ
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:field_expression Text: pdev->irq
|——————————Node:identifier Text: pdev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: irq
|————————Node:; Text: ;
|———————Node:expression_statement Text: i++;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
	/* printk(" CAN: NO at pos 2\n"); */
	;
    }
|————————Node:{ Text: {
|————————Node:comment Text: /* printk(" CAN: NO at pos 2\n"); */
|————————Node:expression_statement Text: ;
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:expression_statement Text: err("int i ist %d", i);
|——————Node:call_expression Text: err("int i ist %d", i)
|———————Node:identifier Text: err
|———————Node:argument_list Text: ("int i ist %d", i)
|————————Node:( Text: (
|————————Node:string_literal Text: "int i ist %d"
|—————————Node:" Text: "
|—————————Node:string_content Text: int i ist %d
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: i
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: DBGout();
|——————Node:call_expression Text: DBGout()
|———————Node:identifier Text: DBGout
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return i;
|——————Node:return Text: return
|——————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:function_definition Text: int new_pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;			/* number of devices found */
int	minor = -1;			/* to make DBGin() happy */

    DBGin();
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
#endif
    DBGout();
    return 0;
}
|————Node:primitive_type Text: int
|————Node:function_declarator Text: new_pcimod_scan(void)
|—————Node:identifier Text: new_pcimod_scan
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:compound_statement Text: {
struct	pci_dev *pdev = NULL;
int	candev = 0;			/* number of devices found */
int	minor = -1;			/* to make DBGin() happy */

    DBGin();
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
#endif
    DBGout();
    return 0;
}
|—————Node:{ Text: {
|—————Node:declaration Text: struct	pci_dev *pdev = NULL;
|——————Node:struct_specifier Text: struct	pci_dev
|———————Node:struct Text: struct
|———————Node:type_identifier Text: pci_dev
|——————Node:init_declarator Text: *pdev = NULL
|———————Node:pointer_declarator Text: *pdev
|————————Node:* Text: *
|————————Node:identifier Text: pdev
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:declaration Text: int	candev = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: candev = 0
|———————Node:identifier Text: candev
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: /* number of devices found */
|—————Node:declaration Text: int	minor = -1;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: minor = -1
|———————Node:identifier Text: minor
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:comment Text: /* to make DBGin() happy */
|—————Node:expression_statement Text: DBGin();
|——————Node:call_expression Text: DBGin()
|———————Node:identifier Text: DBGin
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:preproc_if Text: #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
#endif
|——————Node:#if Text: #if
|——————Node:binary_expression Text: LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
|———————Node:identifier Text: LINUX_VERSION_CODE
|———————Node:< Text: <
|———————Node:call_expression Text: KERNEL_VERSION(2,5,0)
|————————Node:identifier Text: KERNEL_VERSION
|————————Node:argument_list Text: (2,5,0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 5
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|——————Node:
 Text: 

|——————Node:comment Text: /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
|——————Node:if_statement Text: if (pci_present ()) {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else { 
        err("No PCI bios present");
        return -ENODEV;
    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (pci_present ())
|————————Node:( Text: (
|————————Node:call_expression Text: pci_present ()
|—————————Node:identifier Text: pci_present
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
#endif

    for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
    if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    }
|————————Node:{ Text: {
|————————Node:preproc_call Text: #endif

|—————————Node:preproc_directive Text: #endif
|————————Node:function_definition Text: for_each_pci_dev(pdev) {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
|—————————Node:type_identifier Text: for_each_pci_dev
|—————————Node:parenthesized_declarator Text: (pdev)
|——————————Node:( Text: (
|——————————Node:identifier Text: pdev
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
	if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
	if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
    }
|——————————Node:{ Text: {
|——————————Node:if_statement Text: if(pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030) {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: pdev->vendor == PCI_VENDOR_ID_PLX
	&& pdev->device == PCI_DEVICE_ID_PLX_9030
|—————————————Node:binary_expression Text: pdev->vendor == PCI_VENDOR_ID_PLX
|——————————————Node:field_expression Text: pdev->vendor
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: vendor
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: PCI_VENDOR_ID_PLX
|—————————————Node:&& Text: &&
|—————————————Node:binary_expression Text: pdev->device == PCI_DEVICE_ID_PLX_9030
|——————————————Node:field_expression Text: pdev->device
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: device
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: PCI_DEVICE_ID_PLX_9030
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
	    err("found new EMS pci board %d", candev);
	    printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
	    printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
	    /* reading delivers 0x10b5, 0x4000 */
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
	}
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: err("found new EMS pci board %d", candev);
|—————————————Node:call_expression Text: err("found new EMS pci board %d", candev)
|——————————————Node:identifier Text: err
|——————————————Node:argument_list Text: ("found new EMS pci board %d", candev)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "found new EMS pci board %d"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: found new EMS pci board %d
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: candev
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor);
|—————————————Node:call_expression Text: printk("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor)
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: ("Subsystem Vendor 0x%0x\n", pdev->subsystem_vendor)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "Subsystem Vendor 0x%0x\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: Subsystem Vendor 0x%0x
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:field_expression Text: pdev->subsystem_vendor
|————————————————Node:identifier Text: pdev
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: subsystem_vendor
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: printk("Subsystem Device 0x%0x\n", pdev->subsystem_device);
|—————————————Node:call_expression Text: printk("Subsystem Device 0x%0x\n", pdev->subsystem_device)
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: ("Subsystem Device 0x%0x\n", pdev->subsystem_device)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "Subsystem Device 0x%0x\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: Subsystem Device 0x%0x
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:field_expression Text: pdev->subsystem_device
|————————————————Node:identifier Text: pdev
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: subsystem_device
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:comment Text: /* reading delivers 0x10b5, 0x4000 */
|————————————Node:if_statement Text: if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_new_cpcpci(pdev, candev);
	    }
|—————————————Node:if Text: if
|—————————————Node:parenthesized_expression Text: (pci_enable_device(pdev))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: pci_enable_device(pdev)
|———————————————Node:identifier Text: pci_enable_device
|———————————————Node:argument_list Text: (pdev)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: pdev
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|—————————————Node:compound_statement Text: {
		    continue;
	    }
|——————————————Node:{ Text: {
|——————————————Node:continue_statement Text: continue;
|———————————————Node:continue Text: continue
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————————Node:else_clause Text: else {
		candev += register_new_cpcpci(pdev, candev);
	    }
|——————————————Node:else Text: else
|——————————————Node:compound_statement Text: {
		candev += register_new_cpcpci(pdev, candev);
	    }
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: candev += register_new_cpcpci(pdev, candev);
|————————————————Node:assignment_expression Text: candev += register_new_cpcpci(pdev, candev)
|—————————————————Node:identifier Text: candev
|—————————————————Node:+= Text: +=
|—————————————————Node:call_expression Text: register_new_cpcpci(pdev, candev)
|——————————————————Node:identifier Text: register_new_cpcpci
|——————————————————Node:argument_list Text: (pdev, candev)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: pdev
|———————————————————Node:, Text: ,
|———————————————————Node:identifier Text: candev
|———————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|————————————Node:} Text: }
|——————————Node:if_statement Text: if(pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN) {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: pdev->vendor == PCI_VENDOR_CAN_EMS
	&& pdev->device == PCI_DEVICE_CAN
|—————————————Node:binary_expression Text: pdev->vendor == PCI_VENDOR_CAN_EMS
|——————————————Node:field_expression Text: pdev->vendor
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: vendor
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: PCI_VENDOR_CAN_EMS
|—————————————Node:&& Text: &&
|—————————————Node:binary_expression Text: pdev->device == PCI_DEVICE_CAN
|——————————————Node:field_expression Text: pdev->device
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: device
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: PCI_DEVICE_CAN
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
	    err("found old EMS pci board %d", candev);
	    if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
	}
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: err("found old EMS pci board %d", candev);
|—————————————Node:call_expression Text: err("found old EMS pci board %d", candev)
|——————————————Node:identifier Text: err
|——————————————Node:argument_list Text: ("found old EMS pci board %d", candev)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "found old EMS pci board %d"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: found old EMS pci board %d
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: candev
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:if_statement Text: if (pci_enable_device(pdev)) {
		    continue;
	    } else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
|—————————————Node:if Text: if
|—————————————Node:parenthesized_expression Text: (pci_enable_device(pdev))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: pci_enable_device(pdev)
|———————————————Node:identifier Text: pci_enable_device
|———————————————Node:argument_list Text: (pdev)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: pdev
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|—————————————Node:compound_statement Text: {
		    continue;
	    }
|——————————————Node:{ Text: {
|——————————————Node:continue_statement Text: continue;
|———————————————Node:continue Text: continue
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————————Node:else_clause Text: else {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
|——————————————Node:else Text: else
|——————————————Node:compound_statement Text: {
		candev += register_old_cpcpci(pdev, candev);
		;
	    }
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: candev += register_old_cpcpci(pdev, candev);
|————————————————Node:assignment_expression Text: candev += register_old_cpcpci(pdev, candev)
|—————————————————Node:identifier Text: candev
|—————————————————Node:+= Text: +=
|—————————————————Node:call_expression Text: register_old_cpcpci(pdev, candev)
|——————————————————Node:identifier Text: register_old_cpcpci
|——————————————————Node:argument_list Text: (pdev, candev)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: pdev
|———————————————————Node:, Text: ,
|———————————————————Node:identifier Text: candev
|———————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:expression_statement Text: ;
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|————————————Node:} Text: }
|——————————Node:} Text: }
|————————Node:if_statement Text: if(candev == 0) {
	err("No CAN device found");
	return -ENODEV;
    } else {
    	err("found %d CAN controllers", candev);
    }
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (candev == 0)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: candev == 0
|———————————Node:identifier Text: candev
|———————————Node:== Text: ==
|———————————Node:number_literal Text: 0
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
	err("No CAN device found");
	return -ENODEV;
    }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: err("No CAN device found");
|———————————Node:call_expression Text: err("No CAN device found")
|————————————Node:identifier Text: err
|————————————Node:argument_list Text: ("No CAN device found")
|—————————————Node:( Text: (
|—————————————Node:string_literal Text: "No CAN device found"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: No CAN device found
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:return_statement Text: return -ENODEV;
|———————————Node:return Text: return
|———————————Node:unary_expression Text: -ENODEV
|————————————Node:- Text: -
|————————————Node:identifier Text: ENODEV
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else {
    	err("found %d CAN controllers", candev);
    }
|——————————Node:else Text: else
|——————————Node:compound_statement Text: {
    	err("found %d CAN controllers", candev);
    }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: err("found %d CAN controllers", candev);
|————————————Node:call_expression Text: err("found %d CAN controllers", candev)
|—————————————Node:identifier Text: err
|—————————————Node:argument_list Text: ("found %d CAN controllers", candev)
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "found %d CAN controllers"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: found %d CAN controllers
|———————————————Node:" Text: "
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: candev
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|————————Node:preproc_if Text: #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)

|—————————Node:#if Text: #if
|—————————Node:binary_expression Text: LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
|——————————Node:identifier Text: LINUX_VERSION_CODE
|——————————Node:< Text: <
|——————————Node:call_expression Text: KERNEL_VERSION(2,5,0)
|———————————Node:identifier Text: KERNEL_VERSION
|———————————Node:argument_list Text: (2,5,0)
|————————————Node:( Text: (
|————————————Node:number_literal Text: 2
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 5
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:) Text: )
|—————————Node:
 Text: 

|—————————Node:#endif Text: 
|————————Node:} Text: }
|———————Node:else_clause Text: else { 
        err("No PCI bios present");
        return -ENODEV;
    }
|————————Node:else Text: else
|————————Node:compound_statement Text: { 
        err("No PCI bios present");
        return -ENODEV;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: err("No PCI bios present");
|——————————Node:call_expression Text: err("No PCI bios present")
|———————————Node:identifier Text: err
|———————————Node:argument_list Text: ("No PCI bios present")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "No PCI bios present"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: No PCI bios present
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -ENODEV;
|——————————Node:return Text: return
|——————————Node:unary_expression Text: -ENODEV
|———————————Node:- Text: -
|———————————Node:identifier Text: ENODEV
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:#endif Text: #endif
|—————Node:expression_statement Text: DBGout();
|——————Node:call_expression Text: DBGout()
|———————Node:identifier Text: DBGout
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Should be replaced by  new_pcimod_scan() soon
 * to be able to handle both kinds of CPC-PCI
 * hopefully for both boards with the same driver
 * and if possible for the Kvaser PCI as well
 */
|———Node:function_definition Text: int pcimod_scan(void)
{
struct	pci_dev *pdev = NULL;
int	candev = 0;				/* number of devices found */
unsigned long ptr;				/* ptr to PITA control */

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
#endif
    return 0;
}
|————Node:primitive_type Text: int
|————Node:function_declarator Text: pcimod_scan(void)
|—————Node:identifier Text: pcimod_scan
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:compound_statement Text: {
struct	pci_dev *pdev = NULL;
int	candev = 0;				/* number of devices found */
unsigned long ptr;				/* ptr to PITA control */

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
#endif
    return 0;
}
|—————Node:{ Text: {
|—————Node:declaration Text: struct	pci_dev *pdev = NULL;
|——————Node:struct_specifier Text: struct	pci_dev
|———————Node:struct Text: struct
|———————Node:type_identifier Text: pci_dev
|——————Node:init_declarator Text: *pdev = NULL
|———————Node:pointer_declarator Text: *pdev
|————————Node:* Text: *
|————————Node:identifier Text: pdev
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:declaration Text: int	candev = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: candev = 0
|———————Node:identifier Text: candev
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: /* number of devices found */
|—————Node:declaration Text: unsigned long ptr;
|——————Node:sized_type_specifier Text: unsigned long
|———————Node:unsigned Text: unsigned
|———————Node:long Text: long
|——————Node:identifier Text: ptr
|——————Node:; Text: ;
|—————Node:comment Text: /* ptr to PITA control */
|—————Node:preproc_if Text: #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
    if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
#endif
|——————Node:#if Text: #if
|——————Node:binary_expression Text: LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
|———————Node:identifier Text: LINUX_VERSION_CODE
|———————Node:< Text: <
|———————Node:call_expression Text: KERNEL_VERSION(2,5,0)
|————————Node:identifier Text: KERNEL_VERSION
|————————Node:argument_list Text: (2,5,0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 2
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 5
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|——————Node:
 Text: 

|——————Node:comment Text: /* Testing the PCI presence is no longer neccessary
     * On a non  PCI kernel, insmod will just complain
     */
|——————Node:if_statement Text: if (pci_present ()) {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    } else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (pci_present ())
|————————Node:( Text: (
|————————Node:call_expression Text: pci_present ()
|—————————Node:identifier Text: pci_present
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
#endif
	    while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
    }
|————————Node:{ Text: {
|————————Node:preproc_call Text: #endif

|—————————Node:preproc_directive Text: #endif
|————————Node:while_statement Text: while((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))) {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
|—————————Node:while Text: while
|—————————Node:parenthesized_expression Text: ((pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev)))
|——————————Node:( Text: (
|——————————Node:parenthesized_expression Text: (pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev))
|———————————Node:( Text: (
|———————————Node:assignment_expression Text: pdev =
	    	pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev)
|————————————Node:identifier Text: pdev
|————————————Node:= Text: =
|————————————Node:call_expression Text: pci_get_device (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev)
|—————————————Node:identifier Text: pci_get_device
|—————————————Node:argument_list Text: (PCI_VENDOR_CAN_EMS, PCI_DEVICE_CAN, pdev)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: PCI_VENDOR_CAN_EMS
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: PCI_DEVICE_CAN
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: pdev
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
	    if (pci_enable_device(pdev)) {
		continue;
	    }
	    /* printk("        using IRQ %d\n", pdev->irq); */

	    ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
	    /* enable memory access */
	    /* printk("write to pita\n"); */
	    writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
	    Can_pitapci_control[candev] = ptr;

	    /* printk("        pita ptr %lx\n", ptr); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
	    /* printk("---------------\n"); */
	    /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */

	    /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
	    {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
	    /* we are now sure to have the right board,
	       reset the CAN controller(s) */
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
	    reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);

	    /* enable interrupts Int_0 */
	    /* write to PITAs ICR register */
	    writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);

	    /* look for a CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
	    /* look for a second CAN controller at 0x400 */
	    if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
	}
|——————————Node:{ Text: {
|——————————Node:preproc_if Text: #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
	    printk("  found CPC-PCI: %s\n", pdev->name);
#else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
#endif
|———————————Node:#if Text: #if
|———————————Node:binary_expression Text: LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
|————————————Node:identifier Text: LINUX_VERSION_CODE
|————————————Node:< Text: <
|————————————Node:call_expression Text: KERNEL_VERSION(2,5,0)
|—————————————Node:identifier Text: KERNEL_VERSION
|—————————————Node:argument_list Text: (2,5,0)
|——————————————Node:( Text: (
|——————————————Node:number_literal Text: 2
|——————————————Node:, Text: ,
|——————————————Node:number_literal Text: 5
|——————————————Node:, Text: ,
|——————————————Node:number_literal Text: 0
|——————————————Node:) Text: )
|———————————Node:
 Text: 

|———————————Node:expression_statement Text: printk("  found CPC-PCI: %s\n", pdev->name);
|————————————Node:call_expression Text: printk("  found CPC-PCI: %s\n", pdev->name)
|—————————————Node:identifier Text: printk
|—————————————Node:argument_list Text: ("  found CPC-PCI: %s\n", pdev->name)
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "  found CPC-PCI: %s\n"
|———————————————Node:" Text: "
|———————————————Node:string_content Text:   found CPC-PCI: %s
|———————————————Node:escape_sequence Text: \n
|———————————————Node:" Text: "
|——————————————Node:, Text: ,
|——————————————Node:field_expression Text: pdev->name
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: name
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:preproc_else Text: #else
	    printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
	    printk("               : %s\n", pci_name(pdev));
|————————————Node:#else Text: #else
|————————————Node:expression_statement Text: printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev));
|—————————————Node:call_expression Text: printk("  found CPC-PCI: %s\n", pci_pretty_name(pdev))
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: ("  found CPC-PCI: %s\n", pci_pretty_name(pdev))
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "  found CPC-PCI: %s\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text:   found CPC-PCI: %s
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:call_expression Text: pci_pretty_name(pdev)
|————————————————Node:identifier Text: pci_pretty_name
|————————————————Node:argument_list Text: (pdev)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: pdev
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: printk("               : %s\n", pci_name(pdev));
|—————————————Node:call_expression Text: printk("               : %s\n", pci_name(pdev))
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: ("               : %s\n", pci_name(pdev))
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "               : %s\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text:                : %s
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:call_expression Text: pci_name(pdev)
|————————————————Node:identifier Text: pci_name
|————————————————Node:argument_list Text: (pdev)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: pdev
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|———————————Node:#endif Text: #endif
|——————————Node:if_statement Text: if (pci_enable_device(pdev)) {
		continue;
	    }
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (pci_enable_device(pdev))
|————————————Node:( Text: (
|————————————Node:call_expression Text: pci_enable_device(pdev)
|—————————————Node:identifier Text: pci_enable_device
|—————————————Node:argument_list Text: (pdev)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: pdev
|——————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
		continue;
	    }
|————————————Node:{ Text: {
|————————————Node:continue_statement Text: continue;
|—————————————Node:continue Text: continue
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|——————————Node:comment Text: /* printk("        using IRQ %d\n", pdev->irq); */
|——————————Node:expression_statement Text: ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256);
|———————————Node:assignment_expression Text: ptr = (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|————————————Node:identifier Text: ptr
|————————————Node:= Text: =
|————————————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: unsigned long
|——————————————Node:sized_type_specifier Text: unsigned long
|———————————————Node:unsigned Text: unsigned
|———————————————Node:long Text: long
|—————————————Node:) Text: )
|—————————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS0(pdev), 256)
|——————————————Node:identifier Text: ioremap
|——————————————Node:argument_list Text: (PCI_BASE_ADDRESS0(pdev), 256)
|———————————————Node:( Text: (
|———————————————Node:call_expression Text: PCI_BASE_ADDRESS0(pdev)
|————————————————Node:identifier Text: PCI_BASE_ADDRESS0
|————————————————Node:argument_list Text: (pdev)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: pdev
|—————————————————Node:) Text: )
|———————————————Node:, Text: ,
|———————————————Node:number_literal Text: 256
|———————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:comment Text: /* enable memory access */
|——————————Node:comment Text: /* printk("write to pita\n"); */
|——————————Node:expression_statement Text: writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC);
|———————————Node:call_expression Text: writel(PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC)
|————————————Node:identifier Text: writel
|————————————Node:argument_list Text: (PITA2_MISC_CONFIG, (void __iomem *)ptr + PITA2_MISC)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: PITA2_MISC_CONFIG
|—————————————Node:, Text: ,
|—————————————Node:binary_expression Text: (void __iomem *)ptr + PITA2_MISC
|——————————————Node:cast_expression Text: (void __iomem *)ptr
|———————————————Node:( Text: (
|———————————————Node:ERROR Text: void
|————————————————Node:primitive_type Text: void
|———————————————Node:type_descriptor Text: __iomem *
|————————————————Node:type_identifier Text: __iomem
|————————————————Node:abstract_pointer_declarator Text: *
|—————————————————Node:* Text: *
|———————————————Node:) Text: )
|———————————————Node:identifier Text: ptr
|——————————————Node:+ Text: +
|——————————————Node:identifier Text: PITA2_MISC
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: Can_pitapci_control[candev] = ptr;
|———————————Node:assignment_expression Text: Can_pitapci_control[candev] = ptr
|————————————Node:subscript_expression Text: Can_pitapci_control[candev]
|—————————————Node:identifier Text: Can_pitapci_control
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: candev
|—————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:identifier Text: ptr
|———————————Node:; Text: ;
|——————————Node:comment Text: /* printk("        pita ptr %lx\n", ptr); */
|——————————Node:comment Text: /* printk("---------------\n"); */
|——————————Node:comment Text: /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x400, 4); */
|——————————Node:comment Text: /* printk("---------------\n"); */
|——————————Node:comment Text: /* dump_CAN(PCI_BASE_ADDRESS1(pdev)+0x600, 4); */
|——————————Node:comment Text: /* PCI_BASE_ADDRESS1:
	     * at address 0 are some EMS control registers
	     * at address 0x400 the first controller area 
	     * at address 0x600 the second controller area 
	     * registers are read as 32bit
	     *
	     * at adress 0 we can verify the card
	     * 0x55 0xaa 0x01 0xcb
     */
|——————————Node:compound_statement Text: {
		void __iomem *sigptr; /* ptr to EMS signature  */
		unsigned long signature = 0;
	        sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
	        signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
	    	/* printk("        signature  %lx\n", signature); */
	    	if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
	    }
|———————————Node:{ Text: {
|———————————Node:declaration Text: void __iomem *sigptr;
|————————————Node:primitive_type Text: void
|————————————Node:ERROR Text: __iomem
|—————————————Node:identifier Text: __iomem
|————————————Node:pointer_declarator Text: *sigptr
|—————————————Node:* Text: *
|—————————————Node:identifier Text: sigptr
|————————————Node:; Text: ;
|———————————Node:comment Text: /* ptr to EMS signature  */
|———————————Node:declaration Text: unsigned long signature = 0;
|————————————Node:sized_type_specifier Text: unsigned long
|—————————————Node:unsigned Text: unsigned
|—————————————Node:long Text: long
|————————————Node:init_declarator Text: signature = 0
|—————————————Node:identifier Text: signature
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256);
|————————————Node:assignment_expression Text: sigptr = (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|—————————————Node:identifier Text: sigptr
|—————————————Node:= Text: =
|—————————————Node:cast_expression Text: (void __iomem *)ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|——————————————Node:( Text: (
|——————————————Node:ERROR Text: void
|———————————————Node:primitive_type Text: void
|——————————————Node:type_descriptor Text: __iomem *
|———————————————Node:type_identifier Text: __iomem
|———————————————Node:abstract_pointer_declarator Text: *
|————————————————Node:* Text: *
|——————————————Node:) Text: )
|——————————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev), 256)
|———————————————Node:identifier Text: ioremap
|———————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev), 256)
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|—————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|—————————————————Node:argument_list Text: (pdev)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: pdev
|——————————————————Node:) Text: )
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 256
|————————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12);
|————————————Node:assignment_expression Text: signature =
	        	  (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12)
|—————————————Node:identifier Text: signature
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
	        	+  readb(sigptr + 12)
|——————————————Node:binary_expression Text: (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
	        	+ (readb(sigptr +  8) <<  8)
|———————————————Node:binary_expression Text: (readb(sigptr)      << 24)
	        	+ (readb(sigptr +  4) << 16)
|————————————————Node:parenthesized_expression Text: (readb(sigptr)      << 24)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: readb(sigptr)      << 24
|——————————————————Node:call_expression Text: readb(sigptr)
|———————————————————Node:identifier Text: readb
|———————————————————Node:argument_list Text: (sigptr)
|————————————————————Node:( Text: (
|————————————————————Node:identifier Text: sigptr
|————————————————————Node:) Text: )
|——————————————————Node:<< Text: <<
|——————————————————Node:number_literal Text: 24
|—————————————————Node:) Text: )
|————————————————Node:+ Text: +
|————————————————Node:parenthesized_expression Text: (readb(sigptr +  4) << 16)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: readb(sigptr +  4) << 16
|——————————————————Node:call_expression Text: readb(sigptr +  4)
|———————————————————Node:identifier Text: readb
|———————————————————Node:argument_list Text: (sigptr +  4)
|————————————————————Node:( Text: (
|————————————————————Node:binary_expression Text: sigptr +  4
|—————————————————————Node:identifier Text: sigptr
|—————————————————————Node:+ Text: +
|—————————————————————Node:number_literal Text: 4
|————————————————————Node:) Text: )
|——————————————————Node:<< Text: <<
|——————————————————Node:number_literal Text: 16
|—————————————————Node:) Text: )
|———————————————Node:+ Text: +
|———————————————Node:parenthesized_expression Text: (readb(sigptr +  8) <<  8)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: readb(sigptr +  8) <<  8
|—————————————————Node:call_expression Text: readb(sigptr +  8)
|——————————————————Node:identifier Text: readb
|——————————————————Node:argument_list Text: (sigptr +  8)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: sigptr +  8
|————————————————————Node:identifier Text: sigptr
|————————————————————Node:+ Text: +
|————————————————————Node:number_literal Text: 8
|———————————————————Node:) Text: )
|—————————————————Node:<< Text: <<
|—————————————————Node:number_literal Text: 8
|————————————————Node:) Text: )
|——————————————Node:+ Text: +
|——————————————Node:call_expression Text: readb(sigptr + 12)
|———————————————Node:identifier Text: readb
|———————————————Node:argument_list Text: (sigptr + 12)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: sigptr + 12
|—————————————————Node:identifier Text: sigptr
|—————————————————Node:+ Text: +
|—————————————————Node:number_literal Text: 12
|————————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:comment Text: /* printk("        signature  %lx\n", signature); */
|———————————Node:if_statement Text: if( 0x55aa01cb != signature) {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: ( 0x55aa01cb != signature)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 0x55aa01cb != signature
|——————————————Node:number_literal Text: 0x55aa01cb
|——————————————Node:!= Text: !=
|——————————————Node:identifier Text: signature
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
	    	    printk(" wrong signature -- no EMS CPC-PCI board\n");
		    return -ENODEV;
	    	}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: printk(" wrong signature -- no EMS CPC-PCI board\n");
|——————————————Node:call_expression Text: printk(" wrong signature -- no EMS CPC-PCI board\n")
|———————————————Node:identifier Text: printk
|———————————————Node:argument_list Text: (" wrong signature -- no EMS CPC-PCI board\n")
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: " wrong signature -- no EMS CPC-PCI board\n"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text:  wrong signature -- no EMS CPC-PCI board
|—————————————————Node:escape_sequence Text: \n
|—————————————————Node:" Text: "
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:return_statement Text: return -ENODEV;
|——————————————Node:return Text: return
|——————————————Node:unary_expression Text: -ENODEV
|———————————————Node:- Text: -
|———————————————Node:identifier Text: ENODEV
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:comment Text: /* we are now sure to have the right board,
	       reset the CAN controller(s) */
|——————————Node:expression_statement Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400);
|———————————Node:call_expression Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x400)
|————————————Node:identifier Text: reset_CPC_PCI
|————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|——————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|———————————————Node:identifier Text: PCI_BASE_ADDRESS1
|———————————————Node:argument_list Text: (pdev)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: pdev
|————————————————Node:) Text: )
|——————————————Node:+ Text: +
|——————————————Node:number_literal Text: 0x400
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600);
|———————————Node:call_expression Text: reset_CPC_PCI(PCI_BASE_ADDRESS1(pdev) + 0x600)
|————————————Node:identifier Text: reset_CPC_PCI
|————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|——————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|———————————————Node:identifier Text: PCI_BASE_ADDRESS1
|———————————————Node:argument_list Text: (pdev)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: pdev
|————————————————Node:) Text: )
|——————————————Node:+ Text: +
|——————————————Node:number_literal Text: 0x600
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:comment Text: /* enable interrupts Int_0 */
|——————————Node:comment Text: /* write to PITAs ICR register */
|——————————Node:expression_statement Text: writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR);
|———————————Node:call_expression Text: writel(PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR)
|————————————Node:identifier Text: writel
|————————————Node:argument_list Text: (PITA2_ICR_INT0_EN,
	    (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: PITA2_ICR_INT0_EN
|—————————————Node:, Text: ,
|—————————————Node:binary_expression Text: (void __iomem *)Can_pitapci_control[candev] + PITA2_ICR
|——————————————Node:cast_expression Text: (void __iomem *)Can_pitapci_control[candev]
|———————————————Node:( Text: (
|———————————————Node:ERROR Text: void
|————————————————Node:primitive_type Text: void
|———————————————Node:type_descriptor Text: __iomem *
|————————————————Node:type_identifier Text: __iomem
|————————————————Node:abstract_pointer_declarator Text: *
|—————————————————Node:* Text: *
|———————————————Node:) Text: )
|———————————————Node:subscript_expression Text: Can_pitapci_control[candev]
|————————————————Node:identifier Text: Can_pitapci_control
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: candev
|————————————————Node:] Text: ]
|——————————————Node:+ Text: +
|——————————————Node:identifier Text: PITA2_ICR
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:comment Text: /* look for a CAN controller at 0x400 */
|——————————Node:if_statement Text: if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)) {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4))
|————————————Node:( Text: (
|————————————Node:call_expression Text: controller_available(PCI_BASE_ADDRESS1(pdev) + 0x400, 4)
|—————————————Node:identifier Text: controller_available
|—————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400, 4)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|———————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|————————————————Node:argument_list Text: (pdev)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: pdev
|—————————————————Node:) Text: )
|———————————————Node:+ Text: +
|———————————————Node:number_literal Text: 0x400
|——————————————Node:, Text: ,
|——————————————Node:number_literal Text: 4
|——————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
		printk(" CAN: %d. at pos 1\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}


#ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif

		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		Clock = 16000;	/* all EMS PCI Boards use the sam clock for all CAN */
		candev++;
	    }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: printk(" CAN: %d. at pos 1\n", candev + 1);
|—————————————Node:call_expression Text: printk(" CAN: %d. at pos 1\n", candev + 1)
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: (" CAN: %d. at pos 1\n", candev + 1)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: " CAN: %d. at pos 1\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text:  CAN: %d. at pos 1
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:binary_expression Text: candev + 1
|————————————————Node:identifier Text: candev
|————————————————Node:+ Text: +
|————————————————Node:number_literal Text: 1
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:if_statement Text: if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
|—————————————Node:if Text: if
|—————————————Node:parenthesized_expression Text: (candev > MAX_CHANNELS)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: candev > MAX_CHANNELS
|———————————————Node:identifier Text: candev
|———————————————Node:> Text: >
|———————————————Node:identifier Text: MAX_CHANNELS
|——————————————Node:) Text: )
|—————————————Node:compound_statement Text: {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS);
|———————————————Node:call_expression Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS)
|————————————————Node:identifier Text: printk
|————————————————Node:argument_list Text: ("CAN: only %d devices supported\n", MAX_CHANNELS)
|—————————————————Node:( Text: (
|—————————————————Node:string_literal Text: "CAN: only %d devices supported\n"
|——————————————————Node:" Text: "
|——————————————————Node:string_content Text: CAN: only %d devices supported
|——————————————————Node:escape_sequence Text: \n
|——————————————————Node:" Text: "
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: MAX_CHANNELS
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|——————————————Node:comment Text: /* the devices scan loop */
|——————————————Node:} Text: }
|————————————Node:preproc_ifdef Text: #ifdef __x86_64__
		Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
	    err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
	    err("Base %lx", Base[candev]);
#else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
#endif
|—————————————Node:#ifdef Text: #ifdef
|—————————————Node:identifier Text: __x86_64__
|—————————————Node:expression_statement Text: Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
|——————————————Node:assignment_expression Text: Base[candev]
		= (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|———————————————Node:subscript_expression Text: Base[candev]
|————————————————Node:identifier Text: Base
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: candev
|————————————————Node:] Text: ]
|———————————————Node:= Text: =
|———————————————Node:cast_expression Text: (upointer_t)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|————————————————Node:( Text: (
|————————————————Node:type_descriptor Text: upointer_t
|—————————————————Node:type_identifier Text: upointer_t
|————————————————Node:) Text: )
|————————————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|—————————————————Node:identifier Text: ioremap
|—————————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|——————————————————Node:( Text: (
|——————————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|———————————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|————————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|————————————————————Node:argument_list Text: (pdev)
|—————————————————————Node:( Text: (
|—————————————————————Node:identifier Text: pdev
|—————————————————————Node:) Text: )
|———————————————————Node:+ Text: +
|———————————————————Node:number_literal Text: 0x400
|——————————————————Node:, Text: ,
|——————————————————Node:binary_expression Text: 32*4
|———————————————————Node:number_literal Text: 32
|———————————————————Node:* Text: *
|———————————————————Node:number_literal Text: 4
|——————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev]);
|——————————————Node:call_expression Text: err("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev])
|———————————————Node:identifier Text: err
|———————————————Node:argument_list Text: ("Base %llx/%lld", 
	    	(long long unsigned)Base[candev],
	    	(long long unsigned)Base[candev])
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: "Base %llx/%lld"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text: Base %llx/%lld
|—————————————————Node:" Text: "
|————————————————Node:, Text: ,
|————————————————Node:cast_expression Text: (long long unsigned)Base[candev]
|—————————————————Node:( Text: (
|—————————————————Node:type_descriptor Text: long long unsigned
|——————————————————Node:sized_type_specifier Text: long long unsigned
|———————————————————Node:long Text: long
|———————————————————Node:long Text: long
|———————————————————Node:unsigned Text: unsigned
|—————————————————Node:) Text: )
|—————————————————Node:subscript_expression Text: Base[candev]
|——————————————————Node:identifier Text: Base
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: candev
|——————————————————Node:] Text: ]
|————————————————Node:, Text: ,
|————————————————Node:cast_expression Text: (long long unsigned)Base[candev]
|—————————————————Node:( Text: (
|—————————————————Node:type_descriptor Text: long long unsigned
|——————————————————Node:sized_type_specifier Text: long long unsigned
|———————————————————Node:long Text: long
|———————————————————Node:long Text: long
|———————————————————Node:unsigned Text: unsigned
|—————————————————Node:) Text: )
|—————————————————Node:subscript_expression Text: Base[candev]
|——————————————————Node:identifier Text: Base
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: candev
|——————————————————Node:] Text: ]
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: err("Base %lx", Base[candev]);
|——————————————Node:call_expression Text: err("Base %lx", Base[candev])
|———————————————Node:identifier Text: err
|———————————————Node:argument_list Text: ("Base %lx", Base[candev])
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: "Base %lx"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text: Base %lx
|—————————————————Node:" Text: "
|————————————————Node:, Text: ,
|————————————————Node:subscript_expression Text: Base[candev]
|—————————————————Node:identifier Text: Base
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: candev
|—————————————————Node:] Text: ]
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:preproc_else Text: #else
	    err("Base %lx", Base[candev]);
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
|——————————————Node:#else Text: #else
|——————————————Node:expression_statement Text: err("Base %lx", Base[candev]);
|———————————————Node:call_expression Text: err("Base %lx", Base[candev])
|————————————————Node:identifier Text: err
|————————————————Node:argument_list Text: ("Base %lx", Base[candev])
|—————————————————Node:( Text: (
|—————————————————Node:string_literal Text: "Base %lx"
|——————————————————Node:" Text: "
|——————————————————Node:string_content Text: Base %lx
|——————————————————Node:" Text: "
|—————————————————Node:, Text: ,
|—————————————————Node:subscript_expression Text: Base[candev]
|——————————————————Node:identifier Text: Base
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: candev
|——————————————————Node:] Text: ]
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:expression_statement Text: Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4);
|———————————————Node:assignment_expression Text: Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|————————————————Node:subscript_expression Text: Base[candev]
|—————————————————Node:identifier Text: Base
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: candev
|—————————————————Node:] Text: ]
|————————————————Node:= Text: =
|————————————————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|—————————————————Node:( Text: (
|—————————————————Node:type_descriptor Text: unsigned long
|——————————————————Node:sized_type_specifier Text: unsigned long
|———————————————————Node:unsigned Text: unsigned
|———————————————————Node:long Text: long
|—————————————————Node:) Text: )
|—————————————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|——————————————————Node:identifier Text: ioremap
|——————————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x400, 32*4)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x400
|————————————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|—————————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|—————————————————————Node:argument_list Text: (pdev)
|——————————————————————Node:( Text: (
|——————————————————————Node:identifier Text: pdev
|——————————————————————Node:) Text: )
|————————————————————Node:+ Text: +
|————————————————————Node:number_literal Text: 0x400
|———————————————————Node:, Text: ,
|———————————————————Node:binary_expression Text: 32*4
|————————————————————Node:number_literal Text: 32
|————————————————————Node:* Text: *
|————————————————————Node:number_literal Text: 4
|———————————————————Node:) Text: )
|———————————————Node:; Text: ;
|—————————————Node:#endif Text: #endif
|————————————Node:expression_statement Text: IOModel[candev] = 'm';
|—————————————Node:assignment_expression Text: IOModel[candev] = 'm'
|——————————————Node:subscript_expression Text: IOModel[candev]
|———————————————Node:identifier Text: IOModel
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:char_literal Text: 'm'
|———————————————Node:' Text: '
|———————————————Node:character Text: m
|———————————————Node:' Text: '
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: IRQ[candev] = pdev->irq;
|—————————————Node:assignment_expression Text: IRQ[candev] = pdev->irq
|——————————————Node:subscript_expression Text: IRQ[candev]
|———————————————Node:identifier Text: IRQ
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:field_expression Text: pdev->irq
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: irq
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: Clock = 16000;
|—————————————Node:assignment_expression Text: Clock = 16000
|——————————————Node:identifier Text: Clock
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 16000
|—————————————Node:; Text: ;
|————————————Node:comment Text: /* all EMS PCI Boards use the sam clock for all CAN */
|————————————Node:expression_statement Text: candev++;
|—————————————Node:update_expression Text: candev++
|——————————————Node:identifier Text: candev
|——————————————Node:++ Text: ++
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
		printk(" CAN: NO CAN at pos 1\n");
		;
	    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: printk(" CAN: NO CAN at pos 1\n");
|——————————————Node:call_expression Text: printk(" CAN: NO CAN at pos 1\n")
|———————————————Node:identifier Text: printk
|———————————————Node:argument_list Text: (" CAN: NO CAN at pos 1\n")
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: " CAN: NO CAN at pos 1\n"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text:  CAN: NO CAN at pos 1
|—————————————————Node:escape_sequence Text: \n
|—————————————————Node:" Text: "
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: ;
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|——————————Node:comment Text: /* look for a second CAN controller at 0x400 */
|——————————Node:if_statement Text: if(controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)) {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    } else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4))
|————————————Node:( Text: (
|————————————Node:call_expression Text: controller_available(PCI_BASE_ADDRESS1(pdev) + 0x600, 4)
|—————————————Node:identifier Text: controller_available
|—————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600, 4)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|———————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|————————————————Node:argument_list Text: (pdev)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: pdev
|—————————————————Node:) Text: )
|———————————————Node:+ Text: +
|———————————————Node:number_literal Text: 0x600
|——————————————Node:, Text: ,
|——————————————Node:number_literal Text: 4
|——————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
		printk(" CAN: %d. at pos 2\n", candev + 1);
		if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
		/* share the board control register with prev ch */
		Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
		Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
		IOModel[candev] = 'm';
		IRQ[candev] = pdev->irq;
		candev++;
	    }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: printk(" CAN: %d. at pos 2\n", candev + 1);
|—————————————Node:call_expression Text: printk(" CAN: %d. at pos 2\n", candev + 1)
|——————————————Node:identifier Text: printk
|——————————————Node:argument_list Text: (" CAN: %d. at pos 2\n", candev + 1)
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: " CAN: %d. at pos 2\n"
|————————————————Node:" Text: "
|————————————————Node:string_content Text:  CAN: %d. at pos 2
|————————————————Node:escape_sequence Text: \n
|————————————————Node:" Text: "
|———————————————Node:, Text: ,
|———————————————Node:binary_expression Text: candev + 1
|————————————————Node:identifier Text: candev
|————————————————Node:+ Text: +
|————————————————Node:number_literal Text: 1
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:if_statement Text: if(candev > MAX_CHANNELS) {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
|—————————————Node:if Text: if
|—————————————Node:parenthesized_expression Text: (candev > MAX_CHANNELS)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: candev > MAX_CHANNELS
|———————————————Node:identifier Text: candev
|———————————————Node:> Text: >
|———————————————Node:identifier Text: MAX_CHANNELS
|——————————————Node:) Text: )
|—————————————Node:compound_statement Text: {
		    printk("CAN: only %d devices supported\n", MAX_CHANNELS);
		    break; /* the devices scan loop */
		}
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS);
|———————————————Node:call_expression Text: printk("CAN: only %d devices supported\n", MAX_CHANNELS)
|————————————————Node:identifier Text: printk
|————————————————Node:argument_list Text: ("CAN: only %d devices supported\n", MAX_CHANNELS)
|—————————————————Node:( Text: (
|—————————————————Node:string_literal Text: "CAN: only %d devices supported\n"
|——————————————————Node:" Text: "
|——————————————————Node:string_content Text: CAN: only %d devices supported
|——————————————————Node:escape_sequence Text: \n
|——————————————————Node:" Text: "
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: MAX_CHANNELS
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|——————————————Node:comment Text: /* the devices scan loop */
|——————————————Node:} Text: }
|————————————Node:comment Text: /* share the board control register with prev ch */
|————————————Node:expression_statement Text: Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1];
|—————————————Node:assignment_expression Text: Can_pitapci_control[candev] = 
		    Can_pitapci_control[candev - 1]
|——————————————Node:subscript_expression Text: Can_pitapci_control[candev]
|———————————————Node:identifier Text: Can_pitapci_control
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:subscript_expression Text: Can_pitapci_control[candev - 1]
|———————————————Node:identifier Text: Can_pitapci_control
|———————————————Node:[ Text: [
|———————————————Node:binary_expression Text: candev - 1
|————————————————Node:identifier Text: candev
|————————————————Node:- Text: -
|————————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4);
|—————————————Node:assignment_expression Text: Base[candev]
		= (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|——————————————Node:subscript_expression Text: Base[candev]
|———————————————Node:identifier Text: Base
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:cast_expression Text: (unsigned long)ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: unsigned long
|————————————————Node:sized_type_specifier Text: unsigned long
|—————————————————Node:unsigned Text: unsigned
|—————————————————Node:long Text: long
|———————————————Node:) Text: )
|———————————————Node:call_expression Text: ioremap(PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|————————————————Node:identifier Text: ioremap
|————————————————Node:argument_list Text: (PCI_BASE_ADDRESS1(pdev) + 0x600, 32*4)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: PCI_BASE_ADDRESS1(pdev) + 0x600
|——————————————————Node:call_expression Text: PCI_BASE_ADDRESS1(pdev)
|———————————————————Node:identifier Text: PCI_BASE_ADDRESS1
|———————————————————Node:argument_list Text: (pdev)
|————————————————————Node:( Text: (
|————————————————————Node:identifier Text: pdev
|————————————————————Node:) Text: )
|——————————————————Node:+ Text: +
|——————————————————Node:number_literal Text: 0x600
|—————————————————Node:, Text: ,
|—————————————————Node:binary_expression Text: 32*4
|——————————————————Node:number_literal Text: 32
|——————————————————Node:* Text: *
|——————————————————Node:number_literal Text: 4
|—————————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: IOModel[candev] = 'm';
|—————————————Node:assignment_expression Text: IOModel[candev] = 'm'
|——————————————Node:subscript_expression Text: IOModel[candev]
|———————————————Node:identifier Text: IOModel
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:char_literal Text: 'm'
|———————————————Node:' Text: '
|———————————————Node:character Text: m
|———————————————Node:' Text: '
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: IRQ[candev] = pdev->irq;
|—————————————Node:assignment_expression Text: IRQ[candev] = pdev->irq
|——————————————Node:subscript_expression Text: IRQ[candev]
|———————————————Node:identifier Text: IRQ
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: candev
|———————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:field_expression Text: pdev->irq
|———————————————Node:identifier Text: pdev
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: irq
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: candev++;
|—————————————Node:update_expression Text: candev++
|——————————————Node:identifier Text: candev
|——————————————Node:++ Text: ++
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
		printk(" CAN: NO CAN at pos 2\n");
		;
	    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: printk(" CAN: NO CAN at pos 2\n");
|——————————————Node:call_expression Text: printk(" CAN: NO CAN at pos 2\n")
|———————————————Node:identifier Text: printk
|———————————————Node:argument_list Text: (" CAN: NO CAN at pos 2\n")
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: " CAN: NO CAN at pos 2\n"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text:  CAN: NO CAN at pos 2
|—————————————————Node:escape_sequence Text: \n
|—————————————————Node:" Text: "
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: ;
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|——————————Node:} Text: }
|————————Node:preproc_if Text: #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)

|—————————Node:#if Text: #if
|—————————Node:binary_expression Text: LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
|——————————Node:identifier Text: LINUX_VERSION_CODE
|——————————Node:< Text: <
|——————————Node:call_expression Text: KERNEL_VERSION(2,5,0)
|———————————Node:identifier Text: KERNEL_VERSION
|———————————Node:argument_list Text: (2,5,0)
|————————————Node:( Text: (
|————————————Node:number_literal Text: 2
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 5
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:) Text: )
|—————————Node:
 Text: 

|—————————Node:#endif Text: 
|————————Node:} Text: }
|———————Node:else_clause Text: else {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
        printk("CAN: No PCI bios present\n");
        return -ENODEV;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: printk("CAN: No PCI bios present\n");
|——————————Node:call_expression Text: printk("CAN: No PCI bios present\n")
|———————————Node:identifier Text: printk
|———————————Node:argument_list Text: ("CAN: No PCI bios present\n")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "CAN: No PCI bios present\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: CAN: No PCI bios present
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -ENODEV;
|——————————Node:return Text: return
|——————————Node:unary_expression Text: -ENODEV
|———————————Node:- Text: -
|———————————Node:identifier Text: ENODEV
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:#endif Text: #endif
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:function_definition Text: void board_clear_interrupts(int minor)
{

/* old  Siemens PITA */
    /* Interrupt_0_Enable (bit 17) + Int_0_Reset (bit 1) */
    /*  
     Uttenthaler:
      nur 
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
      als letzte Anweisung in der ISR
     Schoett:
      bei Eintritt
        writel(0x00000000, Can_pitapci_control[minor] + 0x0);
      am ende
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
    */
    writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0);
    writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0);

/* new */

    writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR);

}
|————Node:primitive_type Text: void
|————Node:function_declarator Text: board_clear_interrupts(int minor)
|—————Node:identifier Text: board_clear_interrupts
|—————Node:parameter_list Text: (int minor)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: int minor
|———————Node:primitive_type Text: int
|———————Node:identifier Text: minor
|——————Node:) Text: )
|————Node:compound_statement Text: {

/* old  Siemens PITA */
    /* Interrupt_0_Enable (bit 17) + Int_0_Reset (bit 1) */
    /*  
     Uttenthaler:
      nur 
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
      als letzte Anweisung in der ISR
     Schoett:
      bei Eintritt
        writel(0x00000000, Can_pitapci_control[minor] + 0x0);
      am ende
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
    */
    writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0);
    writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0);

/* new */

    writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR);

}
|—————Node:{ Text: {
|—————Node:comment Text: /* old  Siemens PITA */
|—————Node:comment Text: /* Interrupt_0_Enable (bit 17) + Int_0_Reset (bit 1) */
|—————Node:comment Text: /*  
     Uttenthaler:
      nur 
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
      als letzte Anweisung in der ISR
     Schoett:
      bei Eintritt
        writel(0x00000000, Can_pitapci_control[minor] + 0x0);
      am ende
        writel(0x00020002, Can_pitapci_control[minor] + 0x0);
    */
|—————Node:expression_statement Text: writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0);
|——————Node:call_expression Text: writel(0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (0x00020002, (void __iomem *)Can_pitapci_control[minor] + 0x0)
|————————Node:( Text: (
|————————Node:number_literal Text: 0x00020002
|————————Node:, Text: ,
|————————Node:binary_expression Text: (void __iomem *)Can_pitapci_control[minor] + 0x0
|—————————Node:cast_expression Text: (void __iomem *)Can_pitapci_control[minor]
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: Can_pitapci_control[minor]
|———————————Node:identifier Text: Can_pitapci_control
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 0x0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0);
|——————Node:call_expression Text: writel(0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (0x00020000, (void __iomem *)Can_pitapci_control[minor] + 0x0)
|————————Node:( Text: (
|————————Node:number_literal Text: 0x00020000
|————————Node:, Text: ,
|————————Node:binary_expression Text: (void __iomem *)Can_pitapci_control[minor] + 0x0
|—————————Node:cast_expression Text: (void __iomem *)Can_pitapci_control[minor]
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: Can_pitapci_control[minor]
|———————————Node:identifier Text: Can_pitapci_control
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 0x0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* new */
|—————Node:expression_statement Text: writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR);
|——————Node:call_expression Text: writel(PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR)
|———————Node:identifier Text: writel
|———————Node:argument_list Text: (PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0,
          (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR)
|————————Node:( Text: (
|————————Node:binary_expression Text: PLX9030_ICR_CLEAR_IRQ0 | PLX9030_ICR_ENABLE_IRQ0
|—————————Node:identifier Text: PLX9030_ICR_CLEAR_IRQ0
|—————————Node:| Text: |
|—————————Node:identifier Text: PLX9030_ICR_ENABLE_IRQ0
|————————Node:, Text: ,
|————————Node:binary_expression Text: (void __iomem *)Can_pitapci_control[minor] + PLX9030_ICR
|—————————Node:cast_expression Text: (void __iomem *)Can_pitapci_control[minor]
|——————————Node:( Text: (
|——————————Node:ERROR Text: void
|———————————Node:primitive_type Text: void
|——————————Node:type_descriptor Text: __iomem *
|———————————Node:type_identifier Text: __iomem
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: Can_pitapci_control[minor]
|———————————Node:identifier Text: Can_pitapci_control
|———————————Node:[ Text: [
|———————————Node:identifier Text: minor
|———————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:identifier Text: PLX9030_ICR
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:#endif Text: # endif
|——Node:comment Text: /* defined(CPC_PCI) */
|——Node:#endif Text: #endif
