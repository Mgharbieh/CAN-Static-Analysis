ng_can-src\ng_can.c

|Node:translation_unit
|—Node:preproc_include Text: #include <stdio.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <stdio.h>
|—Node:preproc_include Text: #include <stdlib.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <stdlib.h>
|—Node:preproc_include Text: #include <string.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <string.h>
|—Node:preproc_include Text: #include "erlcmd.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "erlcmd.h"
|———Node:" Text: "
|———Node:string_content Text: erlcmd.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "util.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "util.h"
|———Node:" Text: "
|———Node:string_content Text: util.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "can_port.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "can_port.h"
|———Node:" Text: "
|———Node:string_content Text: can_port.h
|———Node:" Text: "
|—Node:preproc_include Text: #include <poll.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <poll.h>
|—Node:preproc_include Text: #include <unistd.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <unistd.h>
|—Node:preproc_include Text: #include <sys/types.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <sys/types.h>
|—Node:preproc_include Text: #include <sys/stat.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <sys/stat.h>
|—Node:preproc_include Text: #include <fcntl.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <fcntl.h>
|—Node:struct_specifier Text: struct request_handler {
  const char *name;
  void (*handler)(const char *req, int *req_index);
}
|——Node:struct Text: struct
|——Node:type_identifier Text: request_handler
|——Node:field_declaration_list Text: {
  const char *name;
  void (*handler)(const char *req, int *req_index);
}
|———Node:{ Text: {
|———Node:field_declaration Text: const char *name;
|————Node:type_qualifier Text: const
|—————Node:const Text: const
|————Node:primitive_type Text: char
|————Node:pointer_declarator Text: *name
|—————Node:* Text: *
|—————Node:field_identifier Text: name
|————Node:; Text: ;
|———Node:field_declaration Text: void (*handler)(const char *req, int *req_index);
|————Node:primitive_type Text: void
|————Node:function_declarator Text: (*handler)(const char *req, int *req_index)
|—————Node:parenthesized_declarator Text: (*handler)
|——————Node:( Text: (
|——————Node:pointer_declarator Text: *handler
|———————Node:* Text: *
|———————Node:field_identifier Text: handler
|——————Node:) Text: )
|—————Node:parameter_list Text: (const char *req, int *req_index)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: const char *req
|———————Node:type_qualifier Text: const
|————————Node:const Text: const
|———————Node:primitive_type Text: char
|———————Node:pointer_declarator Text: *req
|————————Node:* Text: *
|————————Node:identifier Text: req
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: int *req_index
|———————Node:primitive_type Text: int
|———————Node:pointer_declarator Text: *req_index
|————————Node:* Text: *
|————————Node:identifier Text: req_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:; Text: ;
|—Node:declaration Text: static struct can_port *can_port = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct can_port
|———Node:struct Text: struct
|———Node:type_identifier Text: can_port
|——Node:init_declarator Text: *can_port = NULL
|———Node:pointer_declarator Text: *can_port
|————Node:* Text: *
|————Node:identifier Text: can_port
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:comment Text: // Utilities
|—Node:declaration Text: static const char response_id = 'r';
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: char
|——Node:init_declarator Text: response_id = 'r'
|———Node:identifier Text: response_id
|———Node:= Text: =
|———Node:char_literal Text: 'r'
|————Node:' Text: '
|————Node:character Text: r
|————Node:' Text: '
|——Node:; Text: ;
|—Node:declaration Text: static const char notification_id = 'n';
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: char
|——Node:init_declarator Text: notification_id = 'n'
|———Node:identifier Text: notification_id
|———Node:= Text: =
|———Node:char_literal Text: 'n'
|————Node:' Text: '
|————Node:character Text: n
|————Node:' Text: '
|——Node:; Text: ;
|—Node:comment Text: /**
 * @brief Send :ok back to Elixir
 */
|—Node:function_definition Text: static void send_ok_response()
{
  char resp[256];
  int resp_index = sizeof(uint16_t); // Space for payload size
  resp[resp_index++] = response_id;
  ei_encode_version(resp, &resp_index);
  ei_encode_atom(resp, &resp_index, "ok");
  erlcmd_send(resp, resp_index);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: send_ok_response()
|———Node:identifier Text: send_ok_response
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
  char resp[256];
  int resp_index = sizeof(uint16_t); // Space for payload size
  resp[resp_index++] = response_id;
  ei_encode_version(resp, &resp_index);
  ei_encode_atom(resp, &resp_index, "ok");
  erlcmd_send(resp, resp_index);
}
|———Node:{ Text: {
|———Node:declaration Text: char resp[256];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: resp[256]
|—————Node:identifier Text: resp
|—————Node:[ Text: [
|—————Node:number_literal Text: 256
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: int resp_index = sizeof(uint16_t);
|————Node:primitive_type Text: int
|————Node:init_declarator Text: resp_index = sizeof(uint16_t)
|—————Node:identifier Text: resp_index
|—————Node:= Text: =
|—————Node:sizeof_expression Text: sizeof(uint16_t)
|——————Node:sizeof Text: sizeof
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Space for payload size
|———Node:expression_statement Text: resp[resp_index++] = response_id;
|————Node:assignment_expression Text: resp[resp_index++] = response_id
|—————Node:subscript_expression Text: resp[resp_index++]
|——————Node:identifier Text: resp
|——————Node:[ Text: [
|——————Node:update_expression Text: resp_index++
|———————Node:identifier Text: resp_index
|———————Node:++ Text: ++
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: response_id
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_version(resp, &resp_index);
|————Node:call_expression Text: ei_encode_version(resp, &resp_index)
|—————Node:identifier Text: ei_encode_version
|—————Node:argument_list Text: (resp, &resp_index)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_atom(resp, &resp_index, "ok");
|————Node:call_expression Text: ei_encode_atom(resp, &resp_index, "ok")
|—————Node:identifier Text: ei_encode_atom
|—————Node:argument_list Text: (resp, &resp_index, "ok")
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:string_literal Text: "ok"
|———————Node:" Text: "
|———————Node:string_content Text: ok
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: erlcmd_send(resp, resp_index);
|————Node:call_expression Text: erlcmd_send(resp, resp_index)
|—————Node:identifier Text: erlcmd_send
|—————Node:argument_list Text: (resp, resp_index)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * @brief Send a response of the form {:error, reason}
 *
 * @param reason a reason (sent back as an atom)
 */
|—Node:function_definition Text: static void send_error_response(const char *reason)
{
  char resp[256];
  int resp_index = sizeof(uint16_t); // Space for payload size
  resp[resp_index++] = response_id;
  ei_encode_version(resp, &resp_index);
  ei_encode_tuple_header(resp, &resp_index, 2);
  ei_encode_atom(resp, &resp_index, "error");
  ei_encode_atom(resp, &resp_index, reason);
  erlcmd_send(resp, resp_index);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: send_error_response(const char *reason)
|———Node:identifier Text: send_error_response
|———Node:parameter_list Text: (const char *reason)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *reason
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *reason
|——————Node:* Text: *
|——————Node:identifier Text: reason
|————Node:) Text: )
|——Node:compound_statement Text: {
  char resp[256];
  int resp_index = sizeof(uint16_t); // Space for payload size
  resp[resp_index++] = response_id;
  ei_encode_version(resp, &resp_index);
  ei_encode_tuple_header(resp, &resp_index, 2);
  ei_encode_atom(resp, &resp_index, "error");
  ei_encode_atom(resp, &resp_index, reason);
  erlcmd_send(resp, resp_index);
}
|———Node:{ Text: {
|———Node:declaration Text: char resp[256];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: resp[256]
|—————Node:identifier Text: resp
|—————Node:[ Text: [
|—————Node:number_literal Text: 256
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: int resp_index = sizeof(uint16_t);
|————Node:primitive_type Text: int
|————Node:init_declarator Text: resp_index = sizeof(uint16_t)
|—————Node:identifier Text: resp_index
|—————Node:= Text: =
|—————Node:sizeof_expression Text: sizeof(uint16_t)
|——————Node:sizeof Text: sizeof
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Space for payload size
|———Node:expression_statement Text: resp[resp_index++] = response_id;
|————Node:assignment_expression Text: resp[resp_index++] = response_id
|—————Node:subscript_expression Text: resp[resp_index++]
|——————Node:identifier Text: resp
|——————Node:[ Text: [
|——————Node:update_expression Text: resp_index++
|———————Node:identifier Text: resp_index
|———————Node:++ Text: ++
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: response_id
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_version(resp, &resp_index);
|————Node:call_expression Text: ei_encode_version(resp, &resp_index)
|—————Node:identifier Text: ei_encode_version
|—————Node:argument_list Text: (resp, &resp_index)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_tuple_header(resp, &resp_index, 2);
|————Node:call_expression Text: ei_encode_tuple_header(resp, &resp_index, 2)
|—————Node:identifier Text: ei_encode_tuple_header
|—————Node:argument_list Text: (resp, &resp_index, 2)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:number_literal Text: 2
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_atom(resp, &resp_index, "error");
|————Node:call_expression Text: ei_encode_atom(resp, &resp_index, "error")
|—————Node:identifier Text: ei_encode_atom
|—————Node:argument_list Text: (resp, &resp_index, "error")
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:string_literal Text: "error"
|———————Node:" Text: "
|———————Node:string_content Text: error
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_atom(resp, &resp_index, reason);
|————Node:call_expression Text: ei_encode_atom(resp, &resp_index, reason)
|—————Node:identifier Text: ei_encode_atom
|—————Node:argument_list Text: (resp, &resp_index, reason)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:identifier Text: reason
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: erlcmd_send(resp, resp_index);
|————Node:call_expression Text: erlcmd_send(resp, resp_index)
|—————Node:identifier Text: erlcmd_send
|—————Node:argument_list Text: (resp, resp_index)
|——————Node:( Text: (
|——————Node:identifier Text: resp
|——————Node:, Text: ,
|——————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static struct can_frame parse_can_frame(const char *req, int *req_index)
{
    struct can_frame can_frame;
    int num_tuple_elements;
    if(ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0 || num_tuple_elements != 2)
      send_error_response("badtuple");
    unsigned long id;
    if (ei_decode_ulong(req, req_index, &id) < 0)
      send_error_response("badcanid");
    long data_len;
    char data[8] = "";
    if(ei_decode_binary(req, req_index, data, &data_len) < 0 || data_len > 8)
      send_error_response("badcandata");

    can_frame.can_id = id;
    can_frame.can_dlc = data_len;
    memcpy(can_frame.data, data, 8);
    return can_frame;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct can_frame
|———Node:struct Text: struct
|———Node:type_identifier Text: can_frame
|——Node:function_declarator Text: parse_can_frame(const char *req, int *req_index)
|———Node:identifier Text: parse_can_frame
|———Node:parameter_list Text: (const char *req, int *req_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: int *req_index
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: *req_index
|——————Node:* Text: *
|——————Node:identifier Text: req_index
|————Node:) Text: )
|——Node:compound_statement Text: {
    struct can_frame can_frame;
    int num_tuple_elements;
    if(ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0 || num_tuple_elements != 2)
      send_error_response("badtuple");
    unsigned long id;
    if (ei_decode_ulong(req, req_index, &id) < 0)
      send_error_response("badcanid");
    long data_len;
    char data[8] = "";
    if(ei_decode_binary(req, req_index, data, &data_len) < 0 || data_len > 8)
      send_error_response("badcandata");

    can_frame.can_id = id;
    can_frame.can_dlc = data_len;
    memcpy(can_frame.data, data, 8);
    return can_frame;
}
|———Node:{ Text: {
|———Node:declaration Text: struct can_frame can_frame;
|————Node:struct_specifier Text: struct can_frame
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_frame
|————Node:identifier Text: can_frame
|————Node:; Text: ;
|———Node:declaration Text: int num_tuple_elements;
|————Node:primitive_type Text: int
|————Node:identifier Text: num_tuple_elements
|————Node:; Text: ;
|———Node:if_statement Text: if(ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0 || num_tuple_elements != 2)
      send_error_response("badtuple");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0 || num_tuple_elements != 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0 || num_tuple_elements != 2
|——————Node:binary_expression Text: ei_decode_tuple_header(req, req_index, &num_tuple_elements) < 0
|———————Node:call_expression Text: ei_decode_tuple_header(req, req_index, &num_tuple_elements)
|————————Node:identifier Text: ei_decode_tuple_header
|————————Node:argument_list Text: (req, req_index, &num_tuple_elements)
|—————————Node:( Text: (
|—————————Node:identifier Text: req
|—————————Node:, Text: ,
|—————————Node:identifier Text: req_index
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &num_tuple_elements
|——————————Node:& Text: &
|——————————Node:identifier Text: num_tuple_elements
|—————————Node:) Text: )
|———————Node:< Text: <
|———————Node:number_literal Text: 0
|——————Node:|| Text: ||
|——————Node:binary_expression Text: num_tuple_elements != 2
|———————Node:identifier Text: num_tuple_elements
|———————Node:!= Text: !=
|———————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:expression_statement Text: send_error_response("badtuple");
|—————Node:call_expression Text: send_error_response("badtuple")
|——————Node:identifier Text: send_error_response
|——————Node:argument_list Text: ("badtuple")
|———————Node:( Text: (
|———————Node:string_literal Text: "badtuple"
|————————Node:" Text: "
|————————Node:string_content Text: badtuple
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:declaration Text: unsigned long id;
|————Node:sized_type_specifier Text: unsigned long
|—————Node:unsigned Text: unsigned
|—————Node:long Text: long
|————Node:identifier Text: id
|————Node:; Text: ;
|———Node:if_statement Text: if (ei_decode_ulong(req, req_index, &id) < 0)
      send_error_response("badcanid");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_ulong(req, req_index, &id) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_ulong(req, req_index, &id) < 0
|——————Node:call_expression Text: ei_decode_ulong(req, req_index, &id)
|———————Node:identifier Text: ei_decode_ulong
|———————Node:argument_list Text: (req, req_index, &id)
|————————Node:( Text: (
|————————Node:identifier Text: req
|————————Node:, Text: ,
|————————Node:identifier Text: req_index
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &id
|—————————Node:& Text: &
|—————————Node:identifier Text: id
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: send_error_response("badcanid");
|—————Node:call_expression Text: send_error_response("badcanid")
|——————Node:identifier Text: send_error_response
|——————Node:argument_list Text: ("badcanid")
|———————Node:( Text: (
|———————Node:string_literal Text: "badcanid"
|————————Node:" Text: "
|————————Node:string_content Text: badcanid
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:declaration Text: long data_len;
|————Node:sized_type_specifier Text: long
|—————Node:long Text: long
|————Node:identifier Text: data_len
|————Node:; Text: ;
|———Node:declaration Text: char data[8] = "";
|————Node:primitive_type Text: char
|————Node:init_declarator Text: data[8] = ""
|—————Node:array_declarator Text: data[8]
|——————Node:identifier Text: data
|——————Node:[ Text: [
|——————Node:number_literal Text: 8
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:string_literal Text: ""
|——————Node:" Text: "
|——————Node:" Text: "
|————Node:; Text: ;
|———Node:if_statement Text: if(ei_decode_binary(req, req_index, data, &data_len) < 0 || data_len > 8)
      send_error_response("badcandata");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_binary(req, req_index, data, &data_len) < 0 || data_len > 8)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_binary(req, req_index, data, &data_len) < 0 || data_len > 8
|——————Node:binary_expression Text: ei_decode_binary(req, req_index, data, &data_len) < 0
|———————Node:call_expression Text: ei_decode_binary(req, req_index, data, &data_len)
|————————Node:identifier Text: ei_decode_binary
|————————Node:argument_list Text: (req, req_index, data, &data_len)
|—————————Node:( Text: (
|—————————Node:identifier Text: req
|—————————Node:, Text: ,
|—————————Node:identifier Text: req_index
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &data_len
|——————————Node:& Text: &
|——————————Node:identifier Text: data_len
|—————————Node:) Text: )
|———————Node:< Text: <
|———————Node:number_literal Text: 0
|——————Node:|| Text: ||
|——————Node:binary_expression Text: data_len > 8
|———————Node:identifier Text: data_len
|———————Node:> Text: >
|———————Node:number_literal Text: 8
|—————Node:) Text: )
|————Node:expression_statement Text: send_error_response("badcandata");
|—————Node:call_expression Text: send_error_response("badcandata")
|——————Node:identifier Text: send_error_response
|——————Node:argument_list Text: ("badcandata")
|———————Node:( Text: (
|———————Node:string_literal Text: "badcandata"
|————————Node:" Text: "
|————————Node:string_content Text: badcandata
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:expression_statement Text: can_frame.can_id = id;
|————Node:assignment_expression Text: can_frame.can_id = id
|—————Node:field_expression Text: can_frame.can_id
|——————Node:identifier Text: can_frame
|——————Node:. Text: .
|——————Node:field_identifier Text: can_id
|—————Node:= Text: =
|—————Node:identifier Text: id
|————Node:; Text: ;
|———Node:expression_statement Text: can_frame.can_dlc = data_len;
|————Node:assignment_expression Text: can_frame.can_dlc = data_len
|—————Node:field_expression Text: can_frame.can_dlc
|——————Node:identifier Text: can_frame
|——————Node:. Text: .
|——————Node:field_identifier Text: can_dlc
|—————Node:= Text: =
|—————Node:identifier Text: data_len
|————Node:; Text: ;
|———Node:expression_statement Text: memcpy(can_frame.data, data, 8);
|————Node:call_expression Text: memcpy(can_frame.data, data, 8)
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: (can_frame.data, data, 8)
|——————Node:( Text: (
|——————Node:field_expression Text: can_frame.data
|———————Node:identifier Text: can_frame
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:, Text: ,
|——————Node:identifier Text: data
|——————Node:, Text: ,
|——————Node:number_literal Text: 8
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return can_frame;
|————Node:return Text: return
|————Node:identifier Text: can_frame
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static int write_buffer(const char *req, int *req_index, int num_frames)
{
  for (int i = 0; i < num_frames; i++) {
    int start_index = *req_index;
    struct can_frame can_frame = parse_can_frame(req, req_index);
    int write_result = can_write(can_port, &can_frame);

    if(write_result < 0 && errno == EAGAIN) {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    } else if(write_result < 0) {
      send_error_response("badwriteres");
    }
  }
  return 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: write_buffer(const char *req, int *req_index, int num_frames)
|———Node:identifier Text: write_buffer
|———Node:parameter_list Text: (const char *req, int *req_index, int num_frames)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: int *req_index
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: *req_index
|——————Node:* Text: *
|——————Node:identifier Text: req_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: int num_frames
|—————Node:primitive_type Text: int
|—————Node:identifier Text: num_frames
|————Node:) Text: )
|——Node:compound_statement Text: {
  for (int i = 0; i < num_frames; i++) {
    int start_index = *req_index;
    struct can_frame can_frame = parse_can_frame(req, req_index);
    int write_result = can_write(can_port, &can_frame);

    if(write_result < 0 && errno == EAGAIN) {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    } else if(write_result < 0) {
      send_error_response("badwriteres");
    }
  }
  return 0;
}
|———Node:{ Text: {
|———Node:for_statement Text: for (int i = 0; i < num_frames; i++) {
    int start_index = *req_index;
    struct can_frame can_frame = parse_can_frame(req, req_index);
    int write_result = can_write(can_port, &can_frame);

    if(write_result < 0 && errno == EAGAIN) {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    } else if(write_result < 0) {
      send_error_response("badwriteres");
    }
  }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < num_frames
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: num_frames
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
    int start_index = *req_index;
    struct can_frame can_frame = parse_can_frame(req, req_index);
    int write_result = can_write(can_port, &can_frame);

    if(write_result < 0 && errno == EAGAIN) {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    } else if(write_result < 0) {
      send_error_response("badwriteres");
    }
  }
|—————Node:{ Text: {
|—————Node:declaration Text: int start_index = *req_index;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: start_index = *req_index
|———————Node:identifier Text: start_index
|———————Node:= Text: =
|———————Node:pointer_expression Text: *req_index
|————————Node:* Text: *
|————————Node:identifier Text: req_index
|——————Node:; Text: ;
|—————Node:declaration Text: struct can_frame can_frame = parse_can_frame(req, req_index);
|——————Node:struct_specifier Text: struct can_frame
|———————Node:struct Text: struct
|———————Node:type_identifier Text: can_frame
|——————Node:init_declarator Text: can_frame = parse_can_frame(req, req_index)
|———————Node:identifier Text: can_frame
|———————Node:= Text: =
|———————Node:call_expression Text: parse_can_frame(req, req_index)
|————————Node:identifier Text: parse_can_frame
|————————Node:argument_list Text: (req, req_index)
|—————————Node:( Text: (
|—————————Node:identifier Text: req
|—————————Node:, Text: ,
|—————————Node:identifier Text: req_index
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: int write_result = can_write(can_port, &can_frame);
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: write_result = can_write(can_port, &can_frame)
|———————Node:identifier Text: write_result
|———————Node:= Text: =
|———————Node:call_expression Text: can_write(can_port, &can_frame)
|————————Node:identifier Text: can_write
|————————Node:argument_list Text: (can_port, &can_frame)
|—————————Node:( Text: (
|—————————Node:identifier Text: can_port
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &can_frame
|——————————Node:& Text: &
|——————————Node:identifier Text: can_frame
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if(write_result < 0 && errno == EAGAIN) {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    } else if(write_result < 0) {
      send_error_response("badwriteres");
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (write_result < 0 && errno == EAGAIN)
|———————Node:( Text: (
|———————Node:binary_expression Text: write_result < 0 && errno == EAGAIN
|————————Node:binary_expression Text: write_result < 0
|—————————Node:identifier Text: write_result
|—————————Node:< Text: <
|—————————Node:number_literal Text: 0
|————————Node:&& Text: &&
|————————Node:binary_expression Text: errno == EAGAIN
|—————————Node:identifier Text: errno
|—————————Node:== Text: ==
|—————————Node:identifier Text: EAGAIN
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      //enqueue the remaining frames
      int num_unsent = num_frames - i;
      can_port->write_buffer_offset = 0;
      can_port->write_buffer_size = num_unsent;
      int frame_size = *req_index - start_index;
      int num_bytes = frame_size * num_unsent;
      char *buffer = malloc(num_bytes);
      memcpy(buffer, req + start_index, num_bytes);
      free(can_port->write_buffer);
      can_port->write_buffer = buffer;
      return -1;
    }
|———————Node:{ Text: {
|———————Node:comment Text: //enqueue the remaining frames
|———————Node:declaration Text: int num_unsent = num_frames - i;
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: num_unsent = num_frames - i
|—————————Node:identifier Text: num_unsent
|—————————Node:= Text: =
|—————————Node:binary_expression Text: num_frames - i
|——————————Node:identifier Text: num_frames
|——————————Node:- Text: -
|——————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:expression_statement Text: can_port->write_buffer_offset = 0;
|————————Node:assignment_expression Text: can_port->write_buffer_offset = 0
|—————————Node:field_expression Text: can_port->write_buffer_offset
|——————————Node:identifier Text: can_port
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: write_buffer_offset
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: can_port->write_buffer_size = num_unsent;
|————————Node:assignment_expression Text: can_port->write_buffer_size = num_unsent
|—————————Node:field_expression Text: can_port->write_buffer_size
|——————————Node:identifier Text: can_port
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: write_buffer_size
|—————————Node:= Text: =
|—————————Node:identifier Text: num_unsent
|————————Node:; Text: ;
|———————Node:declaration Text: int frame_size = *req_index - start_index;
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: frame_size = *req_index - start_index
|—————————Node:identifier Text: frame_size
|—————————Node:= Text: =
|—————————Node:binary_expression Text: *req_index - start_index
|——————————Node:pointer_expression Text: *req_index
|———————————Node:* Text: *
|———————————Node:identifier Text: req_index
|——————————Node:- Text: -
|——————————Node:identifier Text: start_index
|————————Node:; Text: ;
|———————Node:declaration Text: int num_bytes = frame_size * num_unsent;
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: num_bytes = frame_size * num_unsent
|—————————Node:identifier Text: num_bytes
|—————————Node:= Text: =
|—————————Node:binary_expression Text: frame_size * num_unsent
|——————————Node:identifier Text: frame_size
|——————————Node:* Text: *
|——————————Node:identifier Text: num_unsent
|————————Node:; Text: ;
|———————Node:declaration Text: char *buffer = malloc(num_bytes);
|————————Node:primitive_type Text: char
|————————Node:init_declarator Text: *buffer = malloc(num_bytes)
|—————————Node:pointer_declarator Text: *buffer
|——————————Node:* Text: *
|——————————Node:identifier Text: buffer
|—————————Node:= Text: =
|—————————Node:call_expression Text: malloc(num_bytes)
|——————————Node:identifier Text: malloc
|——————————Node:argument_list Text: (num_bytes)
|———————————Node:( Text: (
|———————————Node:identifier Text: num_bytes
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: memcpy(buffer, req + start_index, num_bytes);
|————————Node:call_expression Text: memcpy(buffer, req + start_index, num_bytes)
|—————————Node:identifier Text: memcpy
|—————————Node:argument_list Text: (buffer, req + start_index, num_bytes)
|——————————Node:( Text: (
|——————————Node:identifier Text: buffer
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: req + start_index
|———————————Node:identifier Text: req
|———————————Node:+ Text: +
|———————————Node:identifier Text: start_index
|——————————Node:, Text: ,
|——————————Node:identifier Text: num_bytes
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: free(can_port->write_buffer);
|————————Node:call_expression Text: free(can_port->write_buffer)
|—————————Node:identifier Text: free
|—————————Node:argument_list Text: (can_port->write_buffer)
|——————————Node:( Text: (
|——————————Node:field_expression Text: can_port->write_buffer
|———————————Node:identifier Text: can_port
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: write_buffer
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: can_port->write_buffer = buffer;
|————————Node:assignment_expression Text: can_port->write_buffer = buffer
|—————————Node:field_expression Text: can_port->write_buffer
|——————————Node:identifier Text: can_port
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: write_buffer
|—————————Node:= Text: =
|—————————Node:identifier Text: buffer
|————————Node:; Text: ;
|———————Node:return_statement Text: return -1;
|————————Node:return Text: return
|————————Node:number_literal Text: -1
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if(write_result < 0) {
      send_error_response("badwriteres");
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if(write_result < 0) {
      send_error_response("badwriteres");
    }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (write_result < 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: write_result < 0
|——————————Node:identifier Text: write_result
|——————————Node:< Text: <
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
      send_error_response("badwriteres");
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: send_error_response("badwriteres");
|——————————Node:call_expression Text: send_error_response("badwriteres")
|———————————Node:identifier Text: send_error_response
|———————————Node:argument_list Text: ("badwriteres")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "badwriteres"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: badwriteres
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: //request is an array of maps with keys {:id, :data, :data_size}
|—Node:function_definition Text: static void handle_write(const char *req, int *req_index)
{
  int num_frames;
  if(ei_decode_list_header(req, req_index, &num_frames) < 0)
    send_error_response("expectinglist");
  write_buffer(req, req_index, num_frames);
  send_ok_response();
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: handle_write(const char *req, int *req_index)
|———Node:identifier Text: handle_write
|———Node:parameter_list Text: (const char *req, int *req_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: int *req_index
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: *req_index
|——————Node:* Text: *
|——————Node:identifier Text: req_index
|————Node:) Text: )
|——Node:compound_statement Text: {
  int num_frames;
  if(ei_decode_list_header(req, req_index, &num_frames) < 0)
    send_error_response("expectinglist");
  write_buffer(req, req_index, num_frames);
  send_ok_response();
}
|———Node:{ Text: {
|———Node:declaration Text: int num_frames;
|————Node:primitive_type Text: int
|————Node:identifier Text: num_frames
|————Node:; Text: ;
|———Node:if_statement Text: if(ei_decode_list_header(req, req_index, &num_frames) < 0)
    send_error_response("expectinglist");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_list_header(req, req_index, &num_frames) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_list_header(req, req_index, &num_frames) < 0
|——————Node:call_expression Text: ei_decode_list_header(req, req_index, &num_frames)
|———————Node:identifier Text: ei_decode_list_header
|———————Node:argument_list Text: (req, req_index, &num_frames)
|————————Node:( Text: (
|————————Node:identifier Text: req
|————————Node:, Text: ,
|————————Node:identifier Text: req_index
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &num_frames
|—————————Node:& Text: &
|—————————Node:identifier Text: num_frames
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: send_error_response("expectinglist");
|—————Node:call_expression Text: send_error_response("expectinglist")
|——————Node:identifier Text: send_error_response
|——————Node:argument_list Text: ("expectinglist")
|———————Node:( Text: (
|———————Node:string_literal Text: "expectinglist"
|————————Node:" Text: "
|————————Node:string_content Text: expectinglist
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:expression_statement Text: write_buffer(req, req_index, num_frames);
|————Node:call_expression Text: write_buffer(req, req_index, num_frames)
|—————Node:identifier Text: write_buffer
|—————Node:argument_list Text: (req, req_index, num_frames)
|——————Node:( Text: (
|——————Node:identifier Text: req
|——————Node:, Text: ,
|——————Node:identifier Text: req_index
|——————Node:, Text: ,
|——————Node:identifier Text: num_frames
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: send_ok_response();
|————Node:call_expression Text: send_ok_response()
|—————Node:identifier Text: send_ok_response
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static void process_write_buffer()
{
  if(write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size) == 0){
    free(can_port->write_buffer);
    can_port->write_buffer_size = 0;
    can_port->write_buffer_offset = 0;
  }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: process_write_buffer()
|———Node:identifier Text: process_write_buffer
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
  if(write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size) == 0){
    free(can_port->write_buffer);
    can_port->write_buffer_size = 0;
    can_port->write_buffer_offset = 0;
  }
}
|———Node:{ Text: {
|———Node:if_statement Text: if(write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size) == 0){
    free(can_port->write_buffer);
    can_port->write_buffer_size = 0;
    can_port->write_buffer_offset = 0;
  }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size) == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size) == 0
|——————Node:call_expression Text: write_buffer(can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size)
|———————Node:identifier Text: write_buffer
|———————Node:argument_list Text: (can_port->write_buffer, &(can_port->write_buffer_offset), can_port->write_buffer_size)
|————————Node:( Text: (
|————————Node:field_expression Text: can_port->write_buffer
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: write_buffer
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &(can_port->write_buffer_offset)
|—————————Node:& Text: &
|—————————Node:parenthesized_expression Text: (can_port->write_buffer_offset)
|——————————Node:( Text: (
|——————————Node:field_expression Text: can_port->write_buffer_offset
|———————————Node:identifier Text: can_port
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: write_buffer_offset
|——————————Node:) Text: )
|————————Node:, Text: ,
|————————Node:field_expression Text: can_port->write_buffer_size
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: write_buffer_size
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
    free(can_port->write_buffer);
    can_port->write_buffer_size = 0;
    can_port->write_buffer_offset = 0;
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: free(can_port->write_buffer);
|——————Node:call_expression Text: free(can_port->write_buffer)
|———————Node:identifier Text: free
|———————Node:argument_list Text: (can_port->write_buffer)
|————————Node:( Text: (
|————————Node:field_expression Text: can_port->write_buffer
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: write_buffer
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: can_port->write_buffer_size = 0;
|——————Node:assignment_expression Text: can_port->write_buffer_size = 0
|———————Node:field_expression Text: can_port->write_buffer_size
|————————Node:identifier Text: can_port
|————————Node:-> Text: ->
|————————Node:field_identifier Text: write_buffer_size
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: can_port->write_buffer_offset = 0;
|——————Node:assignment_expression Text: can_port->write_buffer_offset = 0
|———————Node:field_expression Text: can_port->write_buffer_offset
|————————Node:identifier Text: can_port
|————————Node:-> Text: ->
|————————Node:field_identifier Text: write_buffer_offset
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: static void handle_open(const char *req, int *req_index)
{
  char interface_name[64];
  long binary_len;
  if(ei_decode_binary(req, req_index, interface_name, &binary_len) < 0) {
    send_error_response("enoent");
    return;
  }

  //REVIEW: is this necessary?
  interface_name[binary_len] = '\0';

  if (can_is_open(can_port))
    can_close(can_port);

  if (can_open(can_port, interface_name) >= 0) {
    send_ok_response();
  } else {
    send_error_response("error opening can port");
  }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: handle_open(const char *req, int *req_index)
|———Node:identifier Text: handle_open
|———Node:parameter_list Text: (const char *req, int *req_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: int *req_index
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: *req_index
|——————Node:* Text: *
|——————Node:identifier Text: req_index
|————Node:) Text: )
|——Node:compound_statement Text: {
  char interface_name[64];
  long binary_len;
  if(ei_decode_binary(req, req_index, interface_name, &binary_len) < 0) {
    send_error_response("enoent");
    return;
  }

  //REVIEW: is this necessary?
  interface_name[binary_len] = '\0';

  if (can_is_open(can_port))
    can_close(can_port);

  if (can_open(can_port, interface_name) >= 0) {
    send_ok_response();
  } else {
    send_error_response("error opening can port");
  }
}
|———Node:{ Text: {
|———Node:declaration Text: char interface_name[64];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: interface_name[64]
|—————Node:identifier Text: interface_name
|—————Node:[ Text: [
|—————Node:number_literal Text: 64
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: long binary_len;
|————Node:sized_type_specifier Text: long
|—————Node:long Text: long
|————Node:identifier Text: binary_len
|————Node:; Text: ;
|———Node:if_statement Text: if(ei_decode_binary(req, req_index, interface_name, &binary_len) < 0) {
    send_error_response("enoent");
    return;
  }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_binary(req, req_index, interface_name, &binary_len) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_binary(req, req_index, interface_name, &binary_len) < 0
|——————Node:call_expression Text: ei_decode_binary(req, req_index, interface_name, &binary_len)
|———————Node:identifier Text: ei_decode_binary
|———————Node:argument_list Text: (req, req_index, interface_name, &binary_len)
|————————Node:( Text: (
|————————Node:identifier Text: req
|————————Node:, Text: ,
|————————Node:identifier Text: req_index
|————————Node:, Text: ,
|————————Node:identifier Text: interface_name
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &binary_len
|—————————Node:& Text: &
|—————————Node:identifier Text: binary_len
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
    send_error_response("enoent");
    return;
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: send_error_response("enoent");
|——————Node:call_expression Text: send_error_response("enoent")
|———————Node:identifier Text: send_error_response
|———————Node:argument_list Text: ("enoent")
|————————Node:( Text: (
|————————Node:string_literal Text: "enoent"
|—————————Node:" Text: "
|—————————Node:string_content Text: enoent
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: //REVIEW: is this necessary?
|———Node:expression_statement Text: interface_name[binary_len] = '\0';
|————Node:assignment_expression Text: interface_name[binary_len] = '\0'
|—————Node:subscript_expression Text: interface_name[binary_len]
|——————Node:identifier Text: interface_name
|——————Node:[ Text: [
|——————Node:identifier Text: binary_len
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:char_literal Text: '\0'
|——————Node:' Text: '
|——————Node:escape_sequence Text: \0
|——————Node:' Text: '
|————Node:; Text: ;
|———Node:if_statement Text: if (can_is_open(can_port))
    can_close(can_port);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (can_is_open(can_port))
|—————Node:( Text: (
|—————Node:call_expression Text: can_is_open(can_port)
|——————Node:identifier Text: can_is_open
|——————Node:argument_list Text: (can_port)
|———————Node:( Text: (
|———————Node:identifier Text: can_port
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:expression_statement Text: can_close(can_port);
|—————Node:call_expression Text: can_close(can_port)
|——————Node:identifier Text: can_close
|——————Node:argument_list Text: (can_port)
|———————Node:( Text: (
|———————Node:identifier Text: can_port
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:if_statement Text: if (can_open(can_port, interface_name) >= 0) {
    send_ok_response();
  } else {
    send_error_response("error opening can port");
  }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (can_open(can_port, interface_name) >= 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: can_open(can_port, interface_name) >= 0
|——————Node:call_expression Text: can_open(can_port, interface_name)
|———————Node:identifier Text: can_open
|———————Node:argument_list Text: (can_port, interface_name)
|————————Node:( Text: (
|————————Node:identifier Text: can_port
|————————Node:, Text: ,
|————————Node:identifier Text: interface_name
|————————Node:) Text: )
|——————Node:>= Text: >=
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
    send_ok_response();
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: send_ok_response();
|——————Node:call_expression Text: send_ok_response()
|———————Node:identifier Text: send_ok_response
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
    send_error_response("error opening can port");
  }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
    send_error_response("error opening can port");
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: send_error_response("error opening can port");
|———————Node:call_expression Text: send_error_response("error opening can port")
|————————Node:identifier Text: send_error_response
|————————Node:argument_list Text: ("error opening can port")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "error opening can port"
|——————————Node:" Text: "
|——————————Node:string_content Text: error opening can port
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: static void handle_await_read(const char *req, int *req_index)
{
  if(can_port->awaiting_read == 1){
    send_error_response("busy");
  }
  else {
    can_port->awaiting_read = 1;
    send_ok_response();
  }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: handle_await_read(const char *req, int *req_index)
|———Node:identifier Text: handle_await_read
|———Node:parameter_list Text: (const char *req, int *req_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: int *req_index
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: *req_index
|——————Node:* Text: *
|——————Node:identifier Text: req_index
|————Node:) Text: )
|——Node:compound_statement Text: {
  if(can_port->awaiting_read == 1){
    send_error_response("busy");
  }
  else {
    can_port->awaiting_read = 1;
    send_ok_response();
  }
}
|———Node:{ Text: {
|———Node:if_statement Text: if(can_port->awaiting_read == 1){
    send_error_response("busy");
  }
  else {
    can_port->awaiting_read = 1;
    send_ok_response();
  }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (can_port->awaiting_read == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: can_port->awaiting_read == 1
|——————Node:field_expression Text: can_port->awaiting_read
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: awaiting_read
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
    send_error_response("busy");
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: send_error_response("busy");
|——————Node:call_expression Text: send_error_response("busy")
|———————Node:identifier Text: send_error_response
|———————Node:argument_list Text: ("busy")
|————————Node:( Text: (
|————————Node:string_literal Text: "busy"
|—————————Node:" Text: "
|—————————Node:string_content Text: busy
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
    can_port->awaiting_read = 1;
    send_ok_response();
  }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
    can_port->awaiting_read = 1;
    send_ok_response();
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: can_port->awaiting_read = 1;
|———————Node:assignment_expression Text: can_port->awaiting_read = 1
|————————Node:field_expression Text: can_port->awaiting_read
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: awaiting_read
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:expression_statement Text: send_ok_response();
|———————Node:call_expression Text: send_ok_response()
|————————Node:identifier Text: send_ok_response
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: static void notify_read()
{
  //each can frame is ENCODED_FRAME_SIZE, add 32 (not exactly calculated) for headers + other stuff
  can_port->read_buffer = malloc(32 + (MAX_READBUF * ENCODED_FRAME_SIZE));
  int resp_index = sizeof(uint16_t);
  can_port->read_buffer[resp_index++] = notification_id;
  ei_encode_version(can_port->read_buffer, &resp_index);
  ei_encode_tuple_header(can_port->read_buffer, &resp_index, 2);
  ei_encode_atom(can_port->read_buffer, &resp_index, "notif");
  can_read_into_buffer(can_port, &resp_index);
  ei_encode_empty_list(can_port->read_buffer, &resp_index);
  erlcmd_send(can_port->read_buffer, resp_index);
  free(can_port->read_buffer);
  can_port->read_buffer = NULL;
  can_port->awaiting_read = 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: notify_read()
|———Node:identifier Text: notify_read
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
  //each can frame is ENCODED_FRAME_SIZE, add 32 (not exactly calculated) for headers + other stuff
  can_port->read_buffer = malloc(32 + (MAX_READBUF * ENCODED_FRAME_SIZE));
  int resp_index = sizeof(uint16_t);
  can_port->read_buffer[resp_index++] = notification_id;
  ei_encode_version(can_port->read_buffer, &resp_index);
  ei_encode_tuple_header(can_port->read_buffer, &resp_index, 2);
  ei_encode_atom(can_port->read_buffer, &resp_index, "notif");
  can_read_into_buffer(can_port, &resp_index);
  ei_encode_empty_list(can_port->read_buffer, &resp_index);
  erlcmd_send(can_port->read_buffer, resp_index);
  free(can_port->read_buffer);
  can_port->read_buffer = NULL;
  can_port->awaiting_read = 0;
}
|———Node:{ Text: {
|———Node:comment Text: //each can frame is ENCODED_FRAME_SIZE, add 32 (not exactly calculated) for headers + other stuff
|———Node:expression_statement Text: can_port->read_buffer = malloc(32 + (MAX_READBUF * ENCODED_FRAME_SIZE));
|————Node:assignment_expression Text: can_port->read_buffer = malloc(32 + (MAX_READBUF * ENCODED_FRAME_SIZE))
|—————Node:field_expression Text: can_port->read_buffer
|——————Node:identifier Text: can_port
|——————Node:-> Text: ->
|——————Node:field_identifier Text: read_buffer
|—————Node:= Text: =
|—————Node:call_expression Text: malloc(32 + (MAX_READBUF * ENCODED_FRAME_SIZE))
|——————Node:identifier Text: malloc
|——————Node:argument_list Text: (32 + (MAX_READBUF * ENCODED_FRAME_SIZE))
|———————Node:( Text: (
|———————Node:binary_expression Text: 32 + (MAX_READBUF * ENCODED_FRAME_SIZE)
|————————Node:number_literal Text: 32
|————————Node:+ Text: +
|————————Node:parenthesized_expression Text: (MAX_READBUF * ENCODED_FRAME_SIZE)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: MAX_READBUF * ENCODED_FRAME_SIZE
|——————————Node:identifier Text: MAX_READBUF
|——————————Node:* Text: *
|——————————Node:identifier Text: ENCODED_FRAME_SIZE
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: int resp_index = sizeof(uint16_t);
|————Node:primitive_type Text: int
|————Node:init_declarator Text: resp_index = sizeof(uint16_t)
|—————Node:identifier Text: resp_index
|—————Node:= Text: =
|—————Node:sizeof_expression Text: sizeof(uint16_t)
|——————Node:sizeof Text: sizeof
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: can_port->read_buffer[resp_index++] = notification_id;
|————Node:assignment_expression Text: can_port->read_buffer[resp_index++] = notification_id
|—————Node:subscript_expression Text: can_port->read_buffer[resp_index++]
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:[ Text: [
|——————Node:update_expression Text: resp_index++
|———————Node:identifier Text: resp_index
|———————Node:++ Text: ++
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: notification_id
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_version(can_port->read_buffer, &resp_index);
|————Node:call_expression Text: ei_encode_version(can_port->read_buffer, &resp_index)
|—————Node:identifier Text: ei_encode_version
|—————Node:argument_list Text: (can_port->read_buffer, &resp_index)
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_tuple_header(can_port->read_buffer, &resp_index, 2);
|————Node:call_expression Text: ei_encode_tuple_header(can_port->read_buffer, &resp_index, 2)
|—————Node:identifier Text: ei_encode_tuple_header
|—————Node:argument_list Text: (can_port->read_buffer, &resp_index, 2)
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:number_literal Text: 2
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_atom(can_port->read_buffer, &resp_index, "notif");
|————Node:call_expression Text: ei_encode_atom(can_port->read_buffer, &resp_index, "notif")
|—————Node:identifier Text: ei_encode_atom
|—————Node:argument_list Text: (can_port->read_buffer, &resp_index, "notif")
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:, Text: ,
|——————Node:string_literal Text: "notif"
|———————Node:" Text: "
|———————Node:string_content Text: notif
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: can_read_into_buffer(can_port, &resp_index);
|————Node:call_expression Text: can_read_into_buffer(can_port, &resp_index)
|—————Node:identifier Text: can_read_into_buffer
|—————Node:argument_list Text: (can_port, &resp_index)
|——————Node:( Text: (
|——————Node:identifier Text: can_port
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ei_encode_empty_list(can_port->read_buffer, &resp_index);
|————Node:call_expression Text: ei_encode_empty_list(can_port->read_buffer, &resp_index)
|—————Node:identifier Text: ei_encode_empty_list
|—————Node:argument_list Text: (can_port->read_buffer, &resp_index)
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &resp_index
|———————Node:& Text: &
|———————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: erlcmd_send(can_port->read_buffer, resp_index);
|————Node:call_expression Text: erlcmd_send(can_port->read_buffer, resp_index)
|—————Node:identifier Text: erlcmd_send
|—————Node:argument_list Text: (can_port->read_buffer, resp_index)
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:, Text: ,
|——————Node:identifier Text: resp_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: free(can_port->read_buffer);
|————Node:call_expression Text: free(can_port->read_buffer)
|—————Node:identifier Text: free
|—————Node:argument_list Text: (can_port->read_buffer)
|——————Node:( Text: (
|——————Node:field_expression Text: can_port->read_buffer
|———————Node:identifier Text: can_port
|———————Node:-> Text: ->
|———————Node:field_identifier Text: read_buffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: can_port->read_buffer = NULL;
|————Node:assignment_expression Text: can_port->read_buffer = NULL
|—————Node:field_expression Text: can_port->read_buffer
|——————Node:identifier Text: can_port
|——————Node:-> Text: ->
|——————Node:field_identifier Text: read_buffer
|—————Node:= Text: =
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:expression_statement Text: can_port->awaiting_read = 0;
|————Node:assignment_expression Text: can_port->awaiting_read = 0
|—————Node:field_expression Text: can_port->awaiting_read
|——————Node:identifier Text: can_port
|——————Node:-> Text: ->
|——————Node:field_identifier Text: awaiting_read
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:declaration Text: static struct request_handler request_handlers[] = {
  { "await_read", handle_await_read },
  { "write", handle_write },
  { "open", handle_open },
  { NULL, NULL }
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:struct_specifier Text: struct request_handler
|———Node:struct Text: struct
|———Node:type_identifier Text: request_handler
|——Node:init_declarator Text: request_handlers[] = {
  { "await_read", handle_await_read },
  { "write", handle_write },
  { "open", handle_open },
  { NULL, NULL }
}
|———Node:array_declarator Text: request_handlers[]
|————Node:identifier Text: request_handlers
|————Node:[ Text: [
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
  { "await_read", handle_await_read },
  { "write", handle_write },
  { "open", handle_open },
  { NULL, NULL }
}
|————Node:{ Text: {
|————Node:initializer_list Text: { "await_read", handle_await_read }
|—————Node:{ Text: {
|—————Node:string_literal Text: "await_read"
|——————Node:" Text: "
|——————Node:string_content Text: await_read
|——————Node:" Text: "
|—————Node:, Text: ,
|—————Node:identifier Text: handle_await_read
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: { "write", handle_write }
|—————Node:{ Text: {
|—————Node:string_literal Text: "write"
|——————Node:" Text: "
|——————Node:string_content Text: write
|——————Node:" Text: "
|—————Node:, Text: ,
|—————Node:identifier Text: handle_write
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: { "open", handle_open }
|—————Node:{ Text: {
|—————Node:string_literal Text: "open"
|——————Node:" Text: "
|——————Node:string_content Text: open
|——————Node:" Text: "
|—————Node:, Text: ,
|—————Node:identifier Text: handle_open
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: { NULL, NULL }
|—————Node:{ Text: {
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|—————Node:, Text: ,
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|—————Node:} Text: }
|————Node:} Text: }
|——Node:; Text: ;
|—Node:function_definition Text: static void handle_elixir_request(const char *req, void *cookie)
{
  (void) cookie;

  // Commands are of the form {Command, Arguments}:
  // { atom(), term() }
  int req_index = sizeof(uint16_t);
  if (ei_decode_version(req, &req_index, NULL) < 0)
    errx(EXIT_FAILURE, "Message version issue?");

  int arity;
  if (ei_decode_tuple_header(req, &req_index, &arity) < 0 ||
      arity != 2)
    errx(EXIT_FAILURE, "expecting {cmd, args} tuple");

  char cmd[MAXATOMLEN];
  if (ei_decode_atom(req, &req_index, cmd) < 0)
    errx(EXIT_FAILURE, "expecting command atom");

  for (struct request_handler *rh = request_handlers; rh->name != NULL; rh++) {
    if (strcmp(cmd, rh->name) == 0) {
      rh->handler(req, &req_index);
      return;
    }
  }
  errx(EXIT_FAILURE, "unknown command: %s", cmd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: handle_elixir_request(const char *req, void *cookie)
|———Node:identifier Text: handle_elixir_request
|———Node:parameter_list Text: (const char *req, void *cookie)
|————Node:( Text: (
|————Node:parameter_declaration Text: const char *req
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *req
|——————Node:* Text: *
|——————Node:identifier Text: req
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *cookie
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *cookie
|——————Node:* Text: *
|——————Node:identifier Text: cookie
|————Node:) Text: )
|——Node:compound_statement Text: {
  (void) cookie;

  // Commands are of the form {Command, Arguments}:
  // { atom(), term() }
  int req_index = sizeof(uint16_t);
  if (ei_decode_version(req, &req_index, NULL) < 0)
    errx(EXIT_FAILURE, "Message version issue?");

  int arity;
  if (ei_decode_tuple_header(req, &req_index, &arity) < 0 ||
      arity != 2)
    errx(EXIT_FAILURE, "expecting {cmd, args} tuple");

  char cmd[MAXATOMLEN];
  if (ei_decode_atom(req, &req_index, cmd) < 0)
    errx(EXIT_FAILURE, "expecting command atom");

  for (struct request_handler *rh = request_handlers; rh->name != NULL; rh++) {
    if (strcmp(cmd, rh->name) == 0) {
      rh->handler(req, &req_index);
      return;
    }
  }
  errx(EXIT_FAILURE, "unknown command: %s", cmd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: (void) cookie;
|————Node:cast_expression Text: (void) cookie
|—————Node:( Text: (
|—————Node:type_descriptor Text: void
|——————Node:primitive_type Text: void
|—————Node:) Text: )
|—————Node:identifier Text: cookie
|————Node:; Text: ;
|———Node:comment Text: // Commands are of the form {Command, Arguments}:
|———Node:comment Text: // { atom(), term() }
|———Node:declaration Text: int req_index = sizeof(uint16_t);
|————Node:primitive_type Text: int
|————Node:init_declarator Text: req_index = sizeof(uint16_t)
|—————Node:identifier Text: req_index
|—————Node:= Text: =
|—————Node:sizeof_expression Text: sizeof(uint16_t)
|——————Node:sizeof Text: sizeof
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint16_t
|———————Node:primitive_type Text: uint16_t
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ei_decode_version(req, &req_index, NULL) < 0)
    errx(EXIT_FAILURE, "Message version issue?");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_version(req, &req_index, NULL) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_version(req, &req_index, NULL) < 0
|——————Node:call_expression Text: ei_decode_version(req, &req_index, NULL)
|———————Node:identifier Text: ei_decode_version
|———————Node:argument_list Text: (req, &req_index, NULL)
|————————Node:( Text: (
|————————Node:identifier Text: req
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &req_index
|—————————Node:& Text: &
|—————————Node:identifier Text: req_index
|————————Node:, Text: ,
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: errx(EXIT_FAILURE, "Message version issue?");
|—————Node:call_expression Text: errx(EXIT_FAILURE, "Message version issue?")
|——————Node:identifier Text: errx
|——————Node:argument_list Text: (EXIT_FAILURE, "Message version issue?")
|———————Node:( Text: (
|———————Node:identifier Text: EXIT_FAILURE
|———————Node:, Text: ,
|———————Node:string_literal Text: "Message version issue?"
|————————Node:" Text: "
|————————Node:string_content Text: Message version issue?
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:declaration Text: int arity;
|————Node:primitive_type Text: int
|————Node:identifier Text: arity
|————Node:; Text: ;
|———Node:if_statement Text: if (ei_decode_tuple_header(req, &req_index, &arity) < 0 ||
      arity != 2)
    errx(EXIT_FAILURE, "expecting {cmd, args} tuple");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_tuple_header(req, &req_index, &arity) < 0 ||
      arity != 2)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_tuple_header(req, &req_index, &arity) < 0 ||
      arity != 2
|——————Node:binary_expression Text: ei_decode_tuple_header(req, &req_index, &arity) < 0
|———————Node:call_expression Text: ei_decode_tuple_header(req, &req_index, &arity)
|————————Node:identifier Text: ei_decode_tuple_header
|————————Node:argument_list Text: (req, &req_index, &arity)
|—————————Node:( Text: (
|—————————Node:identifier Text: req
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &req_index
|——————————Node:& Text: &
|——————————Node:identifier Text: req_index
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &arity
|——————————Node:& Text: &
|——————————Node:identifier Text: arity
|—————————Node:) Text: )
|———————Node:< Text: <
|———————Node:number_literal Text: 0
|——————Node:|| Text: ||
|——————Node:binary_expression Text: arity != 2
|———————Node:identifier Text: arity
|———————Node:!= Text: !=
|———————Node:number_literal Text: 2
|—————Node:) Text: )
|————Node:expression_statement Text: errx(EXIT_FAILURE, "expecting {cmd, args} tuple");
|—————Node:call_expression Text: errx(EXIT_FAILURE, "expecting {cmd, args} tuple")
|——————Node:identifier Text: errx
|——————Node:argument_list Text: (EXIT_FAILURE, "expecting {cmd, args} tuple")
|———————Node:( Text: (
|———————Node:identifier Text: EXIT_FAILURE
|———————Node:, Text: ,
|———————Node:string_literal Text: "expecting {cmd, args} tuple"
|————————Node:" Text: "
|————————Node:string_content Text: expecting {cmd, args} tuple
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:declaration Text: char cmd[MAXATOMLEN];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: cmd[MAXATOMLEN]
|—————Node:identifier Text: cmd
|—————Node:[ Text: [
|—————Node:identifier Text: MAXATOMLEN
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (ei_decode_atom(req, &req_index, cmd) < 0)
    errx(EXIT_FAILURE, "expecting command atom");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ei_decode_atom(req, &req_index, cmd) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ei_decode_atom(req, &req_index, cmd) < 0
|——————Node:call_expression Text: ei_decode_atom(req, &req_index, cmd)
|———————Node:identifier Text: ei_decode_atom
|———————Node:argument_list Text: (req, &req_index, cmd)
|————————Node:( Text: (
|————————Node:identifier Text: req
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &req_index
|—————————Node:& Text: &
|—————————Node:identifier Text: req_index
|————————Node:, Text: ,
|————————Node:identifier Text: cmd
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: errx(EXIT_FAILURE, "expecting command atom");
|—————Node:call_expression Text: errx(EXIT_FAILURE, "expecting command atom")
|——————Node:identifier Text: errx
|——————Node:argument_list Text: (EXIT_FAILURE, "expecting command atom")
|———————Node:( Text: (
|———————Node:identifier Text: EXIT_FAILURE
|———————Node:, Text: ,
|———————Node:string_literal Text: "expecting command atom"
|————————Node:" Text: "
|————————Node:string_content Text: expecting command atom
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:for_statement Text: for (struct request_handler *rh = request_handlers; rh->name != NULL; rh++) {
    if (strcmp(cmd, rh->name) == 0) {
      rh->handler(req, &req_index);
      return;
    }
  }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: struct request_handler *rh = request_handlers;
|—————Node:struct_specifier Text: struct request_handler
|——————Node:struct Text: struct
|——————Node:type_identifier Text: request_handler
|—————Node:init_declarator Text: *rh = request_handlers
|——————Node:pointer_declarator Text: *rh
|———————Node:* Text: *
|———————Node:identifier Text: rh
|——————Node:= Text: =
|——————Node:identifier Text: request_handlers
|—————Node:; Text: ;
|————Node:binary_expression Text: rh->name != NULL
|—————Node:field_expression Text: rh->name
|——————Node:identifier Text: rh
|——————Node:-> Text: ->
|——————Node:field_identifier Text: name
|—————Node:!= Text: !=
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|————Node:update_expression Text: rh++
|—————Node:identifier Text: rh
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
    if (strcmp(cmd, rh->name) == 0) {
      rh->handler(req, &req_index);
      return;
    }
  }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (strcmp(cmd, rh->name) == 0) {
      rh->handler(req, &req_index);
      return;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (strcmp(cmd, rh->name) == 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: strcmp(cmd, rh->name) == 0
|————————Node:call_expression Text: strcmp(cmd, rh->name)
|—————————Node:identifier Text: strcmp
|—————————Node:argument_list Text: (cmd, rh->name)
|——————————Node:( Text: (
|——————————Node:identifier Text: cmd
|——————————Node:, Text: ,
|——————————Node:field_expression Text: rh->name
|———————————Node:identifier Text: rh
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      rh->handler(req, &req_index);
      return;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: rh->handler(req, &req_index);
|————————Node:call_expression Text: rh->handler(req, &req_index)
|—————————Node:field_expression Text: rh->handler
|——————————Node:identifier Text: rh
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: handler
|—————————Node:argument_list Text: (req, &req_index)
|——————————Node:( Text: (
|——————————Node:identifier Text: req
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &req_index
|———————————Node:& Text: &
|———————————Node:identifier Text: req_index
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return;
|————————Node:return Text: return
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: errx(EXIT_FAILURE, "unknown command: %s", cmd);
|————Node:call_expression Text: errx(EXIT_FAILURE, "unknown command: %s", cmd)
|—————Node:identifier Text: errx
|—————Node:argument_list Text: (EXIT_FAILURE, "unknown command: %s", cmd)
|——————Node:( Text: (
|——————Node:identifier Text: EXIT_FAILURE
|——————Node:, Text: ,
|——————Node:string_literal Text: "unknown command: %s"
|———————Node:" Text: "
|———————Node:string_content Text: unknown command: %s
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:identifier Text: cmd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: int main(int argc, char *argv[])
{
#ifdef DEBUG
    char logfile[64];
    /* sprintf(logfile, "ng_can-%d.log", (int) getpid()); */
    sprintf(logfile, "/root/logs/ng_can.log", (int) getpid());
    FILE *fp = fopen(logfile, "w+");
    log_location = fp;

    debug("Starting!");
#endif
  if (can_init(&can_port) < 0)
    errx(EXIT_FAILURE, "can_init failed");

  struct erlcmd *handler = malloc(sizeof(struct erlcmd));
  erlcmd_init(handler, handle_elixir_request, NULL);

  for (;;) {
    struct pollfd fdset[3];
    int num_listeners = 1;

    fdset[0].fd = STDIN_FILENO;
    fdset[0].events = POLLIN;
    fdset[0].revents = 0;

    fdset[1].fd = can_port->fd;
    fdset[1].revents = 0;

    if(can_port->write_buffer_size > 0) {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }

    if(can_port->awaiting_read == 1) {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }

    int rc = poll(fdset, num_listeners, -1);
    if (rc < 0) {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }

    if (fdset[0].revents & (POLLIN | POLLHUP)) {
      if (erlcmd_process(handler))
        break;
    }
    //ready to work through write buffer
    if (fdset[1].revents & POLLOUT) {
      process_write_buffer();
    }

    if (fdset[1].revents & POLLIN) {
      notify_read();
    }
  }

  return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: main(int argc, char *argv[])
|———Node:identifier Text: main
|———Node:parameter_list Text: (int argc, char *argv[])
|————Node:( Text: (
|————Node:parameter_declaration Text: int argc
|—————Node:primitive_type Text: int
|—————Node:identifier Text: argc
|————Node:, Text: ,
|————Node:parameter_declaration Text: char *argv[]
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: *argv[]
|——————Node:* Text: *
|——————Node:array_declarator Text: argv[]
|———————Node:identifier Text: argv
|———————Node:[ Text: [
|———————Node:] Text: ]
|————Node:) Text: )
|——Node:compound_statement Text: {
#ifdef DEBUG
    char logfile[64];
    /* sprintf(logfile, "ng_can-%d.log", (int) getpid()); */
    sprintf(logfile, "/root/logs/ng_can.log", (int) getpid());
    FILE *fp = fopen(logfile, "w+");
    log_location = fp;

    debug("Starting!");
#endif
  if (can_init(&can_port) < 0)
    errx(EXIT_FAILURE, "can_init failed");

  struct erlcmd *handler = malloc(sizeof(struct erlcmd));
  erlcmd_init(handler, handle_elixir_request, NULL);

  for (;;) {
    struct pollfd fdset[3];
    int num_listeners = 1;

    fdset[0].fd = STDIN_FILENO;
    fdset[0].events = POLLIN;
    fdset[0].revents = 0;

    fdset[1].fd = can_port->fd;
    fdset[1].revents = 0;

    if(can_port->write_buffer_size > 0) {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }

    if(can_port->awaiting_read == 1) {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }

    int rc = poll(fdset, num_listeners, -1);
    if (rc < 0) {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }

    if (fdset[0].revents & (POLLIN | POLLHUP)) {
      if (erlcmd_process(handler))
        break;
    }
    //ready to work through write buffer
    if (fdset[1].revents & POLLOUT) {
      process_write_buffer();
    }

    if (fdset[1].revents & POLLIN) {
      notify_read();
    }
  }

  return 0;
}
|———Node:{ Text: {
|———Node:preproc_ifdef Text: #ifdef DEBUG
    char logfile[64];
    /* sprintf(logfile, "ng_can-%d.log", (int) getpid()); */
    sprintf(logfile, "/root/logs/ng_can.log", (int) getpid());
    FILE *fp = fopen(logfile, "w+");
    log_location = fp;

    debug("Starting!");
#endif
|————Node:#ifdef Text: #ifdef
|————Node:identifier Text: DEBUG
|————Node:declaration Text: char logfile[64];
|—————Node:primitive_type Text: char
|—————Node:array_declarator Text: logfile[64]
|——————Node:identifier Text: logfile
|——————Node:[ Text: [
|——————Node:number_literal Text: 64
|——————Node:] Text: ]
|—————Node:; Text: ;
|————Node:comment Text: /* sprintf(logfile, "ng_can-%d.log", (int) getpid()); */
|————Node:expression_statement Text: sprintf(logfile, "/root/logs/ng_can.log", (int) getpid());
|—————Node:call_expression Text: sprintf(logfile, "/root/logs/ng_can.log", (int) getpid())
|——————Node:identifier Text: sprintf
|——————Node:argument_list Text: (logfile, "/root/logs/ng_can.log", (int) getpid())
|———————Node:( Text: (
|———————Node:identifier Text: logfile
|———————Node:, Text: ,
|———————Node:string_literal Text: "/root/logs/ng_can.log"
|————————Node:" Text: "
|————————Node:string_content Text: /root/logs/ng_can.log
|————————Node:" Text: "
|———————Node:, Text: ,
|———————Node:cast_expression Text: (int) getpid()
|————————Node:( Text: (
|————————Node:type_descriptor Text: int
|—————————Node:primitive_type Text: int
|————————Node:) Text: )
|————————Node:call_expression Text: getpid()
|—————————Node:identifier Text: getpid
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: FILE *fp = fopen(logfile, "w+");
|—————Node:type_identifier Text: FILE
|—————Node:init_declarator Text: *fp = fopen(logfile, "w+")
|——————Node:pointer_declarator Text: *fp
|———————Node:* Text: *
|———————Node:identifier Text: fp
|——————Node:= Text: =
|——————Node:call_expression Text: fopen(logfile, "w+")
|———————Node:identifier Text: fopen
|———————Node:argument_list Text: (logfile, "w+")
|————————Node:( Text: (
|————————Node:identifier Text: logfile
|————————Node:, Text: ,
|————————Node:string_literal Text: "w+"
|—————————Node:" Text: "
|—————————Node:string_content Text: w+
|—————————Node:" Text: "
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: log_location = fp;
|—————Node:assignment_expression Text: log_location = fp
|——————Node:identifier Text: log_location
|——————Node:= Text: =
|——————Node:identifier Text: fp
|—————Node:; Text: ;
|————Node:expression_statement Text: debug("Starting!");
|—————Node:call_expression Text: debug("Starting!")
|——————Node:identifier Text: debug
|——————Node:argument_list Text: ("Starting!")
|———————Node:( Text: (
|———————Node:string_literal Text: "Starting!"
|————————Node:" Text: "
|————————Node:string_content Text: Starting!
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:if_statement Text: if (can_init(&can_port) < 0)
    errx(EXIT_FAILURE, "can_init failed");
|————Node:if Text: if
|————Node:parenthesized_expression Text: (can_init(&can_port) < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: can_init(&can_port) < 0
|——————Node:call_expression Text: can_init(&can_port)
|———————Node:identifier Text: can_init
|———————Node:argument_list Text: (&can_port)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &can_port
|—————————Node:& Text: &
|—————————Node:identifier Text: can_port
|————————Node:) Text: )
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: errx(EXIT_FAILURE, "can_init failed");
|—————Node:call_expression Text: errx(EXIT_FAILURE, "can_init failed")
|——————Node:identifier Text: errx
|——————Node:argument_list Text: (EXIT_FAILURE, "can_init failed")
|———————Node:( Text: (
|———————Node:identifier Text: EXIT_FAILURE
|———————Node:, Text: ,
|———————Node:string_literal Text: "can_init failed"
|————————Node:" Text: "
|————————Node:string_content Text: can_init failed
|————————Node:" Text: "
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:declaration Text: struct erlcmd *handler = malloc(sizeof(struct erlcmd));
|————Node:struct_specifier Text: struct erlcmd
|—————Node:struct Text: struct
|—————Node:type_identifier Text: erlcmd
|————Node:init_declarator Text: *handler = malloc(sizeof(struct erlcmd))
|—————Node:pointer_declarator Text: *handler
|——————Node:* Text: *
|——————Node:identifier Text: handler
|—————Node:= Text: =
|—————Node:call_expression Text: malloc(sizeof(struct erlcmd))
|——————Node:identifier Text: malloc
|——————Node:argument_list Text: (sizeof(struct erlcmd))
|———————Node:( Text: (
|———————Node:sizeof_expression Text: sizeof(struct erlcmd)
|————————Node:sizeof Text: sizeof
|————————Node:( Text: (
|————————Node:type_descriptor Text: struct erlcmd
|—————————Node:struct_specifier Text: struct erlcmd
|——————————Node:struct Text: struct
|——————————Node:type_identifier Text: erlcmd
|————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: erlcmd_init(handler, handle_elixir_request, NULL);
|————Node:call_expression Text: erlcmd_init(handler, handle_elixir_request, NULL)
|—————Node:identifier Text: erlcmd_init
|—————Node:argument_list Text: (handler, handle_elixir_request, NULL)
|——————Node:( Text: (
|——————Node:identifier Text: handler
|——————Node:, Text: ,
|——————Node:identifier Text: handle_elixir_request
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (;;) {
    struct pollfd fdset[3];
    int num_listeners = 1;

    fdset[0].fd = STDIN_FILENO;
    fdset[0].events = POLLIN;
    fdset[0].revents = 0;

    fdset[1].fd = can_port->fd;
    fdset[1].revents = 0;

    if(can_port->write_buffer_size > 0) {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }

    if(can_port->awaiting_read == 1) {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }

    int rc = poll(fdset, num_listeners, -1);
    if (rc < 0) {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }

    if (fdset[0].revents & (POLLIN | POLLHUP)) {
      if (erlcmd_process(handler))
        break;
    }
    //ready to work through write buffer
    if (fdset[1].revents & POLLOUT) {
      process_write_buffer();
    }

    if (fdset[1].revents & POLLIN) {
      notify_read();
    }
  }
|————Node:for Text: for
|————Node:( Text: (
|————Node:; Text: ;
|————Node:; Text: ;
|————Node:) Text: )
|————Node:compound_statement Text: {
    struct pollfd fdset[3];
    int num_listeners = 1;

    fdset[0].fd = STDIN_FILENO;
    fdset[0].events = POLLIN;
    fdset[0].revents = 0;

    fdset[1].fd = can_port->fd;
    fdset[1].revents = 0;

    if(can_port->write_buffer_size > 0) {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }

    if(can_port->awaiting_read == 1) {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }

    int rc = poll(fdset, num_listeners, -1);
    if (rc < 0) {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }

    if (fdset[0].revents & (POLLIN | POLLHUP)) {
      if (erlcmd_process(handler))
        break;
    }
    //ready to work through write buffer
    if (fdset[1].revents & POLLOUT) {
      process_write_buffer();
    }

    if (fdset[1].revents & POLLIN) {
      notify_read();
    }
  }
|—————Node:{ Text: {
|—————Node:declaration Text: struct pollfd fdset[3];
|——————Node:struct_specifier Text: struct pollfd
|———————Node:struct Text: struct
|———————Node:type_identifier Text: pollfd
|——————Node:array_declarator Text: fdset[3]
|———————Node:identifier Text: fdset
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:declaration Text: int num_listeners = 1;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: num_listeners = 1
|———————Node:identifier Text: num_listeners
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: fdset[0].fd = STDIN_FILENO;
|——————Node:assignment_expression Text: fdset[0].fd = STDIN_FILENO
|———————Node:field_expression Text: fdset[0].fd
|————————Node:subscript_expression Text: fdset[0]
|—————————Node:identifier Text: fdset
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: fd
|———————Node:= Text: =
|———————Node:identifier Text: STDIN_FILENO
|——————Node:; Text: ;
|—————Node:expression_statement Text: fdset[0].events = POLLIN;
|——————Node:assignment_expression Text: fdset[0].events = POLLIN
|———————Node:field_expression Text: fdset[0].events
|————————Node:subscript_expression Text: fdset[0]
|—————————Node:identifier Text: fdset
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: events
|———————Node:= Text: =
|———————Node:identifier Text: POLLIN
|——————Node:; Text: ;
|—————Node:expression_statement Text: fdset[0].revents = 0;
|——————Node:assignment_expression Text: fdset[0].revents = 0
|———————Node:field_expression Text: fdset[0].revents
|————————Node:subscript_expression Text: fdset[0]
|—————————Node:identifier Text: fdset
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: revents
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: fdset[1].fd = can_port->fd;
|——————Node:assignment_expression Text: fdset[1].fd = can_port->fd
|———————Node:field_expression Text: fdset[1].fd
|————————Node:subscript_expression Text: fdset[1]
|—————————Node:identifier Text: fdset
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: fd
|———————Node:= Text: =
|———————Node:field_expression Text: can_port->fd
|————————Node:identifier Text: can_port
|————————Node:-> Text: ->
|————————Node:field_identifier Text: fd
|——————Node:; Text: ;
|—————Node:expression_statement Text: fdset[1].revents = 0;
|——————Node:assignment_expression Text: fdset[1].revents = 0
|———————Node:field_expression Text: fdset[1].revents
|————————Node:subscript_expression Text: fdset[1]
|—————————Node:identifier Text: fdset
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: revents
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:if_statement Text: if(can_port->write_buffer_size > 0) {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (can_port->write_buffer_size > 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: can_port->write_buffer_size > 0
|————————Node:field_expression Text: can_port->write_buffer_size
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: write_buffer_size
|————————Node:> Text: >
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      num_listeners = 2;
      fdset[1].events = POLLOUT;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: num_listeners = 2;
|————————Node:assignment_expression Text: num_listeners = 2
|—————————Node:identifier Text: num_listeners
|—————————Node:= Text: =
|—————————Node:number_literal Text: 2
|————————Node:; Text: ;
|———————Node:expression_statement Text: fdset[1].events = POLLOUT;
|————————Node:assignment_expression Text: fdset[1].events = POLLOUT
|—————————Node:field_expression Text: fdset[1].events
|——————————Node:subscript_expression Text: fdset[1]
|———————————Node:identifier Text: fdset
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: events
|—————————Node:= Text: =
|—————————Node:identifier Text: POLLOUT
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if(can_port->awaiting_read == 1) {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (can_port->awaiting_read == 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: can_port->awaiting_read == 1
|————————Node:field_expression Text: can_port->awaiting_read
|—————————Node:identifier Text: can_port
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: awaiting_read
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      num_listeners = 2;
      fdset[1].events |= POLLIN;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: num_listeners = 2;
|————————Node:assignment_expression Text: num_listeners = 2
|—————————Node:identifier Text: num_listeners
|—————————Node:= Text: =
|—————————Node:number_literal Text: 2
|————————Node:; Text: ;
|———————Node:expression_statement Text: fdset[1].events |= POLLIN;
|————————Node:assignment_expression Text: fdset[1].events |= POLLIN
|—————————Node:field_expression Text: fdset[1].events
|——————————Node:subscript_expression Text: fdset[1]
|———————————Node:identifier Text: fdset
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: events
|—————————Node:|= Text: |=
|—————————Node:identifier Text: POLLIN
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:declaration Text: int rc = poll(fdset, num_listeners, -1);
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: rc = poll(fdset, num_listeners, -1)
|———————Node:identifier Text: rc
|———————Node:= Text: =
|———————Node:call_expression Text: poll(fdset, num_listeners, -1)
|————————Node:identifier Text: poll
|————————Node:argument_list Text: (fdset, num_listeners, -1)
|—————————Node:( Text: (
|—————————Node:identifier Text: fdset
|—————————Node:, Text: ,
|—————————Node:identifier Text: num_listeners
|—————————Node:, Text: ,
|—————————Node:number_literal Text: -1
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (rc < 0) {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (rc < 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: rc < 0
|————————Node:identifier Text: rc
|————————Node:< Text: <
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      // Retry if EINTR
      if (errno == EINTR)
        continue;

      debug("exiting due to error");
      errx(EXIT_FAILURE, "poll");
    }
|———————Node:{ Text: {
|———————Node:comment Text: // Retry if EINTR
|———————Node:if_statement Text: if (errno == EINTR)
        continue;
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (errno == EINTR)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: errno == EINTR
|——————————Node:identifier Text: errno
|——————————Node:== Text: ==
|——————————Node:identifier Text: EINTR
|—————————Node:) Text: )
|————————Node:continue_statement Text: continue;
|—————————Node:continue Text: continue
|—————————Node:; Text: ;
|———————Node:expression_statement Text: debug("exiting due to error");
|————————Node:call_expression Text: debug("exiting due to error")
|—————————Node:identifier Text: debug
|—————————Node:argument_list Text: ("exiting due to error")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "exiting due to error"
|———————————Node:" Text: "
|———————————Node:string_content Text: exiting due to error
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: errx(EXIT_FAILURE, "poll");
|————————Node:call_expression Text: errx(EXIT_FAILURE, "poll")
|—————————Node:identifier Text: errx
|—————————Node:argument_list Text: (EXIT_FAILURE, "poll")
|——————————Node:( Text: (
|——————————Node:identifier Text: EXIT_FAILURE
|——————————Node:, Text: ,
|——————————Node:string_literal Text: "poll"
|———————————Node:" Text: "
|———————————Node:string_content Text: poll
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (fdset[0].revents & (POLLIN | POLLHUP)) {
      if (erlcmd_process(handler))
        break;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (fdset[0].revents & (POLLIN | POLLHUP))
|———————Node:( Text: (
|———————Node:binary_expression Text: fdset[0].revents & (POLLIN | POLLHUP)
|————————Node:field_expression Text: fdset[0].revents
|—————————Node:subscript_expression Text: fdset[0]
|——————————Node:identifier Text: fdset
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 0
|——————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: revents
|————————Node:& Text: &
|————————Node:parenthesized_expression Text: (POLLIN | POLLHUP)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: POLLIN | POLLHUP
|——————————Node:identifier Text: POLLIN
|——————————Node:| Text: |
|——————————Node:identifier Text: POLLHUP
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      if (erlcmd_process(handler))
        break;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (erlcmd_process(handler))
        break;
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (erlcmd_process(handler))
|—————————Node:( Text: (
|—————————Node:call_expression Text: erlcmd_process(handler)
|——————————Node:identifier Text: erlcmd_process
|——————————Node:argument_list Text: (handler)
|———————————Node:( Text: (
|———————————Node:identifier Text: handler
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment Text: //ready to work through write buffer
|—————Node:if_statement Text: if (fdset[1].revents & POLLOUT) {
      process_write_buffer();
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (fdset[1].revents & POLLOUT)
|———————Node:( Text: (
|———————Node:binary_expression Text: fdset[1].revents & POLLOUT
|————————Node:field_expression Text: fdset[1].revents
|—————————Node:subscript_expression Text: fdset[1]
|——————————Node:identifier Text: fdset
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 1
|——————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: revents
|————————Node:& Text: &
|————————Node:identifier Text: POLLOUT
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      process_write_buffer();
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: process_write_buffer();
|————————Node:call_expression Text: process_write_buffer()
|—————————Node:identifier Text: process_write_buffer
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (fdset[1].revents & POLLIN) {
      notify_read();
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (fdset[1].revents & POLLIN)
|———————Node:( Text: (
|———————Node:binary_expression Text: fdset[1].revents & POLLIN
|————————Node:field_expression Text: fdset[1].revents
|—————————Node:subscript_expression Text: fdset[1]
|——————————Node:identifier Text: fdset
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 1
|——————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: revents
|————————Node:& Text: &
|————————Node:identifier Text: POLLIN
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      notify_read();
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: notify_read();
|————————Node:call_expression Text: notify_read()
|—————————Node:identifier Text: notify_read
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
