cangaroo-src\model\CanMessage.cpp

|Node:translation_unit
|—Node:comment Text: /*

  Copyright (c) 2015, 2016 Hubert Denkmair <hubert@denkmair.de>

  This file is part of cangaroo.

  cangaroo is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.

  cangaroo is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with cangaroo.  If not, see <http://www.gnu.org/licenses/>.

*/
|—Node:preproc_include Text: #include "CanMessage.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "CanMessage.h"
|———Node:" Text: "
|———Node:string_content Text: CanMessage.h
|———Node:" Text: "
|—Node:preproc_include Text: #include <endian.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <endian.h>
|—Node:enum_specifier Text: enum {
	id_flag_extended = 0x80000000,
	id_flag_rtr      = 0x40000000,
	id_flag_error    = 0x20000000,
	id_mask_extended = 0x1FFFFFFF,
	id_mask_standard = 0x7FF
}
|——Node:enum Text: enum
|——Node:enumerator_list Text: {
	id_flag_extended = 0x80000000,
	id_flag_rtr      = 0x40000000,
	id_flag_error    = 0x20000000,
	id_mask_extended = 0x1FFFFFFF,
	id_mask_standard = 0x7FF
}
|———Node:{ Text: {
|———Node:enumerator Text: id_flag_extended = 0x80000000
|————Node:identifier Text: id_flag_extended
|————Node:= Text: =
|————Node:number_literal Text: 0x80000000
|———Node:, Text: ,
|———Node:enumerator Text: id_flag_rtr      = 0x40000000
|————Node:identifier Text: id_flag_rtr
|————Node:= Text: =
|————Node:number_literal Text: 0x40000000
|———Node:, Text: ,
|———Node:enumerator Text: id_flag_error    = 0x20000000
|————Node:identifier Text: id_flag_error
|————Node:= Text: =
|————Node:number_literal Text: 0x20000000
|———Node:, Text: ,
|———Node:enumerator Text: id_mask_extended = 0x1FFFFFFF
|————Node:identifier Text: id_mask_extended
|————Node:= Text: =
|————Node:number_literal Text: 0x1FFFFFFF
|———Node:, Text: ,
|———Node:enumerator Text: id_mask_standard = 0x7FF
|————Node:identifier Text: id_mask_standard
|————Node:= Text: =
|————Node:number_literal Text: 0x7FF
|———Node:} Text: }
|—Node:; Text: ;
|—Node:function_definition Text: CanMessage::CanMessage()
  : _raw_id(0), _dlc(0), _u64(0)
{
}
|——Node:function_declarator Text: CanMessage::CanMessage()
|———Node:qualified_identifier Text: CanMessage::CanMessage
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: CanMessage
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:field_initializer_list Text: : _raw_id(0), _dlc(0), _u64(0)
|———Node:: Text: :
|———Node:field_initializer Text: _raw_id(0)
|————Node:field_identifier Text: _raw_id
|————Node:argument_list Text: (0)
|—————Node:( Text: (
|—————Node:number_literal Text: 0
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: _dlc(0)
|————Node:field_identifier Text: _dlc
|————Node:argument_list Text: (0)
|—————Node:( Text: (
|—————Node:number_literal Text: 0
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: _u64(0)
|————Node:field_identifier Text: _u64
|————Node:argument_list Text: (0)
|—————Node:( Text: (
|—————Node:number_literal Text: 0
|—————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: CanMessage::CanMessage(uint32_t can_id)
  : _dlc(0), _u64(0)
{
    setId(can_id);
}
|——Node:function_declarator Text: CanMessage::CanMessage(uint32_t can_id)
|———Node:qualified_identifier Text: CanMessage::CanMessage
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: CanMessage
|———Node:parameter_list Text: (uint32_t can_id)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t can_id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: can_id
|————Node:) Text: )
|——Node:field_initializer_list Text: : _dlc(0), _u64(0)
|———Node:: Text: :
|———Node:field_initializer Text: _dlc(0)
|————Node:field_identifier Text: _dlc
|————Node:argument_list Text: (0)
|—————Node:( Text: (
|—————Node:number_literal Text: 0
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: _u64(0)
|————Node:field_identifier Text: _u64
|————Node:argument_list Text: (0)
|—————Node:( Text: (
|—————Node:number_literal Text: 0
|—————Node:) Text: )
|——Node:compound_statement Text: {
    setId(can_id);
}
|———Node:{ Text: {
|———Node:expression_statement Text: setId(can_id);
|————Node:call_expression Text: setId(can_id)
|—————Node:identifier Text: setId
|—————Node:argument_list Text: (can_id)
|——————Node:( Text: (
|——————Node:identifier Text: can_id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CanMessage::CanMessage(const CanMessage &msg)
{
    cloneFrom(msg);
}
|——Node:function_declarator Text: CanMessage::CanMessage(const CanMessage &msg)
|———Node:qualified_identifier Text: CanMessage::CanMessage
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: CanMessage
|———Node:parameter_list Text: (const CanMessage &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: const CanMessage &msg
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CanMessage
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
    cloneFrom(msg);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cloneFrom(msg);
|————Node:call_expression Text: cloneFrom(msg)
|—————Node:identifier Text: cloneFrom
|—————Node:argument_list Text: (msg)
|——————Node:( Text: (
|——————Node:identifier Text: msg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::cloneFrom(const CanMessage &msg)
{
    _raw_id = msg._raw_id;
    _dlc = msg._dlc;
    _u64 = msg._u64;
    _interface = msg._interface;
    _timestamp = msg._timestamp;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::cloneFrom(const CanMessage &msg)
|———Node:qualified_identifier Text: CanMessage::cloneFrom
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: cloneFrom
|———Node:parameter_list Text: (const CanMessage &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: const CanMessage &msg
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CanMessage
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
    _raw_id = msg._raw_id;
    _dlc = msg._dlc;
    _u64 = msg._u64;
    _interface = msg._interface;
    _timestamp = msg._timestamp;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _raw_id = msg._raw_id;
|————Node:assignment_expression Text: _raw_id = msg._raw_id
|—————Node:identifier Text: _raw_id
|—————Node:= Text: =
|—————Node:field_expression Text: msg._raw_id
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: _raw_id
|————Node:; Text: ;
|———Node:expression_statement Text: _dlc = msg._dlc;
|————Node:assignment_expression Text: _dlc = msg._dlc
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:field_expression Text: msg._dlc
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: _dlc
|————Node:; Text: ;
|———Node:expression_statement Text: _u64 = msg._u64;
|————Node:assignment_expression Text: _u64 = msg._u64
|—————Node:identifier Text: _u64
|—————Node:= Text: =
|—————Node:field_expression Text: msg._u64
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: _u64
|————Node:; Text: ;
|———Node:expression_statement Text: _interface = msg._interface;
|————Node:assignment_expression Text: _interface = msg._interface
|—————Node:identifier Text: _interface
|—————Node:= Text: =
|—————Node:field_expression Text: msg._interface
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: _interface
|————Node:; Text: ;
|———Node:expression_statement Text: _timestamp = msg._timestamp;
|————Node:assignment_expression Text: _timestamp = msg._timestamp
|—————Node:identifier Text: _timestamp
|—————Node:= Text: =
|—————Node:field_expression Text: msg._timestamp
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: _timestamp
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint32_t CanMessage::getRawId() const {
	return _raw_id;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CanMessage::getRawId() const
|———Node:qualified_identifier Text: CanMessage::getRawId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getRawId
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return _raw_id;
}
|———Node:{ Text: {
|———Node:return_statement Text: return _raw_id;
|————Node:return Text: return
|————Node:identifier Text: _raw_id
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setRawId(const uint32_t raw_id) {
	_raw_id = raw_id;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setRawId(const uint32_t raw_id)
|———Node:qualified_identifier Text: CanMessage::setRawId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setRawId
|———Node:parameter_list Text: (const uint32_t raw_id)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint32_t raw_id
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: raw_id
|————Node:) Text: )
|——Node:compound_statement Text: {
	_raw_id = raw_id;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _raw_id = raw_id;
|————Node:assignment_expression Text: _raw_id = raw_id
|—————Node:identifier Text: _raw_id
|—————Node:= Text: =
|—————Node:identifier Text: raw_id
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint32_t CanMessage::getId() const {
	if (isExtended()) {
		return _raw_id & id_mask_extended;
	} else {
		return _raw_id & id_mask_standard;
	}
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CanMessage::getId() const
|———Node:qualified_identifier Text: CanMessage::getId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getId
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	if (isExtended()) {
		return _raw_id & id_mask_extended;
	} else {
		return _raw_id & id_mask_standard;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (isExtended()) {
		return _raw_id & id_mask_extended;
	} else {
		return _raw_id & id_mask_standard;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (isExtended())
|—————Node:( Text: (
|—————Node:call_expression Text: isExtended()
|——————Node:identifier Text: isExtended
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return _raw_id & id_mask_extended;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return _raw_id & id_mask_extended;
|——————Node:return Text: return
|——————Node:binary_expression Text: _raw_id & id_mask_extended
|———————Node:identifier Text: _raw_id
|———————Node:& Text: &
|———————Node:identifier Text: id_mask_extended
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		return _raw_id & id_mask_standard;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		return _raw_id & id_mask_standard;
	}
|——————Node:{ Text: {
|——————Node:return_statement Text: return _raw_id & id_mask_standard;
|———————Node:return Text: return
|———————Node:binary_expression Text: _raw_id & id_mask_standard
|————————Node:identifier Text: _raw_id
|————————Node:& Text: &
|————————Node:identifier Text: id_mask_standard
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setId(const uint32_t id) {
	_raw_id &= ~ id_mask_extended;
	_raw_id |= id;
	if (id>0x7FF) {
		setExtended(true);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setId(const uint32_t id)
|———Node:qualified_identifier Text: CanMessage::setId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setId
|———Node:parameter_list Text: (const uint32_t id)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint32_t id
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:) Text: )
|——Node:compound_statement Text: {
	_raw_id &= ~ id_mask_extended;
	_raw_id |= id;
	if (id>0x7FF) {
		setExtended(true);
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: _raw_id &= ~ id_mask_extended;
|————Node:assignment_expression Text: _raw_id &= ~ id_mask_extended
|—————Node:identifier Text: _raw_id
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~ id_mask_extended
|——————Node:~ Text: ~
|——————Node:identifier Text: id_mask_extended
|————Node:; Text: ;
|———Node:expression_statement Text: _raw_id |= id;
|————Node:assignment_expression Text: _raw_id |= id
|—————Node:identifier Text: _raw_id
|—————Node:|= Text: |=
|—————Node:identifier Text: id
|————Node:; Text: ;
|———Node:if_statement Text: if (id>0x7FF) {
		setExtended(true);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (id>0x7FF)
|—————Node:( Text: (
|—————Node:binary_expression Text: id>0x7FF
|——————Node:identifier Text: id
|——————Node:> Text: >
|——————Node:number_literal Text: 0x7FF
|—————Node:) Text: )
|————Node:compound_statement Text: {
		setExtended(true);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: setExtended(true);
|——————Node:call_expression Text: setExtended(true)
|———————Node:identifier Text: setExtended
|———————Node:argument_list Text: (true)
|————————Node:( Text: (
|————————Node:true Text: true
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CanMessage::isExtended() const {
	return (_raw_id & id_flag_extended) != 0;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CanMessage::isExtended() const
|———Node:qualified_identifier Text: CanMessage::isExtended
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: isExtended
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return (_raw_id & id_flag_extended) != 0;
}
|———Node:{ Text: {
|———Node:return_statement Text: return (_raw_id & id_flag_extended) != 0;
|————Node:return Text: return
|————Node:binary_expression Text: (_raw_id & id_flag_extended) != 0
|—————Node:parenthesized_expression Text: (_raw_id & id_flag_extended)
|——————Node:( Text: (
|——————Node:binary_expression Text: _raw_id & id_flag_extended
|———————Node:identifier Text: _raw_id
|———————Node:& Text: &
|———————Node:identifier Text: id_flag_extended
|——————Node:) Text: )
|—————Node:!= Text: !=
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setExtended(const bool isExtended) {
	if (isExtended) {
		_raw_id |= id_flag_extended;
	} else {
		_raw_id &= ~id_flag_extended;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setExtended(const bool isExtended)
|———Node:qualified_identifier Text: CanMessage::setExtended
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setExtended
|———Node:parameter_list Text: (const bool isExtended)
|————Node:( Text: (
|————Node:parameter_declaration Text: const bool isExtended
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: isExtended
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (isExtended) {
		_raw_id |= id_flag_extended;
	} else {
		_raw_id &= ~id_flag_extended;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (isExtended) {
		_raw_id |= id_flag_extended;
	} else {
		_raw_id &= ~id_flag_extended;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (isExtended)
|—————Node:( Text: (
|—————Node:identifier Text: isExtended
|—————Node:) Text: )
|————Node:compound_statement Text: {
		_raw_id |= id_flag_extended;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: _raw_id |= id_flag_extended;
|——————Node:assignment_expression Text: _raw_id |= id_flag_extended
|———————Node:identifier Text: _raw_id
|———————Node:|= Text: |=
|———————Node:identifier Text: id_flag_extended
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		_raw_id &= ~id_flag_extended;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		_raw_id &= ~id_flag_extended;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: _raw_id &= ~id_flag_extended;
|———————Node:assignment_expression Text: _raw_id &= ~id_flag_extended
|————————Node:identifier Text: _raw_id
|————————Node:&= Text: &=
|————————Node:unary_expression Text: ~id_flag_extended
|—————————Node:~ Text: ~
|—————————Node:identifier Text: id_flag_extended
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CanMessage::isRTR() const {
	return (_raw_id & id_flag_rtr) != 0;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CanMessage::isRTR() const
|———Node:qualified_identifier Text: CanMessage::isRTR
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: isRTR
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return (_raw_id & id_flag_rtr) != 0;
}
|———Node:{ Text: {
|———Node:return_statement Text: return (_raw_id & id_flag_rtr) != 0;
|————Node:return Text: return
|————Node:binary_expression Text: (_raw_id & id_flag_rtr) != 0
|—————Node:parenthesized_expression Text: (_raw_id & id_flag_rtr)
|——————Node:( Text: (
|——————Node:binary_expression Text: _raw_id & id_flag_rtr
|———————Node:identifier Text: _raw_id
|———————Node:& Text: &
|———————Node:identifier Text: id_flag_rtr
|——————Node:) Text: )
|—————Node:!= Text: !=
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setRTR(const bool isRTR) {
	if (isRTR) {
		_raw_id |= id_flag_rtr;
	} else {
		_raw_id &= ~id_flag_rtr;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setRTR(const bool isRTR)
|———Node:qualified_identifier Text: CanMessage::setRTR
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setRTR
|———Node:parameter_list Text: (const bool isRTR)
|————Node:( Text: (
|————Node:parameter_declaration Text: const bool isRTR
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: isRTR
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (isRTR) {
		_raw_id |= id_flag_rtr;
	} else {
		_raw_id &= ~id_flag_rtr;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (isRTR) {
		_raw_id |= id_flag_rtr;
	} else {
		_raw_id &= ~id_flag_rtr;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (isRTR)
|—————Node:( Text: (
|—————Node:identifier Text: isRTR
|—————Node:) Text: )
|————Node:compound_statement Text: {
		_raw_id |= id_flag_rtr;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: _raw_id |= id_flag_rtr;
|——————Node:assignment_expression Text: _raw_id |= id_flag_rtr
|———————Node:identifier Text: _raw_id
|———————Node:|= Text: |=
|———————Node:identifier Text: id_flag_rtr
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		_raw_id &= ~id_flag_rtr;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		_raw_id &= ~id_flag_rtr;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: _raw_id &= ~id_flag_rtr;
|———————Node:assignment_expression Text: _raw_id &= ~id_flag_rtr
|————————Node:identifier Text: _raw_id
|————————Node:&= Text: &=
|————————Node:unary_expression Text: ~id_flag_rtr
|—————————Node:~ Text: ~
|—————————Node:identifier Text: id_flag_rtr
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CanMessage::isErrorFrame() const {
	return (_raw_id & id_flag_error) != 0;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CanMessage::isErrorFrame() const
|———Node:qualified_identifier Text: CanMessage::isErrorFrame
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: isErrorFrame
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return (_raw_id & id_flag_error) != 0;
}
|———Node:{ Text: {
|———Node:return_statement Text: return (_raw_id & id_flag_error) != 0;
|————Node:return Text: return
|————Node:binary_expression Text: (_raw_id & id_flag_error) != 0
|—————Node:parenthesized_expression Text: (_raw_id & id_flag_error)
|——————Node:( Text: (
|——————Node:binary_expression Text: _raw_id & id_flag_error
|———————Node:identifier Text: _raw_id
|———————Node:& Text: &
|———————Node:identifier Text: id_flag_error
|——————Node:) Text: )
|—————Node:!= Text: !=
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setErrorFrame(const bool isErrorFrame) {
	if (isErrorFrame) {
		_raw_id |= id_flag_error;
	} else {
		_raw_id &= ~id_flag_error;
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setErrorFrame(const bool isErrorFrame)
|———Node:qualified_identifier Text: CanMessage::setErrorFrame
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setErrorFrame
|———Node:parameter_list Text: (const bool isErrorFrame)
|————Node:( Text: (
|————Node:parameter_declaration Text: const bool isErrorFrame
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: isErrorFrame
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (isErrorFrame) {
		_raw_id |= id_flag_error;
	} else {
		_raw_id &= ~id_flag_error;
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (isErrorFrame) {
		_raw_id |= id_flag_error;
	} else {
		_raw_id &= ~id_flag_error;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (isErrorFrame)
|—————Node:( Text: (
|—————Node:identifier Text: isErrorFrame
|—————Node:) Text: )
|————Node:compound_statement Text: {
		_raw_id |= id_flag_error;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: _raw_id |= id_flag_error;
|——————Node:assignment_expression Text: _raw_id |= id_flag_error
|———————Node:identifier Text: _raw_id
|———————Node:|= Text: |=
|———————Node:identifier Text: id_flag_error
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		_raw_id &= ~id_flag_error;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		_raw_id &= ~id_flag_error;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: _raw_id &= ~id_flag_error;
|———————Node:assignment_expression Text: _raw_id &= ~id_flag_error
|————————Node:identifier Text: _raw_id
|————————Node:&= Text: &=
|————————Node:unary_expression Text: ~id_flag_error
|—————————Node:~ Text: ~
|—————————Node:identifier Text: id_flag_error
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: CanInterfaceId CanMessage::getInterfaceId() const
{
    return _interface;
}
|——Node:type_identifier Text: CanInterfaceId
|——Node:function_declarator Text: CanMessage::getInterfaceId() const
|———Node:qualified_identifier Text: CanMessage::getInterfaceId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getInterfaceId
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    return _interface;
}
|———Node:{ Text: {
|———Node:return_statement Text: return _interface;
|————Node:return Text: return
|————Node:identifier Text: _interface
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setInterfaceId(CanInterfaceId interface)
{
    _interface = interface;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setInterfaceId(CanInterfaceId interface)
|———Node:qualified_identifier Text: CanMessage::setInterfaceId
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setInterfaceId
|———Node:parameter_list Text: (CanInterfaceId interface)
|————Node:( Text: (
|————Node:parameter_declaration Text: CanInterfaceId interface
|—————Node:type_identifier Text: CanInterfaceId
|—————Node:identifier Text: interface
|————Node:) Text: )
|——Node:compound_statement Text: {
    _interface = interface;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _interface = interface;
|————Node:assignment_expression Text: _interface = interface
|—————Node:identifier Text: _interface
|—————Node:= Text: =
|—————Node:identifier Text: interface
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t CanMessage::getLength() const {
	return _dlc;
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CanMessage::getLength() const
|———Node:qualified_identifier Text: CanMessage::getLength
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getLength
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return _dlc;
}
|———Node:{ Text: {
|———Node:return_statement Text: return _dlc;
|————Node:return Text: return
|————Node:identifier Text: _dlc
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setLength(const uint8_t dlc) {
	if (dlc<=8) {
		_dlc = dlc;
	} else {
		_dlc = 8;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setLength(const uint8_t dlc)
|———Node:qualified_identifier Text: CanMessage::setLength
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setLength
|———Node:parameter_list Text: (const uint8_t dlc)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t dlc
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: dlc
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (dlc<=8) {
		_dlc = dlc;
	} else {
		_dlc = 8;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (dlc<=8) {
		_dlc = dlc;
	} else {
		_dlc = 8;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (dlc<=8)
|—————Node:( Text: (
|—————Node:binary_expression Text: dlc<=8
|——————Node:identifier Text: dlc
|——————Node:<= Text: <=
|——————Node:number_literal Text: 8
|—————Node:) Text: )
|————Node:compound_statement Text: {
		_dlc = dlc;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: _dlc = dlc;
|——————Node:assignment_expression Text: _dlc = dlc
|———————Node:identifier Text: _dlc
|———————Node:= Text: =
|———————Node:identifier Text: dlc
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		_dlc = 8;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		_dlc = 8;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: _dlc = 8;
|———————Node:assignment_expression Text: _dlc = 8
|————————Node:identifier Text: _dlc
|————————Node:= Text: =
|————————Node:number_literal Text: 8
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: uint8_t CanMessage::getByte(const uint8_t index) const {
	if (index<sizeof(_u8)) {
		return _u8[index];
	} else {
		return 0;
	}
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CanMessage::getByte(const uint8_t index) const
|———Node:qualified_identifier Text: CanMessage::getByte
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getByte
|———Node:parameter_list Text: (const uint8_t index)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t index
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: index
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	if (index<sizeof(_u8)) {
		return _u8[index];
	} else {
		return 0;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (index<sizeof(_u8)) {
		return _u8[index];
	} else {
		return 0;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (index<sizeof(_u8))
|—————Node:( Text: (
|—————Node:binary_expression Text: index<sizeof(_u8)
|——————Node:identifier Text: index
|——————Node:< Text: <
|——————Node:sizeof_expression Text: sizeof(_u8)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (_u8)
|————————Node:( Text: (
|————————Node:identifier Text: _u8
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return _u8[index];
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return _u8[index];
|——————Node:return Text: return
|——————Node:subscript_expression Text: _u8[index]
|———————Node:identifier Text: _u8
|———————Node:subscript_argument_list Text: [index]
|————————Node:[ Text: [
|————————Node:identifier Text: index
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		return 0;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		return 0;
	}
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setByte(const uint8_t index, const uint8_t value) {
	if (index<sizeof(_u8)) {
		_u8[index] = value;
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setByte(const uint8_t index, const uint8_t value)
|———Node:qualified_identifier Text: CanMessage::setByte
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setByte
|———Node:parameter_list Text: (const uint8_t index, const uint8_t value)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t index
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: index
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t value
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (index<sizeof(_u8)) {
		_u8[index] = value;
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (index<sizeof(_u8)) {
		_u8[index] = value;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (index<sizeof(_u8))
|—————Node:( Text: (
|—————Node:binary_expression Text: index<sizeof(_u8)
|——————Node:identifier Text: index
|——————Node:< Text: <
|——————Node:sizeof_expression Text: sizeof(_u8)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (_u8)
|————————Node:( Text: (
|————————Node:identifier Text: _u8
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		_u8[index] = value;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: _u8[index] = value;
|——————Node:assignment_expression Text: _u8[index] = value
|———————Node:subscript_expression Text: _u8[index]
|————————Node:identifier Text: _u8
|————————Node:subscript_argument_list Text: [index]
|—————————Node:[ Text: [
|—————————Node:identifier Text: index
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:identifier Text: value
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: uint64_t CanMessage::getU64() const
{
    return _u64;
}
|——Node:primitive_type Text: uint64_t
|——Node:function_declarator Text: CanMessage::getU64() const
|———Node:qualified_identifier Text: CanMessage::getU64
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getU64
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    return _u64;
}
|———Node:{ Text: {
|———Node:return_statement Text: return _u64;
|————Node:return Text: return
|————Node:identifier Text: _u64
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint64_t CanMessage::extractRawSignal(uint8_t start_bit, const uint8_t length, const bool isBigEndian) const
{
    uint64_t data = le64toh(_u64);

    if (isBigEndian) {
        // it's magic. just swap the byte order and adjust the startbit, then it works like little endian
        data = __builtin_bswap64(data);
        start_bit = 63 - start_bit - length;
    }

    data >>= start_bit;

    uint64_t mask =  0xFFFFFFFFFFFFFFFF;
    mask <<= length;
    mask = ~mask;

    data &= mask;

    return data;
}
|——Node:primitive_type Text: uint64_t
|——Node:function_declarator Text: CanMessage::extractRawSignal(uint8_t start_bit, const uint8_t length, const bool isBigEndian) const
|———Node:qualified_identifier Text: CanMessage::extractRawSignal
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: extractRawSignal
|———Node:parameter_list Text: (uint8_t start_bit, const uint8_t length, const bool isBigEndian)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t start_bit
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: start_bit
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t length
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: length
|————Node:, Text: ,
|————Node:parameter_declaration Text: const bool isBigEndian
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: isBigEndian
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    uint64_t data = le64toh(_u64);

    if (isBigEndian) {
        // it's magic. just swap the byte order and adjust the startbit, then it works like little endian
        data = __builtin_bswap64(data);
        start_bit = 63 - start_bit - length;
    }

    data >>= start_bit;

    uint64_t mask =  0xFFFFFFFFFFFFFFFF;
    mask <<= length;
    mask = ~mask;

    data &= mask;

    return data;
}
|———Node:{ Text: {
|———Node:declaration Text: uint64_t data = le64toh(_u64);
|————Node:primitive_type Text: uint64_t
|————Node:init_declarator Text: data = le64toh(_u64)
|—————Node:identifier Text: data
|—————Node:= Text: =
|—————Node:call_expression Text: le64toh(_u64)
|——————Node:identifier Text: le64toh
|——————Node:argument_list Text: (_u64)
|———————Node:( Text: (
|———————Node:identifier Text: _u64
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (isBigEndian) {
        // it's magic. just swap the byte order and adjust the startbit, then it works like little endian
        data = __builtin_bswap64(data);
        start_bit = 63 - start_bit - length;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (isBigEndian)
|—————Node:( Text: (
|—————Node:identifier Text: isBigEndian
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // it's magic. just swap the byte order and adjust the startbit, then it works like little endian
        data = __builtin_bswap64(data);
        start_bit = 63 - start_bit - length;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // it's magic. just swap the byte order and adjust the startbit, then it works like little endian
|—————Node:expression_statement Text: data = __builtin_bswap64(data);
|——————Node:assignment_expression Text: data = __builtin_bswap64(data)
|———————Node:identifier Text: data
|———————Node:= Text: =
|———————Node:call_expression Text: __builtin_bswap64(data)
|————————Node:identifier Text: __builtin_bswap64
|————————Node:argument_list Text: (data)
|—————————Node:( Text: (
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: start_bit = 63 - start_bit - length;
|——————Node:assignment_expression Text: start_bit = 63 - start_bit - length
|———————Node:identifier Text: start_bit
|———————Node:= Text: =
|———————Node:binary_expression Text: 63 - start_bit - length
|————————Node:binary_expression Text: 63 - start_bit
|—————————Node:number_literal Text: 63
|—————————Node:- Text: -
|—————————Node:identifier Text: start_bit
|————————Node:- Text: -
|————————Node:identifier Text: length
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: data >>= start_bit;
|————Node:assignment_expression Text: data >>= start_bit
|—————Node:identifier Text: data
|—————Node:>>= Text: >>=
|—————Node:identifier Text: start_bit
|————Node:; Text: ;
|———Node:declaration Text: uint64_t mask =  0xFFFFFFFFFFFFFFFF;
|————Node:primitive_type Text: uint64_t
|————Node:init_declarator Text: mask =  0xFFFFFFFFFFFFFFFF
|—————Node:identifier Text: mask
|—————Node:= Text: =
|—————Node:number_literal Text: 0xFFFFFFFFFFFFFFFF
|————Node:; Text: ;
|———Node:expression_statement Text: mask <<= length;
|————Node:assignment_expression Text: mask <<= length
|—————Node:identifier Text: mask
|—————Node:<<= Text: <<=
|—————Node:identifier Text: length
|————Node:; Text: ;
|———Node:expression_statement Text: mask = ~mask;
|————Node:assignment_expression Text: mask = ~mask
|—————Node:identifier Text: mask
|—————Node:= Text: =
|—————Node:unary_expression Text: ~mask
|——————Node:~ Text: ~
|——————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:expression_statement Text: data &= mask;
|————Node:assignment_expression Text: data &= mask
|—————Node:identifier Text: data
|—————Node:&= Text: &=
|—————Node:identifier Text: mask
|————Node:; Text: ;
|———Node:return_statement Text: return data;
|————Node:return Text: return
|————Node:identifier Text: data
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0) {
	_dlc = 1;
	_u8[0] = d0;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 1;
	_u8[0] = d0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 1;
|————Node:assignment_expression Text: _dlc = 1
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1) {
	_dlc = 2;
	_u8[0] = d0;
	_u8[1] = d1;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 2;
	_u8[0] = d0;
	_u8[1] = d1;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 2;
|————Node:assignment_expression Text: _dlc = 2
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2) {
	_dlc = 3;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 3;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 3;
|————Node:assignment_expression Text: _dlc = 3
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 3
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3) {
	_dlc = 4;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d3
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d3
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 4;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 4;
|————Node:assignment_expression Text: _dlc = 4
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 4
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[3] = d3;
|————Node:assignment_expression Text: _u8[3] = d3
|—————Node:subscript_expression Text: _u8[3]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d3
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4) {
	_dlc = 5;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d3
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d3
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d4
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d4
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 5;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 5;
|————Node:assignment_expression Text: _dlc = 5
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 5
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[3] = d3;
|————Node:assignment_expression Text: _u8[3] = d3
|—————Node:subscript_expression Text: _u8[3]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d3
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[4] = d4;
|————Node:assignment_expression Text: _u8[4] = d4
|—————Node:subscript_expression Text: _u8[4]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [4]
|———————Node:[ Text: [
|———————Node:number_literal Text: 4
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d4
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5) {
	_dlc = 6;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d3
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d3
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d4
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d4
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d5
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d5
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 6;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 6;
|————Node:assignment_expression Text: _dlc = 6
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 6
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[3] = d3;
|————Node:assignment_expression Text: _u8[3] = d3
|—————Node:subscript_expression Text: _u8[3]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d3
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[4] = d4;
|————Node:assignment_expression Text: _u8[4] = d4
|—————Node:subscript_expression Text: _u8[4]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [4]
|———————Node:[ Text: [
|———————Node:number_literal Text: 4
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d4
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[5] = d5;
|————Node:assignment_expression Text: _u8[5] = d5
|—————Node:subscript_expression Text: _u8[5]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [5]
|———————Node:[ Text: [
|———————Node:number_literal Text: 5
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d5
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5,
		const uint8_t d6) {
	_dlc = 7;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
	_u8[6] = d6;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5,
		const uint8_t d6)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5,
		const uint8_t d6)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d3
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d3
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d4
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d4
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d5
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d5
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d6
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d6
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 7;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
	_u8[6] = d6;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 7;
|————Node:assignment_expression Text: _dlc = 7
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 7
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[3] = d3;
|————Node:assignment_expression Text: _u8[3] = d3
|—————Node:subscript_expression Text: _u8[3]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d3
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[4] = d4;
|————Node:assignment_expression Text: _u8[4] = d4
|—————Node:subscript_expression Text: _u8[4]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [4]
|———————Node:[ Text: [
|———————Node:number_literal Text: 4
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d4
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[5] = d5;
|————Node:assignment_expression Text: _u8[5] = d5
|—————Node:subscript_expression Text: _u8[5]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [5]
|———————Node:[ Text: [
|———————Node:number_literal Text: 5
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d5
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[6] = d6;
|————Node:assignment_expression Text: _u8[6] = d6
|—————Node:subscript_expression Text: _u8[6]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [6]
|———————Node:[ Text: [
|———————Node:number_literal Text: 6
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d6
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5, const uint8_t d6,
		const uint8_t d7) {
	_dlc = 8;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
	_u8[6] = d6;
    _u8[7] = d7;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setData(const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5, const uint8_t d6,
		const uint8_t d7)
|———Node:qualified_identifier Text: CanMessage::setData
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setData
|———Node:parameter_list Text: (const uint8_t d0, const uint8_t d1, const uint8_t d2,
		const uint8_t d3, const uint8_t d4, const uint8_t d5, const uint8_t d6,
		const uint8_t d7)
|————Node:( Text: (
|————Node:parameter_declaration Text: const uint8_t d0
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d0
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d1
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d1
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d2
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d2
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d3
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d3
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d4
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d4
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d5
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d5
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d6
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d6
|————Node:, Text: ,
|————Node:parameter_declaration Text: const uint8_t d7
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: d7
|————Node:) Text: )
|——Node:compound_statement Text: {
	_dlc = 8;
	_u8[0] = d0;
	_u8[1] = d1;
	_u8[2] = d2;
	_u8[3] = d3;
	_u8[4] = d4;
	_u8[5] = d5;
	_u8[6] = d6;
    _u8[7] = d7;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _dlc = 8;
|————Node:assignment_expression Text: _dlc = 8
|—————Node:identifier Text: _dlc
|—————Node:= Text: =
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[0] = d0;
|————Node:assignment_expression Text: _u8[0] = d0
|—————Node:subscript_expression Text: _u8[0]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d0
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[1] = d1;
|————Node:assignment_expression Text: _u8[1] = d1
|—————Node:subscript_expression Text: _u8[1]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [1]
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d1
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[2] = d2;
|————Node:assignment_expression Text: _u8[2] = d2
|—————Node:subscript_expression Text: _u8[2]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [2]
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d2
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[3] = d3;
|————Node:assignment_expression Text: _u8[3] = d3
|—————Node:subscript_expression Text: _u8[3]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [3]
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d3
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[4] = d4;
|————Node:assignment_expression Text: _u8[4] = d4
|—————Node:subscript_expression Text: _u8[4]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [4]
|———————Node:[ Text: [
|———————Node:number_literal Text: 4
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d4
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[5] = d5;
|————Node:assignment_expression Text: _u8[5] = d5
|—————Node:subscript_expression Text: _u8[5]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [5]
|———————Node:[ Text: [
|———————Node:number_literal Text: 5
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d5
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[6] = d6;
|————Node:assignment_expression Text: _u8[6] = d6
|—————Node:subscript_expression Text: _u8[6]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [6]
|———————Node:[ Text: [
|———————Node:number_literal Text: 6
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d6
|————Node:; Text: ;
|———Node:expression_statement Text: _u8[7] = d7;
|————Node:assignment_expression Text: _u8[7] = d7
|—————Node:subscript_expression Text: _u8[7]
|——————Node:identifier Text: _u8
|——————Node:subscript_argument_list Text: [7]
|———————Node:[ Text: [
|———————Node:number_literal Text: 7
|———————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: d7
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: timeval CanMessage::getTimestamp() const
{
    return _timestamp;
}
|——Node:type_identifier Text: timeval
|——Node:function_declarator Text: CanMessage::getTimestamp() const
|———Node:qualified_identifier Text: CanMessage::getTimestamp
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getTimestamp
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    return _timestamp;
}
|———Node:{ Text: {
|———Node:return_statement Text: return _timestamp;
|————Node:return Text: return
|————Node:identifier Text: _timestamp
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CanMessage::setTimestamp(const timeval timestamp)
{
    _timestamp = timestamp;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CanMessage::setTimestamp(const timeval timestamp)
|———Node:qualified_identifier Text: CanMessage::setTimestamp
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: setTimestamp
|———Node:parameter_list Text: (const timeval timestamp)
|————Node:( Text: (
|————Node:parameter_declaration Text: const timeval timestamp
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: timeval
|—————Node:identifier Text: timestamp
|————Node:) Text: )
|——Node:compound_statement Text: {
    _timestamp = timestamp;
}
|———Node:{ Text: {
|———Node:expression_statement Text: _timestamp = timestamp;
|————Node:assignment_expression Text: _timestamp = timestamp
|—————Node:identifier Text: _timestamp
|—————Node:= Text: =
|—————Node:identifier Text: timestamp
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: double CanMessage::getFloatTimestamp() const
{
    return (double)_timestamp.tv_sec + ((double)_timestamp.tv_usec/1000000);
}
|——Node:primitive_type Text: double
|——Node:function_declarator Text: CanMessage::getFloatTimestamp() const
|———Node:qualified_identifier Text: CanMessage::getFloatTimestamp
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getFloatTimestamp
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    return (double)_timestamp.tv_sec + ((double)_timestamp.tv_usec/1000000);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (double)_timestamp.tv_sec + ((double)_timestamp.tv_usec/1000000);
|————Node:return Text: return
|————Node:binary_expression Text: (double)_timestamp.tv_sec + ((double)_timestamp.tv_usec/1000000)
|—————Node:cast_expression Text: (double)_timestamp.tv_sec
|——————Node:( Text: (
|——————Node:type_descriptor Text: double
|———————Node:primitive_type Text: double
|——————Node:) Text: )
|——————Node:field_expression Text: _timestamp.tv_sec
|———————Node:identifier Text: _timestamp
|———————Node:. Text: .
|———————Node:field_identifier Text: tv_sec
|—————Node:+ Text: +
|—————Node:parenthesized_expression Text: ((double)_timestamp.tv_usec/1000000)
|——————Node:( Text: (
|——————Node:binary_expression Text: (double)_timestamp.tv_usec/1000000
|———————Node:cast_expression Text: (double)_timestamp.tv_usec
|————————Node:( Text: (
|————————Node:type_descriptor Text: double
|—————————Node:primitive_type Text: double
|————————Node:) Text: )
|————————Node:field_expression Text: _timestamp.tv_usec
|—————————Node:identifier Text: _timestamp
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tv_usec
|———————Node:/ Text: /
|———————Node:number_literal Text: 1000000
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: QString CanMessage::getIdString() const
{
    if (isExtended()) {
        return QString().sprintf("0x%08X", getId());
    } else {
        return QString().sprintf("0x%03X", getId());
    }
}
|——Node:type_identifier Text: QString
|——Node:function_declarator Text: CanMessage::getIdString() const
|———Node:qualified_identifier Text: CanMessage::getIdString
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getIdString
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    if (isExtended()) {
        return QString().sprintf("0x%08X", getId());
    } else {
        return QString().sprintf("0x%03X", getId());
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (isExtended()) {
        return QString().sprintf("0x%08X", getId());
    } else {
        return QString().sprintf("0x%03X", getId());
    }
|————Node:if Text: if
|————Node:condition_clause Text: (isExtended())
|—————Node:( Text: (
|—————Node:call_expression Text: isExtended()
|——————Node:identifier Text: isExtended
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return QString().sprintf("0x%08X", getId());
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return QString().sprintf("0x%08X", getId());
|——————Node:return Text: return
|——————Node:call_expression Text: QString().sprintf("0x%08X", getId())
|———————Node:field_expression Text: QString().sprintf
|————————Node:call_expression Text: QString()
|—————————Node:identifier Text: QString
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:. Text: .
|————————Node:field_identifier Text: sprintf
|———————Node:argument_list Text: ("0x%08X", getId())
|————————Node:( Text: (
|————————Node:string_literal Text: "0x%08X"
|—————————Node:" Text: "
|—————————Node:string_content Text: 0x%08X
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:call_expression Text: getId()
|—————————Node:identifier Text: getId
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        return QString().sprintf("0x%03X", getId());
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        return QString().sprintf("0x%03X", getId());
    }
|——————Node:{ Text: {
|——————Node:return_statement Text: return QString().sprintf("0x%03X", getId());
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("0x%03X", getId())
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("0x%03X", getId())
|—————————Node:( Text: (
|—————————Node:string_literal Text: "0x%03X"
|——————————Node:" Text: "
|——————————Node:string_content Text: 0x%03X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getId()
|——————————Node:identifier Text: getId
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: QString CanMessage::getDataHexString() const
{
    switch (getLength()) {
        case 0: return "";
        case 1: return QString().sprintf("%02X", getByte(0));
        case 2: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
        case 3: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
        case 4: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
        case 5: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
        case 6: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
        case 7: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
        case 8: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
        default: return QString();
    }

}
|——Node:type_identifier Text: QString
|——Node:function_declarator Text: CanMessage::getDataHexString() const
|———Node:qualified_identifier Text: CanMessage::getDataHexString
|————Node:namespace_identifier Text: CanMessage
|————Node::: Text: ::
|————Node:identifier Text: getDataHexString
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
    switch (getLength()) {
        case 0: return "";
        case 1: return QString().sprintf("%02X", getByte(0));
        case 2: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
        case 3: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
        case 4: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
        case 5: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
        case 6: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
        case 7: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
        case 8: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
        default: return QString();
    }

}
|———Node:{ Text: {
|———Node:switch_statement Text: switch (getLength()) {
        case 0: return "";
        case 1: return QString().sprintf("%02X", getByte(0));
        case 2: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
        case 3: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
        case 4: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
        case 5: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
        case 6: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
        case 7: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
        case 8: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
        default: return QString();
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (getLength())
|—————Node:( Text: (
|—————Node:call_expression Text: getLength()
|——————Node:identifier Text: getLength
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case 0: return "";
        case 1: return QString().sprintf("%02X", getByte(0));
        case 2: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
        case 3: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
        case 4: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
        case 5: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
        case 6: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
        case 7: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
        case 8: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
        default: return QString();
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case 0: return "";
|——————Node:case Text: case
|——————Node:number_literal Text: 0
|——————Node:: Text: :
|——————Node:return_statement Text: return "";
|———————Node:return Text: return
|———————Node:string_literal Text: ""
|————————Node:" Text: "
|————————Node:" Text: "
|———————Node:; Text: ;
|—————Node:case_statement Text: case 1: return QString().sprintf("%02X", getByte(0));
|——————Node:case Text: case
|——————Node:number_literal Text: 1
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X", getByte(0));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X", getByte(0))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X", getByte(0))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 2: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
|——————Node:case Text: case
|——————Node:number_literal Text: 2
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X", getByte(0), getByte(1));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X", getByte(0), getByte(1))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X", getByte(0), getByte(1))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 3: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
|——————Node:case Text: case
|——————Node:number_literal Text: 3
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X", getByte(0), getByte(1), getByte(2))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X", getByte(0), getByte(1), getByte(2))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 4: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
|——————Node:case Text: case
|——————Node:number_literal Text: 4
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(3)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (3)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 3
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 5: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
|——————Node:case Text: case
|——————Node:number_literal Text: 5
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(3)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (3)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 3
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(4)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (4)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 4
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 6: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
|——————Node:case Text: case
|——————Node:number_literal Text: 6
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(3)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (3)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 3
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(4)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (4)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 4
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(5)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (5)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 5
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 7: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
|——————Node:case Text: case
|——————Node:number_literal Text: 7
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(3)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (3)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 3
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(4)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (4)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 4
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(5)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (5)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 5
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(6)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (6)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 6
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: case 8: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
|——————Node:case Text: case
|——————Node:number_literal Text: 8
|——————Node:: Text: :
|——————Node:return_statement Text: return QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7));
|———————Node:return Text: return
|———————Node:call_expression Text: QString().sprintf("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7))
|————————Node:field_expression Text: QString().sprintf
|—————————Node:call_expression Text: QString()
|——————————Node:identifier Text: QString
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:. Text: .
|—————————Node:field_identifier Text: sprintf
|————————Node:argument_list Text: ("%02X %02X %02X %02X %02X %02X %02X %02X", getByte(0), getByte(1), getByte(2), getByte(3), getByte(4), getByte(5), getByte(6), getByte(7))
|—————————Node:( Text: (
|—————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X"
|——————————Node:" Text: "
|——————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(0)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (0)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 0
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(1)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(2)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (2)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 2
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(3)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (3)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 3
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(4)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (4)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 4
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(5)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (5)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 5
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(6)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (6)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 6
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: getByte(7)
|——————————Node:identifier Text: getByte
|——————————Node:argument_list Text: (7)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 7
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:case_statement Text: default: return QString();
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:return_statement Text: return QString();
|———————Node:return Text: return
|———————Node:call_expression Text: QString()
|————————Node:identifier Text: QString
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
