busmaster-Sources\CAN_Vector_XL\CAN_Vector_XL.cpp

|Node:translation_unit
|—Node:comment Text: /*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
|—Node:comment Text: /**
 * \file      CAN_Vector_XL.cpp
 * \brief     Source file for Vector XL DIL functions
 * \author    Tobias Lorenz, Arunkumar Karri
 * \copyright Copyright (c) 2011, ETAS GmbH. All rights reserved.
 *
 * Source file for Vector XL DIL functions
 */
|—Node:comment Text: // CAN_Vector_XL.cpp : Defines the initialization routines for the DLL.
|—Node:comment Text: //
|—Node:comment Text: /* C++ includes */
|—Node:preproc_include Text: #include "CAN_Vector_XL_stdafx.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "CAN_Vector_XL_stdafx.h"
|———Node:" Text: "
|———Node:string_content Text: CAN_Vector_XL_stdafx.h
|———Node:" Text: "
|—Node:comment Text: /* C++ includes */
|—Node:preproc_include Text: #include <sstream>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <sstream>
|—Node:preproc_include Text: #include <string>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <string>
|—Node:preproc_include Text: #include <vector>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <vector>
|—Node:comment Text: /* Project includes */
|—Node:preproc_include Text: #include "CAN_Vector_XL.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "CAN_Vector_XL.h"
|———Node:" Text: "
|———Node:string_content Text: CAN_Vector_XL.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "include/Error.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "include/Error.h"
|———Node:" Text: "
|———Node:string_content Text: include/Error.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "include/basedefs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "include/basedefs.h"
|———Node:" Text: "
|———Node:string_content Text: include/basedefs.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "DataTypes/Base_WrapperErrorLogger.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "DataTypes/Base_WrapperErrorLogger.h"
|———Node:" Text: "
|———Node:string_content Text: DataTypes/Base_WrapperErrorLogger.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "DataTypes/MsgBufAll_DataTypes.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "DataTypes/MsgBufAll_DataTypes.h"
|———Node:" Text: "
|———Node:string_content Text: DataTypes/MsgBufAll_DataTypes.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "DataTypes/DIL_Datatypes.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "DataTypes/DIL_Datatypes.h"
|———Node:" Text: "
|———Node:string_content Text: DataTypes/DIL_Datatypes.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "Include/CAN_Error_Defs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "Include/CAN_Error_Defs.h"
|———Node:" Text: "
|———Node:string_content Text: Include/CAN_Error_Defs.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "Include/CanUsbDefs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "Include/CanUsbDefs.h"
|———Node:" Text: "
|———Node:string_content Text: Include/CanUsbDefs.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "Include/Struct_CAN.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "Include/Struct_CAN.h"
|———Node:" Text: "
|———Node:string_content Text: Include/Struct_CAN.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "Utility/Utility_Thread.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "Utility/Utility_Thread.h"
|———Node:" Text: "
|———Node:string_content Text: Utility/Utility_Thread.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "Include/DIL_CommonDefs.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "Include/DIL_CommonDefs.h"
|———Node:" Text: "
|———Node:string_content Text: Include/DIL_CommonDefs.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "DIL_Interface/BaseDIL_CAN_Controller.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "DIL_Interface/BaseDIL_CAN_Controller.h"
|———Node:" Text: "
|———Node:string_content Text: DIL_Interface/BaseDIL_CAN_Controller.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "HardwareListing.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "HardwareListing.h"
|———Node:" Text: "
|———Node:string_content Text: HardwareListing.h
|———Node:" Text: "
|—Node:preproc_def Text: #define DYNAMIC_XLDRIVER_DLL

|——Node:#define Text: #define
|——Node:identifier Text: DYNAMIC_XLDRIVER_DLL
|—Node:preproc_include Text: #include "EXTERNAL_INCLUDE/vxlapi.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "EXTERNAL_INCLUDE/vxlapi.h"
|———Node:" Text: "
|———Node:string_content Text: EXTERNAL_INCLUDE/vxlapi.h
|———Node:" Text: "
|—Node:preproc_def Text: #define USAGE_EXPORT

|——Node:#define Text: #define
|——Node:identifier Text: USAGE_EXPORT
|—Node:preproc_include Text: #include "CAN_Vector_XL_Extern.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "CAN_Vector_XL_Extern.h"
|———Node:" Text: "
|———Node:string_content Text: CAN_Vector_XL_Extern.h
|———Node:" Text: "
|—Node:using_declaration Text: using namespace std;
|——Node:using Text: using
|——Node:namespace Text: namespace
|——Node:identifier Text: std
|——Node:; Text: ;
|—Node:comment Text: // CCAN_Vector_XL
|—Node:expression_statement Text: BEGIN_MESSAGE_MAP(CCAN_Vector_XL, CWinApp)
|——Node:call_expression Text: BEGIN_MESSAGE_MAP(CCAN_Vector_XL, CWinApp)
|———Node:identifier Text: BEGIN_MESSAGE_MAP
|———Node:argument_list Text: (CCAN_Vector_XL, CWinApp)
|————Node:( Text: (
|————Node:identifier Text: CCAN_Vector_XL
|————Node:, Text: ,
|————Node:identifier Text: CWinApp
|————Node:) Text: )
|——Node:; Text: 
|—Node:expression_statement Text: END_MESSAGE_MAP()


/**
 * CCAN_Vector_XL construction
 */
|——Node:call_expression Text: END_MESSAGE_MAP()
|———Node:identifier Text: END_MESSAGE_MAP
|———Node:argument_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:comment Text: /**
 * CCAN_Vector_XL construction
 */
|——Node:; Text: 
|—Node:function_definition Text: CCAN_Vector_XL::CCAN_Vector_XL()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}
|——Node:function_declarator Text: CCAN_Vector_XL::CCAN_Vector_XL()
|———Node:qualified_identifier Text: CCAN_Vector_XL::CCAN_Vector_XL
|————Node:namespace_identifier Text: CCAN_Vector_XL
|————Node::: Text: ::
|————Node:identifier Text: CCAN_Vector_XL
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}
|———Node:{ Text: {
|———Node:comment Text: // TODO: add construction code here,
|———Node:comment Text: // Place all significant initialization in InitInstance
|———Node:} Text: }
|—Node:comment Text: // The one and only CCAN_Vector_XL object
|—Node:declaration Text: CCAN_Vector_XL theApp;
|——Node:type_identifier Text: CCAN_Vector_XL
|——Node:identifier Text: theApp
|——Node:; Text: ;
|—Node:comment Text: /**
 * CCAN_Vector_XL initialization
 */
|—Node:function_definition Text: BOOL CCAN_Vector_XL::InitInstance()
{
    CWinApp::InitInstance();

    return TRUE;
}
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: CCAN_Vector_XL::InitInstance()
|———Node:qualified_identifier Text: CCAN_Vector_XL::InitInstance
|————Node:namespace_identifier Text: CCAN_Vector_XL
|————Node::: Text: ::
|————Node:identifier Text: InitInstance
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    CWinApp::InitInstance();

    return TRUE;
}
|———Node:{ Text: {
|———Node:expression_statement Text: CWinApp::InitInstance();
|————Node:call_expression Text: CWinApp::InitInstance()
|—————Node:qualified_identifier Text: CWinApp::InitInstance
|——————Node:namespace_identifier Text: CWinApp
|——————Node::: Text: ::
|——————Node:identifier Text: InitInstance
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return TRUE;
|————Node:return Text: return
|————Node:true Text: TRUE
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* function pointers */
|—Node:declaration Text: XLGETAPPLCONFIG                xlGetApplConfig = NULL;
|——Node:type_identifier Text: XLGETAPPLCONFIG
|——Node:init_declarator Text: xlGetApplConfig = NULL
|———Node:identifier Text: xlGetApplConfig
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETAPPLCONFIG                xlSetApplConfig = NULL;
|——Node:type_identifier Text: XLSETAPPLCONFIG
|——Node:init_declarator Text: xlSetApplConfig = NULL
|———Node:identifier Text: xlSetApplConfig
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETDRIVERCONFIG              xlGetDriverConfig = NULL;
|——Node:type_identifier Text: XLGETDRIVERCONFIG
|——Node:init_declarator Text: xlGetDriverConfig = NULL
|———Node:identifier Text: xlGetDriverConfig
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETCHANNELINDEX              xlGetChannelIndex = NULL;
|——Node:type_identifier Text: XLGETCHANNELINDEX
|——Node:init_declarator Text: xlGetChannelIndex = NULL
|———Node:identifier Text: xlGetChannelIndex
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETCHANNELMASK               xlGetChannelMask = NULL;
|——Node:type_identifier Text: XLGETCHANNELMASK
|——Node:init_declarator Text: xlGetChannelMask = NULL
|———Node:identifier Text: xlGetChannelMask
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLOPENPORT                     xlOpenPort = NULL;
|——Node:type_identifier Text: XLOPENPORT
|——Node:init_declarator Text: xlOpenPort = NULL
|———Node:identifier Text: xlOpenPort
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETTIMERRATE                 xlSetTimerRate = NULL;
|——Node:type_identifier Text: XLSETTIMERRATE
|——Node:init_declarator Text: xlSetTimerRate = NULL
|———Node:identifier Text: xlSetTimerRate
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLRESETCLOCK                   xlResetClock = NULL;
|——Node:type_identifier Text: XLRESETCLOCK
|——Node:init_declarator Text: xlResetClock = NULL
|———Node:identifier Text: xlResetClock
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETNOTIFICATION              xlSetNotification = NULL;
|——Node:type_identifier Text: XLSETNOTIFICATION
|——Node:init_declarator Text: xlSetNotification = NULL
|———Node:identifier Text: xlSetNotification
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLFLUSHRECEIVEQUEUE            xlFlushReceiveQueue = NULL;
|——Node:type_identifier Text: XLFLUSHRECEIVEQUEUE
|——Node:init_declarator Text: xlFlushReceiveQueue = NULL
|———Node:identifier Text: xlFlushReceiveQueue
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETRECEIVEQUEUELEVEL         xlGetReceiveQueueLevel = NULL;
|——Node:type_identifier Text: XLGETRECEIVEQUEUELEVEL
|——Node:init_declarator Text: xlGetReceiveQueueLevel = NULL
|———Node:identifier Text: xlGetReceiveQueueLevel
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLACTIVATECHANNEL              xlActivateChannel = NULL;
|——Node:type_identifier Text: XLACTIVATECHANNEL
|——Node:init_declarator Text: xlActivateChannel = NULL
|———Node:identifier Text: xlActivateChannel
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLRECEIVE                      xlReceive = NULL;
|——Node:type_identifier Text: XLRECEIVE
|——Node:init_declarator Text: xlReceive = NULL
|———Node:identifier Text: xlReceive
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETEVENTSTRING               xlGetEventString = NULL;
|——Node:type_identifier Text: XLGETEVENTSTRING
|——Node:init_declarator Text: xlGetEventString = NULL
|———Node:identifier Text: xlGetEventString
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETERRORSTRING               xlGetErrorString = NULL;
|——Node:type_identifier Text: XLGETERRORSTRING
|——Node:init_declarator Text: xlGetErrorString = NULL
|———Node:identifier Text: xlGetErrorString
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETSYNCTIME                  xlGetSyncTime = NULL;
|——Node:type_identifier Text: XLGETSYNCTIME
|——Node:init_declarator Text: xlGetSyncTime = NULL
|———Node:identifier Text: xlGetSyncTime
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGENERATESYNCPULSE            xlGenerateSyncPulse = NULL;
|——Node:type_identifier Text: XLGENERATESYNCPULSE
|——Node:init_declarator Text: xlGenerateSyncPulse = NULL
|———Node:identifier Text: xlGenerateSyncPulse
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLPOPUPHWCONFIG                xlPopupHwConfig = NULL;
|——Node:type_identifier Text: XLPOPUPHWCONFIG
|——Node:init_declarator Text: xlPopupHwConfig = NULL
|———Node:identifier Text: xlPopupHwConfig
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLDEACTIVATECHANNEL            xlDeactivateChannel = NULL;
|——Node:type_identifier Text: XLDEACTIVATECHANNEL
|——Node:init_declarator Text: xlDeactivateChannel = NULL
|———Node:identifier Text: xlDeactivateChannel
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCLOSEPORT                    xlClosePort = NULL;
|——Node:type_identifier Text: XLCLOSEPORT
|——Node:init_declarator Text: xlClosePort = NULL
|———Node:identifier Text: xlClosePort
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETTIMERBASEDNOTIFY          xlSetTimerBasedNotify = NULL;
|——Node:type_identifier Text: XLSETTIMERBASEDNOTIFY
|——Node:init_declarator Text: xlSetTimerBasedNotify = NULL
|———Node:identifier Text: xlSetTimerBasedNotify
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETTIMERRATEANDCHANNEL       xlSetTimerRateAndChannel = NULL;
|——Node:type_identifier Text: XLSETTIMERRATEANDCHANNEL
|——Node:init_declarator Text: xlSetTimerRateAndChannel = NULL
|———Node:identifier Text: xlSetTimerRateAndChannel
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLGETLICENSEINFO               xlGetLicenseInfo = NULL;
|——Node:type_identifier Text: XLGETLICENSEINFO
|——Node:init_declarator Text: xlGetLicenseInfo = NULL
|———Node:identifier Text: xlGetLicenseInfo
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLSETGLOBALTIMESYNC            xlSetGlobalTimeSync = NULL;
|——Node:type_identifier Text: XLSETGLOBALTIMESYNC
|——Node:init_declarator Text: xlSetGlobalTimeSync = NULL
|———Node:identifier Text: xlSetGlobalTimeSync
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:comment Text: /* CAN specific functions */
|—Node:declaration Text: XLCANSETCHANNELOUTPUT          xlCanSetChannelOutput = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELOUTPUT
|——Node:init_declarator Text: xlCanSetChannelOutput = NULL
|———Node:identifier Text: xlCanSetChannelOutput
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELMODE            xlCanSetChannelMode = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELMODE
|——Node:init_declarator Text: xlCanSetChannelMode = NULL
|———Node:identifier Text: xlCanSetChannelMode
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETRECEIVEMODE            xlCanSetReceiveMode = NULL;
|——Node:type_identifier Text: XLCANSETRECEIVEMODE
|——Node:init_declarator Text: xlCanSetReceiveMode = NULL
|———Node:identifier Text: xlCanSetReceiveMode
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELTRANSCEIVER     xlCanSetChannelTransceiver = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELTRANSCEIVER
|——Node:init_declarator Text: xlCanSetChannelTransceiver = NULL
|———Node:identifier Text: xlCanSetChannelTransceiver
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELPARAMS          xlCanSetChannelParams = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELPARAMS
|——Node:init_declarator Text: xlCanSetChannelParams = NULL
|———Node:identifier Text: xlCanSetChannelParams
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELPARAMSC200      xlCanSetChannelParamsC200 = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELPARAMSC200
|——Node:init_declarator Text: xlCanSetChannelParamsC200 = NULL
|———Node:identifier Text: xlCanSetChannelParamsC200
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELBITRATE         xlCanSetChannelBitrate = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELBITRATE
|——Node:init_declarator Text: xlCanSetChannelBitrate = NULL
|———Node:identifier Text: xlCanSetChannelBitrate
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANSETCHANNELACCEPTANCE      xlCanSetChannelAcceptance = NULL;
|——Node:type_identifier Text: XLCANSETCHANNELACCEPTANCE
|——Node:init_declarator Text: xlCanSetChannelAcceptance = NULL
|———Node:identifier Text: xlCanSetChannelAcceptance
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANADDACCEPTANCERANGE        xlCanAddAcceptanceRange = NULL;
|——Node:type_identifier Text: XLCANADDACCEPTANCERANGE
|——Node:init_declarator Text: xlCanAddAcceptanceRange = NULL
|———Node:identifier Text: xlCanAddAcceptanceRange
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANREMOVEACCEPTANCERANGE     xlCanRemoveAcceptanceRange = NULL;
|——Node:type_identifier Text: XLCANREMOVEACCEPTANCERANGE
|——Node:init_declarator Text: xlCanRemoveAcceptanceRange = NULL
|———Node:identifier Text: xlCanRemoveAcceptanceRange
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANRESETACCEPTANCE           xlCanResetAcceptance = NULL;
|——Node:type_identifier Text: XLCANRESETACCEPTANCE
|——Node:init_declarator Text: xlCanResetAcceptance = NULL
|———Node:identifier Text: xlCanResetAcceptance
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANREQUESTCHIPSTATE          xlCanRequestChipState = NULL;
|——Node:type_identifier Text: XLCANREQUESTCHIPSTATE
|——Node:init_declarator Text: xlCanRequestChipState = NULL
|———Node:identifier Text: xlCanRequestChipState
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANFLUSHTRANSMITQUEUE        xlCanFlushTransmitQueue = NULL;
|——Node:type_identifier Text: XLCANFLUSHTRANSMITQUEUE
|——Node:init_declarator Text: xlCanFlushTransmitQueue = NULL
|———Node:identifier Text: xlCanFlushTransmitQueue
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: XLCANTRANSMIT                  xlCanTransmit = NULL;
|——Node:type_identifier Text: XLCANTRANSMIT
|——Node:init_declarator Text: xlCanTransmit = NULL
|———Node:identifier Text: xlCanTransmit
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: static  CRITICAL_SECTION sg_CritSectForWrite;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: CRITICAL_SECTION
|——Node:identifier Text: sg_CritSectForWrite
|——Node:; Text: ;
|—Node:comment Text: // To make it thread safe
|—Node:enum_specifier Text: enum
{
    CREATE_MAP_TIMESTAMP = 0x1,
    CALC_TIMESTAMP_READY = 0x2,
}
|——Node:enum Text: enum
|——Node:enumerator_list Text: {
    CREATE_MAP_TIMESTAMP = 0x1,
    CALC_TIMESTAMP_READY = 0x2,
}
|———Node:{ Text: {
|———Node:enumerator Text: CREATE_MAP_TIMESTAMP = 0x1
|————Node:identifier Text: CREATE_MAP_TIMESTAMP
|————Node:= Text: =
|————Node:number_literal Text: 0x1
|———Node:, Text: ,
|———Node:enumerator Text: CALC_TIMESTAMP_READY = 0x2
|————Node:identifier Text: CALC_TIMESTAMP_READY
|————Node:= Text: =
|————Node:number_literal Text: 0x2
|———Node:, Text: ,
|———Node:} Text: }
|—Node:; Text: ;
|—Node:comment Text: /**
 * Current state machine
 */
|—Node:declaration Text: static BYTE sg_byCurrState = CREATE_MAP_TIMESTAMP;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BYTE
|——Node:init_declarator Text: sg_byCurrState = CREATE_MAP_TIMESTAMP
|———Node:identifier Text: sg_byCurrState
|———Node:= Text: =
|———Node:identifier Text: CREATE_MAP_TIMESTAMP
|——Node:; Text: ;
|—Node:preproc_def Text: #define MAX_BUFF_ALLOWED 16

|——Node:#define Text: #define
|——Node:identifier Text: MAX_BUFF_ALLOWED
|——Node:preproc_arg Text: 16
|—Node:preproc_def Text: #define RECEIVE_EVENT_SIZE 1                // DO NOT EDIT! Currently 1 is supported only

|——Node:#define Text: #define
|——Node:identifier Text: RECEIVE_EVENT_SIZE
|——Node:preproc_arg Text: 1                // DO NOT EDIT! Currently 1 is supported only
|—Node:preproc_def Text: #define RX_QUEUE_SIZE      4096             // internal driver queue size in CAN events

|——Node:#define Text: #define
|——Node:identifier Text: RX_QUEUE_SIZE
|——Node:preproc_arg Text: 4096             // internal driver queue size in CAN events
|—Node:comment Text: /**
 * Client and Client Buffer map
 */
|—Node:type_definition Text: typedef struct tagClientBufMap
{
    DWORD dwClientID;
    BYTE hClientHandle;
    CBaseCANBufFSE* pClientBuf[MAX_BUFF_ALLOWED];
    char pacClientName[MAX_PATH];
    UINT unBufCount;
    tagClientBufMap()
    {
        dwClientID = 0;
        hClientHandle = NULL;
        unBufCount = 0;
        memset(pacClientName, 0, sizeof (char) * MAX_PATH);
        for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }

    }
} SCLIENTBUFMAP;
|——Node:typedef Text: typedef
|——Node:struct_specifier Text: struct tagClientBufMap
{
    DWORD dwClientID;
    BYTE hClientHandle;
    CBaseCANBufFSE* pClientBuf[MAX_BUFF_ALLOWED];
    char pacClientName[MAX_PATH];
    UINT unBufCount;
    tagClientBufMap()
    {
        dwClientID = 0;
        hClientHandle = NULL;
        unBufCount = 0;
        memset(pacClientName, 0, sizeof (char) * MAX_PATH);
        for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }

    }
}
|———Node:struct Text: struct
|———Node:type_identifier Text: tagClientBufMap
|———Node:field_declaration_list Text: {
    DWORD dwClientID;
    BYTE hClientHandle;
    CBaseCANBufFSE* pClientBuf[MAX_BUFF_ALLOWED];
    char pacClientName[MAX_PATH];
    UINT unBufCount;
    tagClientBufMap()
    {
        dwClientID = 0;
        hClientHandle = NULL;
        unBufCount = 0;
        memset(pacClientName, 0, sizeof (char) * MAX_PATH);
        for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }

    }
}
|————Node:{ Text: {
|————Node:field_declaration Text: DWORD dwClientID;
|—————Node:type_identifier Text: DWORD
|—————Node:field_identifier Text: dwClientID
|—————Node:; Text: ;
|————Node:field_declaration Text: BYTE hClientHandle;
|—————Node:type_identifier Text: BYTE
|—————Node:field_identifier Text: hClientHandle
|—————Node:; Text: ;
|————Node:field_declaration Text: CBaseCANBufFSE* pClientBuf[MAX_BUFF_ALLOWED];
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * pClientBuf[MAX_BUFF_ALLOWED]
|——————Node:* Text: *
|——————Node:array_declarator Text: pClientBuf[MAX_BUFF_ALLOWED]
|———————Node:field_identifier Text: pClientBuf
|———————Node:[ Text: [
|———————Node:identifier Text: MAX_BUFF_ALLOWED
|———————Node:] Text: ]
|—————Node:; Text: ;
|————Node:field_declaration Text: char pacClientName[MAX_PATH];
|—————Node:primitive_type Text: char
|—————Node:array_declarator Text: pacClientName[MAX_PATH]
|——————Node:field_identifier Text: pacClientName
|——————Node:[ Text: [
|——————Node:identifier Text: MAX_PATH
|——————Node:] Text: ]
|—————Node:; Text: ;
|————Node:field_declaration Text: UINT unBufCount;
|—————Node:type_identifier Text: UINT
|—————Node:field_identifier Text: unBufCount
|—————Node:; Text: ;
|————Node:function_definition Text: tagClientBufMap()
    {
        dwClientID = 0;
        hClientHandle = NULL;
        unBufCount = 0;
        memset(pacClientName, 0, sizeof (char) * MAX_PATH);
        for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }

    }
|—————Node:function_declarator Text: tagClientBufMap()
|——————Node:identifier Text: tagClientBufMap
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:compound_statement Text: {
        dwClientID = 0;
        hClientHandle = NULL;
        unBufCount = 0;
        memset(pacClientName, 0, sizeof (char) * MAX_PATH);
        for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }

    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: dwClientID = 0;
|———————Node:assignment_expression Text: dwClientID = 0
|————————Node:identifier Text: dwClientID
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: hClientHandle = NULL;
|———————Node:assignment_expression Text: hClientHandle = NULL
|————————Node:identifier Text: hClientHandle
|————————Node:= Text: =
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:; Text: ;
|——————Node:expression_statement Text: unBufCount = 0;
|———————Node:assignment_expression Text: unBufCount = 0
|————————Node:identifier Text: unBufCount
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: memset(pacClientName, 0, sizeof (char) * MAX_PATH);
|———————Node:call_expression Text: memset(pacClientName, 0, sizeof (char) * MAX_PATH)
|————————Node:identifier Text: memset
|————————Node:argument_list Text: (pacClientName, 0, sizeof (char) * MAX_PATH)
|—————————Node:( Text: (
|—————————Node:identifier Text: pacClientName
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: sizeof (char) * MAX_PATH
|——————————Node:sizeof_expression Text: sizeof (char)
|———————————Node:sizeof Text: sizeof
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: char
|————————————Node:primitive_type Text: char
|———————————Node:) Text: )
|——————————Node:* Text: *
|——————————Node:identifier Text: MAX_PATH
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:for_statement Text: for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            pClientBuf[i] = NULL;
        }
|———————Node:for Text: for
|———————Node:( Text: (
|———————Node:declaration Text: int i = 0;
|————————Node:primitive_type Text: int
|————————Node:init_declarator Text: i = 0
|—————————Node:identifier Text: i
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:binary_expression Text: i < MAX_BUFF_ALLOWED
|————————Node:identifier Text: i
|————————Node:< Text: <
|————————Node:identifier Text: MAX_BUFF_ALLOWED
|———————Node:; Text: ;
|———————Node:update_expression Text: i++
|————————Node:identifier Text: i
|————————Node:++ Text: ++
|———————Node:) Text: )
|———————Node:compound_statement Text: {
            pClientBuf[i] = NULL;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: pClientBuf[i] = NULL;
|—————————Node:assignment_expression Text: pClientBuf[i] = NULL
|——————————Node:subscript_expression Text: pClientBuf[i]
|———————————Node:identifier Text: pClientBuf
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|——————————Node:= Text: =
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:} Text: }
|——Node:type_identifier Text: SCLIENTBUFMAP
|——Node:; Text: ;
|—Node:comment Text: /* Local variables */
|—Node:declaration Text: static XLCLOSEDRIVER           xlDllCloseDriver = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: XLCLOSEDRIVER
|——Node:init_declarator Text: xlDllCloseDriver = NULL
|———Node:identifier Text: xlDllCloseDriver
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: static XLOPENDRIVER            xlDllOpenDriver = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: XLOPENDRIVER
|——Node:init_declarator Text: xlDllOpenDriver = NULL
|———Node:identifier Text: xlDllOpenDriver
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:comment Text: /* Forward declarations*/
|—Node:declaration Text: static int nInitHwNetwork();
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nInitHwNetwork()
|———Node:identifier Text: nInitHwNetwork
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bRemoveClient(DWORD dwClientId);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bRemoveClient(DWORD dwClientId)
|———Node:identifier Text: bRemoveClient
|———Node:parameter_list Text: (DWORD dwClientId)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD dwClientId
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientId
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static DWORD dwGetAvailableClientSlot();
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: DWORD
|——Node:function_declarator Text: dwGetAvailableClientSlot()
|———Node:identifier Text: dwGetAvailableClientSlot
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bClientExist(string pcClientName, INT& Index);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bClientExist(string pcClientName, INT& Index)
|———Node:identifier Text: bClientExist
|———Node:parameter_list Text: (string pcClientName, INT& Index)
|————Node:( Text: (
|————Node:parameter_declaration Text: string pcClientName
|—————Node:type_identifier Text: string
|—————Node:identifier Text: pcClientName
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT& Index
|—————Node:type_identifier Text: INT
|—————Node:reference_declarator Text: & Index
|——————Node:& Text: &
|——————Node:identifier Text: Index
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bClientIdExist(const DWORD& dwClientId);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bClientIdExist(const DWORD& dwClientId)
|———Node:identifier Text: bClientIdExist
|———Node:parameter_list Text: (const DWORD& dwClientId)
|————Node:( Text: (
|————Node:parameter_declaration Text: const DWORD& dwClientId
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: DWORD
|—————Node:reference_declarator Text: & dwClientId
|——————Node:& Text: &
|——————Node:identifier Text: dwClientId
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bGetClientObj(DWORD dwClientID, UINT& unClientIndex);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
|———Node:identifier Text: bGetClientObj
|———Node:parameter_list Text: (DWORD dwClientID, UINT& unClientIndex)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD dwClientID
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientID
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT& unClientIndex
|—————Node:type_identifier Text: UINT
|—————Node:reference_declarator Text: & unClientIndex
|——————Node:& Text: &
|——————Node:identifier Text: unClientIndex
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static void vRetrieveAndLog(DWORD /*dwErrorCode*/, char* File, int Line);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: vRetrieveAndLog(DWORD /*dwErrorCode*/, char* File, int Line)
|———Node:identifier Text: vRetrieveAndLog
|———Node:parameter_list Text: (DWORD /*dwErrorCode*/, char* File, int Line)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD
|—————Node:type_identifier Text: DWORD
|————Node:comment Text: /*dwErrorCode*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: char* File
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: * File
|——————Node:* Text: *
|——————Node:identifier Text: File
|————Node:, Text: ,
|————Node:parameter_declaration Text: int Line
|—————Node:primitive_type Text: int
|—————Node:identifier Text: Line
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|———Node:identifier Text: bIsBufferExists
|———Node:parameter_list Text: (const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|————Node:( Text: (
|————Node:parameter_declaration Text: const SCLIENTBUFMAP& sClientObj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: SCLIENTBUFMAP
|—————Node:reference_declarator Text: & sClientObj
|——————Node:& Text: &
|——————Node:identifier Text: sClientObj
|————Node:, Text: ,
|————Node:parameter_declaration Text: const CBaseCANBufFSE* pBuf
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * pBuf
|——————Node:* Text: *
|——————Node:identifier Text: pBuf
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static int nConnect(BOOL bConnect);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nConnect(BOOL bConnect)
|———Node:identifier Text: nConnect
|———Node:parameter_list Text: (BOOL bConnect)
|————Node:( Text: (
|————Node:parameter_declaration Text: BOOL bConnect
|—————Node:type_identifier Text: BOOL
|—————Node:identifier Text: bConnect
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static int nGetNoOfConnectedHardware(void);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nGetNoOfConnectedHardware(void)
|———Node:identifier Text: nGetNoOfConnectedHardware
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static BOOL bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED],
                                UINT& unCount, CBaseCANBufFSE* BufferToRemove);
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED],
                                UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|———Node:identifier Text: bRemoveClientBuffer
|———Node:parameter_list Text: (CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED],
                                UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|————Node:( Text: (
|————Node:parameter_declaration Text: CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED]
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * RootBufferArray[MAX_BUFF_ALLOWED]
|——————Node:* Text: *
|——————Node:array_declarator Text: RootBufferArray[MAX_BUFF_ALLOWED]
|———————Node:identifier Text: RootBufferArray
|———————Node:[ Text: [
|———————Node:identifier Text: MAX_BUFF_ALLOWED
|———————Node:] Text: ]
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT& unCount
|—————Node:type_identifier Text: UINT
|—————Node:reference_declarator Text: & unCount
|——————Node:& Text: &
|——————Node:identifier Text: unCount
|————Node:, Text: ,
|————Node:parameter_declaration Text: CBaseCANBufFSE* BufferToRemove
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * BufferToRemove
|——————Node:* Text: *
|——————Node:identifier Text: BufferToRemove
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: static int nDisconnectFromDriver();
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nDisconnectFromDriver()
|———Node:identifier Text: nDisconnectFromDriver
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:; Text: ;
|—Node:comment Text: // state variables
|—Node:declaration Text: static BOOL sg_bIsConnected = FALSE;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:init_declarator Text: sg_bIsConnected = FALSE
|———Node:identifier Text: sg_bIsConnected
|———Node:= Text: =
|———Node:false Text: FALSE
|——Node:; Text: ;
|—Node:declaration Text: static UCHAR sg_ucControllerMode = defUSB_MODE_ACTIVE;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UCHAR
|——Node:init_declarator Text: sg_ucControllerMode = defUSB_MODE_ACTIVE
|———Node:identifier Text: sg_ucControllerMode
|———Node:= Text: =
|———Node:identifier Text: defUSB_MODE_ACTIVE
|——Node:; Text: ;
|—Node:declaration Text: static CPARAM_THREADPROC sg_sParmRThread;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: CPARAM_THREADPROC
|——Node:identifier Text: sg_sParmRThread
|——Node:; Text: ;
|—Node:declaration Text: static int sg_nFRAMES = 128;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:init_declarator Text: sg_nFRAMES = 128
|———Node:identifier Text: sg_nFRAMES
|———Node:= Text: =
|———Node:number_literal Text: 128
|——Node:; Text: ;
|—Node:declaration Text: const int ENTRIES_IN_GBUF       = 2000;
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: int
|——Node:init_declarator Text: ENTRIES_IN_GBUF       = 2000
|———Node:identifier Text: ENTRIES_IN_GBUF
|———Node:= Text: =
|———Node:number_literal Text: 2000
|——Node:; Text: ;
|—Node:declaration Text: static STCANDATA sg_asCANMsg;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: STCANDATA
|——Node:identifier Text: sg_asCANMsg
|——Node:; Text: ;
|—Node:declaration Text: static SCONTROLLER_DETAILS sg_ControllerDetails[defNO_OF_CHANNELS];
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: SCONTROLLER_DETAILS
|——Node:array_declarator Text: sg_ControllerDetails[defNO_OF_CHANNELS]
|———Node:identifier Text: sg_ControllerDetails
|———Node:[ Text: [
|———Node:identifier Text: defNO_OF_CHANNELS
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:declaration Text: static INTERFACE_HW sg_HardwareIntr[defNO_OF_CHANNELS];
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: INTERFACE_HW
|——Node:array_declarator Text: sg_HardwareIntr[defNO_OF_CHANNELS]
|———Node:identifier Text: sg_HardwareIntr
|———Node:[ Text: [
|———Node:identifier Text: defNO_OF_CHANNELS
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:comment Text: // TZM specific Global variables
|—Node:preproc_def Text: #define CAN_MAX_ERRSTR 256

|——Node:#define Text: #define
|——Node:identifier Text: CAN_MAX_ERRSTR
|——Node:preproc_arg Text: 256
|—Node:declaration Text: string sg_acErrStr = "";
|——Node:type_identifier Text: string
|——Node:init_declarator Text: sg_acErrStr = ""
|———Node:identifier Text: sg_acErrStr
|———Node:= Text: =
|———Node:string_literal Text: ""
|————Node:" Text: "
|————Node:" Text: "
|——Node:; Text: ;
|—Node:declaration Text: static UINT sg_unClientCnt = 0;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UINT
|——Node:init_declarator Text: sg_unClientCnt = 0
|———Node:identifier Text: sg_unClientCnt
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:preproc_def Text: #define MAX_CLIENT_ALLOWED 16

|——Node:#define Text: #define
|——Node:identifier Text: MAX_CLIENT_ALLOWED
|——Node:preproc_arg Text: 16
|—Node:declaration Text: static SCLIENTBUFMAP sg_asClientToBufMap[MAX_CLIENT_ALLOWED];
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: SCLIENTBUFMAP
|——Node:array_declarator Text: sg_asClientToBufMap[MAX_CLIENT_ALLOWED]
|———Node:identifier Text: sg_asClientToBufMap
|———Node:[ Text: [
|———Node:identifier Text: MAX_CLIENT_ALLOWED
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:declaration Text: static UINT sg_unDevChannelMap[defNO_OF_CHANNELS] = {(UINT)-1};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UINT
|——Node:init_declarator Text: sg_unDevChannelMap[defNO_OF_CHANNELS] = {(UINT)-1}
|———Node:array_declarator Text: sg_unDevChannelMap[defNO_OF_CHANNELS]
|————Node:identifier Text: sg_unDevChannelMap
|————Node:[ Text: [
|————Node:identifier Text: defNO_OF_CHANNELS
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {(UINT)-1}
|————Node:{ Text: {
|————Node:binary_expression Text: (UINT)-1
|—————Node:parenthesized_expression Text: (UINT)
|——————Node:( Text: (
|——————Node:identifier Text: UINT
|——————Node:) Text: )
|—————Node:- Text: -
|—————Node:number_literal Text: 1
|————Node:} Text: }
|——Node:; Text: ;
|—Node:declaration Text: static HINSTANCE               hxlDll;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: HINSTANCE
|——Node:identifier Text: hxlDll
|——Node:; Text: ;
|—Node:declaration Text: static HWND sg_hOwnerWnd = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: HWND
|——Node:init_declarator Text: sg_hOwnerWnd = NULL
|———Node:identifier Text: sg_hOwnerWnd
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: static Base_WrapperErrorLogger* sg_pIlog   = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: Base_WrapperErrorLogger
|——Node:init_declarator Text: * sg_pIlog   = NULL
|———Node:pointer_declarator Text: * sg_pIlog
|————Node:* Text: *
|————Node:identifier Text: sg_pIlog
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:comment Text: /////////////////////////////////////////////////////////////////////////////
|—Node:comment Text: // globals
|—Node:declaration Text: char            g_AppName[XL_MAX_LENGTH+1]  = "BUSMASTER";
|——Node:primitive_type Text: char
|——Node:init_declarator Text: g_AppName[XL_MAX_LENGTH+1]  = "BUSMASTER"
|———Node:array_declarator Text: g_AppName[XL_MAX_LENGTH+1]
|————Node:identifier Text: g_AppName
|————Node:[ Text: [
|————Node:binary_expression Text: XL_MAX_LENGTH+1
|—————Node:identifier Text: XL_MAX_LENGTH
|—————Node:+ Text: +
|—————Node:number_literal Text: 1
|————Node:] Text: ]
|———Node:= Text: =
|———Node:string_literal Text: "BUSMASTER"
|————Node:" Text: "
|————Node:string_content Text: BUSMASTER
|————Node:" Text: "
|——Node:; Text: ;
|—Node:comment Text: //!< Application name which is displayed in VHWconf
|—Node:declaration Text: XLportHandle    g_xlPortHandle[MAX_CLIENT_ALLOWED]
    = {XL_INVALID_PORTHANDLE};
|——Node:type_identifier Text: XLportHandle
|——Node:init_declarator Text: g_xlPortHandle[MAX_CLIENT_ALLOWED]
    = {XL_INVALID_PORTHANDLE}
|———Node:array_declarator Text: g_xlPortHandle[MAX_CLIENT_ALLOWED]
|————Node:identifier Text: g_xlPortHandle
|————Node:[ Text: [
|————Node:identifier Text: MAX_CLIENT_ALLOWED
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {XL_INVALID_PORTHANDLE}
|————Node:{ Text: {
|————Node:identifier Text: XL_INVALID_PORTHANDLE
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: //!< Global porthandles
|—Node:declaration Text: XLdriverConfig  g_xlDrvConfig;
|——Node:type_identifier Text: XLdriverConfig
|——Node:identifier Text: g_xlDrvConfig
|——Node:; Text: ;
|—Node:comment Text: //!< Contains the actual hardware configuration
|—Node:declaration Text: XLaccess        g_xlChannelMask             = 0;
|——Node:type_identifier Text: XLaccess
|——Node:init_declarator Text: g_xlChannelMask             = 0
|———Node:identifier Text: g_xlChannelMask
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: //!< Global channelmask (includes all founded channels)
|—Node:declaration Text: XLaccess        g_xlPermissionMask          = 0;
|——Node:type_identifier Text: XLaccess
|——Node:init_declarator Text: g_xlPermissionMask          = 0
|———Node:identifier Text: g_xlPermissionMask
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: //!< Global permissionmask (includes all founded channels)
|—Node:declaration Text: unsigned int    g_BaudRate                  = 500000;
|——Node:sized_type_specifier Text: unsigned int
|———Node:unsigned Text: unsigned
|———Node:primitive_type Text: int
|——Node:init_declarator Text: g_BaudRate                  = 500000
|———Node:identifier Text: g_BaudRate
|———Node:= Text: =
|———Node:number_literal Text: 500000
|——Node:; Text: ;
|—Node:comment Text: //!< Default baudrate 500KBauds
|—Node:declaration Text: int             g_silent                    = 0;
|——Node:primitive_type Text: int
|——Node:init_declarator Text: g_silent                    = 0
|———Node:identifier Text: g_silent
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: //!< flag to visualize the message events (on/off)
|—Node:declaration Text: unsigned int    g_TimerRate                 = 0;
|——Node:sized_type_specifier Text: unsigned int
|———Node:unsigned Text: unsigned
|———Node:primitive_type Text: int
|——Node:init_declarator Text: g_TimerRate                 = 0
|———Node:identifier Text: g_TimerRate
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: //!< Global timerrate (to toggel)
|—Node:declaration Text: XLhandle        g_hDataEvent[MAX_CLIENT_ALLOWED]  = {0};
|——Node:type_identifier Text: XLhandle
|——Node:init_declarator Text: g_hDataEvent[MAX_CLIENT_ALLOWED]  = {0}
|———Node:array_declarator Text: g_hDataEvent[MAX_CLIENT_ALLOWED]
|————Node:identifier Text: g_hDataEvent
|————Node:[ Text: [
|————Node:identifier Text: MAX_CLIENT_ALLOWED
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {0}
|————Node:{ Text: {
|————Node:number_literal Text: 0
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: ////////////////////////////////////////////////////////////////////////////
|—Node:comment Text: /* CDIL_CAN_VectorXL class definition */
|—Node:class_specifier Text: class CDIL_CAN_VectorXL : public CBaseDIL_CAN_Controller
{
public:
    /* STARTS IMPLEMENTATION OF THE INTERFACE FUNCTIONS... */
    HRESULT CAN_PerformInitOperations(void);
    HRESULT CAN_PerformClosureOperations(void);
    HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
    HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
    HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
    HRESULT CAN_DeselectHwInterface(void);
    HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
    HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
    HRESULT CAN_StartHardware(void);
    HRESULT CAN_StopHardware(void);
    HRESULT CAN_ResetHardware(void);
    HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
    HRESULT CAN_GetTxMsgBuffer(BYTE*& pouFlxTxMsgBuffer);
    HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
    HRESULT CAN_GetBusConfigInfo(BYTE* BusInfo);
    HRESULT CAN_GetLastErrorString(string& acErrorStr);
    HRESULT CAN_FilterFrames(FILTER_TYPE FilterType, TYPE_CHANNEL Channel, UINT* punMsgIds, UINT nLength);
    HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
    //MVN
    HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
    //~MVN
    HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);

    // Specific function set
    HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
    HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
    HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
    HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
    HRESULT CAN_LoadDriverLibrary(void);
    HRESULT CAN_UnloadDriverLibrary(void);
}
|——Node:class Text: class
|——Node:type_identifier Text: CDIL_CAN_VectorXL
|——Node:base_class_clause Text: : public CBaseDIL_CAN_Controller
|———Node:: Text: :
|———Node:access_specifier Text: public
|————Node:public Text: public
|———Node:type_identifier Text: CBaseDIL_CAN_Controller
|——Node:field_declaration_list Text: {
public:
    /* STARTS IMPLEMENTATION OF THE INTERFACE FUNCTIONS... */
    HRESULT CAN_PerformInitOperations(void);
    HRESULT CAN_PerformClosureOperations(void);
    HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
    HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
    HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
    HRESULT CAN_DeselectHwInterface(void);
    HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
    HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
    HRESULT CAN_StartHardware(void);
    HRESULT CAN_StopHardware(void);
    HRESULT CAN_ResetHardware(void);
    HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
    HRESULT CAN_GetTxMsgBuffer(BYTE*& pouFlxTxMsgBuffer);
    HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
    HRESULT CAN_GetBusConfigInfo(BYTE* BusInfo);
    HRESULT CAN_GetLastErrorString(string& acErrorStr);
    HRESULT CAN_FilterFrames(FILTER_TYPE FilterType, TYPE_CHANNEL Channel, UINT* punMsgIds, UINT nLength);
    HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
    //MVN
    HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
    //~MVN
    HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);

    // Specific function set
    HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
    HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
    HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
    HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
    HRESULT CAN_LoadDriverLibrary(void);
    HRESULT CAN_UnloadDriverLibrary(void);
}
|———Node:{ Text: {
|———Node:access_specifier Text: public
|————Node:public Text: public
|———Node:: Text: :
|———Node:comment Text: /* STARTS IMPLEMENTATION OF THE INTERFACE FUNCTIONS... */
|———Node:field_declaration Text: HRESULT CAN_PerformInitOperations(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_PerformInitOperations(void)
|—————Node:field_identifier Text: CAN_PerformInitOperations
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_PerformClosureOperations(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_PerformClosureOperations(void)
|—————Node:field_identifier Text: CAN_PerformClosureOperations
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL)
|—————Node:field_identifier Text: CAN_GetTimeModeMapping
|—————Node:parameter_list Text: (SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: SYSTEMTIME& CurrSysTime
|———————Node:type_identifier Text: SYSTEMTIME
|———————Node:reference_declarator Text: & CurrSysTime
|————————Node:& Text: &
|————————Node:identifier Text: CurrSysTime
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT64& TimeStamp
|———————Node:type_identifier Text: UINT64
|———————Node:reference_declarator Text: & TimeStamp
|————————Node:& Text: &
|————————Node:identifier Text: TimeStamp
|——————Node:, Text: ,
|——————Node:optional_parameter_declaration Text: LARGE_INTEGER* QueryTickCount = NULL
|———————Node:type_identifier Text: LARGE_INTEGER
|———————Node:pointer_declarator Text: * QueryTickCount
|————————Node:* Text: *
|————————Node:identifier Text: QueryTickCount
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount)
|—————Node:field_identifier Text: CAN_ListHwInterfaces
|—————Node:parameter_list Text: (INTERFACE_HW_LIST& sSelHwInterface, INT& nCount)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: INTERFACE_HW_LIST& sSelHwInterface
|———————Node:type_identifier Text: INTERFACE_HW_LIST
|———————Node:reference_declarator Text: & sSelHwInterface
|————————Node:& Text: &
|————————Node:identifier Text: sSelHwInterface
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: INT& nCount
|———————Node:type_identifier Text: INT
|———————Node:reference_declarator Text: & nCount
|————————Node:& Text: &
|————————Node:identifier Text: nCount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount)
|—————Node:field_identifier Text: CAN_SelectHwInterface
|—————Node:parameter_list Text: (const INTERFACE_HW_LIST& sSelHwInterface, INT nCount)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: const INTERFACE_HW_LIST& sSelHwInterface
|———————Node:type_qualifier Text: const
|————————Node:const Text: const
|———————Node:type_identifier Text: INTERFACE_HW_LIST
|———————Node:reference_declarator Text: & sSelHwInterface
|————————Node:& Text: &
|————————Node:identifier Text: sSelHwInterface
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: INT nCount
|———————Node:type_identifier Text: INT
|———————Node:identifier Text: nCount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_DeselectHwInterface(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_DeselectHwInterface(void)
|—————Node:field_identifier Text: CAN_DeselectHwInterface
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
|—————Node:field_identifier Text: CAN_DisplayConfigDlg
|—————Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int& Length)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|———————Node:type_identifier Text: PSCONTROLLER_DETAILS
|———————Node:identifier Text: InitData
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: int& Length
|———————Node:primitive_type Text: int
|———————Node:reference_declarator Text: & Length
|————————Node:& Text: &
|————————Node:identifier Text: Length
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length)
|—————Node:field_identifier Text: CAN_SetConfigData
|—————Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int Length)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|———————Node:type_identifier Text: PSCONTROLLER_DETAILS
|———————Node:identifier Text: InitData
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: int Length
|———————Node:primitive_type Text: int
|———————Node:identifier Text: Length
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_StartHardware(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_StartHardware(void)
|—————Node:field_identifier Text: CAN_StartHardware
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_StopHardware(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_StopHardware(void)
|—————Node:field_identifier Text: CAN_StopHardware
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_ResetHardware(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_ResetHardware(void)
|—————Node:field_identifier Text: CAN_ResetHardware
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetCurrStatus(s_STATUSMSG& StatusData)
|—————Node:field_identifier Text: CAN_GetCurrStatus
|—————Node:parameter_list Text: (s_STATUSMSG& StatusData)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: s_STATUSMSG& StatusData
|———————Node:type_identifier Text: s_STATUSMSG
|———————Node:reference_declarator Text: & StatusData
|————————Node:& Text: &
|————————Node:identifier Text: StatusData
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetTxMsgBuffer(BYTE*& pouFlxTxMsgBuffer);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetTxMsgBuffer(BYTE*& pouFlxTxMsgBuffer)
|—————Node:field_identifier Text: CAN_GetTxMsgBuffer
|—————Node:parameter_list Text: (BYTE*& pouFlxTxMsgBuffer)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: BYTE*& pouFlxTxMsgBuffer
|———————Node:type_identifier Text: BYTE
|———————Node:pointer_declarator Text: *& pouFlxTxMsgBuffer
|————————Node:* Text: *
|————————Node:reference_declarator Text: & pouFlxTxMsgBuffer
|—————————Node:& Text: &
|—————————Node:identifier Text: pouFlxTxMsgBuffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|—————Node:field_identifier Text: CAN_SendMsg
|—————Node:parameter_list Text: (DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: DWORD dwClientID
|———————Node:type_identifier Text: DWORD
|———————Node:identifier Text: dwClientID
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: const STCAN_MSG& sCanTxMsg
|———————Node:type_qualifier Text: const
|————————Node:const Text: const
|———————Node:type_identifier Text: STCAN_MSG
|———————Node:reference_declarator Text: & sCanTxMsg
|————————Node:& Text: &
|————————Node:identifier Text: sCanTxMsg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetBusConfigInfo(BYTE* BusInfo);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetBusConfigInfo(BYTE* BusInfo)
|—————Node:field_identifier Text: CAN_GetBusConfigInfo
|—————Node:parameter_list Text: (BYTE* BusInfo)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: BYTE* BusInfo
|———————Node:type_identifier Text: BYTE
|———————Node:pointer_declarator Text: * BusInfo
|————————Node:* Text: *
|————————Node:identifier Text: BusInfo
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetLastErrorString(string& acErrorStr);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetLastErrorString(string& acErrorStr)
|—————Node:field_identifier Text: CAN_GetLastErrorString
|—————Node:parameter_list Text: (string& acErrorStr)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: string& acErrorStr
|———————Node:type_identifier Text: string
|———————Node:reference_declarator Text: & acErrorStr
|————————Node:& Text: &
|————————Node:identifier Text: acErrorStr
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_FilterFrames(FILTER_TYPE FilterType, TYPE_CHANNEL Channel, UINT* punMsgIds, UINT nLength);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_FilterFrames(FILTER_TYPE FilterType, TYPE_CHANNEL Channel, UINT* punMsgIds, UINT nLength)
|—————Node:field_identifier Text: CAN_FilterFrames
|—————Node:parameter_list Text: (FILTER_TYPE FilterType, TYPE_CHANNEL Channel, UINT* punMsgIds, UINT nLength)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: FILTER_TYPE FilterType
|———————Node:type_identifier Text: FILTER_TYPE
|———————Node:identifier Text: FilterType
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: TYPE_CHANNEL Channel
|———————Node:type_identifier Text: TYPE_CHANNEL
|———————Node:identifier Text: Channel
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT* punMsgIds
|———————Node:type_identifier Text: UINT
|———————Node:pointer_declarator Text: * punMsgIds
|————————Node:* Text: *
|————————Node:identifier Text: punMsgIds
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT nLength
|———————Node:type_identifier Text: UINT
|———————Node:identifier Text: nLength
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|—————Node:field_identifier Text: CAN_GetControllerParams
|—————Node:parameter_list Text: (LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: LONG& lParam
|———————Node:type_identifier Text: LONG
|———————Node:reference_declarator Text: & lParam
|————————Node:& Text: &
|————————Node:identifier Text: lParam
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT nChannel
|———————Node:type_identifier Text: UINT
|———————Node:identifier Text: nChannel
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|———————Node:type_identifier Text: ECONTR_PARAM
|———————Node:identifier Text: eContrParam
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //MVN
|———Node:field_declaration Text: HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
|—————Node:field_identifier Text: CAN_SetControllerParams
|—————Node:parameter_list Text: (int nValue, ECONTR_PARAM eContrparam)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: int nValue
|———————Node:primitive_type Text: int
|———————Node:identifier Text: nValue
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: ECONTR_PARAM eContrparam
|———————Node:type_identifier Text: ECONTR_PARAM
|———————Node:identifier Text: eContrparam
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //~MVN
|———Node:field_declaration Text: HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|—————Node:field_identifier Text: CAN_GetErrorCount
|—————Node:parameter_list Text: (SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: SERROR_CNT& sErrorCnt
|———————Node:type_identifier Text: SERROR_CNT
|———————Node:reference_declarator Text: & sErrorCnt
|————————Node:& Text: &
|————————Node:identifier Text: sErrorCnt
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT nChannel
|———————Node:type_identifier Text: UINT
|———————Node:identifier Text: nChannel
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|———————Node:type_identifier Text: ECONTR_PARAM
|———————Node:identifier Text: eContrParam
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Specific function set
|———Node:field_declaration Text: HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|—————Node:field_identifier Text: CAN_SetAppParams
|—————Node:parameter_list Text: (HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: HWND hWndOwner
|———————Node:type_identifier Text: HWND
|———————Node:identifier Text: hWndOwner
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: Base_WrapperErrorLogger* pILog
|———————Node:type_identifier Text: Base_WrapperErrorLogger
|———————Node:pointer_declarator Text: * pILog
|————————Node:* Text: *
|————————Node:identifier Text: pILog
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|—————Node:field_identifier Text: CAN_ManageMsgBuf
|—————Node:parameter_list Text: (BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: BYTE bAction
|———————Node:type_identifier Text: BYTE
|———————Node:identifier Text: bAction
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: DWORD ClientID
|———————Node:type_identifier Text: DWORD
|———————Node:identifier Text: ClientID
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: CBaseCANBufFSE* pBufObj
|———————Node:type_identifier Text: CBaseCANBufFSE
|———————Node:pointer_declarator Text: * pBufObj
|————————Node:* Text: *
|————————Node:identifier Text: pBufObj
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
|—————Node:field_identifier Text: CAN_RegisterClient
|—————Node:parameter_list Text: (BOOL bRegister, DWORD& ClientID, char* pacClientName)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: BOOL bRegister
|———————Node:type_identifier Text: BOOL
|———————Node:identifier Text: bRegister
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: DWORD& ClientID
|———————Node:type_identifier Text: DWORD
|———————Node:reference_declarator Text: & ClientID
|————————Node:& Text: &
|————————Node:identifier Text: ClientID
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: char* pacClientName
|———————Node:primitive_type Text: char
|———————Node:pointer_declarator Text: * pacClientName
|————————Node:* Text: *
|————————Node:identifier Text: pacClientName
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus)
|—————Node:field_identifier Text: CAN_GetCntrlStatus
|—————Node:parameter_list Text: (const HANDLE& hEvent, UINT& unCntrlStatus)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: const HANDLE& hEvent
|———————Node:type_qualifier Text: const
|————————Node:const Text: const
|———————Node:type_identifier Text: HANDLE
|———————Node:reference_declarator Text: & hEvent
|————————Node:& Text: &
|————————Node:identifier Text: hEvent
|——————Node:, Text: ,
|——————Node:parameter_declaration Text: UINT& unCntrlStatus
|———————Node:type_identifier Text: UINT
|———————Node:reference_declarator Text: & unCntrlStatus
|————————Node:& Text: &
|————————Node:identifier Text: unCntrlStatus
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_LoadDriverLibrary(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_LoadDriverLibrary(void)
|—————Node:field_identifier Text: CAN_LoadDriverLibrary
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:field_declaration Text: HRESULT CAN_UnloadDriverLibrary(void);
|————Node:type_identifier Text: HRESULT
|————Node:function_declarator Text: CAN_UnloadDriverLibrary(void)
|—————Node:field_identifier Text: CAN_UnloadDriverLibrary
|—————Node:parameter_list Text: (void)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:; Text: ;
|—Node:declaration Text: CDIL_CAN_VectorXL* g_pouDIL_CAN_VectorXL = NULL;
|——Node:type_identifier Text: CDIL_CAN_VectorXL
|——Node:init_declarator Text: * g_pouDIL_CAN_VectorXL = NULL
|———Node:pointer_declarator Text: * g_pouDIL_CAN_VectorXL
|————Node:* Text: *
|————Node:identifier Text: g_pouDIL_CAN_VectorXL
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:comment Text: /**
* \brief         Returns the CDIL_CAN_VectorXL object
* \param[out]    ppvInterface, is void pointer to take back the reference to CDIL_CAN_VectorXL object
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: USAGEMODE HRESULT GetIDIL_CAN_Controller(void** ppvInterface)
{
    HRESULT hResult = S_OK;
    if ( NULL == g_pouDIL_CAN_VectorXL )
    {
        if ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    *ppvInterface = (void*) g_pouDIL_CAN_VectorXL;  /* Doesn't matter even if g_pouDIL_CAN_VectorXL is null */

    return hResult;
}
|——Node:type_identifier Text: USAGEMODE
|——Node:ERROR Text: HRESULT
|———Node:identifier Text: HRESULT
|——Node:function_declarator Text: GetIDIL_CAN_Controller(void** ppvInterface)
|———Node:identifier Text: GetIDIL_CAN_Controller
|———Node:parameter_list Text: (void** ppvInterface)
|————Node:( Text: (
|————Node:parameter_declaration Text: void** ppvInterface
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: ** ppvInterface
|——————Node:* Text: *
|——————Node:pointer_declarator Text: * ppvInterface
|———————Node:* Text: *
|———————Node:identifier Text: ppvInterface
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ( NULL == g_pouDIL_CAN_VectorXL )
    {
        if ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    *ppvInterface = (void*) g_pouDIL_CAN_VectorXL;  /* Doesn't matter even if g_pouDIL_CAN_VectorXL is null */

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:if_statement Text: if ( NULL == g_pouDIL_CAN_VectorXL )
    {
        if ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( NULL == g_pouDIL_CAN_VectorXL )
|—————Node:( Text: (
|—————Node:binary_expression Text: NULL == g_pouDIL_CAN_VectorXL
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:== Text: ==
|——————Node:identifier Text: g_pouDIL_CAN_VectorXL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
        {
            hResult = S_FALSE;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ((g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: (g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL) == NULL
|————————Node:parenthesized_expression Text: (g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL)
|—————————Node:( Text: (
|—————————Node:assignment_expression Text: g_pouDIL_CAN_VectorXL = new CDIL_CAN_VectorXL
|——————————Node:identifier Text: g_pouDIL_CAN_VectorXL
|——————————Node:= Text: =
|——————————Node:new_expression Text: new CDIL_CAN_VectorXL
|———————————Node:new Text: new
|———————————Node:type_identifier Text: CDIL_CAN_VectorXL
|—————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: hResult = S_FALSE;
|————————Node:assignment_expression Text: hResult = S_FALSE
|—————————Node:identifier Text: hResult
|—————————Node:= Text: =
|—————————Node:identifier Text: S_FALSE
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: *ppvInterface = (void*) g_pouDIL_CAN_VectorXL;
|————Node:assignment_expression Text: *ppvInterface = (void*) g_pouDIL_CAN_VectorXL
|—————Node:pointer_expression Text: *ppvInterface
|——————Node:* Text: *
|——————Node:identifier Text: ppvInterface
|—————Node:= Text: =
|—————Node:cast_expression Text: (void*) g_pouDIL_CAN_VectorXL
|——————Node:( Text: (
|——————Node:type_descriptor Text: void*
|———————Node:primitive_type Text: void
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: g_pouDIL_CAN_VectorXL
|————Node:; Text: ;
|———Node:comment Text: /* Doesn't matter even if g_pouDIL_CAN_VectorXL is null */
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * Number of Channels
 */
|—Node:declaration Text: static UINT sg_nNoOfChannels = 0;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UINT
|——Node:init_declarator Text: sg_nNoOfChannels = 0
|———Node:identifier Text: sg_nNoOfChannels
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:declaration Text: static char sg_omErrStr[MAX_STRING] = {0};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: char
|——Node:init_declarator Text: sg_omErrStr[MAX_STRING] = {0}
|———Node:array_declarator Text: sg_omErrStr[MAX_STRING]
|————Node:identifier Text: sg_omErrStr
|————Node:[ Text: [
|————Node:identifier Text: MAX_STRING
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {0}
|————Node:{ Text: {
|————Node:number_literal Text: 0
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: // Count variables
|—Node:declaration Text: static UCHAR sg_ucNoOfHardware = 0;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UCHAR
|——Node:init_declarator Text: sg_ucNoOfHardware = 0
|———Node:identifier Text: sg_ucNoOfHardware
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: /**
 * Starts code for the state machine
 */
|—Node:enum_specifier Text: enum
{
    STATE_DRIVER_SELECTED    = 0x0,
    STATE_HW_INTERFACE_LISTED,
    STATE_HW_INTERFACE_SELECTED,
    STATE_CONNECTED
}
|——Node:enum Text: enum
|——Node:enumerator_list Text: {
    STATE_DRIVER_SELECTED    = 0x0,
    STATE_HW_INTERFACE_LISTED,
    STATE_HW_INTERFACE_SELECTED,
    STATE_CONNECTED
}
|———Node:{ Text: {
|———Node:enumerator Text: STATE_DRIVER_SELECTED    = 0x0
|————Node:identifier Text: STATE_DRIVER_SELECTED
|————Node:= Text: =
|————Node:number_literal Text: 0x0
|———Node:, Text: ,
|———Node:enumerator Text: STATE_HW_INTERFACE_LISTED
|————Node:identifier Text: STATE_HW_INTERFACE_LISTED
|———Node:, Text: ,
|———Node:enumerator Text: STATE_HW_INTERFACE_SELECTED
|————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|———Node:, Text: ,
|———Node:enumerator Text: STATE_CONNECTED
|————Node:identifier Text: STATE_CONNECTED
|———Node:} Text: }
|—Node:; Text: ;
|—Node:declaration Text: BYTE sg_bCurrState = STATE_DRIVER_SELECTED;
|——Node:type_identifier Text: BYTE
|——Node:init_declarator Text: sg_bCurrState = STATE_DRIVER_SELECTED
|———Node:identifier Text: sg_bCurrState
|———Node:= Text: =
|———Node:identifier Text: STATE_DRIVER_SELECTED
|——Node:; Text: ;
|—Node:declaration Text: static SYSTEMTIME sg_CurrSysTime;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: SYSTEMTIME
|——Node:identifier Text: sg_CurrSysTime
|——Node:; Text: ;
|—Node:declaration Text: static UINT64 sg_TimeStamp = 0;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UINT64
|——Node:init_declarator Text: sg_TimeStamp = 0
|———Node:identifier Text: sg_TimeStamp
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:comment Text: /**
 * Query Tick Count
 */
|—Node:declaration Text: static LARGE_INTEGER sg_QueryTickCount;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: LARGE_INTEGER
|——Node:identifier Text: sg_QueryTickCount
|——Node:; Text: ;
|—Node:declaration Text: static LARGE_INTEGER sg_lnFrequency;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: LARGE_INTEGER
|——Node:identifier Text: sg_lnFrequency
|——Node:; Text: ;
|—Node:comment Text: /**
 * Channel information
 */
|—Node:struct_specifier Text: struct CChannel
{
    /* To store baud rate information */
    USHORT  m_usClock;
    USHORT  m_usSampling;
    UINT    m_unBaudrate;

    /* Bit Timing */
    USHORT  m_usBaudRate; /*BTR0,BTR1*/
    BYTE    m_bCNF1;
    BYTE    m_bCNF2;
    BYTE    m_bCNF3;

    /**
     * To store controller state
     * 0 - Active State
     * 1 - Passive State
     * 2 - Bus Off State
     * -1 - For invalid value
     */
    UCHAR m_ucControllerState;

    /**
     * Pointer to corresponding XLchannelConfig
     */
    XLchannelConfig* m_pXLChannelInfo;

    /** Programmed warning limit of this channel */
    UCHAR m_ucWarningLimit;

    /** Tx Error counter value */
    UCHAR m_ucTxErrorCounter;

    /** Rx Error counter value */
    UCHAR m_ucRxErrorCounter;

    /** Peak Tx Error counter value */
    UCHAR m_ucPeakTxErrorCounter;

    /** Peak Rx Error counter value */
    UCHAR m_ucPeakRxErrorCounter;

    /** Tx Error Handler execution state */
    BOOL m_bTxErrorExecuted;

    /** Rx Error Handler execution state */
    BOOL m_bRxErrorExecuted;

    // Init members with default value
    CChannel()
    {
        // Baud Rate
        m_usBaudRate = defBAUD_RATE;

        // Controller state
        m_ucControllerState = defMODE_ACTIVE;

        // Pointer to corresponding XLchannelConfig
        m_pXLChannelInfo = NULL;

        // Programmed warning limit of this channel
        m_ucWarningLimit = defWARNING_LIMIT_INT;

        // Tx Error counter value
        m_ucTxErrorCounter = 0;

        // Rx Error counter value
        m_ucRxErrorCounter = 0;

        // Peak Tx Error counter value
        m_ucPeakTxErrorCounter = 0;

        // Peak Rx Error counter value
        m_ucPeakRxErrorCounter = 0;

        // Tx Error Handler execution state
        m_bTxErrorExecuted = FALSE;

        // Rx Error Handler execution state
        m_bRxErrorExecuted = FALSE;
    }
}
|——Node:struct Text: struct
|——Node:type_identifier Text: CChannel
|——Node:field_declaration_list Text: {
    /* To store baud rate information */
    USHORT  m_usClock;
    USHORT  m_usSampling;
    UINT    m_unBaudrate;

    /* Bit Timing */
    USHORT  m_usBaudRate; /*BTR0,BTR1*/
    BYTE    m_bCNF1;
    BYTE    m_bCNF2;
    BYTE    m_bCNF3;

    /**
     * To store controller state
     * 0 - Active State
     * 1 - Passive State
     * 2 - Bus Off State
     * -1 - For invalid value
     */
    UCHAR m_ucControllerState;

    /**
     * Pointer to corresponding XLchannelConfig
     */
    XLchannelConfig* m_pXLChannelInfo;

    /** Programmed warning limit of this channel */
    UCHAR m_ucWarningLimit;

    /** Tx Error counter value */
    UCHAR m_ucTxErrorCounter;

    /** Rx Error counter value */
    UCHAR m_ucRxErrorCounter;

    /** Peak Tx Error counter value */
    UCHAR m_ucPeakTxErrorCounter;

    /** Peak Rx Error counter value */
    UCHAR m_ucPeakRxErrorCounter;

    /** Tx Error Handler execution state */
    BOOL m_bTxErrorExecuted;

    /** Rx Error Handler execution state */
    BOOL m_bRxErrorExecuted;

    // Init members with default value
    CChannel()
    {
        // Baud Rate
        m_usBaudRate = defBAUD_RATE;

        // Controller state
        m_ucControllerState = defMODE_ACTIVE;

        // Pointer to corresponding XLchannelConfig
        m_pXLChannelInfo = NULL;

        // Programmed warning limit of this channel
        m_ucWarningLimit = defWARNING_LIMIT_INT;

        // Tx Error counter value
        m_ucTxErrorCounter = 0;

        // Rx Error counter value
        m_ucRxErrorCounter = 0;

        // Peak Tx Error counter value
        m_ucPeakTxErrorCounter = 0;

        // Peak Rx Error counter value
        m_ucPeakRxErrorCounter = 0;

        // Tx Error Handler execution state
        m_bTxErrorExecuted = FALSE;

        // Rx Error Handler execution state
        m_bRxErrorExecuted = FALSE;
    }
}
|———Node:{ Text: {
|———Node:comment Text: /* To store baud rate information */
|———Node:field_declaration Text: USHORT  m_usClock;
|————Node:type_identifier Text: USHORT
|————Node:field_identifier Text: m_usClock
|————Node:; Text: ;
|———Node:field_declaration Text: USHORT  m_usSampling;
|————Node:type_identifier Text: USHORT
|————Node:field_identifier Text: m_usSampling
|————Node:; Text: ;
|———Node:field_declaration Text: UINT    m_unBaudrate;
|————Node:type_identifier Text: UINT
|————Node:field_identifier Text: m_unBaudrate
|————Node:; Text: ;
|———Node:comment Text: /* Bit Timing */
|———Node:field_declaration Text: USHORT  m_usBaudRate;
|————Node:type_identifier Text: USHORT
|————Node:field_identifier Text: m_usBaudRate
|————Node:; Text: ;
|———Node:comment Text: /*BTR0,BTR1*/
|———Node:field_declaration Text: BYTE    m_bCNF1;
|————Node:type_identifier Text: BYTE
|————Node:field_identifier Text: m_bCNF1
|————Node:; Text: ;
|———Node:field_declaration Text: BYTE    m_bCNF2;
|————Node:type_identifier Text: BYTE
|————Node:field_identifier Text: m_bCNF2
|————Node:; Text: ;
|———Node:field_declaration Text: BYTE    m_bCNF3;
|————Node:type_identifier Text: BYTE
|————Node:field_identifier Text: m_bCNF3
|————Node:; Text: ;
|———Node:comment Text: /**
     * To store controller state
     * 0 - Active State
     * 1 - Passive State
     * 2 - Bus Off State
     * -1 - For invalid value
     */
|———Node:field_declaration Text: UCHAR m_ucControllerState;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucControllerState
|————Node:; Text: ;
|———Node:comment Text: /**
     * Pointer to corresponding XLchannelConfig
     */
|———Node:field_declaration Text: XLchannelConfig* m_pXLChannelInfo;
|————Node:type_identifier Text: XLchannelConfig
|————Node:pointer_declarator Text: * m_pXLChannelInfo
|—————Node:* Text: *
|—————Node:field_identifier Text: m_pXLChannelInfo
|————Node:; Text: ;
|———Node:comment Text: /** Programmed warning limit of this channel */
|———Node:field_declaration Text: UCHAR m_ucWarningLimit;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucWarningLimit
|————Node:; Text: ;
|———Node:comment Text: /** Tx Error counter value */
|———Node:field_declaration Text: UCHAR m_ucTxErrorCounter;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucTxErrorCounter
|————Node:; Text: ;
|———Node:comment Text: /** Rx Error counter value */
|———Node:field_declaration Text: UCHAR m_ucRxErrorCounter;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucRxErrorCounter
|————Node:; Text: ;
|———Node:comment Text: /** Peak Tx Error counter value */
|———Node:field_declaration Text: UCHAR m_ucPeakTxErrorCounter;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucPeakTxErrorCounter
|————Node:; Text: ;
|———Node:comment Text: /** Peak Rx Error counter value */
|———Node:field_declaration Text: UCHAR m_ucPeakRxErrorCounter;
|————Node:type_identifier Text: UCHAR
|————Node:field_identifier Text: m_ucPeakRxErrorCounter
|————Node:; Text: ;
|———Node:comment Text: /** Tx Error Handler execution state */
|———Node:field_declaration Text: BOOL m_bTxErrorExecuted;
|————Node:type_identifier Text: BOOL
|————Node:field_identifier Text: m_bTxErrorExecuted
|————Node:; Text: ;
|———Node:comment Text: /** Rx Error Handler execution state */
|———Node:field_declaration Text: BOOL m_bRxErrorExecuted;
|————Node:type_identifier Text: BOOL
|————Node:field_identifier Text: m_bRxErrorExecuted
|————Node:; Text: ;
|———Node:comment Text: // Init members with default value
|———Node:function_definition Text: CChannel()
    {
        // Baud Rate
        m_usBaudRate = defBAUD_RATE;

        // Controller state
        m_ucControllerState = defMODE_ACTIVE;

        // Pointer to corresponding XLchannelConfig
        m_pXLChannelInfo = NULL;

        // Programmed warning limit of this channel
        m_ucWarningLimit = defWARNING_LIMIT_INT;

        // Tx Error counter value
        m_ucTxErrorCounter = 0;

        // Rx Error counter value
        m_ucRxErrorCounter = 0;

        // Peak Tx Error counter value
        m_ucPeakTxErrorCounter = 0;

        // Peak Rx Error counter value
        m_ucPeakRxErrorCounter = 0;

        // Tx Error Handler execution state
        m_bTxErrorExecuted = FALSE;

        // Rx Error Handler execution state
        m_bRxErrorExecuted = FALSE;
    }
|————Node:function_declarator Text: CChannel()
|—————Node:identifier Text: CChannel
|—————Node:parameter_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:compound_statement Text: {
        // Baud Rate
        m_usBaudRate = defBAUD_RATE;

        // Controller state
        m_ucControllerState = defMODE_ACTIVE;

        // Pointer to corresponding XLchannelConfig
        m_pXLChannelInfo = NULL;

        // Programmed warning limit of this channel
        m_ucWarningLimit = defWARNING_LIMIT_INT;

        // Tx Error counter value
        m_ucTxErrorCounter = 0;

        // Rx Error counter value
        m_ucRxErrorCounter = 0;

        // Peak Tx Error counter value
        m_ucPeakTxErrorCounter = 0;

        // Peak Rx Error counter value
        m_ucPeakRxErrorCounter = 0;

        // Tx Error Handler execution state
        m_bTxErrorExecuted = FALSE;

        // Rx Error Handler execution state
        m_bRxErrorExecuted = FALSE;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // Baud Rate
|—————Node:expression_statement Text: m_usBaudRate = defBAUD_RATE;
|——————Node:assignment_expression Text: m_usBaudRate = defBAUD_RATE
|———————Node:identifier Text: m_usBaudRate
|———————Node:= Text: =
|———————Node:identifier Text: defBAUD_RATE
|——————Node:; Text: ;
|—————Node:comment Text: // Controller state
|—————Node:expression_statement Text: m_ucControllerState = defMODE_ACTIVE;
|——————Node:assignment_expression Text: m_ucControllerState = defMODE_ACTIVE
|———————Node:identifier Text: m_ucControllerState
|———————Node:= Text: =
|———————Node:identifier Text: defMODE_ACTIVE
|——————Node:; Text: ;
|—————Node:comment Text: // Pointer to corresponding XLchannelConfig
|—————Node:expression_statement Text: m_pXLChannelInfo = NULL;
|——————Node:assignment_expression Text: m_pXLChannelInfo = NULL
|———————Node:identifier Text: m_pXLChannelInfo
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:comment Text: // Programmed warning limit of this channel
|—————Node:expression_statement Text: m_ucWarningLimit = defWARNING_LIMIT_INT;
|——————Node:assignment_expression Text: m_ucWarningLimit = defWARNING_LIMIT_INT
|———————Node:identifier Text: m_ucWarningLimit
|———————Node:= Text: =
|———————Node:identifier Text: defWARNING_LIMIT_INT
|——————Node:; Text: ;
|—————Node:comment Text: // Tx Error counter value
|—————Node:expression_statement Text: m_ucTxErrorCounter = 0;
|——————Node:assignment_expression Text: m_ucTxErrorCounter = 0
|———————Node:identifier Text: m_ucTxErrorCounter
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: // Rx Error counter value
|—————Node:expression_statement Text: m_ucRxErrorCounter = 0;
|——————Node:assignment_expression Text: m_ucRxErrorCounter = 0
|———————Node:identifier Text: m_ucRxErrorCounter
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: // Peak Tx Error counter value
|—————Node:expression_statement Text: m_ucPeakTxErrorCounter = 0;
|——————Node:assignment_expression Text: m_ucPeakTxErrorCounter = 0
|———————Node:identifier Text: m_ucPeakTxErrorCounter
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: // Peak Rx Error counter value
|—————Node:expression_statement Text: m_ucPeakRxErrorCounter = 0;
|——————Node:assignment_expression Text: m_ucPeakRxErrorCounter = 0
|———————Node:identifier Text: m_ucPeakRxErrorCounter
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: // Tx Error Handler execution state
|—————Node:expression_statement Text: m_bTxErrorExecuted = FALSE;
|——————Node:assignment_expression Text: m_bTxErrorExecuted = FALSE
|———————Node:identifier Text: m_bTxErrorExecuted
|———————Node:= Text: =
|———————Node:false Text: FALSE
|——————Node:; Text: ;
|—————Node:comment Text: // Rx Error Handler execution state
|—————Node:expression_statement Text: m_bRxErrorExecuted = FALSE;
|——————Node:assignment_expression Text: m_bRxErrorExecuted = FALSE
|———————Node:identifier Text: m_bRxErrorExecuted
|———————Node:= Text: =
|———————Node:false Text: FALSE
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:; Text: ;
|—Node:comment Text: /**
 * Array of channel objects. The size of this array is maximun number
 * of channels the application will support.
 */
|—Node:declaration Text: static CChannel sg_aodChannels[ defNO_OF_CHANNELS ];
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: CChannel
|——Node:array_declarator Text: sg_aodChannels[ defNO_OF_CHANNELS ]
|———Node:identifier Text: sg_aodChannels
|———Node:[ Text: [
|———Node:identifier Text: defNO_OF_CHANNELS
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:declaration Text: static INT sg_anSelectedItems[CHANNEL_ALLOWED];
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: INT
|——Node:array_declarator Text: sg_anSelectedItems[CHANNEL_ALLOWED]
|———Node:identifier Text: sg_anSelectedItems
|———Node:[ Text: [
|———Node:identifier Text: CHANNEL_ALLOWED
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:comment Text: /**
* \brief         Sets the application params.
* \param[in]     hWndOwner, is the main frame HWND value
* \param[in]     pILog, is pointer to error logger object
* \return        S_OK (always)
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
{
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;

    /* Initialise both the time parameters */
    GetLocalTime(&sg_CurrSysTime);
    sg_TimeStamp = 0x0;

    /* Query Tick Count */
    sg_QueryTickCount.QuadPart = 0;

    /* INITIALISE_ARRAY(sg_acErrStr); */
    sg_acErrStr = "";
    CAN_ManageMsgBuf(MSGBUF_CLEAR, NULL, NULL);

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_SetAppParams
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_SetAppParams
|———Node:parameter_list Text: (HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|————Node:( Text: (
|————Node:parameter_declaration Text: HWND hWndOwner
|—————Node:type_identifier Text: HWND
|—————Node:identifier Text: hWndOwner
|————Node:, Text: ,
|————Node:parameter_declaration Text: Base_WrapperErrorLogger* pILog
|—————Node:type_identifier Text: Base_WrapperErrorLogger
|—————Node:pointer_declarator Text: * pILog
|——————Node:* Text: *
|——————Node:identifier Text: pILog
|————Node:) Text: )
|——Node:compound_statement Text: {
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;

    /* Initialise both the time parameters */
    GetLocalTime(&sg_CurrSysTime);
    sg_TimeStamp = 0x0;

    /* Query Tick Count */
    sg_QueryTickCount.QuadPart = 0;

    /* INITIALISE_ARRAY(sg_acErrStr); */
    sg_acErrStr = "";
    CAN_ManageMsgBuf(MSGBUF_CLEAR, NULL, NULL);

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: sg_hOwnerWnd = hWndOwner;
|————Node:assignment_expression Text: sg_hOwnerWnd = hWndOwner
|—————Node:identifier Text: sg_hOwnerWnd
|—————Node:= Text: =
|—————Node:identifier Text: hWndOwner
|————Node:; Text: ;
|———Node:expression_statement Text: sg_pIlog = pILog;
|————Node:assignment_expression Text: sg_pIlog = pILog
|—————Node:identifier Text: sg_pIlog
|—————Node:= Text: =
|—————Node:identifier Text: pILog
|————Node:; Text: ;
|———Node:comment Text: /* Initialise both the time parameters */
|———Node:expression_statement Text: GetLocalTime(&sg_CurrSysTime);
|————Node:call_expression Text: GetLocalTime(&sg_CurrSysTime)
|—————Node:identifier Text: GetLocalTime
|—————Node:argument_list Text: (&sg_CurrSysTime)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &sg_CurrSysTime
|———————Node:& Text: &
|———————Node:identifier Text: sg_CurrSysTime
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sg_TimeStamp = 0x0;
|————Node:assignment_expression Text: sg_TimeStamp = 0x0
|—————Node:identifier Text: sg_TimeStamp
|—————Node:= Text: =
|—————Node:number_literal Text: 0x0
|————Node:; Text: ;
|———Node:comment Text: /* Query Tick Count */
|———Node:expression_statement Text: sg_QueryTickCount.QuadPart = 0;
|————Node:assignment_expression Text: sg_QueryTickCount.QuadPart = 0
|—————Node:field_expression Text: sg_QueryTickCount.QuadPart
|——————Node:identifier Text: sg_QueryTickCount
|——————Node:. Text: .
|——————Node:field_identifier Text: QuadPart
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: /* INITIALISE_ARRAY(sg_acErrStr); */
|———Node:expression_statement Text: sg_acErrStr = "";
|————Node:assignment_expression Text: sg_acErrStr = ""
|—————Node:identifier Text: sg_acErrStr
|—————Node:= Text: =
|—————Node:string_literal Text: ""
|——————Node:" Text: "
|——————Node:" Text: "
|————Node:; Text: ;
|———Node:expression_statement Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, NULL, NULL);
|————Node:call_expression Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, NULL, NULL)
|—————Node:identifier Text: CAN_ManageMsgBuf
|—————Node:argument_list Text: (MSGBUF_CLEAR, NULL, NULL)
|——————Node:( Text: (
|——————Node:identifier Text: MSGBUF_CLEAR
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Unloads verdor's driver lobrary
* \param         void
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_UnloadDriverLibrary(void)
{
    if (hxlDll != NULL)
    {
        FreeLibrary(hxlDll);
        hxlDll = NULL;
    }

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_UnloadDriverLibrary(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_UnloadDriverLibrary
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_UnloadDriverLibrary
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (hxlDll != NULL)
    {
        FreeLibrary(hxlDll);
        hxlDll = NULL;
    }

    return S_OK;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (hxlDll != NULL)
    {
        FreeLibrary(hxlDll);
        hxlDll = NULL;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hxlDll != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: hxlDll != NULL
|——————Node:identifier Text: hxlDll
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        FreeLibrary(hxlDll);
        hxlDll = NULL;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: FreeLibrary(hxlDll);
|——————Node:call_expression Text: FreeLibrary(hxlDll)
|———————Node:identifier Text: FreeLibrary
|———————Node:argument_list Text: (hxlDll)
|————————Node:( Text: (
|————————Node:identifier Text: hxlDll
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hxlDll = NULL;
|——————Node:assignment_expression Text: hxlDll = NULL
|———————Node:identifier Text: hxlDll
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Registers the buffer pBufObj to the client ClientID
* \param[in]     bAction, contains one of the values MSGBUF_ADD or MSGBUF_CLEAR
* \param[in]     ClientID, is the client ID
* \param[in]     pBufObj, is pointer to CBaseCANBufFSE object
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
{
    HRESULT hResult = S_FALSE;
    if (ClientID != NULL)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_ManageMsgBuf
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_ManageMsgBuf
|———Node:parameter_list Text: (BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|————Node:( Text: (
|————Node:parameter_declaration Text: BYTE bAction
|—————Node:type_identifier Text: BYTE
|—————Node:identifier Text: bAction
|————Node:, Text: ,
|————Node:parameter_declaration Text: DWORD ClientID
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: ClientID
|————Node:, Text: ,
|————Node:parameter_declaration Text: CBaseCANBufFSE* pBufObj
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * pBufObj
|——————Node:* Text: *
|——————Node:identifier Text: pBufObj
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    if (ClientID != NULL)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_FALSE;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_FALSE
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_FALSE
|————Node:; Text: ;
|———Node:if_statement Text: if (ClientID != NULL)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (ClientID != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: ClientID != NULL
|——————Node:identifier Text: ClientID
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|—————Node:{ Text: {
|—————Node:declaration Text: UINT unClientIndex;
|——————Node:type_identifier Text: UINT
|——————Node:identifier Text: unClientIndex
|——————Node:; Text: ;
|—————Node:if_statement Text: if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (bGetClientObj(ClientID, unClientIndex))
|———————Node:( Text: (
|———————Node:call_expression Text: bGetClientObj(ClientID, unClientIndex)
|————————Node:identifier Text: bGetClientObj
|————————Node:argument_list Text: (ClientID, unClientIndex)
|—————————Node:( Text: (
|—————————Node:identifier Text: ClientID
|—————————Node:, Text: ,
|—————————Node:identifier Text: unClientIndex
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
        }
|———————Node:{ Text: {
|———————Node:declaration Text: SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
|————————Node:type_identifier Text: SCLIENTBUFMAP
|————————Node:init_declarator Text: & sClientObj = sg_asClientToBufMap[unClientIndex]
|—————————Node:reference_declarator Text: & sClientObj
|——————————Node:& Text: &
|——————————Node:identifier Text: sClientObj
|—————————Node:= Text: =
|—————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|——————————Node:identifier Text: sg_asClientToBufMap
|——————————Node:subscript_argument_list Text: [unClientIndex]
|———————————Node:[ Text: [
|———————————Node:identifier Text: unClientIndex
|———————————Node:] Text: ]
|————————Node:; Text: ;
|———————Node:if_statement Text: if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (bAction == MSGBUF_ADD)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: bAction == MSGBUF_ADD
|——————————Node:identifier Text: bAction
|——————————Node:== Text: ==
|——————————Node:identifier Text: MSGBUF_ADD
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
|—————————Node:{ Text: {
|—————————Node:comment Text: /* Add msg buffer */
|—————————Node:if_statement Text: if (pBufObj != NULL)
                {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (pBufObj != NULL)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: pBufObj != NULL
|————————————Node:identifier Text: pBufObj
|————————————Node:!= Text: !=
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (sClientObj.unBufCount < MAX_BUFF_ALLOWED)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: sClientObj.unBufCount < MAX_BUFF_ALLOWED
|——————————————Node:field_expression Text: sClientObj.unBufCount
|———————————————Node:identifier Text: sClientObj
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: unBufCount
|——————————————Node:< Text: <
|——————————————Node:identifier Text: MAX_BUFF_ALLOWED
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
|—————————————Node:{ Text: {
|—————————————Node:if_statement Text: if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (bIsBufferExists(sClientObj, pBufObj) == FALSE)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: bIsBufferExists(sClientObj, pBufObj) == FALSE
|————————————————Node:call_expression Text: bIsBufferExists(sClientObj, pBufObj)
|—————————————————Node:identifier Text: bIsBufferExists
|—————————————————Node:argument_list Text: (sClientObj, pBufObj)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: sClientObj
|——————————————————Node:, Text: ,
|——————————————————Node:identifier Text: pBufObj
|——————————————————Node:) Text: )
|————————————————Node:== Text: ==
|————————————————Node:false Text: FALSE
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
                            sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj;
|————————————————Node:assignment_expression Text: sClientObj.pClientBuf[sClientObj.unBufCount++] = pBufObj
|—————————————————Node:subscript_expression Text: sClientObj.pClientBuf[sClientObj.unBufCount++]
|——————————————————Node:field_expression Text: sClientObj.pClientBuf
|———————————————————Node:identifier Text: sClientObj
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: pClientBuf
|——————————————————Node:subscript_argument_list Text: [sClientObj.unBufCount++]
|———————————————————Node:[ Text: [
|———————————————————Node:update_expression Text: sClientObj.unBufCount++
|————————————————————Node:field_expression Text: sClientObj.unBufCount
|—————————————————————Node:identifier Text: sClientObj
|—————————————————————Node:. Text: .
|—————————————————————Node:field_identifier Text: unBufCount
|————————————————————Node:++ Text: ++
|———————————————————Node:] Text: ]
|—————————————————Node:= Text: =
|—————————————————Node:identifier Text: pBufObj
|————————————————Node:; Text: ;
|———————————————Node:expression_statement Text: hResult = S_OK;
|————————————————Node:assignment_expression Text: hResult = S_OK
|—————————————————Node:identifier Text: hResult
|—————————————————Node:= Text: =
|—————————————————Node:identifier Text: S_OK
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|——————————————Node:else_clause Text: else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|———————————————Node:else Text: else
|———————————————Node:compound_statement Text: {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|————————————————Node:{ Text: {
|————————————————Node:expression_statement Text: hResult = ERR_BUFFER_EXISTS;
|—————————————————Node:assignment_expression Text: hResult = ERR_BUFFER_EXISTS
|——————————————————Node:identifier Text: hResult
|——————————————————Node:= Text: =
|——————————————————Node:identifier Text: ERR_BUFFER_EXISTS
|—————————————————Node:; Text: ;
|————————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (bAction == MSGBUF_CLEAR)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: bAction == MSGBUF_CLEAR
|————————————Node:identifier Text: bAction
|————————————Node:== Text: ==
|————————————Node:identifier Text: MSGBUF_CLEAR
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                /* clear msg buffer */
                if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
                hResult = S_OK;
            }
|———————————Node:{ Text: {
|———————————Node:comment Text: /* clear msg buffer */
|———————————Node:if_statement Text: if (pBufObj != NULL)
                {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
                else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (pBufObj != NULL)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: pBufObj != NULL
|——————————————Node:identifier Text: pBufObj
|——————————————Node:!= Text: !=
|——————————————Node:null Text: NULL
|———————————————Node:NULL Text: NULL
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                    /* Remove only buffer mentioned */
                    bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
                }
|—————————————Node:{ Text: {
|—————————————Node:comment Text: /* Remove only buffer mentioned */
|—————————————Node:expression_statement Text: bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj);
|——————————————Node:call_expression Text: bRemoveClientBuffer(sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj)
|———————————————Node:identifier Text: bRemoveClientBuffer
|———————————————Node:argument_list Text: (sClientObj.pClientBuf, sClientObj.unBufCount, pBufObj)
|————————————————Node:( Text: (
|————————————————Node:field_expression Text: sClientObj.pClientBuf
|—————————————————Node:identifier Text: sClientObj
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: pClientBuf
|————————————————Node:, Text: ,
|————————————————Node:field_expression Text: sClientObj.unBufCount
|—————————————————Node:identifier Text: sClientObj
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: unBufCount
|————————————————Node:, Text: ,
|————————————————Node:identifier Text: pBufObj
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else
                {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
|—————————————Node:else Text: else
|—————————————Node:compound_statement Text: {
                    /* Remove all */
                    for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
                    sClientObj.unBufCount = 0;
                }
|——————————————Node:{ Text: {
|——————————————Node:comment Text: /* Remove all */
|——————————————Node:for_statement Text: for (UINT i = 0; i < sClientObj.unBufCount; i++)
                    {
                        sClientObj.pClientBuf[i] = NULL;
                    }
|———————————————Node:for Text: for
|———————————————Node:( Text: (
|———————————————Node:declaration Text: UINT i = 0;
|————————————————Node:type_identifier Text: UINT
|————————————————Node:init_declarator Text: i = 0
|—————————————————Node:identifier Text: i
|—————————————————Node:= Text: =
|—————————————————Node:number_literal Text: 0
|————————————————Node:; Text: ;
|———————————————Node:binary_expression Text: i < sClientObj.unBufCount
|————————————————Node:identifier Text: i
|————————————————Node:< Text: <
|————————————————Node:field_expression Text: sClientObj.unBufCount
|—————————————————Node:identifier Text: sClientObj
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: unBufCount
|———————————————Node:; Text: ;
|———————————————Node:update_expression Text: i++
|————————————————Node:identifier Text: i
|————————————————Node:++ Text: ++
|———————————————Node:) Text: )
|———————————————Node:compound_statement Text: {
                        sClientObj.pClientBuf[i] = NULL;
                    }
|————————————————Node:{ Text: {
|————————————————Node:expression_statement Text: sClientObj.pClientBuf[i] = NULL;
|—————————————————Node:assignment_expression Text: sClientObj.pClientBuf[i] = NULL
|——————————————————Node:subscript_expression Text: sClientObj.pClientBuf[i]
|———————————————————Node:field_expression Text: sClientObj.pClientBuf
|————————————————————Node:identifier Text: sClientObj
|————————————————————Node:. Text: .
|————————————————————Node:field_identifier Text: pClientBuf
|———————————————————Node:subscript_argument_list Text: [i]
|————————————————————Node:[ Text: [
|————————————————————Node:identifier Text: i
|————————————————————Node:] Text: ]
|——————————————————Node:= Text: =
|——————————————————Node:null Text: NULL
|———————————————————Node:NULL Text: NULL
|—————————————————Node:; Text: ;
|————————————————Node:} Text: }
|——————————————Node:expression_statement Text: sClientObj.unBufCount = 0;
|———————————————Node:assignment_expression Text: sClientObj.unBufCount = 0
|————————————————Node:field_expression Text: sClientObj.unBufCount
|—————————————————Node:identifier Text: sClientObj
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: unBufCount
|————————————————Node:= Text: =
|————————————————Node:number_literal Text: 0
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|———————————Node:expression_statement Text: hResult = S_OK;
|————————————Node:assignment_expression Text: hResult = S_OK
|—————————————Node:identifier Text: hResult
|—————————————Node:= Text: =
|—————————————Node:identifier Text: S_OK
|————————————Node:; Text: ;
|———————————Node:} Text: }
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|—————————Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: ERR_NO_CLIENT_EXIST
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|——————Node:{ Text: {
|——————Node:if_statement Text: if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (bAction == MSGBUF_CLEAR)
|————————Node:( Text: (
|————————Node:binary_expression Text: bAction == MSGBUF_CLEAR
|—————————Node:identifier Text: bAction
|—————————Node:== Text: ==
|—————————Node:identifier Text: MSGBUF_CLEAR
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
            hResult = S_OK;
        }
|————————Node:{ Text: {
|————————Node:comment Text: /* clear msg buffer */
|————————Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
|—————————Node:for Text: for
|—————————Node:( Text: (
|—————————Node:declaration Text: UINT i = 0;
|——————————Node:type_identifier Text: UINT
|——————————Node:init_declarator Text: i = 0
|———————————Node:identifier Text: i
|———————————Node:= Text: =
|———————————Node:number_literal Text: 0
|——————————Node:; Text: ;
|—————————Node:binary_expression Text: i < sg_unClientCnt
|——————————Node:identifier Text: i
|——————————Node:< Text: <
|——————————Node:identifier Text: sg_unClientCnt
|—————————Node:; Text: ;
|—————————Node:update_expression Text: i++
|——————————Node:identifier Text: i
|——————————Node:++ Text: ++
|—————————Node:) Text: )
|—————————Node:compound_statement Text: {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL);
|———————————Node:call_expression Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL)
|————————————Node:identifier Text: CAN_ManageMsgBuf
|————————————Node:argument_list Text: (MSGBUF_CLEAR, sg_asClientToBufMap[i].dwClientID, NULL)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: MSGBUF_CLEAR
|—————————————Node:, Text: ,
|—————————————Node:field_expression Text: sg_asClientToBufMap[i].dwClientID
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[i]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: dwClientID
|—————————————Node:, Text: ,
|—————————————Node:null Text: NULL
|——————————————Node:NULL Text: NULL
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:expression_statement Text: hResult = S_OK;
|—————————Node:assignment_expression Text: hResult = S_OK
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: S_OK
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Registers a client to the DIL.
* \param[in]     bRegister, if TRUE signifies 'Register', FALSE indicates 'Unregister'
* \param[out]    ClientID, is Client ID assigned, will be used for further client related calls
* \param[in]     pacClientName, is the client name
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
{
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;

    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_RegisterClient
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_RegisterClient
|———Node:parameter_list Text: (BOOL bRegister, DWORD& ClientID, char* pacClientName)
|————Node:( Text: (
|————Node:parameter_declaration Text: BOOL bRegister
|—————Node:type_identifier Text: BOOL
|—————Node:identifier Text: bRegister
|————Node:, Text: ,
|————Node:parameter_declaration Text: DWORD& ClientID
|—————Node:type_identifier Text: DWORD
|—————Node:reference_declarator Text: & ClientID
|——————Node:& Text: &
|——————Node:identifier Text: ClientID
|————Node:, Text: ,
|————Node:parameter_declaration Text: char* pacClientName
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: * pacClientName
|——————Node:* Text: *
|——————Node:identifier Text: pacClientName
|————Node:) Text: )
|——Node:compound_statement Text: {
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;

    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_FALSE;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_FALSE
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_FALSE
|————Node:; Text: ;
|———Node:if_statement Text: if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (bRegister)
|—————Node:( Text: (
|—————Node:identifier Text: bRegister
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sg_unClientCnt < MAX_CLIENT_ALLOWED)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_unClientCnt < MAX_CLIENT_ALLOWED
|————————Node:identifier Text: sg_unClientCnt
|————————Node:< Text: <
|————————Node:identifier Text: MAX_CLIENT_ALLOWED
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
|———————Node:{ Text: {
|———————Node:declaration Text: INT Index = 0;
|————————Node:type_identifier Text: INT
|————————Node:init_declarator Text: Index = 0
|—————————Node:identifier Text: Index
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:if_statement Text: if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (!bClientExist(pacClientName, Index))
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !bClientExist(pacClientName, Index)
|——————————Node:! Text: !
|——————————Node:call_expression Text: bClientExist(pacClientName, Index)
|———————————Node:identifier Text: bClientExist
|———————————Node:argument_list Text: (pacClientName, Index)
|————————————Node:( Text: (
|————————————Node:identifier Text: pacClientName
|————————————Node:, Text: ,
|————————————Node:identifier Text: Index
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                /* Currently store the client information */
                if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
|—————————Node:{ Text: {
|—————————Node:comment Text: /* Currently store the client information */
|—————————Node:if_statement Text: if (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (_tcscmp(pacClientName, CAN_MONITOR_NODE) == 0)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: _tcscmp(pacClientName, CAN_MONITOR_NODE) == 0
|————————————Node:call_expression Text: _tcscmp(pacClientName, CAN_MONITOR_NODE)
|—————————————Node:identifier Text: _tcscmp
|—————————————Node:argument_list Text: (pacClientName, CAN_MONITOR_NODE)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: pacClientName
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: CAN_MONITOR_NODE
|——————————————Node:) Text: )
|————————————Node:== Text: ==
|————————————Node:number_literal Text: 0
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
                    sg_asClientToBufMap[0].dwClientID = ClientID;
                    sg_asClientToBufMap[0].unBufCount = 0;
                }
|———————————Node:{ Text: {
|———————————Node:comment Text: /* First slot is reserved to monitor node */
|———————————Node:expression_statement Text: ClientID = 1;
|————————————Node:assignment_expression Text: ClientID = 1
|—————————————Node:identifier Text: ClientID
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 1
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName);
|————————————Node:call_expression Text: _tcscpy(sg_asClientToBufMap[0].pacClientName, pacClientName)
|—————————————Node:identifier Text: _tcscpy
|—————————————Node:argument_list Text: (sg_asClientToBufMap[0].pacClientName, pacClientName)
|——————————————Node:( Text: (
|——————————————Node:field_expression Text: sg_asClientToBufMap[0].pacClientName
|———————————————Node:subscript_expression Text: sg_asClientToBufMap[0]
|————————————————Node:identifier Text: sg_asClientToBufMap
|————————————————Node:subscript_argument_list Text: [0]
|—————————————————Node:[ Text: [
|—————————————————Node:number_literal Text: 0
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: pacClientName
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: pacClientName
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: sg_asClientToBufMap[0].dwClientID = ClientID;
|————————————Node:assignment_expression Text: sg_asClientToBufMap[0].dwClientID = ClientID
|—————————————Node:field_expression Text: sg_asClientToBufMap[0].dwClientID
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[0]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [0]
|————————————————Node:[ Text: [
|————————————————Node:number_literal Text: 0
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: dwClientID
|—————————————Node:= Text: =
|—————————————Node:identifier Text: ClientID
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: sg_asClientToBufMap[0].unBufCount = 0;
|————————————Node:assignment_expression Text: sg_asClientToBufMap[0].unBufCount = 0
|—————————————Node:field_expression Text: sg_asClientToBufMap[0].unBufCount
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[0]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [0]
|————————————————Node:[ Text: [
|————————————————Node:number_literal Text: 0
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unBufCount
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);

                    sg_asClientToBufMap[Index].dwClientID = ClientID;
                    sg_asClientToBufMap[Index].unBufCount = 0;
                }
|————————————Node:{ Text: {
|————————————Node:if_statement Text: if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
|—————————————Node:if Text: if
|—————————————Node:condition_clause Text: (!bClientExist(CAN_MONITOR_NODE, Index))
|——————————————Node:( Text: (
|——————————————Node:unary_expression Text: !bClientExist(CAN_MONITOR_NODE, Index)
|———————————————Node:! Text: !
|———————————————Node:call_expression Text: bClientExist(CAN_MONITOR_NODE, Index)
|————————————————Node:identifier Text: bClientExist
|————————————————Node:argument_list Text: (CAN_MONITOR_NODE, Index)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: CAN_MONITOR_NODE
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: Index
|—————————————————Node:) Text: )
|——————————————Node:) Text: )
|—————————————Node:compound_statement Text: {
                        Index = sg_unClientCnt + 1;
                    }
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: Index = sg_unClientCnt + 1;
|———————————————Node:assignment_expression Text: Index = sg_unClientCnt + 1
|————————————————Node:identifier Text: Index
|————————————————Node:= Text: =
|————————————————Node:binary_expression Text: sg_unClientCnt + 1
|—————————————————Node:identifier Text: sg_unClientCnt
|—————————————————Node:+ Text: +
|—————————————————Node:number_literal Text: 1
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————————Node:else_clause Text: else
                    {
                        Index = sg_unClientCnt;
                    }
|——————————————Node:else Text: else
|——————————————Node:compound_statement Text: {
                        Index = sg_unClientCnt;
                    }
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: Index = sg_unClientCnt;
|————————————————Node:assignment_expression Text: Index = sg_unClientCnt
|—————————————————Node:identifier Text: Index
|—————————————————Node:= Text: =
|—————————————————Node:identifier Text: sg_unClientCnt
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|————————————Node:expression_statement Text: ClientID = dwGetAvailableClientSlot();
|—————————————Node:assignment_expression Text: ClientID = dwGetAvailableClientSlot()
|——————————————Node:identifier Text: ClientID
|——————————————Node:= Text: =
|——————————————Node:call_expression Text: dwGetAvailableClientSlot()
|———————————————Node:identifier Text: dwGetAvailableClientSlot
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName);
|—————————————Node:call_expression Text: _tcscpy(sg_asClientToBufMap[Index].pacClientName, pacClientName)
|——————————————Node:identifier Text: _tcscpy
|——————————————Node:argument_list Text: (sg_asClientToBufMap[Index].pacClientName, pacClientName)
|———————————————Node:( Text: (
|———————————————Node:field_expression Text: sg_asClientToBufMap[Index].pacClientName
|————————————————Node:subscript_expression Text: sg_asClientToBufMap[Index]
|—————————————————Node:identifier Text: sg_asClientToBufMap
|—————————————————Node:subscript_argument_list Text: [Index]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: Index
|——————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: pacClientName
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: pacClientName
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: sg_asClientToBufMap[Index].dwClientID = ClientID;
|—————————————Node:assignment_expression Text: sg_asClientToBufMap[Index].dwClientID = ClientID
|——————————————Node:field_expression Text: sg_asClientToBufMap[Index].dwClientID
|———————————————Node:subscript_expression Text: sg_asClientToBufMap[Index]
|————————————————Node:identifier Text: sg_asClientToBufMap
|————————————————Node:subscript_argument_list Text: [Index]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: Index
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: dwClientID
|——————————————Node:= Text: =
|——————————————Node:identifier Text: ClientID
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: sg_asClientToBufMap[Index].unBufCount = 0;
|—————————————Node:assignment_expression Text: sg_asClientToBufMap[Index].unBufCount = 0
|——————————————Node:field_expression Text: sg_asClientToBufMap[Index].unBufCount
|———————————————Node:subscript_expression Text: sg_asClientToBufMap[Index]
|————————————————Node:identifier Text: sg_asClientToBufMap
|————————————————Node:subscript_argument_list Text: [Index]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: Index
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: unBufCount
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:expression_statement Text: sg_unClientCnt++;
|——————————Node:update_expression Text: sg_unClientCnt++
|———————————Node:identifier Text: sg_unClientCnt
|———————————Node:++ Text: ++
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hResult = S_OK;
|——————————Node:assignment_expression Text: hResult = S_OK
|———————————Node:identifier Text: hResult
|———————————Node:= Text: =
|———————————Node:identifier Text: S_OK
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else
            {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
                ClientID = sg_asClientToBufMap[Index].dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ClientID = sg_asClientToBufMap[Index].dwClientID;
|———————————Node:assignment_expression Text: ClientID = sg_asClientToBufMap[Index].dwClientID
|————————————Node:identifier Text: ClientID
|————————————Node:= Text: =
|————————————Node:field_expression Text: sg_asClientToBufMap[Index].dwClientID
|—————————————Node:subscript_expression Text: sg_asClientToBufMap[Index]
|——————————————Node:identifier Text: sg_asClientToBufMap
|——————————————Node:subscript_argument_list Text: [Index]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: Index
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dwClientID
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: hResult = ERR_CLIENT_EXISTS;
|———————————Node:assignment_expression Text: hResult = ERR_CLIENT_EXISTS
|————————————Node:identifier Text: hResult
|————————————Node:= Text: =
|————————————Node:identifier Text: ERR_CLIENT_EXISTS
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: hResult = ERR_NO_MORE_CLIENT_ALLOWED;
|—————————Node:assignment_expression Text: hResult = ERR_NO_MORE_CLIENT_ALLOWED
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: ERR_NO_MORE_CLIENT_ALLOWED
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|——————Node:{ Text: {
|——————Node:if_statement Text: if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (bRemoveClient(ClientID))
|————————Node:( Text: (
|————————Node:call_expression Text: bRemoveClient(ClientID)
|—————————Node:identifier Text: bRemoveClient
|—————————Node:argument_list Text: (ClientID)
|——————————Node:( Text: (
|——————————Node:identifier Text: ClientID
|——————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            hResult = S_OK;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: hResult = S_OK;
|—————————Node:assignment_expression Text: hResult = S_OK
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: S_OK
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|——————————Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|———————————Node:identifier Text: hResult
|———————————Node:= Text: =
|———————————Node:identifier Text: ERR_NO_CLIENT_EXIST
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Returns the controller status.hEvent will be registered
*                and will be set whenever there is change in the controller status.
* \param[in]     hEvent, is the handle of the event
* \param[in]    unCntrlStatus, indicates contoller status
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& /*unCntrlStatus*/)
{
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& /*unCntrlStatus*/)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetCntrlStatus
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetCntrlStatus
|———Node:parameter_list Text: (const HANDLE& /*hEvent*/, UINT& /*unCntrlStatus*/)
|————Node:( Text: (
|————Node:parameter_declaration Text: const HANDLE&
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: HANDLE
|—————Node:abstract_reference_declarator Text: &
|——————Node:& Text: &
|————Node:comment Text: /*hEvent*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT&
|—————Node:type_identifier Text: UINT
|—————Node:abstract_reference_declarator Text: &
|——————Node:& Text: &
|————Node:comment Text: /*unCntrlStatus*/
|————Node:) Text: )
|——Node:compound_statement Text: {
    return S_OK;
}
|———Node:{ Text: {
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Loads vendor's driver library
* \param         void
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_LoadDriverLibrary(void)
{
    HRESULT hResult = S_OK;

    if (hxlDll != NULL)
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"));
        hResult = DLL_ALREADY_LOADED;
    }

    if (hResult == S_OK)
    {
        hxlDll = LoadLibrary("vxlapi.dll");
        if (hxlDll == NULL)
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
        else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_LoadDriverLibrary(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_LoadDriverLibrary
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_LoadDriverLibrary
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;

    if (hxlDll != NULL)
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"));
        hResult = DLL_ALREADY_LOADED;
    }

    if (hResult == S_OK)
    {
        hxlDll = LoadLibrary("vxlapi.dll");
        if (hxlDll == NULL)
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
        else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:if_statement Text: if (hxlDll != NULL)
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"));
        hResult = DLL_ALREADY_LOADED;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hxlDll != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: hxlDll != NULL
|——————Node:identifier Text: hxlDll
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"));
        hResult = DLL_ALREADY_LOADED;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"));
|——————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"))
|———————Node:field_expression Text: sg_pIlog->vLogAMessage
|————————Node:identifier Text: sg_pIlog
|————————Node:-> Text: ->
|————————Node:field_identifier Text: vLogAMessage
|———————Node:argument_list Text: (A2T(__FILE__), __LINE__, _T("vxlapi.dll already loaded"))
|————————Node:( Text: (
|————————Node:call_expression Text: A2T(__FILE__)
|—————————Node:identifier Text: A2T
|—————————Node:argument_list Text: (__FILE__)
|——————————Node:( Text: (
|——————————Node:identifier Text: __FILE__
|——————————Node:) Text: )
|————————Node:, Text: ,
|————————Node:identifier Text: __LINE__
|————————Node:, Text: ,
|————————Node:call_expression Text: _T("vxlapi.dll already loaded")
|—————————Node:identifier Text: _T
|—————————Node:argument_list Text: ("vxlapi.dll already loaded")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "vxlapi.dll already loaded"
|———————————Node:" Text: "
|———————————Node:string_content Text: vxlapi.dll already loaded
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hResult = DLL_ALREADY_LOADED;
|——————Node:assignment_expression Text: hResult = DLL_ALREADY_LOADED
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: DLL_ALREADY_LOADED
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (hResult == S_OK)
    {
        hxlDll = LoadLibrary("vxlapi.dll");
        if (hxlDll == NULL)
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
        else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hResult == S_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: hResult == S_OK
|——————Node:identifier Text: hResult
|——————Node:== Text: ==
|——————Node:identifier Text: S_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        hxlDll = LoadLibrary("vxlapi.dll");
        if (hxlDll == NULL)
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
        else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: hxlDll = LoadLibrary("vxlapi.dll");
|——————Node:assignment_expression Text: hxlDll = LoadLibrary("vxlapi.dll")
|———————Node:identifier Text: hxlDll
|———————Node:= Text: =
|———————Node:call_expression Text: LoadLibrary("vxlapi.dll")
|————————Node:identifier Text: LoadLibrary
|————————Node:argument_list Text: ("vxlapi.dll")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "vxlapi.dll"
|——————————Node:" Text: "
|——————————Node:string_content Text: vxlapi.dll
|——————————Node:" Text: "
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (hxlDll == NULL)
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
        else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (hxlDll == NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: hxlDll == NULL
|————————Node:identifier Text: hxlDll
|————————Node:== Text: ==
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
            hResult = ERR_LOAD_DRIVER;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"));
|————————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"))
|—————————Node:field_expression Text: sg_pIlog->vLogAMessage
|——————————Node:identifier Text: sg_pIlog
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: vLogAMessage
|—————————Node:argument_list Text: (A2T(__FILE__), __LINE__, _T("vxlapi.dll loading failed"))
|——————————Node:( Text: (
|——————————Node:call_expression Text: A2T(__FILE__)
|———————————Node:identifier Text: A2T
|———————————Node:argument_list Text: (__FILE__)
|————————————Node:( Text: (
|————————————Node:identifier Text: __FILE__
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: __LINE__
|——————————Node:, Text: ,
|——————————Node:call_expression Text: _T("vxlapi.dll loading failed")
|———————————Node:identifier Text: _T
|———————————Node:argument_list Text: ("vxlapi.dll loading failed")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "vxlapi.dll loading failed"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: vxlapi.dll loading failed
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: hResult = ERR_LOAD_DRIVER;
|————————Node:assignment_expression Text: hResult = ERR_LOAD_DRIVER
|—————————Node:identifier Text: hResult
|—————————Node:= Text: =
|—————————Node:identifier Text: ERR_LOAD_DRIVER
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
            xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");

            /* bus independed functions */
            xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
            xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
            xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
            xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
            xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
            xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
            xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
            xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
            xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
            xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
            xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
            xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
            xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
            xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
            xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
            xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
            xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
            xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
            xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
            xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
            xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
            xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
            xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
            xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");


            /* CAN specific functions */
            xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
            xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
            xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
            xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
            xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
            xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
            xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
            xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
            xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
            xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
            xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
            xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
            xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
            xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");

            /* check for error */
            if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver");
|—————————Node:assignment_expression Text: xlDllOpenDriver           = (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver")
|——————————Node:identifier Text: xlDllOpenDriver
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLOPENDRIVER)                GetProcAddress(hxlDll,"xlOpenDriver")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLOPENDRIVER
|————————————Node:type_identifier Text: XLOPENDRIVER
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlOpenDriver")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlOpenDriver")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlOpenDriver"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlOpenDriver
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver");
|—————————Node:assignment_expression Text: xlDllCloseDriver          = (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver")
|——————————Node:identifier Text: xlDllCloseDriver
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCLOSEDRIVER)               GetProcAddress(hxlDll,"xlCloseDriver")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCLOSEDRIVER
|————————————Node:type_identifier Text: XLCLOSEDRIVER
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCloseDriver")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCloseDriver")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCloseDriver"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCloseDriver
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: /* bus independed functions */
|————————Node:expression_statement Text: xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig");
|—————————Node:assignment_expression Text: xlGetApplConfig            = (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig")
|——————————Node:identifier Text: xlGetApplConfig
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETAPPLCONFIG)            GetProcAddress(hxlDll,"xlGetApplConfig")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETAPPLCONFIG
|————————————Node:type_identifier Text: XLGETAPPLCONFIG
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetApplConfig")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetApplConfig")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetApplConfig"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetApplConfig
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig");
|—————————Node:assignment_expression Text: xlSetApplConfig            = (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig")
|——————————Node:identifier Text: xlSetApplConfig
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETAPPLCONFIG)            GetProcAddress(hxlDll,"xlSetApplConfig")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETAPPLCONFIG
|————————————Node:type_identifier Text: XLSETAPPLCONFIG
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlSetApplConfig")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlSetApplConfig")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetApplConfig"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetApplConfig
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig");
|—————————Node:assignment_expression Text: xlGetDriverConfig          = (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig")
|——————————Node:identifier Text: xlGetDriverConfig
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETDRIVERCONFIG)          GetProcAddress(hxlDll,"xlGetDriverConfig")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETDRIVERCONFIG
|————————————Node:type_identifier Text: XLGETDRIVERCONFIG
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetDriverConfig")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetDriverConfig")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetDriverConfig"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetDriverConfig
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex");
|—————————Node:assignment_expression Text: xlGetChannelIndex          = (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex")
|——————————Node:identifier Text: xlGetChannelIndex
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETCHANNELINDEX)          GetProcAddress(hxlDll,"xlGetChannelIndex")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETCHANNELINDEX
|————————————Node:type_identifier Text: XLGETCHANNELINDEX
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetChannelIndex")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetChannelIndex")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetChannelIndex"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetChannelIndex
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask");
|—————————Node:assignment_expression Text: xlGetChannelMask           = (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask")
|——————————Node:identifier Text: xlGetChannelMask
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETCHANNELMASK)           GetProcAddress(hxlDll,"xlGetChannelMask")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETCHANNELMASK
|————————————Node:type_identifier Text: XLGETCHANNELMASK
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetChannelMask")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetChannelMask")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetChannelMask"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetChannelMask
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort");
|—————————Node:assignment_expression Text: xlOpenPort                 = (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort")
|——————————Node:identifier Text: xlOpenPort
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLOPENPORT)                 GetProcAddress(hxlDll,"xlOpenPort")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLOPENPORT
|————————————Node:type_identifier Text: XLOPENPORT
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlOpenPort")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlOpenPort")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlOpenPort"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlOpenPort
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate");
|—————————Node:assignment_expression Text: xlSetTimerRate             = (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate")
|——————————Node:identifier Text: xlSetTimerRate
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETTIMERRATE)             GetProcAddress(hxlDll,"xlSetTimerRate")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETTIMERRATE
|————————————Node:type_identifier Text: XLSETTIMERRATE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlSetTimerRate")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlSetTimerRate")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetTimerRate"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetTimerRate
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock");
|—————————Node:assignment_expression Text: xlResetClock               = (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock")
|——————————Node:identifier Text: xlResetClock
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLRESETCLOCK)               GetProcAddress(hxlDll,"xlResetClock")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLRESETCLOCK
|————————————Node:type_identifier Text: XLRESETCLOCK
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlResetClock")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlResetClock")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlResetClock"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlResetClock
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification");
|—————————Node:assignment_expression Text: xlSetNotification          = (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification")
|——————————Node:identifier Text: xlSetNotification
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETNOTIFICATION)          GetProcAddress(hxlDll,"xlSetNotification")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETNOTIFICATION
|————————————Node:type_identifier Text: XLSETNOTIFICATION
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlSetNotification")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlSetNotification")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetNotification"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetNotification
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue");
|—————————Node:assignment_expression Text: xlFlushReceiveQueue        = (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue")
|——————————Node:identifier Text: xlFlushReceiveQueue
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLFLUSHRECEIVEQUEUE)        GetProcAddress(hxlDll,"xlFlushReceiveQueue")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLFLUSHRECEIVEQUEUE
|————————————Node:type_identifier Text: XLFLUSHRECEIVEQUEUE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlFlushReceiveQueue")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlFlushReceiveQueue")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlFlushReceiveQueue"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlFlushReceiveQueue
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel");
|—————————Node:assignment_expression Text: xlGetReceiveQueueLevel     = (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel")
|——————————Node:identifier Text: xlGetReceiveQueueLevel
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETRECEIVEQUEUELEVEL)     GetProcAddress(hxlDll,"xlGetReceiveQueueLevel")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETRECEIVEQUEUELEVEL
|————————————Node:type_identifier Text: XLGETRECEIVEQUEUELEVEL
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetReceiveQueueLevel")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetReceiveQueueLevel")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetReceiveQueueLevel"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetReceiveQueueLevel
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel");
|—————————Node:assignment_expression Text: xlActivateChannel          = (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel")
|——————————Node:identifier Text: xlActivateChannel
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLACTIVATECHANNEL)          GetProcAddress(hxlDll,"xlActivateChannel")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLACTIVATECHANNEL
|————————————Node:type_identifier Text: XLACTIVATECHANNEL
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlActivateChannel")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlActivateChannel")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlActivateChannel"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlActivateChannel
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive");
|—————————Node:assignment_expression Text: xlReceive                  = (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive")
|——————————Node:identifier Text: xlReceive
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLRECEIVE)                  GetProcAddress(hxlDll,"xlReceive")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLRECEIVE
|————————————Node:type_identifier Text: XLRECEIVE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlReceive")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlReceive")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlReceive"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlReceive
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString");
|—————————Node:assignment_expression Text: xlGetEventString           = (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString")
|——————————Node:identifier Text: xlGetEventString
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETEVENTSTRING)           GetProcAddress(hxlDll,"xlGetEventString")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETEVENTSTRING
|————————————Node:type_identifier Text: XLGETEVENTSTRING
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetEventString")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetEventString")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetEventString"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetEventString
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString");
|—————————Node:assignment_expression Text: xlGetErrorString           = (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString")
|——————————Node:identifier Text: xlGetErrorString
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETERRORSTRING)           GetProcAddress(hxlDll,"xlGetErrorString")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETERRORSTRING
|————————————Node:type_identifier Text: XLGETERRORSTRING
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetErrorString")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetErrorString")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetErrorString"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetErrorString
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse");
|—————————Node:assignment_expression Text: xlGenerateSyncPulse        = (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse")
|——————————Node:identifier Text: xlGenerateSyncPulse
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGENERATESYNCPULSE)        GetProcAddress(hxlDll,"xlGenerateSyncPulse")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGENERATESYNCPULSE
|————————————Node:type_identifier Text: XLGENERATESYNCPULSE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGenerateSyncPulse")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGenerateSyncPulse")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGenerateSyncPulse"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGenerateSyncPulse
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime");
|—————————Node:assignment_expression Text: xlGetSyncTime              = (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime")
|——————————Node:identifier Text: xlGetSyncTime
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETSYNCTIME)              GetProcAddress(hxlDll,"xlGetSyncTime")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETSYNCTIME
|————————————Node:type_identifier Text: XLGETSYNCTIME
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlGetSyncTime")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlGetSyncTime")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetSyncTime"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetSyncTime
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig");
|—————————Node:assignment_expression Text: xlPopupHwConfig            = (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig")
|——————————Node:identifier Text: xlPopupHwConfig
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLPOPUPHWCONFIG)            GetProcAddress(hxlDll,"xlPopupHwConfig")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLPOPUPHWCONFIG
|————————————Node:type_identifier Text: XLPOPUPHWCONFIG
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlPopupHwConfig")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlPopupHwConfig")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlPopupHwConfig"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlPopupHwConfig
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel");
|—————————Node:assignment_expression Text: xlDeactivateChannel        = (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel")
|——————————Node:identifier Text: xlDeactivateChannel
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLDEACTIVATECHANNEL)        GetProcAddress(hxlDll,"xlDeactivateChannel")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLDEACTIVATECHANNEL
|————————————Node:type_identifier Text: XLDEACTIVATECHANNEL
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlDeactivateChannel")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlDeactivateChannel")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlDeactivateChannel"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlDeactivateChannel
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort");
|—————————Node:assignment_expression Text: xlClosePort                = (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort")
|——————————Node:identifier Text: xlClosePort
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCLOSEPORT)                GetProcAddress(hxlDll,"xlClosePort")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCLOSEPORT
|————————————Node:type_identifier Text: XLCLOSEPORT
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlClosePort")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlClosePort")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlClosePort"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlClosePort
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify");
|—————————Node:assignment_expression Text: xlSetTimerBasedNotify      = (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify")
|——————————Node:identifier Text: xlSetTimerBasedNotify
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETTIMERBASEDNOTIFY)      GetProcAddress(hxlDll,"xlSetTimerBasedNotify")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETTIMERBASEDNOTIFY
|————————————Node:type_identifier Text: XLSETTIMERBASEDNOTIFY
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlSetTimerBasedNotify")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlSetTimerBasedNotify")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetTimerBasedNotify"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetTimerBasedNotify
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel");
|—————————Node:assignment_expression Text: xlSetTimerRateAndChannel   = (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel")
|——————————Node:identifier Text: xlSetTimerRateAndChannel
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETTIMERRATEANDCHANNEL)   GetProcAddress(hxlDll, "xlSetTimerRateAndChannel")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETTIMERRATEANDCHANNEL
|————————————Node:type_identifier Text: XLSETTIMERRATEANDCHANNEL
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll, "xlSetTimerRateAndChannel")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll, "xlSetTimerRateAndChannel")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetTimerRateAndChannel"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetTimerRateAndChannel
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo");
|—————————Node:assignment_expression Text: xlGetLicenseInfo           = (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo")
|——————————Node:identifier Text: xlGetLicenseInfo
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLGETLICENSEINFO)           GetProcAddress(hxlDll, "xlGetLicenseInfo")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLGETLICENSEINFO
|————————————Node:type_identifier Text: XLGETLICENSEINFO
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll, "xlGetLicenseInfo")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll, "xlGetLicenseInfo")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlGetLicenseInfo"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlGetLicenseInfo
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync");
|—————————Node:assignment_expression Text: xlSetGlobalTimeSync        = (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync")
|——————————Node:identifier Text: xlSetGlobalTimeSync
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLSETGLOBALTIMESYNC)        GetProcAddress(hxlDll, "xlSetGlobalTimeSync")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLSETGLOBALTIMESYNC
|————————————Node:type_identifier Text: XLSETGLOBALTIMESYNC
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll, "xlSetGlobalTimeSync")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll, "xlSetGlobalTimeSync")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlSetGlobalTimeSync"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlSetGlobalTimeSync
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: /* CAN specific functions */
|————————Node:expression_statement Text: xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput");
|—————————Node:assignment_expression Text: xlCanSetChannelOutput      = (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput")
|——————————Node:identifier Text: xlCanSetChannelOutput
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELOUTPUT)      GetProcAddress(hxlDll,"xlCanSetChannelOutput")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELOUTPUT
|————————————Node:type_identifier Text: XLCANSETCHANNELOUTPUT
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelOutput")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelOutput")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelOutput"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelOutput
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode");
|—————————Node:assignment_expression Text: xlCanSetChannelMode        = (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode")
|——————————Node:identifier Text: xlCanSetChannelMode
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELMODE)        GetProcAddress(hxlDll,"xlCanSetChannelMode")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELMODE
|————————————Node:type_identifier Text: XLCANSETCHANNELMODE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelMode")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelMode")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelMode"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelMode
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode");
|—————————Node:assignment_expression Text: xlCanSetReceiveMode        = (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode")
|——————————Node:identifier Text: xlCanSetReceiveMode
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETRECEIVEMODE)        GetProcAddress(hxlDll,"xlCanSetReceiveMode")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETRECEIVEMODE
|————————————Node:type_identifier Text: XLCANSETRECEIVEMODE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetReceiveMode")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetReceiveMode")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetReceiveMode"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetReceiveMode
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver");
|—————————Node:assignment_expression Text: xlCanSetChannelTransceiver = (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver")
|——————————Node:identifier Text: xlCanSetChannelTransceiver
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELTRANSCEIVER) GetProcAddress(hxlDll,"xlCanSetChannelTransceiver")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELTRANSCEIVER
|————————————Node:type_identifier Text: XLCANSETCHANNELTRANSCEIVER
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelTransceiver")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelTransceiver")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelTransceiver"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelTransceiver
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams");
|—————————Node:assignment_expression Text: xlCanSetChannelParams      = (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams")
|——————————Node:identifier Text: xlCanSetChannelParams
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELPARAMS)      GetProcAddress(hxlDll,"xlCanSetChannelParams")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELPARAMS
|————————————Node:type_identifier Text: XLCANSETCHANNELPARAMS
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelParams")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelParams")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelParams"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelParams
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200");
|—————————Node:assignment_expression Text: xlCanSetChannelParamsC200  = (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200")
|——————————Node:identifier Text: xlCanSetChannelParamsC200
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELPARAMSC200)  GetProcAddress(hxlDll,"xlCanSetChannelParamsC200")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELPARAMSC200
|————————————Node:type_identifier Text: XLCANSETCHANNELPARAMSC200
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelParamsC200")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelParamsC200")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelParamsC200"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelParamsC200
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate");
|—————————Node:assignment_expression Text: xlCanSetChannelBitrate     = (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate")
|——————————Node:identifier Text: xlCanSetChannelBitrate
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELBITRATE)     GetProcAddress(hxlDll,"xlCanSetChannelBitrate")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELBITRATE
|————————————Node:type_identifier Text: XLCANSETCHANNELBITRATE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelBitrate")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelBitrate")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelBitrate"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelBitrate
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance");
|—————————Node:assignment_expression Text: xlCanSetChannelAcceptance  = (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance")
|——————————Node:identifier Text: xlCanSetChannelAcceptance
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANSETCHANNELACCEPTANCE)  GetProcAddress(hxlDll,"xlCanSetChannelAcceptance")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANSETCHANNELACCEPTANCE
|————————————Node:type_identifier Text: XLCANSETCHANNELACCEPTANCE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanSetChannelAcceptance")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanSetChannelAcceptance")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanSetChannelAcceptance"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanSetChannelAcceptance
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange");
|—————————Node:assignment_expression Text: xlCanAddAcceptanceRange    = (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange")
|——————————Node:identifier Text: xlCanAddAcceptanceRange
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANADDACCEPTANCERANGE)    GetProcAddress(hxlDll,"xlCanAddAcceptanceRange")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANADDACCEPTANCERANGE
|————————————Node:type_identifier Text: XLCANADDACCEPTANCERANGE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanAddAcceptanceRange")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanAddAcceptanceRange")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanAddAcceptanceRange"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanAddAcceptanceRange
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange");
|—————————Node:assignment_expression Text: xlCanRemoveAcceptanceRange = (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange")
|——————————Node:identifier Text: xlCanRemoveAcceptanceRange
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANREMOVEACCEPTANCERANGE) GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANREMOVEACCEPTANCERANGE
|————————————Node:type_identifier Text: XLCANREMOVEACCEPTANCERANGE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanRemoveAcceptanceRange")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanRemoveAcceptanceRange")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanRemoveAcceptanceRange"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanRemoveAcceptanceRange
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance");
|—————————Node:assignment_expression Text: xlCanResetAcceptance       = (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance")
|——————————Node:identifier Text: xlCanResetAcceptance
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANRESETACCEPTANCE)       GetProcAddress(hxlDll,"xlCanResetAcceptance")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANRESETACCEPTANCE
|————————————Node:type_identifier Text: XLCANRESETACCEPTANCE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanResetAcceptance")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanResetAcceptance")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanResetAcceptance"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanResetAcceptance
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState");
|—————————Node:assignment_expression Text: xlCanRequestChipState      = (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState")
|——————————Node:identifier Text: xlCanRequestChipState
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANREQUESTCHIPSTATE)      GetProcAddress(hxlDll,"xlCanRequestChipState")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANREQUESTCHIPSTATE
|————————————Node:type_identifier Text: XLCANREQUESTCHIPSTATE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanRequestChipState")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanRequestChipState")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanRequestChipState"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanRequestChipState
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue");
|—————————Node:assignment_expression Text: xlCanFlushTransmitQueue    = (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue")
|——————————Node:identifier Text: xlCanFlushTransmitQueue
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANFLUSHTRANSMITQUEUE)    GetProcAddress(hxlDll,"xlCanFlushTransmitQueue")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANFLUSHTRANSMITQUEUE
|————————————Node:type_identifier Text: XLCANFLUSHTRANSMITQUEUE
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanFlushTransmitQueue")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanFlushTransmitQueue")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanFlushTransmitQueue"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanFlushTransmitQueue
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit");
|—————————Node:assignment_expression Text: xlCanTransmit              = (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit")
|——————————Node:identifier Text: xlCanTransmit
|——————————Node:= Text: =
|——————————Node:cast_expression Text: (XLCANTRANSMIT)              GetProcAddress(hxlDll,"xlCanTransmit")
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: XLCANTRANSMIT
|————————————Node:type_identifier Text: XLCANTRANSMIT
|———————————Node:) Text: )
|———————————Node:call_expression Text: GetProcAddress(hxlDll,"xlCanTransmit")
|————————————Node:identifier Text: GetProcAddress
|————————————Node:argument_list Text: (hxlDll,"xlCanTransmit")
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "xlCanTransmit"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: xlCanTransmit
|——————————————Node:" Text: "
|—————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:comment Text: /* check for error */
|————————Node:if_statement Text: if (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
            {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (!xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit || !xlSetGlobalTimeSync
|———————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue ||
                    !xlCanTransmit
|————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState || !xlCanFlushTransmitQueue
|—————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance ||
                    !xlCanRequestChipState
|——————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange || !xlCanResetAcceptance
|———————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange ||
                    !xlCanRemoveAcceptanceRange
|————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance || !xlCanAddAcceptanceRange
|—————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate ||
                    !xlCanSetChannelAcceptance
|——————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200 || !xlCanSetChannelBitrate
|———————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams ||
                    !xlCanSetChannelParamsC200
|————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver || !xlCanSetChannelParams
|—————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode ||
                    !xlCanSetChannelTransceiver
|——————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode || !xlCanSetReceiveMode
|———————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput ||
                    !xlCanSetChannelMode
|————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo || !xlCanSetChannelOutput
|—————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel ||
                    !xlGetLicenseInfo
|——————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify || !xlSetTimerRateAndChannel
|———————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort ||
                    !xlSetTimerBasedNotify
|————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel || !xlClosePort
|—————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig ||
                    !xlDeactivateChannel
|——————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime || !xlPopupHwConfig
|———————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse ||
                    !xlGetSyncTime
|————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString || !xlGenerateSyncPulse
|—————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString ||
                    !xlGetErrorString
|——————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive || !xlGetEventString
|———————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel ||
                    !xlReceive
|————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel || !xlActivateChannel
|—————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue ||
                    !xlGetReceiveQueueLevel
|——————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification || !xlFlushReceiveQueue
|———————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock ||
                    !xlSetNotification
|————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate || !xlResetClock
|—————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort ||
                    !xlSetTimerRate
|——————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask || !xlOpenPort
|———————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex ||
                    !xlGetChannelMask
|————————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig || !xlGetChannelIndex
|—————————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig ||
                    !xlGetDriverConfig
|——————————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig || !xlSetApplConfig
|———————————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver ||
                    !xlGetApplConfig
|————————————————————————————————————————————————Node:binary_expression Text: !xlDllOpenDriver || !xlDllCloseDriver
|—————————————————————————————————————————————————Node:unary_expression Text: !xlDllOpenDriver
|——————————————————————————————————————————————————Node:! Text: !
|——————————————————————————————————————————————————Node:identifier Text: xlDllOpenDriver
|—————————————————————————————————————————————————Node:|| Text: ||
|—————————————————————————————————————————————————Node:unary_expression Text: !xlDllCloseDriver
|——————————————————————————————————————————————————Node:! Text: !
|——————————————————————————————————————————————————Node:identifier Text: xlDllCloseDriver
|————————————————————————————————————————————————Node:|| Text: ||
|————————————————————————————————————————————————Node:unary_expression Text: !xlGetApplConfig
|—————————————————————————————————————————————————Node:! Text: !
|—————————————————————————————————————————————————Node:identifier Text: xlGetApplConfig
|———————————————————————————————————————————————Node:|| Text: ||
|———————————————————————————————————————————————Node:unary_expression Text: !xlSetApplConfig
|————————————————————————————————————————————————Node:! Text: !
|————————————————————————————————————————————————Node:identifier Text: xlSetApplConfig
|——————————————————————————————————————————————Node:|| Text: ||
|——————————————————————————————————————————————Node:unary_expression Text: !xlGetDriverConfig
|———————————————————————————————————————————————Node:! Text: !
|———————————————————————————————————————————————Node:identifier Text: xlGetDriverConfig
|—————————————————————————————————————————————Node:|| Text: ||
|—————————————————————————————————————————————Node:unary_expression Text: !xlGetChannelIndex
|——————————————————————————————————————————————Node:! Text: !
|——————————————————————————————————————————————Node:identifier Text: xlGetChannelIndex
|————————————————————————————————————————————Node:|| Text: ||
|————————————————————————————————————————————Node:unary_expression Text: !xlGetChannelMask
|—————————————————————————————————————————————Node:! Text: !
|—————————————————————————————————————————————Node:identifier Text: xlGetChannelMask
|———————————————————————————————————————————Node:|| Text: ||
|———————————————————————————————————————————Node:unary_expression Text: !xlOpenPort
|————————————————————————————————————————————Node:! Text: !
|————————————————————————————————————————————Node:identifier Text: xlOpenPort
|——————————————————————————————————————————Node:|| Text: ||
|——————————————————————————————————————————Node:unary_expression Text: !xlSetTimerRate
|———————————————————————————————————————————Node:! Text: !
|———————————————————————————————————————————Node:identifier Text: xlSetTimerRate
|—————————————————————————————————————————Node:|| Text: ||
|—————————————————————————————————————————Node:unary_expression Text: !xlResetClock
|——————————————————————————————————————————Node:! Text: !
|——————————————————————————————————————————Node:identifier Text: xlResetClock
|————————————————————————————————————————Node:|| Text: ||
|————————————————————————————————————————Node:unary_expression Text: !xlSetNotification
|—————————————————————————————————————————Node:! Text: !
|—————————————————————————————————————————Node:identifier Text: xlSetNotification
|———————————————————————————————————————Node:|| Text: ||
|———————————————————————————————————————Node:unary_expression Text: !xlFlushReceiveQueue
|————————————————————————————————————————Node:! Text: !
|————————————————————————————————————————Node:identifier Text: xlFlushReceiveQueue
|——————————————————————————————————————Node:|| Text: ||
|——————————————————————————————————————Node:unary_expression Text: !xlGetReceiveQueueLevel
|———————————————————————————————————————Node:! Text: !
|———————————————————————————————————————Node:identifier Text: xlGetReceiveQueueLevel
|—————————————————————————————————————Node:|| Text: ||
|—————————————————————————————————————Node:unary_expression Text: !xlActivateChannel
|——————————————————————————————————————Node:! Text: !
|——————————————————————————————————————Node:identifier Text: xlActivateChannel
|————————————————————————————————————Node:|| Text: ||
|————————————————————————————————————Node:unary_expression Text: !xlReceive
|—————————————————————————————————————Node:! Text: !
|—————————————————————————————————————Node:identifier Text: xlReceive
|———————————————————————————————————Node:|| Text: ||
|———————————————————————————————————Node:unary_expression Text: !xlGetEventString
|————————————————————————————————————Node:! Text: !
|————————————————————————————————————Node:identifier Text: xlGetEventString
|——————————————————————————————————Node:|| Text: ||
|——————————————————————————————————Node:unary_expression Text: !xlGetErrorString
|———————————————————————————————————Node:! Text: !
|———————————————————————————————————Node:identifier Text: xlGetErrorString
|—————————————————————————————————Node:|| Text: ||
|—————————————————————————————————Node:unary_expression Text: !xlGenerateSyncPulse
|——————————————————————————————————Node:! Text: !
|——————————————————————————————————Node:identifier Text: xlGenerateSyncPulse
|————————————————————————————————Node:|| Text: ||
|————————————————————————————————Node:unary_expression Text: !xlGetSyncTime
|—————————————————————————————————Node:! Text: !
|—————————————————————————————————Node:identifier Text: xlGetSyncTime
|———————————————————————————————Node:|| Text: ||
|———————————————————————————————Node:unary_expression Text: !xlPopupHwConfig
|————————————————————————————————Node:! Text: !
|————————————————————————————————Node:identifier Text: xlPopupHwConfig
|——————————————————————————————Node:|| Text: ||
|——————————————————————————————Node:unary_expression Text: !xlDeactivateChannel
|———————————————————————————————Node:! Text: !
|———————————————————————————————Node:identifier Text: xlDeactivateChannel
|—————————————————————————————Node:|| Text: ||
|—————————————————————————————Node:unary_expression Text: !xlClosePort
|——————————————————————————————Node:! Text: !
|——————————————————————————————Node:identifier Text: xlClosePort
|————————————————————————————Node:|| Text: ||
|————————————————————————————Node:unary_expression Text: !xlSetTimerBasedNotify
|—————————————————————————————Node:! Text: !
|—————————————————————————————Node:identifier Text: xlSetTimerBasedNotify
|———————————————————————————Node:|| Text: ||
|———————————————————————————Node:unary_expression Text: !xlSetTimerRateAndChannel
|————————————————————————————Node:! Text: !
|————————————————————————————Node:identifier Text: xlSetTimerRateAndChannel
|——————————————————————————Node:|| Text: ||
|——————————————————————————Node:unary_expression Text: !xlGetLicenseInfo
|———————————————————————————Node:! Text: !
|———————————————————————————Node:identifier Text: xlGetLicenseInfo
|—————————————————————————Node:|| Text: ||
|—————————————————————————Node:unary_expression Text: !xlCanSetChannelOutput
|——————————————————————————Node:! Text: !
|——————————————————————————Node:identifier Text: xlCanSetChannelOutput
|————————————————————————Node:|| Text: ||
|————————————————————————Node:unary_expression Text: !xlCanSetChannelMode
|—————————————————————————Node:! Text: !
|—————————————————————————Node:identifier Text: xlCanSetChannelMode
|———————————————————————Node:|| Text: ||
|———————————————————————Node:unary_expression Text: !xlCanSetReceiveMode
|————————————————————————Node:! Text: !
|————————————————————————Node:identifier Text: xlCanSetReceiveMode
|——————————————————————Node:|| Text: ||
|——————————————————————Node:unary_expression Text: !xlCanSetChannelTransceiver
|———————————————————————Node:! Text: !
|———————————————————————Node:identifier Text: xlCanSetChannelTransceiver
|—————————————————————Node:|| Text: ||
|—————————————————————Node:unary_expression Text: !xlCanSetChannelParams
|——————————————————————Node:! Text: !
|——————————————————————Node:identifier Text: xlCanSetChannelParams
|————————————————————Node:|| Text: ||
|————————————————————Node:unary_expression Text: !xlCanSetChannelParamsC200
|—————————————————————Node:! Text: !
|—————————————————————Node:identifier Text: xlCanSetChannelParamsC200
|———————————————————Node:|| Text: ||
|———————————————————Node:unary_expression Text: !xlCanSetChannelBitrate
|————————————————————Node:! Text: !
|————————————————————Node:identifier Text: xlCanSetChannelBitrate
|——————————————————Node:|| Text: ||
|——————————————————Node:unary_expression Text: !xlCanSetChannelAcceptance
|———————————————————Node:! Text: !
|———————————————————Node:identifier Text: xlCanSetChannelAcceptance
|—————————————————Node:|| Text: ||
|—————————————————Node:unary_expression Text: !xlCanAddAcceptanceRange
|——————————————————Node:! Text: !
|——————————————————Node:identifier Text: xlCanAddAcceptanceRange
|————————————————Node:|| Text: ||
|————————————————Node:unary_expression Text: !xlCanRemoveAcceptanceRange
|—————————————————Node:! Text: !
|—————————————————Node:identifier Text: xlCanRemoveAcceptanceRange
|———————————————Node:|| Text: ||
|———————————————Node:unary_expression Text: !xlCanResetAcceptance
|————————————————Node:! Text: !
|————————————————Node:identifier Text: xlCanResetAcceptance
|——————————————Node:|| Text: ||
|——————————————Node:unary_expression Text: !xlCanRequestChipState
|———————————————Node:! Text: !
|———————————————Node:identifier Text: xlCanRequestChipState
|—————————————Node:|| Text: ||
|—————————————Node:unary_expression Text: !xlCanFlushTransmitQueue
|——————————————Node:! Text: !
|——————————————Node:identifier Text: xlCanFlushTransmitQueue
|————————————Node:|| Text: ||
|————————————Node:unary_expression Text: !xlCanTransmit
|—————————————Node:! Text: !
|—————————————Node:identifier Text: xlCanTransmit
|———————————Node:|| Text: ||
|———————————Node:unary_expression Text: !xlSetGlobalTimeSync
|————————————Node:! Text: !
|————————————Node:identifier Text: xlSetGlobalTimeSync
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                FreeLibrary(hxlDll);
                sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
                hResult = ERR_LOAD_DRIVER;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: FreeLibrary(hxlDll);
|———————————Node:call_expression Text: FreeLibrary(hxlDll)
|————————————Node:identifier Text: FreeLibrary
|————————————Node:argument_list Text: (hxlDll)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: hxlDll
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"));
|———————————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"))
|————————————Node:field_expression Text: sg_pIlog->vLogAMessage
|—————————————Node:identifier Text: sg_pIlog
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: vLogAMessage
|————————————Node:argument_list Text: (A2T(__FILE__),
                                       __LINE__, _T("Getting Process address of the APIs failed"))
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: A2T(__FILE__)
|——————————————Node:identifier Text: A2T
|——————————————Node:argument_list Text: (__FILE__)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: __FILE__
|———————————————Node:) Text: )
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: __LINE__
|—————————————Node:, Text: ,
|—————————————Node:call_expression Text: _T("Getting Process address of the APIs failed")
|——————————————Node:identifier Text: _T
|——————————————Node:argument_list Text: ("Getting Process address of the APIs failed")
|———————————————Node:( Text: (
|———————————————Node:string_literal Text: "Getting Process address of the APIs failed"
|————————————————Node:" Text: "
|————————————————Node:string_content Text: Getting Process address of the APIs failed
|————————————————Node:" Text: "
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: hResult = ERR_LOAD_DRIVER;
|———————————Node:assignment_expression Text: hResult = ERR_LOAD_DRIVER
|————————————Node:identifier Text: hResult
|————————————Node:= Text: =
|————————————Node:identifier Text: ERR_LOAD_DRIVER
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Performs intial operations.
*                Initializes filter, queue, controller config with default values.
* \param         void
* \return        S_OK if the open driver call successfull otherwise S_FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_PerformInitOperations(void)
{
    HRESULT hResult = S_FALSE;

    /* Register Monitor client */
    DWORD dwClientID = 0;
    CAN_RegisterClient(TRUE, dwClientID, CAN_MONITOR_NODE);

    // ------------------------------------
    // open the driver
    // ------------------------------------
    if (xlDllOpenDriver() == XL_SUCCESS)
    {
        hResult = S_OK;
    }

    //Initialize the selected channel items array to -1
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_PerformInitOperations(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_PerformInitOperations
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_PerformInitOperations
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;

    /* Register Monitor client */
    DWORD dwClientID = 0;
    CAN_RegisterClient(TRUE, dwClientID, CAN_MONITOR_NODE);

    // ------------------------------------
    // open the driver
    // ------------------------------------
    if (xlDllOpenDriver() == XL_SUCCESS)
    {
        hResult = S_OK;
    }

    //Initialize the selected channel items array to -1
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_FALSE;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_FALSE
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_FALSE
|————Node:; Text: ;
|———Node:comment Text: /* Register Monitor client */
|———Node:declaration Text: DWORD dwClientID = 0;
|————Node:type_identifier Text: DWORD
|————Node:init_declarator Text: dwClientID = 0
|—————Node:identifier Text: dwClientID
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: CAN_RegisterClient(TRUE, dwClientID, CAN_MONITOR_NODE);
|————Node:call_expression Text: CAN_RegisterClient(TRUE, dwClientID, CAN_MONITOR_NODE)
|—————Node:identifier Text: CAN_RegisterClient
|—————Node:argument_list Text: (TRUE, dwClientID, CAN_MONITOR_NODE)
|——————Node:( Text: (
|——————Node:true Text: TRUE
|——————Node:, Text: ,
|——————Node:identifier Text: dwClientID
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_MONITOR_NODE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // ------------------------------------
|———Node:comment Text: // open the driver
|———Node:comment Text: // ------------------------------------
|———Node:if_statement Text: if (xlDllOpenDriver() == XL_SUCCESS)
    {
        hResult = S_OK;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (xlDllOpenDriver() == XL_SUCCESS)
|—————Node:( Text: (
|—————Node:binary_expression Text: xlDllOpenDriver() == XL_SUCCESS
|——————Node:call_expression Text: xlDllOpenDriver()
|———————Node:identifier Text: xlDllOpenDriver
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: XL_SUCCESS
|—————Node:) Text: )
|————Node:compound_statement Text: {
        hResult = S_OK;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: hResult = S_OK;
|——————Node:assignment_expression Text: hResult = S_OK
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: S_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: //Initialize the selected channel items array to -1
|———Node:for_statement Text: for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i< CHANNEL_ALLOWED
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: CHANNEL_ALLOWED
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sg_anSelectedItems[i] = -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_anSelectedItems[i] = -1;
|——————Node:assignment_expression Text: sg_anSelectedItems[i] = -1
|———————Node:subscript_expression Text: sg_anSelectedItems[i]
|————————Node:identifier Text: sg_anSelectedItems
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Performs closure operations.
* \param         void
* \return        S_OK if the CAN_StopHardware call successfull otherwise S_FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_PerformClosureOperations(void)
{
    HRESULT hResult = S_OK;

    hResult = CAN_StopHardware();

    if (hResult == S_OK)
    {
        // ------------------------------------
        // Close the driver
        // ------------------------------------
        if (NULL != xlDllCloseDriver)
        {
            xlDllCloseDriver();
        }

        UINT ClientIndex = 0;
        while (sg_unClientCnt > 0)
        {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }

        if (hResult == S_OK)
        {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_PerformClosureOperations(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_PerformClosureOperations
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_PerformClosureOperations
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;

    hResult = CAN_StopHardware();

    if (hResult == S_OK)
    {
        // ------------------------------------
        // Close the driver
        // ------------------------------------
        if (NULL != xlDllCloseDriver)
        {
            xlDllCloseDriver();
        }

        UINT ClientIndex = 0;
        while (sg_unClientCnt > 0)
        {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }

        if (hResult == S_OK)
        {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:expression_statement Text: hResult = CAN_StopHardware();
|————Node:assignment_expression Text: hResult = CAN_StopHardware()
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:call_expression Text: CAN_StopHardware()
|——————Node:identifier Text: CAN_StopHardware
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (hResult == S_OK)
    {
        // ------------------------------------
        // Close the driver
        // ------------------------------------
        if (NULL != xlDllCloseDriver)
        {
            xlDllCloseDriver();
        }

        UINT ClientIndex = 0;
        while (sg_unClientCnt > 0)
        {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }

        if (hResult == S_OK)
        {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hResult == S_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: hResult == S_OK
|——————Node:identifier Text: hResult
|——————Node:== Text: ==
|——————Node:identifier Text: S_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // ------------------------------------
        // Close the driver
        // ------------------------------------
        if (NULL != xlDllCloseDriver)
        {
            xlDllCloseDriver();
        }

        UINT ClientIndex = 0;
        while (sg_unClientCnt > 0)
        {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }

        if (hResult == S_OK)
        {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // ------------------------------------
|—————Node:comment Text: // Close the driver
|—————Node:comment Text: // ------------------------------------
|—————Node:if_statement Text: if (NULL != xlDllCloseDriver)
        {
            xlDllCloseDriver();
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (NULL != xlDllCloseDriver)
|———————Node:( Text: (
|———————Node:binary_expression Text: NULL != xlDllCloseDriver
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:!= Text: !=
|————————Node:identifier Text: xlDllCloseDriver
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            xlDllCloseDriver();
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: xlDllCloseDriver();
|————————Node:call_expression Text: xlDllCloseDriver()
|—————————Node:identifier Text: xlDllCloseDriver
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:declaration Text: UINT ClientIndex = 0;
|——————Node:type_identifier Text: UINT
|——————Node:init_declarator Text: ClientIndex = 0
|———————Node:identifier Text: ClientIndex
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:while_statement Text: while (sg_unClientCnt > 0)
        {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }
|——————Node:while Text: while
|——————Node:condition_clause Text: (sg_unClientCnt > 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_unClientCnt > 0
|————————Node:identifier Text: sg_unClientCnt
|————————Node:> Text: >
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID);
|————————Node:call_expression Text: bRemoveClient(sg_asClientToBufMap[ClientIndex].dwClientID)
|—————————Node:identifier Text: bRemoveClient
|—————————Node:argument_list Text: (sg_asClientToBufMap[ClientIndex].dwClientID)
|——————————Node:( Text: (
|——————————Node:field_expression Text: sg_asClientToBufMap[ClientIndex].dwClientID
|———————————Node:subscript_expression Text: sg_asClientToBufMap[ClientIndex]
|————————————Node:identifier Text: sg_asClientToBufMap
|————————————Node:subscript_argument_list Text: [ClientIndex]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: ClientIndex
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: dwClientID
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (hResult == S_OK)
        {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (hResult == S_OK)
|———————Node:( Text: (
|———————Node:binary_expression Text: hResult == S_OK
|————————Node:identifier Text: hResult
|————————Node:== Text: ==
|————————Node:identifier Text: S_OK
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sg_bCurrState = STATE_DRIVER_SELECTED;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sg_bCurrState = STATE_DRIVER_SELECTED;
|————————Node:assignment_expression Text: sg_bCurrState = STATE_DRIVER_SELECTED
|—————————Node:identifier Text: sg_bCurrState
|—————————Node:= Text: =
|—————————Node:identifier Text: STATE_DRIVER_SELECTED
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Gets the time mode mapping of the hardware. CurrSysTime
*                will be updated with the system time ref.
*                TimeStamp will be updated with the corresponding timestamp.
* \param[out]    CurrSysTime, is SYSTEMTIME structure
* \param[out]    TimeStamp, is UINT64
* \param[out]    QueryTickCount, is LARGE_INTEGER
* \return        S_OK for success
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
{
    memcpy(&CurrSysTime, &sg_CurrSysTime, sizeof(SYSTEMTIME));
    TimeStamp = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetTimeModeMapping
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetTimeModeMapping
|———Node:parameter_list Text: (SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
|————Node:( Text: (
|————Node:parameter_declaration Text: SYSTEMTIME& CurrSysTime
|—————Node:type_identifier Text: SYSTEMTIME
|—————Node:reference_declarator Text: & CurrSysTime
|——————Node:& Text: &
|——————Node:identifier Text: CurrSysTime
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT64& TimeStamp
|—————Node:type_identifier Text: UINT64
|—————Node:reference_declarator Text: & TimeStamp
|——————Node:& Text: &
|——————Node:identifier Text: TimeStamp
|————Node:, Text: ,
|————Node:parameter_declaration Text: LARGE_INTEGER* QueryTickCount
|—————Node:type_identifier Text: LARGE_INTEGER
|—————Node:pointer_declarator Text: * QueryTickCount
|——————Node:* Text: *
|——————Node:identifier Text: QueryTickCount
|————Node:) Text: )
|——Node:compound_statement Text: {
    memcpy(&CurrSysTime, &sg_CurrSysTime, sizeof(SYSTEMTIME));
    TimeStamp = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: memcpy(&CurrSysTime, &sg_CurrSysTime, sizeof(SYSTEMTIME));
|————Node:call_expression Text: memcpy(&CurrSysTime, &sg_CurrSysTime, sizeof(SYSTEMTIME))
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: (&CurrSysTime, &sg_CurrSysTime, sizeof(SYSTEMTIME))
|——————Node:( Text: (
|——————Node:pointer_expression Text: &CurrSysTime
|———————Node:& Text: &
|———————Node:identifier Text: CurrSysTime
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &sg_CurrSysTime
|———————Node:& Text: &
|———————Node:identifier Text: sg_CurrSysTime
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(SYSTEMTIME)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (SYSTEMTIME)
|————————Node:( Text: (
|————————Node:identifier Text: SYSTEMTIME
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: TimeStamp = sg_TimeStamp;
|————Node:assignment_expression Text: TimeStamp = sg_TimeStamp
|—————Node:identifier Text: TimeStamp
|—————Node:= Text: =
|—————Node:identifier Text: sg_TimeStamp
|————Node:; Text: ;
|———Node:if_statement Text: if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (QueryTickCount != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: QueryTickCount != NULL
|——————Node:identifier Text: QueryTickCount
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        *QueryTickCount = sg_QueryTickCount;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: *QueryTickCount = sg_QueryTickCount;
|——————Node:assignment_expression Text: *QueryTickCount = sg_QueryTickCount
|———————Node:pointer_expression Text: *QueryTickCount
|————————Node:* Text: *
|————————Node:identifier Text: QueryTickCount
|———————Node:= Text: =
|———————Node:identifier Text: sg_QueryTickCount
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Lists the hardware interface available.
* \param[out]    asSelHwInterface, is INTERFACE_HW_LIST structure
* \param[out]    nCount , is INT contains the selected channel count.
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
{
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;

    if (nInitHwNetwork() == 0)
    {
        nCount = sg_nNoOfChannels;
        for (UINT i = 0; i < sg_nNoOfChannels; i++)
        {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
        hResult = S_OK;
    }
    else
    {
        hResult = NO_HW_INTERFACE;
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
    }
    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_ListHwInterfaces
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_ListHwInterfaces
|———Node:parameter_list Text: (INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
|————Node:( Text: (
|————Node:parameter_declaration Text: INTERFACE_HW_LIST& asSelHwInterface
|—————Node:type_identifier Text: INTERFACE_HW_LIST
|—————Node:reference_declarator Text: & asSelHwInterface
|——————Node:& Text: &
|——————Node:identifier Text: asSelHwInterface
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT& nCount
|—————Node:type_identifier Text: INT
|—————Node:reference_declarator Text: & nCount
|——————Node:& Text: &
|——————Node:identifier Text: nCount
|————Node:) Text: )
|——Node:compound_statement Text: {
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;

    if (nInitHwNetwork() == 0)
    {
        nCount = sg_nNoOfChannels;
        for (UINT i = 0; i < sg_nNoOfChannels; i++)
        {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
        hResult = S_OK;
    }
    else
    {
        hResult = NO_HW_INTERFACE;
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
    }
    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_FALSE;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_FALSE
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_FALSE
|————Node:; Text: ;
|———Node:if_statement Text: if (nInitHwNetwork() == 0)
    {
        nCount = sg_nNoOfChannels;
        for (UINT i = 0; i < sg_nNoOfChannels; i++)
        {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
        hResult = S_OK;
    }
    else
    {
        hResult = NO_HW_INTERFACE;
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
    }
|————Node:if Text: if
|————Node:condition_clause Text: (nInitHwNetwork() == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: nInitHwNetwork() == 0
|——————Node:call_expression Text: nInitHwNetwork()
|———————Node:identifier Text: nInitHwNetwork
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        nCount = sg_nNoOfChannels;
        for (UINT i = 0; i < sg_nNoOfChannels; i++)
        {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
        hResult = S_OK;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: nCount = sg_nNoOfChannels;
|——————Node:assignment_expression Text: nCount = sg_nNoOfChannels
|———————Node:identifier Text: nCount
|———————Node:= Text: =
|———————Node:identifier Text: sg_nNoOfChannels
|——————Node:; Text: ;
|—————Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
        {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: UINT i = 0;
|———————Node:type_identifier Text: UINT
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < sg_nNoOfChannels
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: sg_nNoOfChannels
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            asSelHwInterface[i].m_dwIdInterface = i;
            unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
            ostringstream oss;
            oss << dec << serialNumber;
            asSelHwInterface[i].m_acDescription = oss.str();
            //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
            ostringstream oss1;
            oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
            oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
            sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();

            /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: asSelHwInterface[i].m_dwIdInterface = i;
|————————Node:assignment_expression Text: asSelHwInterface[i].m_dwIdInterface = i
|—————————Node:field_expression Text: asSelHwInterface[i].m_dwIdInterface
|——————————Node:subscript_expression Text: asSelHwInterface[i]
|———————————Node:identifier Text: asSelHwInterface
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_dwIdInterface
|—————————Node:= Text: =
|—————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:declaration Text: unsigned int serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber;
|————————Node:sized_type_specifier Text: unsigned int
|—————————Node:unsigned Text: unsigned
|—————————Node:primitive_type Text: int
|————————Node:init_declarator Text: serialNumber = sg_aodChannels[i].m_pXLChannelInfo->serialNumber
|—————————Node:identifier Text: serialNumber
|—————————Node:= Text: =
|—————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo->serialNumber
|——————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo
|———————————Node:subscript_expression Text: sg_aodChannels[i]
|————————————Node:identifier Text: sg_aodChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_pXLChannelInfo
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: serialNumber
|————————Node:; Text: ;
|———————Node:declaration Text: ostringstream oss;
|————————Node:type_identifier Text: ostringstream
|————————Node:identifier Text: oss
|————————Node:; Text: ;
|———————Node:expression_statement Text: oss << dec << serialNumber;
|————————Node:binary_expression Text: oss << dec << serialNumber
|—————————Node:binary_expression Text: oss << dec
|——————————Node:identifier Text: oss
|——————————Node:<< Text: <<
|——————————Node:identifier Text: dec
|—————————Node:<< Text: <<
|—————————Node:identifier Text: serialNumber
|————————Node:; Text: ;
|———————Node:expression_statement Text: asSelHwInterface[i].m_acDescription = oss.str();
|————————Node:assignment_expression Text: asSelHwInterface[i].m_acDescription = oss.str()
|—————————Node:field_expression Text: asSelHwInterface[i].m_acDescription
|——————————Node:subscript_expression Text: asSelHwInterface[i]
|———————————Node:identifier Text: asSelHwInterface
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_acDescription
|—————————Node:= Text: =
|—————————Node:call_expression Text: oss.str()
|——————————Node:field_expression Text: oss.str
|———————————Node:identifier Text: oss
|———————————Node:. Text: .
|———————————Node:field_identifier Text: str
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: //_stprintf(asSelHwInterface[i].m_acDescription, _T("%d"), serialNumber);
|———————Node:declaration Text: ostringstream oss1;
|————————Node:type_identifier Text: ostringstream
|————————Node:identifier Text: oss1
|————————Node:; Text: ;
|———————Node:expression_statement Text: oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber;
|————————Node:binary_expression Text: oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - " <<serialNumber
|—————————Node:binary_expression Text: oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name << " SN - "
|——————————Node:binary_expression Text: oss1 << "Vector - " << sg_aodChannels[i].m_pXLChannelInfo->name
|———————————Node:binary_expression Text: oss1 << "Vector - "
|————————————Node:identifier Text: oss1
|————————————Node:<< Text: <<
|————————————Node:string_literal Text: "Vector - "
|—————————————Node:" Text: "
|—————————————Node:string_content Text: Vector - 
|—————————————Node:" Text: "
|———————————Node:<< Text: <<
|———————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo->name
|————————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo
|—————————————Node:subscript_expression Text: sg_aodChannels[i]
|——————————————Node:identifier Text: sg_aodChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: m_pXLChannelInfo
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: name
|——————————Node:<< Text: <<
|——————————Node:string_literal Text: " SN - "
|———————————Node:" Text: "
|———————————Node:string_content Text:  SN - 
|———————————Node:" Text: "
|—————————Node:<< Text: <<
|—————————Node:identifier Text: serialNumber
|————————Node:; Text: ;
|———————Node:expression_statement Text: oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex;
|————————Node:binary_expression Text: oss1 << "Channel Index - " <<(int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex
|—————————Node:binary_expression Text: oss1 << "Channel Index - "
|——————————Node:identifier Text: oss1
|——————————Node:<< Text: <<
|——————————Node:string_literal Text: "Channel Index - "
|———————————Node:" Text: "
|———————————Node:string_content Text: Channel Index - 
|———————————Node:" Text: "
|—————————Node:<< Text: <<
|—————————Node:cast_expression Text: (int)sg_aodChannels[i].m_pXLChannelInfo->channelIndex
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: int
|———————————Node:primitive_type Text: int
|——————————Node:) Text: )
|——————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo->channelIndex
|———————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo
|————————————Node:subscript_expression Text: sg_aodChannels[i]
|—————————————Node:identifier Text: sg_aodChannels
|—————————————Node:subscript_argument_list Text: [i]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: i
|——————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_pXLChannelInfo
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: channelIndex
|————————Node:; Text: ;
|———————Node:expression_statement Text: sg_ControllerDetails[i].m_omHardwareDesc = oss1.str();
|————————Node:assignment_expression Text: sg_ControllerDetails[i].m_omHardwareDesc = oss1.str()
|—————————Node:field_expression Text: sg_ControllerDetails[i].m_omHardwareDesc
|——————————Node:subscript_expression Text: sg_ControllerDetails[i]
|———————————Node:identifier Text: sg_ControllerDetails
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_omHardwareDesc
|—————————Node:= Text: =
|—————————Node:call_expression Text: oss1.str()
|——————————Node:field_expression Text: oss1.str
|———————————Node:identifier Text: oss1
|———————————Node:. Text: .
|———————————Node:field_identifier Text: str
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: /*_stprintf(sg_ControllerDetails[i].m_omHardwareDesc, _T("Vector - %s SN - %d Channel Index - %d"),
                                        sg_aodChannels[i].m_pXLChannelInfo->name,
                                        serialNumber,
                                        sg_aodChannels[i].m_pXLChannelInfo->channelIndex);*/
|———————Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED;
|————————Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED
|—————————Node:identifier Text: sg_bCurrState
|—————————Node:= Text: =
|—————————Node:identifier Text: STATE_HW_INTERFACE_LISTED
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: hResult = S_OK;
|——————Node:assignment_expression Text: hResult = S_OK
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: S_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        hResult = NO_HW_INTERFACE;
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        hResult = NO_HW_INTERFACE;
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: hResult = NO_HW_INTERFACE;
|———————Node:assignment_expression Text: hResult = NO_HW_INTERFACE
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: NO_HW_INTERFACE
|———————Node:; Text: ;
|——————Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"));
|———————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Error connecting to driver"))
|————————Node:field_expression Text: sg_pIlog->vLogAMessage
|—————————Node:identifier Text: sg_pIlog
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: vLogAMessage
|————————Node:argument_list Text: (A2T(__FILE__), __LINE__, _T("Error connecting to driver"))
|—————————Node:( Text: (
|—————————Node:call_expression Text: A2T(__FILE__)
|——————————Node:identifier Text: A2T
|——————————Node:argument_list Text: (__FILE__)
|———————————Node:( Text: (
|———————————Node:identifier Text: __FILE__
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: __LINE__
|—————————Node:, Text: ,
|—————————Node:call_expression Text: _T("Error connecting to driver")
|——————————Node:identifier Text: _T
|——————————Node:argument_list Text: ("Error connecting to driver")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "Error connecting to driver"
|————————————Node:" Text: "
|————————————Node:string_content Text: Error connecting to driver
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Selects the hardware interface selected by the user.
* \param[out]    asSelHwInterface, is INTERFACE_HW_LIST structure
* \param[out]    nCount , is INT contains the selected channel count.
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_SelectHwInterface(const INTERFACE_HW_LIST& /*asSelHwInterface*/, INT /*nCount*/)
{
    USES_CONVERSION;

    VALIDATE_POINTER_RETURN_VAL(hxlDll, S_FALSE);

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    /* Check for the success */
    sg_bCurrState = STATE_HW_INTERFACE_SELECTED;

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_SelectHwInterface(const INTERFACE_HW_LIST& /*asSelHwInterface*/, INT /*nCount*/)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_SelectHwInterface
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_SelectHwInterface
|———Node:parameter_list Text: (const INTERFACE_HW_LIST& /*asSelHwInterface*/, INT /*nCount*/)
|————Node:( Text: (
|————Node:parameter_declaration Text: const INTERFACE_HW_LIST&
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INTERFACE_HW_LIST
|—————Node:abstract_reference_declarator Text: &
|——————Node:& Text: &
|————Node:comment Text: /*asSelHwInterface*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT
|—————Node:type_identifier Text: INT
|————Node:comment Text: /*nCount*/
|————Node:) Text: )
|——Node:compound_statement Text: {
    USES_CONVERSION;

    VALIDATE_POINTER_RETURN_VAL(hxlDll, S_FALSE);

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    /* Check for the success */
    sg_bCurrState = STATE_HW_INTERFACE_SELECTED;

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:expression_statement Text: VALIDATE_POINTER_RETURN_VAL(hxlDll, S_FALSE);
|————Node:call_expression Text: VALIDATE_POINTER_RETURN_VAL(hxlDll, S_FALSE)
|—————Node:identifier Text: VALIDATE_POINTER_RETURN_VAL
|—————Node:argument_list Text: (hxlDll, S_FALSE)
|——————Node:( Text: (
|——————Node:identifier Text: hxlDll
|——————Node:, Text: ,
|——————Node:identifier Text: S_FALSE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_HW_INTERFACE_LISTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Check for the success */
|———Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
|————Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED
|—————Node:identifier Text: sg_bCurrState
|—————Node:= Text: =
|—————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|————Node:; Text: ;
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Deselects the selected hardware interface.
* \param         void
* \return        S_OK if CAN_ResetHardware call is success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_DeselectHwInterface(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;

    hResult = CAN_ResetHardware();

    sg_bCurrState = STATE_HW_INTERFACE_LISTED;

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_DeselectHwInterface(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_DeselectHwInterface
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_DeselectHwInterface
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;

    hResult = CAN_ResetHardware();

    sg_bCurrState = STATE_HW_INTERFACE_LISTED;

    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:expression_statement Text: hResult = CAN_ResetHardware();
|————Node:assignment_expression Text: hResult = CAN_ResetHardware()
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:call_expression Text: CAN_ResetHardware()
|——————Node:identifier Text: CAN_ResetHardware
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED;
|————Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED
|—————Node:identifier Text: sg_bCurrState
|—————Node:= Text: =
|—————Node:identifier Text: STATE_HW_INTERFACE_LISTED
|————Node:; Text: ;
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Displays the controller configuration dialog.
* \param[out]    InitData, is SCONTROLLER_DETAILS structure
* \param[out]    Length , is INT
* \return        S_OK for success
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
{
    xlPopupHwConfig(NULL, INFINITE);

    //Get back the baud rate from controller
    SCONTROLLER_DETAILS* pCntrlDetails = (SCONTROLLER_DETAILS*)InitData;
    XLstatus xlStatus;

    xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    char chTemp[256];
    for ( UINT i = 0 ; i < sg_nNoOfChannels ; i++ )
    {
        sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ));
        pCntrlDetails[i].m_omStrBaudrate = chTemp;
    }

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_DisplayConfigDlg
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_DisplayConfigDlg
|———Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int& Length)
|————Node:( Text: (
|————Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|—————Node:type_identifier Text: PSCONTROLLER_DETAILS
|—————Node:identifier Text: InitData
|————Node:, Text: ,
|————Node:parameter_declaration Text: int& Length
|—————Node:primitive_type Text: int
|—————Node:reference_declarator Text: & Length
|——————Node:& Text: &
|——————Node:identifier Text: Length
|————Node:) Text: )
|——Node:compound_statement Text: {
    xlPopupHwConfig(NULL, INFINITE);

    //Get back the baud rate from controller
    SCONTROLLER_DETAILS* pCntrlDetails = (SCONTROLLER_DETAILS*)InitData;
    XLstatus xlStatus;

    xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    char chTemp[256];
    for ( UINT i = 0 ; i < sg_nNoOfChannels ; i++ )
    {
        sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ));
        pCntrlDetails[i].m_omStrBaudrate = chTemp;
    }

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: xlPopupHwConfig(NULL, INFINITE);
|————Node:call_expression Text: xlPopupHwConfig(NULL, INFINITE)
|—————Node:identifier Text: xlPopupHwConfig
|—————Node:argument_list Text: (NULL, INFINITE)
|——————Node:( Text: (
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:identifier Text: INFINITE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //Get back the baud rate from controller
|———Node:declaration Text: SCONTROLLER_DETAILS* pCntrlDetails = (SCONTROLLER_DETAILS*)InitData;
|————Node:type_identifier Text: SCONTROLLER_DETAILS
|————Node:init_declarator Text: * pCntrlDetails = (SCONTROLLER_DETAILS*)InitData
|—————Node:pointer_declarator Text: * pCntrlDetails
|——————Node:* Text: *
|——————Node:identifier Text: pCntrlDetails
|—————Node:= Text: =
|—————Node:cast_expression Text: (SCONTROLLER_DETAILS*)InitData
|——————Node:( Text: (
|——————Node:type_descriptor Text: SCONTROLLER_DETAILS*
|———————Node:type_identifier Text: SCONTROLLER_DETAILS
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: InitData
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus;
|————Node:type_identifier Text: XLstatus
|————Node:identifier Text: xlStatus
|————Node:; Text: ;
|———Node:expression_statement Text: xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
|————Node:assignment_expression Text: xlStatus = xlGetDriverConfig(&g_xlDrvConfig)
|—————Node:identifier Text: xlStatus
|—————Node:= Text: =
|—————Node:call_expression Text: xlGetDriverConfig(&g_xlDrvConfig)
|——————Node:identifier Text: xlGetDriverConfig
|——————Node:argument_list Text: (&g_xlDrvConfig)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &g_xlDrvConfig
|————————Node:& Text: &
|————————Node:identifier Text: g_xlDrvConfig
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: char chTemp[256];
|————Node:primitive_type Text: char
|————Node:array_declarator Text: chTemp[256]
|—————Node:identifier Text: chTemp
|—————Node:[ Text: [
|—————Node:number_literal Text: 256
|—————Node:] Text: ]
|————Node:; Text: ;
|———Node:for_statement Text: for ( UINT i = 0 ; i < sg_nNoOfChannels ; i++ )
    {
        sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ));
        pCntrlDetails[i].m_omStrBaudrate = chTemp;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0 ;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_nNoOfChannels
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_nNoOfChannels
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ));
        pCntrlDetails[i].m_omStrBaudrate = chTemp;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ));
|——————Node:call_expression Text: sprintf_s(chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ))
|———————Node:identifier Text: sprintf_s
|———————Node:argument_list Text: (chTemp, "%0.3f", float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 ))
|————————Node:( Text: (
|————————Node:identifier Text: chTemp
|————————Node:, Text: ,
|————————Node:string_literal Text: "%0.3f"
|—————————Node:" Text: "
|—————————Node:string_content Text: %0.3f
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:call_expression Text: float(
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 )
|—————————Node:primitive_type Text: float
|—————————Node:argument_list Text: (
                      g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000 )
|——————————Node:( Text: (
|——————————Node:binary_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate / 1000.000
|———————————Node:field_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can.bitRate
|————————————Node:field_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data.can
|—————————————Node:field_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams.data
|——————————————Node:field_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex].
                      busParams
|———————————————Node:subscript_expression Text: g_xlDrvConfig.channel[sg_aodChannels[i].m_pXLChannelInfo->channelIndex]
|————————————————Node:field_expression Text: g_xlDrvConfig.channel
|—————————————————Node:identifier Text: g_xlDrvConfig
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: channel
|————————————————Node:subscript_argument_list Text: [sg_aodChannels[i].m_pXLChannelInfo->channelIndex]
|—————————————————Node:[ Text: [
|—————————————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo->channelIndex
|——————————————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo
|———————————————————Node:subscript_expression Text: sg_aodChannels[i]
|————————————————————Node:identifier Text: sg_aodChannels
|————————————————————Node:subscript_argument_list Text: [i]
|—————————————————————Node:[ Text: [
|—————————————————————Node:identifier Text: i
|—————————————————————Node:] Text: ]
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: m_pXLChannelInfo
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: channelIndex
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: busParams
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: data
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: can
|————————————Node:. Text: .
|————————————Node:field_identifier Text: bitRate
|———————————Node:/ Text: /
|———————————Node:number_literal Text: 1000.000
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: pCntrlDetails[i].m_omStrBaudrate = chTemp;
|——————Node:assignment_expression Text: pCntrlDetails[i].m_omStrBaudrate = chTemp
|———————Node:field_expression Text: pCntrlDetails[i].m_omStrBaudrate
|————————Node:subscript_expression Text: pCntrlDetails[i]
|—————————Node:identifier Text: pCntrlDetails
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: m_omStrBaudrate
|———————Node:= Text: =
|———————Node:identifier Text: chTemp
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Sets the controller configuration data supplied by ConfigFile.
* \param[in]     ConfigFile, is SCONTROLLER_DETAILS structure
* \param[in]     Length , is INT
* \return        S_OK for success
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_SetConfigData(PSCONTROLLER_DETAILS ConfigFile, int Length)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;

    /* Fill the hardware description details */
    for (UINT nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc;
    }
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        sg_ControllerDetails[i] = ConfigFile[i];
    }

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_SetConfigData(PSCONTROLLER_DETAILS ConfigFile, int Length)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_SetConfigData
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_SetConfigData
|———Node:parameter_list Text: (PSCONTROLLER_DETAILS ConfigFile, int Length)
|————Node:( Text: (
|————Node:parameter_declaration Text: PSCONTROLLER_DETAILS ConfigFile
|—————Node:type_identifier Text: PSCONTROLLER_DETAILS
|—————Node:identifier Text: ConfigFile
|————Node:, Text: ,
|————Node:parameter_declaration Text: int Length
|—————Node:primitive_type Text: int
|—————Node:identifier Text: Length
|————Node:) Text: )
|——Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;

    /* Fill the hardware description details */
    for (UINT nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc;
    }
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        sg_ControllerDetails[i] = ConfigFile[i];
    }

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:comment Text: /* Fill the hardware description details */
|———Node:for_statement Text: for (UINT nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT nCount = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: nCount = 0
|——————Node:identifier Text: nCount
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: nCount < sg_ucNoOfHardware
|—————Node:identifier Text: nCount
|—————Node:< Text: <
|—————Node:identifier Text: sg_ucNoOfHardware
|————Node:; Text: ;
|————Node:update_expression Text: nCount++
|—————Node:identifier Text: nCount
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc;
|——————Node:assignment_expression Text: ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc = sg_ControllerDetails[nCount].m_omHardwareDesc
|———————Node:field_expression Text: ((PSCONTROLLER_DETAILS)ConfigFile)[nCount].m_omHardwareDesc
|————————Node:subscript_expression Text: ((PSCONTROLLER_DETAILS)ConfigFile)[nCount]
|—————————Node:parenthesized_expression Text: ((PSCONTROLLER_DETAILS)ConfigFile)
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (PSCONTROLLER_DETAILS)ConfigFile
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: PSCONTROLLER_DETAILS
|————————————Node:type_identifier Text: PSCONTROLLER_DETAILS
|———————————Node:) Text: )
|———————————Node:identifier Text: ConfigFile
|——————————Node:) Text: )
|—————————Node:subscript_argument_list Text: [nCount]
|——————————Node:[ Text: [
|——————————Node:identifier Text: nCount
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: m_omHardwareDesc
|———————Node:= Text: =
|———————Node:field_expression Text: sg_ControllerDetails[nCount].m_omHardwareDesc
|————————Node:subscript_expression Text: sg_ControllerDetails[nCount]
|—————————Node:identifier Text: sg_ControllerDetails
|—————————Node:subscript_argument_list Text: [nCount]
|——————————Node:[ Text: [
|——————————Node:identifier Text: nCount
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: m_omHardwareDesc
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:for_statement Text: for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        sg_ControllerDetails[i] = ConfigFile[i];
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < defNO_OF_CHANNELS
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: defNO_OF_CHANNELS
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sg_ControllerDetails[i] = ConfigFile[i];
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_ControllerDetails[i] = ConfigFile[i];
|——————Node:assignment_expression Text: sg_ControllerDetails[i] = ConfigFile[i]
|———————Node:subscript_expression Text: sg_ControllerDetails[i]
|————————Node:identifier Text: sg_ControllerDetails
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: ConfigFile[i]
|————————Node:identifier Text: ConfigFile
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Writes the message 'sCanData' to the corresponding clients buffer
* \param[out]    sCanData, is STCANDATA structure
* \param[out]    unClientIndex , is UINT containing client ID
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static void vWriteIntoClientsBuffer(STCANDATA& sCanData, UINT unClientIndex)
{
    /* Write into the respective client's buffer */
    for (UINT j = 0; j < sg_asClientToBufMap[unClientIndex].unBufCount; j++)
    {
        sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData);
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: vWriteIntoClientsBuffer(STCANDATA& sCanData, UINT unClientIndex)
|———Node:identifier Text: vWriteIntoClientsBuffer
|———Node:parameter_list Text: (STCANDATA& sCanData, UINT unClientIndex)
|————Node:( Text: (
|————Node:parameter_declaration Text: STCANDATA& sCanData
|—————Node:type_identifier Text: STCANDATA
|—————Node:reference_declarator Text: & sCanData
|——————Node:& Text: &
|——————Node:identifier Text: sCanData
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT unClientIndex
|—————Node:type_identifier Text: UINT
|—————Node:identifier Text: unClientIndex
|————Node:) Text: )
|——Node:compound_statement Text: {
    /* Write into the respective client's buffer */
    for (UINT j = 0; j < sg_asClientToBufMap[unClientIndex].unBufCount; j++)
    {
        sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData);
    }
}
|———Node:{ Text: {
|———Node:comment Text: /* Write into the respective client's buffer */
|———Node:for_statement Text: for (UINT j = 0; j < sg_asClientToBufMap[unClientIndex].unBufCount; j++)
    {
        sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData);
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT j = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: j = 0
|——————Node:identifier Text: j
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: j < sg_asClientToBufMap[unClientIndex].unBufCount
|—————Node:identifier Text: j
|—————Node:< Text: <
|—————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].unBufCount
|——————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————Node:identifier Text: sg_asClientToBufMap
|———————Node:subscript_argument_list Text: [unClientIndex]
|————————Node:[ Text: [
|————————Node:identifier Text: unClientIndex
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: unBufCount
|————Node:; Text: ;
|————Node:update_expression Text: j++
|—————Node:identifier Text: j
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData);
|——————Node:call_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer(&sCanData)
|———————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[j]->WriteIntoBuffer
|————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[j]
|—————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf
|——————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————————Node:identifier Text: sg_asClientToBufMap
|———————————Node:subscript_argument_list Text: [unClientIndex]
|————————————Node:[ Text: [
|————————————Node:identifier Text: unClientIndex
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pClientBuf
|—————————Node:subscript_argument_list Text: [j]
|——————————Node:[ Text: [
|——————————Node:identifier Text: j
|——————————Node:] Text: ]
|————————Node:-> Text: ->
|————————Node:field_identifier Text: WriteIntoBuffer
|———————Node:argument_list Text: (&sCanData)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &sCanData
|—————————Node:& Text: &
|—————————Node:identifier Text: sCanData
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to create time mode mapping
* \param[in]     hDataEvent, is HANDLE
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static void vCreateTimeModeMapping(HANDLE hDataEvent)
{
    WaitForSingleObject(hDataEvent, INFINITE);
    GetLocalTime(&sg_CurrSysTime);
    /*Query Tick Count*/
    QueryPerformanceCounter(&sg_QueryTickCount);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: vCreateTimeModeMapping(HANDLE hDataEvent)
|———Node:identifier Text: vCreateTimeModeMapping
|———Node:parameter_list Text: (HANDLE hDataEvent)
|————Node:( Text: (
|————Node:parameter_declaration Text: HANDLE hDataEvent
|—————Node:type_identifier Text: HANDLE
|—————Node:identifier Text: hDataEvent
|————Node:) Text: )
|——Node:compound_statement Text: {
    WaitForSingleObject(hDataEvent, INFINITE);
    GetLocalTime(&sg_CurrSysTime);
    /*Query Tick Count*/
    QueryPerformanceCounter(&sg_QueryTickCount);
}
|———Node:{ Text: {
|———Node:expression_statement Text: WaitForSingleObject(hDataEvent, INFINITE);
|————Node:call_expression Text: WaitForSingleObject(hDataEvent, INFINITE)
|—————Node:identifier Text: WaitForSingleObject
|—————Node:argument_list Text: (hDataEvent, INFINITE)
|——————Node:( Text: (
|——————Node:identifier Text: hDataEvent
|——————Node:, Text: ,
|——————Node:identifier Text: INFINITE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: GetLocalTime(&sg_CurrSysTime);
|————Node:call_expression Text: GetLocalTime(&sg_CurrSysTime)
|—————Node:identifier Text: GetLocalTime
|—————Node:argument_list Text: (&sg_CurrSysTime)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &sg_CurrSysTime
|———————Node:& Text: &
|———————Node:identifier Text: sg_CurrSysTime
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*Query Tick Count*/
|———Node:expression_statement Text: QueryPerformanceCounter(&sg_QueryTickCount);
|————Node:call_expression Text: QueryPerformanceCounter(&sg_QueryTickCount)
|—————Node:identifier Text: QueryPerformanceCounter
|—————Node:argument_list Text: (&sg_QueryTickCount)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &sg_QueryTickCount
|———————Node:& Text: &
|———————Node:identifier Text: sg_QueryTickCount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This will convert the error code from vector driver format
*                to the format that is used by BUSMASTER.
* \param[in]     lError Error code in Peak USB driver format
* \param[in]     byDir  Error direction Tx/Rx
* \return        UCHAR which indicates error code
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static UCHAR USB_ucGetErrorCode(LONG lError, BYTE byDir)
{
    UCHAR ucReturn = 0;

    // Tx Errors
    if( byDir == 1)
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_TX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR )
        {
            ucReturn = FORM_ERROR_TX;
        }
        else
        {
            ucReturn = OTHER_ERROR_TX;
        }
    }
    // Rx Errors
    else
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
    }
    // Return the error code
    return ucReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: UCHAR
|——Node:function_declarator Text: USB_ucGetErrorCode(LONG lError, BYTE byDir)
|———Node:identifier Text: USB_ucGetErrorCode
|———Node:parameter_list Text: (LONG lError, BYTE byDir)
|————Node:( Text: (
|————Node:parameter_declaration Text: LONG lError
|—————Node:type_identifier Text: LONG
|—————Node:identifier Text: lError
|————Node:, Text: ,
|————Node:parameter_declaration Text: BYTE byDir
|—————Node:type_identifier Text: BYTE
|—————Node:identifier Text: byDir
|————Node:) Text: )
|——Node:compound_statement Text: {
    UCHAR ucReturn = 0;

    // Tx Errors
    if( byDir == 1)
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_TX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR )
        {
            ucReturn = FORM_ERROR_TX;
        }
        else
        {
            ucReturn = OTHER_ERROR_TX;
        }
    }
    // Rx Errors
    else
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
    }
    // Return the error code
    return ucReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: UCHAR ucReturn = 0;
|————Node:type_identifier Text: UCHAR
|————Node:init_declarator Text: ucReturn = 0
|—————Node:identifier Text: ucReturn
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // Tx Errors
|———Node:if_statement Text: if( byDir == 1)
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_TX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR )
        {
            ucReturn = FORM_ERROR_TX;
        }
        else
        {
            ucReturn = OTHER_ERROR_TX;
        }
    }
    // Rx Errors
    else
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( byDir == 1)
|—————Node:( Text: (
|—————Node:binary_expression Text: byDir == 1
|——————Node:identifier Text: byDir
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_TX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR )
        {
            ucReturn = FORM_ERROR_TX;
        }
        else
        {
            ucReturn = OTHER_ERROR_TX;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_TX;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
|———————Node:( Text: (
|———————Node:binary_expression Text: lError & XL_CAN_MSG_FLAG_ERROR_FRAME
|————————Node:identifier Text: lError
|————————Node:& Text: &
|————————Node:identifier Text: XL_CAN_MSG_FLAG_ERROR_FRAME
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            ucReturn = BIT_ERROR_TX;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: ucReturn = BIT_ERROR_TX;
|————————Node:assignment_expression Text: ucReturn = BIT_ERROR_TX
|—————————Node:identifier Text: ucReturn
|—————————Node:= Text: =
|—————————Node:identifier Text: BIT_ERROR_TX
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (lError & XL_CAN_MSG_FLAG_NERR )
        {
            ucReturn = FORM_ERROR_TX;
        }
        else
        {
            ucReturn = OTHER_ERROR_TX;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (lError & XL_CAN_MSG_FLAG_NERR )
|———————Node:( Text: (
|———————Node:binary_expression Text: lError & XL_CAN_MSG_FLAG_NERR
|————————Node:identifier Text: lError
|————————Node:& Text: &
|————————Node:identifier Text: XL_CAN_MSG_FLAG_NERR
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            ucReturn = FORM_ERROR_TX;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: ucReturn = FORM_ERROR_TX;
|————————Node:assignment_expression Text: ucReturn = FORM_ERROR_TX
|—————————Node:identifier Text: ucReturn
|—————————Node:= Text: =
|—————————Node:identifier Text: FORM_ERROR_TX
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            ucReturn = OTHER_ERROR_TX;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            ucReturn = OTHER_ERROR_TX;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: ucReturn = OTHER_ERROR_TX;
|—————————Node:assignment_expression Text: ucReturn = OTHER_ERROR_TX
|——————————Node:identifier Text: ucReturn
|——————————Node:= Text: =
|——————————Node:identifier Text: OTHER_ERROR_TX
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:comment Text: // Rx Errors
|————Node:else_clause Text: else
    {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
        if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
    }
|——————Node:{ Text: {
|——————Node:if_statement Text: if (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
        {
            ucReturn = BIT_ERROR_RX;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lError & XL_CAN_MSG_FLAG_ERROR_FRAME)
|————————Node:( Text: (
|————————Node:binary_expression Text: lError & XL_CAN_MSG_FLAG_ERROR_FRAME
|—————————Node:identifier Text: lError
|—————————Node:& Text: &
|—————————Node:identifier Text: XL_CAN_MSG_FLAG_ERROR_FRAME
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            ucReturn = BIT_ERROR_RX;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: ucReturn = BIT_ERROR_RX;
|—————————Node:assignment_expression Text: ucReturn = BIT_ERROR_RX
|——————————Node:identifier Text: ucReturn
|——————————Node:= Text: =
|——————————Node:identifier Text: BIT_ERROR_RX
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:if_statement Text: if (lError & XL_CAN_MSG_FLAG_NERR)
        {
            ucReturn = FORM_ERROR_RX;
        }
        else
        {
            ucReturn = OTHER_ERROR_RX;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lError & XL_CAN_MSG_FLAG_NERR)
|————————Node:( Text: (
|————————Node:binary_expression Text: lError & XL_CAN_MSG_FLAG_NERR
|—————————Node:identifier Text: lError
|—————————Node:& Text: &
|—————————Node:identifier Text: XL_CAN_MSG_FLAG_NERR
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            ucReturn = FORM_ERROR_RX;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: ucReturn = FORM_ERROR_RX;
|—————————Node:assignment_expression Text: ucReturn = FORM_ERROR_RX
|——————————Node:identifier Text: ucReturn
|——————————Node:= Text: =
|——————————Node:identifier Text: FORM_ERROR_RX
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
        {
            ucReturn = OTHER_ERROR_RX;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ucReturn = OTHER_ERROR_RX;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ucReturn = OTHER_ERROR_RX;
|——————————Node:assignment_expression Text: ucReturn = OTHER_ERROR_RX
|———————————Node:identifier Text: ucReturn
|———————————Node:= Text: =
|———————————Node:identifier Text: OTHER_ERROR_RX
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:} Text: }
|———Node:comment Text: // Return the error code
|———Node:return_statement Text: return ucReturn;
|————Node:return Text: return
|————Node:identifier Text: ucReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This will classify the messages, which can be one of Rx, Tx or
*                Error messages. In case of Err messages this identifies under
*                what broader category (Rx / Tx) does this occur.
* \param[in]     XLevent& xlEvent message polled from the bus in XLevent format
* \param[out]    sCanData Application specific data format
* \return        TRUE (always)
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BYTE bClassifyMsgType(XLevent& xlEvent, STCANDATA& sCanData)
{
    sCanData.m_lTickCount.QuadPart = (LONGLONG)xlEvent.timeStamp / 100000;

    if (CREATE_MAP_TIMESTAMP == sg_byCurrState)
    {
        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
        //Time difference should be +ve value
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }

        sg_byCurrState = CALC_TIMESTAMP_READY;
    }

    if ( !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)     &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)         )
    {
        ///* Check for RTR Message */
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
        {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
        else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }

        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            sCanData.m_ucDataType = TX_FLAG;
        }
        else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }

    	if ( xlEvent.tagData.msg.dlc <= 8 ) /* Valid CAN message length */
		{
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}

        /* Copy the message ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id;

        /* Check for extended message indication */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE;

        if ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }

        /* Set channel ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
    }
    else
    {
        sCanData.m_ucDataType = ERR_FLAG;
        // Set bus error as default error. This will be
        // Modified by the function USB_ucHandleErrorCounter
        sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
        // Assign the channel number
        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;

        // Assign error type in the Error Capture register
        // and the direction of the error
        BOOL bIsTxMsg = FALSE;
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
        sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
        //explaination of error bit
        sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
    }

    return TRUE;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BYTE
|——Node:function_declarator Text: bClassifyMsgType(XLevent& xlEvent, STCANDATA& sCanData)
|———Node:identifier Text: bClassifyMsgType
|———Node:parameter_list Text: (XLevent& xlEvent, STCANDATA& sCanData)
|————Node:( Text: (
|————Node:parameter_declaration Text: XLevent& xlEvent
|—————Node:type_identifier Text: XLevent
|—————Node:reference_declarator Text: & xlEvent
|——————Node:& Text: &
|——————Node:identifier Text: xlEvent
|————Node:, Text: ,
|————Node:parameter_declaration Text: STCANDATA& sCanData
|—————Node:type_identifier Text: STCANDATA
|—————Node:reference_declarator Text: & sCanData
|——————Node:& Text: &
|——————Node:identifier Text: sCanData
|————Node:) Text: )
|——Node:compound_statement Text: {
    sCanData.m_lTickCount.QuadPart = (LONGLONG)xlEvent.timeStamp / 100000;

    if (CREATE_MAP_TIMESTAMP == sg_byCurrState)
    {
        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
        //Time difference should be +ve value
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }

        sg_byCurrState = CALC_TIMESTAMP_READY;
    }

    if ( !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)     &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)         )
    {
        ///* Check for RTR Message */
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
        {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
        else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }

        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            sCanData.m_ucDataType = TX_FLAG;
        }
        else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }

    	if ( xlEvent.tagData.msg.dlc <= 8 ) /* Valid CAN message length */
		{
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}

        /* Copy the message ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id;

        /* Check for extended message indication */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE;

        if ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }

        /* Set channel ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
    }
    else
    {
        sCanData.m_ucDataType = ERR_FLAG;
        // Set bus error as default error. This will be
        // Modified by the function USB_ucHandleErrorCounter
        sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
        // Assign the channel number
        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;

        // Assign error type in the Error Capture register
        // and the direction of the error
        BOOL bIsTxMsg = FALSE;
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
        sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
        //explaination of error bit
        sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
    }

    return TRUE;
}
|———Node:{ Text: {
|———Node:expression_statement Text: sCanData.m_lTickCount.QuadPart = (LONGLONG)xlEvent.timeStamp / 100000;
|————Node:assignment_expression Text: sCanData.m_lTickCount.QuadPart = (LONGLONG)xlEvent.timeStamp / 100000
|—————Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|——————Node:field_expression Text: sCanData.m_lTickCount
|———————Node:identifier Text: sCanData
|———————Node:. Text: .
|———————Node:field_identifier Text: m_lTickCount
|——————Node:. Text: .
|——————Node:field_identifier Text: QuadPart
|—————Node:= Text: =
|—————Node:binary_expression Text: (LONGLONG)xlEvent.timeStamp / 100000
|——————Node:cast_expression Text: (LONGLONG)xlEvent.timeStamp
|———————Node:( Text: (
|———————Node:type_descriptor Text: LONGLONG
|————————Node:type_identifier Text: LONGLONG
|———————Node:) Text: )
|———————Node:field_expression Text: xlEvent.timeStamp
|————————Node:identifier Text: xlEvent
|————————Node:. Text: .
|————————Node:field_identifier Text: timeStamp
|——————Node:/ Text: /
|——————Node:number_literal Text: 100000
|————Node:; Text: ;
|———Node:if_statement Text: if (CREATE_MAP_TIMESTAMP == sg_byCurrState)
    {
        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
        //Time difference should be +ve value
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }

        sg_byCurrState = CALC_TIMESTAMP_READY;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (CREATE_MAP_TIMESTAMP == sg_byCurrState)
|—————Node:( Text: (
|—————Node:binary_expression Text: CREATE_MAP_TIMESTAMP == sg_byCurrState
|——————Node:identifier Text: CREATE_MAP_TIMESTAMP
|——————Node:== Text: ==
|——————Node:identifier Text: sg_byCurrState
|—————Node:) Text: )
|————Node:compound_statement Text: {
        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
        //Time difference should be +ve value
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }

        sg_byCurrState = CALC_TIMESTAMP_READY;
    }
|—————Node:{ Text: {
|—————Node:declaration Text: LARGE_INTEGER g_QueryTickCount;
|——————Node:type_identifier Text: LARGE_INTEGER
|——————Node:identifier Text: g_QueryTickCount
|——————Node:; Text: ;
|—————Node:expression_statement Text: QueryPerformanceCounter(&g_QueryTickCount);
|——————Node:call_expression Text: QueryPerformanceCounter(&g_QueryTickCount)
|———————Node:identifier Text: QueryPerformanceCounter
|———————Node:argument_list Text: (&g_QueryTickCount)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &g_QueryTickCount
|—————————Node:& Text: &
|—————————Node:identifier Text: g_QueryTickCount
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: UINT64 unConnectionTime;
|——————Node:type_identifier Text: UINT64
|——————Node:identifier Text: unConnectionTime
|——————Node:; Text: ;
|—————Node:expression_statement Text: unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
|——————Node:assignment_expression Text: unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp
|———————Node:identifier Text: unConnectionTime
|———————Node:= Text: =
|———————Node:binary_expression Text: ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp
|————————Node:parenthesized_expression Text: ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|——————————Node:parenthesized_expression Text: (g_QueryTickCount.QuadPart * 10000)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: g_QueryTickCount.QuadPart * 10000
|————————————Node:field_expression Text: g_QueryTickCount.QuadPart
|—————————————Node:identifier Text: g_QueryTickCount
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: QuadPart
|————————————Node:* Text: *
|————————————Node:number_literal Text: 10000
|———————————Node:) Text: )
|——————————Node:/ Text: /
|——————————Node:field_expression Text: sg_lnFrequency.QuadPart
|———————————Node:identifier Text: sg_lnFrequency
|———————————Node:. Text: .
|———————————Node:field_identifier Text: QuadPart
|—————————Node:) Text: )
|————————Node:- Text: -
|————————Node:identifier Text: sg_TimeStamp
|——————Node:; Text: ;
|—————Node:comment Text: //Time difference should be +ve value
|—————Node:if_statement Text: if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sCanData.m_lTickCount.QuadPart >= unConnectionTime)
|———————Node:( Text: (
|———————Node:binary_expression Text: sCanData.m_lTickCount.QuadPart >= unConnectionTime
|————————Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|—————————Node:field_expression Text: sCanData.m_lTickCount
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_lTickCount
|—————————Node:. Text: .
|—————————Node:field_identifier Text: QuadPart
|————————Node:>= Text: >=
|————————Node:identifier Text: unConnectionTime
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
|————————Node:assignment_expression Text: sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime)
|—————————Node:identifier Text: sg_TimeStamp
|—————————Node:= Text: =
|—————————Node:call_expression Text: (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime)
|——————————Node:parenthesized_expression Text: (LONGLONG)
|———————————Node:( Text: (
|———————————Node:identifier Text: LONGLONG
|———————————Node:) Text: )
|——————————Node:argument_list Text: (sCanData.m_lTickCount.QuadPart - unConnectionTime)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: sCanData.m_lTickCount.QuadPart - unConnectionTime
|————————————Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|—————————————Node:field_expression Text: sCanData.m_lTickCount
|——————————————Node:identifier Text: sCanData
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: m_lTickCount
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: QuadPart
|————————————Node:- Text: -
|————————————Node:identifier Text: unConnectionTime
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
|—————————Node:assignment_expression Text: sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart)
|——————————Node:identifier Text: sg_TimeStamp
|——————————Node:= Text: =
|——————————Node:call_expression Text: (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart)
|———————————Node:parenthesized_expression Text: (LONGLONG)
|————————————Node:( Text: (
|————————————Node:identifier Text: LONGLONG
|————————————Node:) Text: )
|———————————Node:argument_list Text: (unConnectionTime - sCanData.m_lTickCount.QuadPart)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: unConnectionTime - sCanData.m_lTickCount.QuadPart
|—————————————Node:identifier Text: unConnectionTime
|—————————————Node:- Text: -
|—————————————Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|——————————————Node:field_expression Text: sCanData.m_lTickCount
|———————————————Node:identifier Text: sCanData
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: m_lTickCount
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: QuadPart
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:expression_statement Text: sg_byCurrState = CALC_TIMESTAMP_READY;
|——————Node:assignment_expression Text: sg_byCurrState = CALC_TIMESTAMP_READY
|———————Node:identifier Text: sg_byCurrState
|———————Node:= Text: =
|———————Node:identifier Text: CALC_TIMESTAMP_READY
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if ( !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)     &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)         )
    {
        ///* Check for RTR Message */
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
        {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
        else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }

        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            sCanData.m_ucDataType = TX_FLAG;
        }
        else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }

    	if ( xlEvent.tagData.msg.dlc <= 8 ) /* Valid CAN message length */
		{
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}

        /* Copy the message ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id;

        /* Check for extended message indication */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE;

        if ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }

        /* Set channel ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
    }
    else
    {
        sCanData.m_ucDataType = ERR_FLAG;
        // Set bus error as default error. This will be
        // Modified by the function USB_ucHandleErrorCounter
        sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
        // Assign the channel number
        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;

        // Assign error type in the Error Capture register
        // and the direction of the error
        BOOL bIsTxMsg = FALSE;
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
        sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
        //explaination of error bit
        sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)     &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)         )
|—————Node:( Text: (
|—————Node:binary_expression Text: !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)     &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)
|——————Node:binary_expression Text: !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME) &&
            !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)
|———————Node:unary_expression Text: !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME)
|————————Node:! Text: !
|————————Node:parenthesized_expression Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_ERROR_FRAME
|——————————Node:field_expression Text: xlEvent.tagData.msg.flags
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:& Text: &
|——————————Node:identifier Text: XL_CAN_MSG_FLAG_ERROR_FRAME
|—————————Node:) Text: )
|———————Node:&& Text: &&
|———————Node:unary_expression Text: !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)
|————————Node:! Text: !
|————————Node:parenthesized_expression Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_OVERRUN
|——————————Node:field_expression Text: xlEvent.tagData.msg.flags
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:& Text: &
|——————————Node:identifier Text: XL_CAN_MSG_FLAG_OVERRUN
|—————————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:unary_expression Text: !(xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)
|———————Node:! Text: !
|———————Node:parenthesized_expression Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR)
|————————Node:( Text: (
|————————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_NERR
|—————————Node:field_expression Text: xlEvent.tagData.msg.flags
|——————————Node:field_expression Text: xlEvent.tagData.msg
|———————————Node:field_expression Text: xlEvent.tagData
|————————————Node:identifier Text: xlEvent
|————————————Node:. Text: .
|————————————Node:field_identifier Text: tagData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: flags
|—————————Node:& Text: &
|—————————Node:identifier Text: XL_CAN_MSG_FLAG_NERR
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        ///* Check for RTR Message */
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
        {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
        else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }

        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            sCanData.m_ucDataType = TX_FLAG;
        }
        else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }

    	if ( xlEvent.tagData.msg.dlc <= 8 ) /* Valid CAN message length */
		{
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}

        /* Copy the message ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id;

        /* Check for extended message indication */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE;

        if ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }

        /* Set channel ID */
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
    }
|—————Node:{ Text: {
|—————Node:comment Text: ///* Check for RTR Message */
|—————Node:if_statement Text: if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
        {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
        else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME)
|———————Node:( Text: (
|———————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_REMOTE_FRAME
|————————Node:field_expression Text: xlEvent.tagData.msg.flags
|—————————Node:field_expression Text: xlEvent.tagData.msg
|——————————Node:field_expression Text: xlEvent.tagData
|———————————Node:identifier Text: xlEvent
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tagData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: XL_CAN_MSG_FLAG_REMOTE_FRAME
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sCanData.m_ucDataType = RX_FLAG;
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sCanData.m_ucDataType = RX_FLAG;
|————————Node:assignment_expression Text: sCanData.m_ucDataType = RX_FLAG
|—————————Node:field_expression Text: sCanData.m_ucDataType
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_ucDataType
|—————————Node:= Text: =
|—————————Node:identifier Text: RX_FLAG
|————————Node:; Text: ;
|———————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE;
|————————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = TRUE
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR
|——————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|———————————Node:field_expression Text: sCanData.m_uDataInfo
|————————————Node:identifier Text: sCanData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_uDataInfo
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_sCANMsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_ucRTR
|—————————Node:= Text: =
|—————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE;
|—————————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR = FALSE
|——————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucRTR
|———————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|————————————Node:field_expression Text: sCanData.m_uDataInfo
|—————————————Node:identifier Text: sCanData
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: m_uDataInfo
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_sCANMsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_ucRTR
|——————————Node:= Text: =
|——————————Node:false Text: FALSE
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:if_statement Text: if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            sCanData.m_ucDataType = TX_FLAG;
        }
        else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
|———————Node:( Text: (
|———————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED
|————————Node:field_expression Text: xlEvent.tagData.msg.flags
|—————————Node:field_expression Text: xlEvent.tagData.msg
|——————————Node:field_expression Text: xlEvent.tagData
|———————————Node:identifier Text: xlEvent
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tagData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: flags
|————————Node:& Text: &
|————————Node:identifier Text: XL_CAN_MSG_FLAG_TX_COMPLETED
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sCanData.m_ucDataType = TX_FLAG;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sCanData.m_ucDataType = TX_FLAG;
|————————Node:assignment_expression Text: sCanData.m_ucDataType = TX_FLAG
|—————————Node:field_expression Text: sCanData.m_ucDataType
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_ucDataType
|—————————Node:= Text: =
|—————————Node:identifier Text: TX_FLAG
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            sCanData.m_ucDataType = RX_FLAG;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            sCanData.m_ucDataType = RX_FLAG;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: sCanData.m_ucDataType = RX_FLAG;
|—————————Node:assignment_expression Text: sCanData.m_ucDataType = RX_FLAG
|——————————Node:field_expression Text: sCanData.m_ucDataType
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_ucDataType
|——————————Node:= Text: =
|——————————Node:identifier Text: RX_FLAG
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:if_statement Text: if ( xlEvent.tagData.msg.dlc <= 8 ) /* Valid CAN message length */
		{
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: ( xlEvent.tagData.msg.dlc <= 8 )
|———————Node:( Text: (
|———————Node:binary_expression Text: xlEvent.tagData.msg.dlc <= 8
|————————Node:field_expression Text: xlEvent.tagData.msg.dlc
|—————————Node:field_expression Text: xlEvent.tagData.msg
|——————————Node:field_expression Text: xlEvent.tagData
|———————————Node:identifier Text: xlEvent
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tagData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: dlc
|————————Node:<= Text: <=
|————————Node:number_literal Text: 8
|———————Node:) Text: )
|——————Node:comment Text: /* Valid CAN message length */
|——————Node:compound_statement Text: {
			/* Copy data length */
			sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;

			/* Copy the message data */
			memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
		}
|———————Node:{ Text: {
|———————Node:comment Text: /* Copy data length */
|———————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc;
|————————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = (UCHAR)xlEvent.tagData.msg.dlc
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen
|——————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|———————————Node:field_expression Text: sCanData.m_uDataInfo
|————————————Node:identifier Text: sCanData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_uDataInfo
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_sCANMsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_ucDataLen
|—————————Node:= Text: =
|—————————Node:cast_expression Text: (UCHAR)xlEvent.tagData.msg.dlc
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: UCHAR
|———————————Node:type_identifier Text: UCHAR
|——————————Node:) Text: )
|——————————Node:field_expression Text: xlEvent.tagData.msg.dlc
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: dlc
|————————Node:; Text: ;
|———————Node:comment Text: /* Copy the message data */
|———————Node:expression_statement Text: memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc);
|————————Node:call_expression Text: memcpy(sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc)
|—————————Node:identifier Text: memcpy
|—————————Node:argument_list Text: (sCanData.m_uDataInfo.m_sCANMsg.m_ucData,
				   xlEvent.tagData.msg.data, xlEvent.tagData.msg.dlc)
|——————————Node:( Text: (
|——————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucData
|———————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|————————————Node:field_expression Text: sCanData.m_uDataInfo
|—————————————Node:identifier Text: sCanData
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: m_uDataInfo
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_sCANMsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_ucData
|——————————Node:, Text: ,
|——————————Node:field_expression Text: xlEvent.tagData.msg.data
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: data
|——————————Node:, Text: ,
|——————————Node:field_expression Text: xlEvent.tagData.msg.dlc
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: dlc
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment Text: /* Copy the message ID */
|—————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id;
|——————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID = (UINT)xlEvent.tagData.msg.id
|———————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|—————————Node:field_expression Text: sCanData.m_uDataInfo
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_uDataInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_sCANMsg
|————————Node:. Text: .
|————————Node:field_identifier Text: m_unMsgID
|———————Node:= Text: =
|———————Node:cast_expression Text: (UINT)xlEvent.tagData.msg.id
|————————Node:( Text: (
|————————Node:type_descriptor Text: UINT
|—————————Node:type_identifier Text: UINT
|————————Node:) Text: )
|————————Node:field_expression Text: xlEvent.tagData.msg.id
|—————————Node:field_expression Text: xlEvent.tagData.msg
|——————————Node:field_expression Text: xlEvent.tagData
|———————————Node:identifier Text: xlEvent
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tagData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: id
|——————Node:; Text: ;
|—————Node:comment Text: /* Check for extended message indication */
|—————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE;
|——————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED =
            (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE
|———————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|—————————Node:field_expression Text: sCanData.m_uDataInfo
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_uDataInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_sCANMsg
|————————Node:. Text: .
|————————Node:field_identifier Text: m_ucEXTENDED
|———————Node:= Text: =
|———————Node:conditional_expression Text: (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID) ? TRUE : FALSE
|————————Node:parenthesized_expression Text: (xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: xlEvent.tagData.msg.id & XL_CAN_EXT_MSG_ID
|——————————Node:field_expression Text: xlEvent.tagData.msg.id
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|——————————Node:& Text: &
|——————————Node:identifier Text: XL_CAN_EXT_MSG_ID
|—————————Node:) Text: )
|————————Node:? Text: ?
|————————Node:true Text: TRUE
|————————Node:: Text: :
|————————Node:false Text: FALSE
|——————Node:; Text: ;
|—————Node:if_statement Text: if ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
        {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED )
|———————Node:( Text: (
|———————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucEXTENDED
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|—————————Node:field_expression Text: sCanData.m_uDataInfo
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_uDataInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_sCANMsg
|————————Node:. Text: .
|————————Node:field_identifier Text: m_ucEXTENDED
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;    // make it std
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID;
|————————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID ^= XL_CAN_EXT_MSG_ID
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID
|——————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|———————————Node:field_expression Text: sCanData.m_uDataInfo
|————————————Node:identifier Text: sCanData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_uDataInfo
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_sCANMsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_unMsgID
|—————————Node:^= Text: ^=
|—————————Node:identifier Text: XL_CAN_EXT_MSG_ID
|————————Node:; Text: ;
|———————Node:comment Text: // make it std
|———————Node:} Text: }
|—————Node:comment Text: /* Set channel ID */
|—————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
|——————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|———————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|—————————Node:field_expression Text: sCanData.m_uDataInfo
|——————————Node:identifier Text: sCanData
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_uDataInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_sCANMsg
|————————Node:. Text: .
|————————Node:field_identifier Text: m_ucChannel
|———————Node:= Text: =
|———————Node:binary_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|————————Node:cast_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex]
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: UCHAR
|——————————Node:type_identifier Text: UCHAR
|—————————Node:) Text: )
|—————————Node:subscript_expression Text: sg_unDevChannelMap[xlEvent.chanIndex]
|——————————Node:identifier Text: sg_unDevChannelMap
|——————————Node:subscript_argument_list Text: [xlEvent.chanIndex]
|———————————Node:[ Text: [
|———————————Node:field_expression Text: xlEvent.chanIndex
|————————————Node:identifier Text: xlEvent
|————————————Node:. Text: .
|————————————Node:field_identifier Text: chanIndex
|———————————Node:] Text: ]
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        sCanData.m_ucDataType = ERR_FLAG;
        // Set bus error as default error. This will be
        // Modified by the function USB_ucHandleErrorCounter
        sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
        // Assign the channel number
        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;

        // Assign error type in the Error Capture register
        // and the direction of the error
        BOOL bIsTxMsg = FALSE;
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
        sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
        //explaination of error bit
        sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        sCanData.m_ucDataType = ERR_FLAG;
        // Set bus error as default error. This will be
        // Modified by the function USB_ucHandleErrorCounter
        sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
        // Assign the channel number
        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
        sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;

        // Assign error type in the Error Capture register
        // and the direction of the error
        BOOL bIsTxMsg = FALSE;
        if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
        sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
        //explaination of error bit
        sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: sCanData.m_ucDataType = ERR_FLAG;
|———————Node:assignment_expression Text: sCanData.m_ucDataType = ERR_FLAG
|————————Node:field_expression Text: sCanData.m_ucDataType
|—————————Node:identifier Text: sCanData
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucDataType
|————————Node:= Text: =
|————————Node:identifier Text: ERR_FLAG
|———————Node:; Text: ;
|——————Node:comment Text: // Set bus error as default error. This will be
|——————Node:comment Text: // Modified by the function USB_ucHandleErrorCounter
|——————Node:expression_statement Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS;
|———————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_BUS
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucErrType
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|——————————Node:field_expression Text: sCanData.m_uDataInfo
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_uDataInfo
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_sErrInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucErrType
|————————Node:= Text: =
|————————Node:identifier Text: ERROR_BUS
|———————Node:; Text: ;
|——————Node:comment Text: // Assign the channel number
|——————Node:expression_statement Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
|———————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|——————————Node:field_expression Text: sCanData.m_uDataInfo
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_uDataInfo
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_sErrInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucChannel
|————————Node:= Text: =
|————————Node:binary_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|—————————Node:cast_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex]
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: UCHAR
|———————————Node:type_identifier Text: UCHAR
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: sg_unDevChannelMap[xlEvent.chanIndex]
|———————————Node:identifier Text: sg_unDevChannelMap
|———————————Node:subscript_argument_list Text: [xlEvent.chanIndex]
|————————————Node:[ Text: [
|————————————Node:field_expression Text: xlEvent.chanIndex
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: chanIndex
|————————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1;
|———————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|——————————Node:field_expression Text: sCanData.m_uDataInfo
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_uDataInfo
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_sCANMsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucChannel
|————————Node:= Text: =
|————————Node:binary_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex] + 1
|—————————Node:cast_expression Text: (UCHAR)sg_unDevChannelMap[xlEvent.chanIndex]
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: UCHAR
|———————————Node:type_identifier Text: UCHAR
|——————————Node:) Text: )
|——————————Node:subscript_expression Text: sg_unDevChannelMap[xlEvent.chanIndex]
|———————————Node:identifier Text: sg_unDevChannelMap
|———————————Node:subscript_argument_list Text: [xlEvent.chanIndex]
|————————————Node:[ Text: [
|————————————Node:field_expression Text: xlEvent.chanIndex
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: chanIndex
|————————————Node:] Text: ]
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:comment Text: // Assign error type in the Error Capture register
|——————Node:comment Text: // and the direction of the error
|——————Node:declaration Text: BOOL bIsTxMsg = FALSE;
|———————Node:type_identifier Text: BOOL
|———————Node:init_declarator Text: bIsTxMsg = FALSE
|————————Node:identifier Text: bIsTxMsg
|————————Node:= Text: =
|————————Node:false Text: FALSE
|———————Node:; Text: ;
|——————Node:if_statement Text: if (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
        {
            bIsTxMsg = TRUE;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED)
|————————Node:( Text: (
|————————Node:binary_expression Text: xlEvent.tagData.msg.flags & XL_CAN_MSG_FLAG_TX_COMPLETED
|—————————Node:field_expression Text: xlEvent.tagData.msg.flags
|——————————Node:field_expression Text: xlEvent.tagData.msg
|———————————Node:field_expression Text: xlEvent.tagData
|————————————Node:identifier Text: xlEvent
|————————————Node:. Text: .
|————————————Node:field_identifier Text: tagData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: flags
|—————————Node:& Text: &
|—————————Node:identifier Text: XL_CAN_MSG_FLAG_TX_COMPLETED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            bIsTxMsg = TRUE;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: bIsTxMsg = TRUE;
|—————————Node:assignment_expression Text: bIsTxMsg = TRUE
|——————————Node:identifier Text: bIsTxMsg
|——————————Node:= Text: =
|——————————Node:true Text: TRUE
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg);
|———————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap =
            USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg)
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucReg_ErrCap
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|——————————Node:field_expression Text: sCanData.m_uDataInfo
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_uDataInfo
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_sErrInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucReg_ErrCap
|————————Node:= Text: =
|————————Node:call_expression Text: USB_ucGetErrorCode(xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg)
|—————————Node:identifier Text: USB_ucGetErrorCode
|—————————Node:argument_list Text: (xlEvent.tagData.msg.flags, (BYTE) bIsTxMsg)
|——————————Node:( Text: (
|——————————Node:field_expression Text: xlEvent.tagData.msg.flags
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:, Text: ,
|——————————Node:cast_expression Text: (BYTE) bIsTxMsg
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: BYTE
|————————————Node:type_identifier Text: BYTE
|———————————Node:) Text: )
|———————————Node:identifier Text: bIsTxMsg
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: //explaination of error bit
|——————Node:expression_statement Text: sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0;
|———————Node:assignment_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_nSubError= 0
|————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_nSubError
|—————————Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|——————————Node:field_expression Text: sCanData.m_uDataInfo
|———————————Node:identifier Text: sCanData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_uDataInfo
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_sErrInfo
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_nSubError
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return TRUE;
|————Node:return Text: return
|————Node:true Text: TRUE
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Processing of the received packets from bus
* \param[in]     XLevent& xlEvent message polled from the bus in XLevent format
* \param[in]     unClientIndex is the client index
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static void ProcessCANMsg(XLevent& xlEvent, UINT unClientIndex)
{
    int nSize = sg_nFRAMES;

    bClassifyMsgType(xlEvent, sg_asCANMsg);

    vWriteIntoClientsBuffer(sg_asCANMsg, unClientIndex);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: ProcessCANMsg(XLevent& xlEvent, UINT unClientIndex)
|———Node:identifier Text: ProcessCANMsg
|———Node:parameter_list Text: (XLevent& xlEvent, UINT unClientIndex)
|————Node:( Text: (
|————Node:parameter_declaration Text: XLevent& xlEvent
|—————Node:type_identifier Text: XLevent
|—————Node:reference_declarator Text: & xlEvent
|——————Node:& Text: &
|——————Node:identifier Text: xlEvent
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT unClientIndex
|—————Node:type_identifier Text: UINT
|—————Node:identifier Text: unClientIndex
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nSize = sg_nFRAMES;

    bClassifyMsgType(xlEvent, sg_asCANMsg);

    vWriteIntoClientsBuffer(sg_asCANMsg, unClientIndex);
}
|———Node:{ Text: {
|———Node:declaration Text: int nSize = sg_nFRAMES;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nSize = sg_nFRAMES
|—————Node:identifier Text: nSize
|—————Node:= Text: =
|—————Node:identifier Text: sg_nFRAMES
|————Node:; Text: ;
|———Node:expression_statement Text: bClassifyMsgType(xlEvent, sg_asCANMsg);
|————Node:call_expression Text: bClassifyMsgType(xlEvent, sg_asCANMsg)
|—————Node:identifier Text: bClassifyMsgType
|—————Node:argument_list Text: (xlEvent, sg_asCANMsg)
|——————Node:( Text: (
|——————Node:identifier Text: xlEvent
|——————Node:, Text: ,
|——————Node:identifier Text: sg_asCANMsg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: vWriteIntoClientsBuffer(sg_asCANMsg, unClientIndex);
|————Node:call_expression Text: vWriteIntoClientsBuffer(sg_asCANMsg, unClientIndex)
|—————Node:identifier Text: vWriteIntoClientsBuffer
|—————Node:argument_list Text: (sg_asCANMsg, unClientIndex)
|——————Node:( Text: (
|——————Node:identifier Text: sg_asCANMsg
|——————Node:, Text: ,
|——————Node:identifier Text: unClientIndex
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Read thread procedure
* \param[in]     pVoid contains the CPARAM_THREADPROC class object
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: DWORD WINAPI CanMsgReadThreadProc_CAN_Vector_XL(LPVOID pVoid)
{
    USES_CONVERSION;
    XLstatus xlStatus = XL_SUCCESS;

    CPARAM_THREADPROC* pThreadParam = (CPARAM_THREADPROC*) pVoid;

    /* Validate certain required pointers */
    VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam, (DWORD)-1);
    /* Assign thread action to CREATE_TIME_MAP */
    pThreadParam->m_unActionCode = CREATE_TIME_MAP;

    /* Set the event to CAN_Vector_XL driver for wakeup and frame arrival notification */
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1);
    }

    /* Set the thread action event to first notification event handle */
    if (g_hDataEvent[0] != NULL)
    {
        pThreadParam->m_hActionEvent = g_hDataEvent[0];
    }

    /* Get the handle to the controller and validate it */
    VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam->m_hActionEvent, (DWORD)-1);

    DWORD dwResult = 0;
    unsigned int msgsrx;
    XLevent  xlEvent;

    bool bLoopON = true;

    while (bLoopON)
    {
        WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE);
        switch (pThreadParam->m_unActionCode)
        {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
    }
    SetEvent(pThreadParam->hGetExitNotifyEvent());
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        ResetEvent(g_hDataEvent[i]);
        g_hDataEvent[i] = NULL;
    }
    pThreadParam->m_hActionEvent = NULL;

    return 0;
}
|——Node:type_identifier Text: DWORD
|——Node:ERROR Text: WINAPI
|———Node:identifier Text: WINAPI
|——Node:function_declarator Text: CanMsgReadThreadProc_CAN_Vector_XL(LPVOID pVoid)
|———Node:identifier Text: CanMsgReadThreadProc_CAN_Vector_XL
|———Node:parameter_list Text: (LPVOID pVoid)
|————Node:( Text: (
|————Node:parameter_declaration Text: LPVOID pVoid
|—————Node:type_identifier Text: LPVOID
|—————Node:identifier Text: pVoid
|————Node:) Text: )
|——Node:compound_statement Text: {
    USES_CONVERSION;
    XLstatus xlStatus = XL_SUCCESS;

    CPARAM_THREADPROC* pThreadParam = (CPARAM_THREADPROC*) pVoid;

    /* Validate certain required pointers */
    VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam, (DWORD)-1);
    /* Assign thread action to CREATE_TIME_MAP */
    pThreadParam->m_unActionCode = CREATE_TIME_MAP;

    /* Set the event to CAN_Vector_XL driver for wakeup and frame arrival notification */
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1);
    }

    /* Set the thread action event to first notification event handle */
    if (g_hDataEvent[0] != NULL)
    {
        pThreadParam->m_hActionEvent = g_hDataEvent[0];
    }

    /* Get the handle to the controller and validate it */
    VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam->m_hActionEvent, (DWORD)-1);

    DWORD dwResult = 0;
    unsigned int msgsrx;
    XLevent  xlEvent;

    bool bLoopON = true;

    while (bLoopON)
    {
        WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE);
        switch (pThreadParam->m_unActionCode)
        {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
    }
    SetEvent(pThreadParam->hGetExitNotifyEvent());
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        ResetEvent(g_hDataEvent[i]);
        g_hDataEvent[i] = NULL;
    }
    pThreadParam->m_hActionEvent = NULL;

    return 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus = XL_SUCCESS;
|————Node:type_identifier Text: XLstatus
|————Node:init_declarator Text: xlStatus = XL_SUCCESS
|—————Node:identifier Text: xlStatus
|—————Node:= Text: =
|—————Node:identifier Text: XL_SUCCESS
|————Node:; Text: ;
|———Node:declaration Text: CPARAM_THREADPROC* pThreadParam = (CPARAM_THREADPROC*) pVoid;
|————Node:type_identifier Text: CPARAM_THREADPROC
|————Node:init_declarator Text: * pThreadParam = (CPARAM_THREADPROC*) pVoid
|—————Node:pointer_declarator Text: * pThreadParam
|——————Node:* Text: *
|——————Node:identifier Text: pThreadParam
|—————Node:= Text: =
|—————Node:cast_expression Text: (CPARAM_THREADPROC*) pVoid
|——————Node:( Text: (
|——————Node:type_descriptor Text: CPARAM_THREADPROC*
|———————Node:type_identifier Text: CPARAM_THREADPROC
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: pVoid
|————Node:; Text: ;
|———Node:comment Text: /* Validate certain required pointers */
|———Node:expression_statement Text: VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam, (DWORD)-1);
|————Node:call_expression Text: VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam, (DWORD)-1)
|—————Node:identifier Text: VALIDATE_POINTER_RETURN_VALUE_LOG
|—————Node:argument_list Text: (pThreadParam, (DWORD)-1)
|——————Node:( Text: (
|——————Node:identifier Text: pThreadParam
|——————Node:, Text: ,
|——————Node:binary_expression Text: (DWORD)-1
|———————Node:parenthesized_expression Text: (DWORD)
|————————Node:( Text: (
|————————Node:identifier Text: DWORD
|————————Node:) Text: )
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Assign thread action to CREATE_TIME_MAP */
|———Node:expression_statement Text: pThreadParam->m_unActionCode = CREATE_TIME_MAP;
|————Node:assignment_expression Text: pThreadParam->m_unActionCode = CREATE_TIME_MAP
|—————Node:field_expression Text: pThreadParam->m_unActionCode
|——————Node:identifier Text: pThreadParam
|——————Node:-> Text: ->
|——————Node:field_identifier Text: m_unActionCode
|—————Node:= Text: =
|—————Node:identifier Text: CREATE_TIME_MAP
|————Node:; Text: ;
|———Node:comment Text: /* Set the event to CAN_Vector_XL driver for wakeup and frame arrival notification */
|———Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1);
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1);
|——————Node:assignment_expression Text: xlStatus = xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1)
|———————Node:identifier Text: xlStatus
|———————Node:= Text: =
|———————Node:call_expression Text: xlSetNotification (g_xlPortHandle[i], &g_hDataEvent[i], 1)
|————————Node:identifier Text: xlSetNotification
|————————Node:argument_list Text: (g_xlPortHandle[i], &g_hDataEvent[i], 1)
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: g_xlPortHandle[i]
|——————————Node:identifier Text: g_xlPortHandle
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &g_hDataEvent[i]
|——————————Node:& Text: &
|——————————Node:subscript_expression Text: g_hDataEvent[i]
|———————————Node:identifier Text: g_hDataEvent
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Set the thread action event to first notification event handle */
|———Node:if_statement Text: if (g_hDataEvent[0] != NULL)
    {
        pThreadParam->m_hActionEvent = g_hDataEvent[0];
    }
|————Node:if Text: if
|————Node:condition_clause Text: (g_hDataEvent[0] != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: g_hDataEvent[0] != NULL
|——————Node:subscript_expression Text: g_hDataEvent[0]
|———————Node:identifier Text: g_hDataEvent
|———————Node:subscript_argument_list Text: [0]
|————————Node:[ Text: [
|————————Node:number_literal Text: 0
|————————Node:] Text: ]
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        pThreadParam->m_hActionEvent = g_hDataEvent[0];
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: pThreadParam->m_hActionEvent = g_hDataEvent[0];
|——————Node:assignment_expression Text: pThreadParam->m_hActionEvent = g_hDataEvent[0]
|———————Node:field_expression Text: pThreadParam->m_hActionEvent
|————————Node:identifier Text: pThreadParam
|————————Node:-> Text: ->
|————————Node:field_identifier Text: m_hActionEvent
|———————Node:= Text: =
|———————Node:subscript_expression Text: g_hDataEvent[0]
|————————Node:identifier Text: g_hDataEvent
|————————Node:subscript_argument_list Text: [0]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Get the handle to the controller and validate it */
|———Node:expression_statement Text: VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam->m_hActionEvent, (DWORD)-1);
|————Node:call_expression Text: VALIDATE_POINTER_RETURN_VALUE_LOG(pThreadParam->m_hActionEvent, (DWORD)-1)
|—————Node:identifier Text: VALIDATE_POINTER_RETURN_VALUE_LOG
|—————Node:argument_list Text: (pThreadParam->m_hActionEvent, (DWORD)-1)
|——————Node:( Text: (
|——————Node:field_expression Text: pThreadParam->m_hActionEvent
|———————Node:identifier Text: pThreadParam
|———————Node:-> Text: ->
|———————Node:field_identifier Text: m_hActionEvent
|——————Node:, Text: ,
|——————Node:binary_expression Text: (DWORD)-1
|———————Node:parenthesized_expression Text: (DWORD)
|————————Node:( Text: (
|————————Node:identifier Text: DWORD
|————————Node:) Text: )
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: DWORD dwResult = 0;
|————Node:type_identifier Text: DWORD
|————Node:init_declarator Text: dwResult = 0
|—————Node:identifier Text: dwResult
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: unsigned int msgsrx;
|————Node:sized_type_specifier Text: unsigned int
|—————Node:unsigned Text: unsigned
|—————Node:primitive_type Text: int
|————Node:identifier Text: msgsrx
|————Node:; Text: ;
|———Node:declaration Text: XLevent  xlEvent;
|————Node:type_identifier Text: XLevent
|————Node:identifier Text: xlEvent
|————Node:; Text: ;
|———Node:declaration Text: bool bLoopON = true;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: bLoopON = true
|—————Node:identifier Text: bLoopON
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:while_statement Text: while (bLoopON)
    {
        WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE);
        switch (pThreadParam->m_unActionCode)
        {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
    }
|————Node:while Text: while
|————Node:condition_clause Text: (bLoopON)
|—————Node:( Text: (
|—————Node:identifier Text: bLoopON
|—————Node:) Text: )
|————Node:compound_statement Text: {
        WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE);
        switch (pThreadParam->m_unActionCode)
        {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE);
|——————Node:call_expression Text: WaitForMultipleObjects(sg_unClientCnt, g_hDataEvent, FALSE, INFINITE)
|———————Node:identifier Text: WaitForMultipleObjects
|———————Node:argument_list Text: (sg_unClientCnt, g_hDataEvent, FALSE, INFINITE)
|————————Node:( Text: (
|————————Node:identifier Text: sg_unClientCnt
|————————Node:, Text: ,
|————————Node:identifier Text: g_hDataEvent
|————————Node:, Text: ,
|————————Node:false Text: FALSE
|————————Node:, Text: ,
|————————Node:identifier Text: INFINITE
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:switch_statement Text: switch (pThreadParam->m_unActionCode)
        {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
|——————Node:switch Text: switch
|——————Node:condition_clause Text: (pThreadParam->m_unActionCode)
|———————Node:( Text: (
|———————Node:field_expression Text: pThreadParam->m_unActionCode
|————————Node:identifier Text: pThreadParam
|————————Node:-> Text: ->
|————————Node:field_identifier Text: m_unActionCode
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
            case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
            case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
            default:
            case INACTION:
            {
                // nothing right at this moment
            }
            break;
        }
|———————Node:{ Text: {
|———————Node:case_statement Text: case INVOKE_FUNCTION:
            {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: INVOKE_FUNCTION
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                bool bMoreDataExist;
                do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
            }
|—————————Node:{ Text: {
|—————————Node:declaration Text: bool bMoreDataExist;
|——————————Node:primitive_type Text: bool
|——————————Node:identifier Text: bMoreDataExist
|——————————Node:; Text: ;
|—————————Node:do_statement Text: do
                {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                while (bMoreDataExist);
|——————————Node:do Text: do
|——————————Node:compound_statement Text: {
                    bMoreDataExist = false;
                    /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
                    for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: bMoreDataExist = false;
|————————————Node:assignment_expression Text: bMoreDataExist = false
|—————————————Node:identifier Text: bMoreDataExist
|—————————————Node:= Text: =
|—————————————Node:false Text: false
|————————————Node:; Text: ;
|———————————Node:comment Text: /* Read all the available CAN messages using 'xlReceive'
                       across all the port handles */
|———————————Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
                    {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: UINT i = 0;
|—————————————Node:type_identifier Text: UINT
|—————————————Node:init_declarator Text: i = 0
|——————————————Node:identifier Text: i
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: i < sg_unClientCnt
|—————————————Node:identifier Text: i
|—————————————Node:< Text: <
|—————————————Node:identifier Text: sg_unClientCnt
|————————————Node:; Text: ;
|————————————Node:update_expression Text: i++
|—————————————Node:identifier Text: i
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        msgsrx = RECEIVE_EVENT_SIZE;
                        xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
                        switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
                    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: msgsrx = RECEIVE_EVENT_SIZE;
|——————————————Node:assignment_expression Text: msgsrx = RECEIVE_EVENT_SIZE
|———————————————Node:identifier Text: msgsrx
|———————————————Node:= Text: =
|———————————————Node:identifier Text: RECEIVE_EVENT_SIZE
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent);
|——————————————Node:assignment_expression Text: xlStatus = xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent)
|———————————————Node:identifier Text: xlStatus
|———————————————Node:= Text: =
|———————————————Node:call_expression Text: xlReceive(g_xlPortHandle[i], &msgsrx, &xlEvent)
|————————————————Node:identifier Text: xlReceive
|————————————————Node:argument_list Text: (g_xlPortHandle[i], &msgsrx, &xlEvent)
|—————————————————Node:( Text: (
|—————————————————Node:subscript_expression Text: g_xlPortHandle[i]
|——————————————————Node:identifier Text: g_xlPortHandle
|——————————————————Node:subscript_argument_list Text: [i]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: i
|———————————————————Node:] Text: ]
|—————————————————Node:, Text: ,
|—————————————————Node:pointer_expression Text: &msgsrx
|——————————————————Node:& Text: &
|——————————————————Node:identifier Text: msgsrx
|—————————————————Node:, Text: ,
|—————————————————Node:pointer_expression Text: &xlEvent
|——————————————————Node:& Text: &
|——————————————————Node:identifier Text: xlEvent
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:switch_statement Text: switch (xlStatus)
                        {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
|——————————————Node:switch Text: switch
|——————————————Node:condition_clause Text: (xlStatus)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: xlStatus
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
                            case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;

                            default:
                                break;
                        }
|———————————————Node:{ Text: {
|———————————————Node:case_statement Text: case XL_SUCCESS:
                            {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
                            break;
|————————————————Node:case Text: case
|————————————————Node:identifier Text: XL_SUCCESS
|————————————————Node:: Text: :
|————————————————Node:compound_statement Text: {
                                ProcessCANMsg(xlEvent, i);
                                bMoreDataExist = true;
                            }
|—————————————————Node:{ Text: {
|—————————————————Node:expression_statement Text: ProcessCANMsg(xlEvent, i);
|——————————————————Node:call_expression Text: ProcessCANMsg(xlEvent, i)
|———————————————————Node:identifier Text: ProcessCANMsg
|———————————————————Node:argument_list Text: (xlEvent, i)
|————————————————————Node:( Text: (
|————————————————————Node:identifier Text: xlEvent
|————————————————————Node:, Text: ,
|————————————————————Node:identifier Text: i
|————————————————————Node:) Text: )
|——————————————————Node:; Text: ;
|—————————————————Node:expression_statement Text: bMoreDataExist = true;
|——————————————————Node:assignment_expression Text: bMoreDataExist = true
|———————————————————Node:identifier Text: bMoreDataExist
|———————————————————Node:= Text: =
|———————————————————Node:true Text: true
|——————————————————Node:; Text: ;
|—————————————————Node:} Text: }
|————————————————Node:break_statement Text: break;
|—————————————————Node:break Text: break
|—————————————————Node:; Text: ;
|———————————————Node:case_statement Text: default:
                                break;
|————————————————Node:default Text: default
|————————————————Node:: Text: :
|————————————————Node:break_statement Text: break;
|—————————————————Node:break Text: break
|—————————————————Node:; Text: ;
|———————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:while Text: while
|——————————Node:parenthesized_expression Text: (bMoreDataExist)
|———————————Node:( Text: (
|———————————Node:identifier Text: bMoreDataExist
|———————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case EXIT_THREAD:
            {
                bLoopON = false;
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: EXIT_THREAD
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                bLoopON = false;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: bLoopON = false;
|——————————Node:assignment_expression Text: bLoopON = false
|———————————Node:identifier Text: bLoopON
|———————————Node:= Text: =
|———————————Node:false Text: false
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case CREATE_TIME_MAP:
            {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: CREATE_TIME_MAP
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
                SetEvent(pThreadParam->m_hActionEvent);
                pThreadParam->m_unActionCode = INVOKE_FUNCTION;
            }
|—————————Node:{ Text: {
|—————————Node:comment Text: //vCreateTimeModeMapping(pThreadParam->m_hActionEvent);
|—————————Node:expression_statement Text: SetEvent(pThreadParam->m_hActionEvent);
|——————————Node:call_expression Text: SetEvent(pThreadParam->m_hActionEvent)
|———————————Node:identifier Text: SetEvent
|———————————Node:argument_list Text: (pThreadParam->m_hActionEvent)
|————————————Node:( Text: (
|————————————Node:field_expression Text: pThreadParam->m_hActionEvent
|—————————————Node:identifier Text: pThreadParam
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: m_hActionEvent
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pThreadParam->m_unActionCode = INVOKE_FUNCTION;
|——————————Node:assignment_expression Text: pThreadParam->m_unActionCode = INVOKE_FUNCTION
|———————————Node:field_expression Text: pThreadParam->m_unActionCode
|————————————Node:identifier Text: pThreadParam
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: m_unActionCode
|———————————Node:= Text: =
|———————————Node:identifier Text: INVOKE_FUNCTION
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: default:
|————————Node:default Text: default
|————————Node:: Text: :
|———————Node:case_statement Text: case INACTION:
            {
                // nothing right at this moment
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: INACTION
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                // nothing right at this moment
            }
|—————————Node:{ Text: {
|—————————Node:comment Text: // nothing right at this moment
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: SetEvent(pThreadParam->hGetExitNotifyEvent());
|————Node:call_expression Text: SetEvent(pThreadParam->hGetExitNotifyEvent())
|—————Node:identifier Text: SetEvent
|—————Node:argument_list Text: (pThreadParam->hGetExitNotifyEvent())
|——————Node:( Text: (
|——————Node:call_expression Text: pThreadParam->hGetExitNotifyEvent()
|———————Node:field_expression Text: pThreadParam->hGetExitNotifyEvent
|————————Node:identifier Text: pThreadParam
|————————Node:-> Text: ->
|————————Node:field_identifier Text: hGetExitNotifyEvent
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        ResetEvent(g_hDataEvent[i]);
        g_hDataEvent[i] = NULL;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        ResetEvent(g_hDataEvent[i]);
        g_hDataEvent[i] = NULL;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ResetEvent(g_hDataEvent[i]);
|——————Node:call_expression Text: ResetEvent(g_hDataEvent[i])
|———————Node:identifier Text: ResetEvent
|———————Node:argument_list Text: (g_hDataEvent[i])
|————————Node:( Text: (
|————————Node:subscript_expression Text: g_hDataEvent[i]
|—————————Node:identifier Text: g_hDataEvent
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: g_hDataEvent[i] = NULL;
|——————Node:assignment_expression Text: g_hDataEvent[i] = NULL
|———————Node:subscript_expression Text: g_hDataEvent[i]
|————————Node:identifier Text: g_hDataEvent
|————————Node:subscript_argument_list Text: [i]
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: pThreadParam->m_hActionEvent = NULL;
|————Node:assignment_expression Text: pThreadParam->m_hActionEvent = NULL
|—————Node:field_expression Text: pThreadParam->m_hActionEvent
|——————Node:identifier Text: pThreadParam
|——————Node:-> Text: ->
|——————Node:field_identifier Text: m_hActionEvent
|—————Node:= Text: =
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         connects to the channels and initiates read thread.
* \param         void
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_StartHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    //Connect to the network
    hResult = nConnect(TRUE);
    if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_CONNECTED;
        vCreateTimeModeMapping(g_hDataEvent[0]);
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }

    //If everything is ok start the read thread
    if (sg_sParmRThread.bStartThread(CanMsgReadThreadProc_CAN_Vector_XL))
    {
        hResult = S_OK;
    }
    else
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_StartHardware(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_StartHardware
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_StartHardware
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    //Connect to the network
    hResult = nConnect(TRUE);
    if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_CONNECTED;
        vCreateTimeModeMapping(g_hDataEvent[0]);
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }

    //If everything is ok start the read thread
    if (sg_sParmRThread.bStartThread(CanMsgReadThreadProc_CAN_Vector_XL))
    {
        hResult = S_OK;
    }
    else
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:comment Text: //Connect to the network
|———Node:expression_statement Text: hResult = nConnect(TRUE);
|————Node:assignment_expression Text: hResult = nConnect(TRUE)
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:call_expression Text: nConnect(TRUE)
|——————Node:identifier Text: nConnect
|——————Node:argument_list Text: (TRUE)
|———————Node:( Text: (
|———————Node:true Text: TRUE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_CONNECTED;
        vCreateTimeModeMapping(g_hDataEvent[0]);
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hResult == defERR_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: hResult == defERR_OK
|——————Node:identifier Text: hResult
|——————Node:== Text: ==
|——————Node:identifier Text: defERR_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        hResult = S_OK;
        sg_bCurrState = STATE_CONNECTED;
        vCreateTimeModeMapping(g_hDataEvent[0]);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: hResult = S_OK;
|——————Node:assignment_expression Text: hResult = S_OK
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: S_OK
|——————Node:; Text: ;
|—————Node:expression_statement Text: sg_bCurrState = STATE_CONNECTED;
|——————Node:assignment_expression Text: sg_bCurrState = STATE_CONNECTED
|———————Node:identifier Text: sg_bCurrState
|———————Node:= Text: =
|———————Node:identifier Text: STATE_CONNECTED
|——————Node:; Text: ;
|—————Node:expression_statement Text: vCreateTimeModeMapping(g_hDataEvent[0]);
|——————Node:call_expression Text: vCreateTimeModeMapping(g_hDataEvent[0])
|———————Node:identifier Text: vCreateTimeModeMapping
|———————Node:argument_list Text: (g_hDataEvent[0])
|————————Node:( Text: (
|————————Node:subscript_expression Text: g_hDataEvent[0]
|—————————Node:identifier Text: g_hDataEvent
|—————————Node:subscript_argument_list Text: [0]
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 0
|——————————Node:] Text: ]
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|——————Node:{ Text: {
|——————Node:comment Text: //log the error for open port failure
|——————Node:expression_statement Text: vRetrieveAndLog(hResult, __FILE__, __LINE__);
|———————Node:call_expression Text: vRetrieveAndLog(hResult, __FILE__, __LINE__)
|————————Node:identifier Text: vRetrieveAndLog
|————————Node:argument_list Text: (hResult, __FILE__, __LINE__)
|—————————Node:( Text: (
|—————————Node:identifier Text: hResult
|—————————Node:, Text: ,
|—————————Node:identifier Text: __FILE__
|—————————Node:, Text: ,
|—————————Node:identifier Text: __LINE__
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|———————Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: ERR_LOAD_HW_INTERFACE
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:comment Text: //If everything is ok start the read thread
|———Node:if_statement Text: if (sg_sParmRThread.bStartThread(CanMsgReadThreadProc_CAN_Vector_XL))
    {
        hResult = S_OK;
    }
    else
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
    }
|————Node:if Text: if
|————Node:condition_clause Text: (sg_sParmRThread.bStartThread(CanMsgReadThreadProc_CAN_Vector_XL))
|—————Node:( Text: (
|—————Node:call_expression Text: sg_sParmRThread.bStartThread(CanMsgReadThreadProc_CAN_Vector_XL)
|——————Node:field_expression Text: sg_sParmRThread.bStartThread
|———————Node:identifier Text: sg_sParmRThread
|———————Node:. Text: .
|———————Node:field_identifier Text: bStartThread
|——————Node:argument_list Text: (CanMsgReadThreadProc_CAN_Vector_XL)
|———————Node:( Text: (
|———————Node:identifier Text: CanMsgReadThreadProc_CAN_Vector_XL
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        hResult = S_OK;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: hResult = S_OK;
|——————Node:assignment_expression Text: hResult = S_OK
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: S_OK
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ));
|———————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _T("Could not start the read thread" ))
|————————Node:field_expression Text: sg_pIlog->vLogAMessage
|—————————Node:identifier Text: sg_pIlog
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: vLogAMessage
|————————Node:argument_list Text: (A2T(__FILE__), __LINE__, _T("Could not start the read thread" ))
|—————————Node:( Text: (
|—————————Node:call_expression Text: A2T(__FILE__)
|——————————Node:identifier Text: A2T
|——————————Node:argument_list Text: (__FILE__)
|———————————Node:( Text: (
|———————————Node:identifier Text: __FILE__
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: __LINE__
|—————————Node:, Text: ,
|—————————Node:call_expression Text: _T("Could not start the read thread" )
|——————————Node:identifier Text: _T
|——————————Node:argument_list Text: ("Could not start the read thread" )
|———————————Node:( Text: (
|———————————Node:string_literal Text: "Could not start the read thread"
|————————————Node:" Text: "
|————————————Node:string_content Text: Could not start the read thread
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This will close the connection with the driver. This will be
*                called before deleting HI layer. This will be called during
*                application close.
* \param         void
* \return        Operation Result. 0 incase of no errors. Failure Error codes(-1) otherwise.
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nDisconnectFromDriver()
{
    int nReturn = 0;
    XLstatus xlStatus;

    for ( UINT i = 0; i< sg_unClientCnt; i++ )
    {
        if (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
        {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
        else
        {
            nReturn = -1;
        }
    }
    sg_bCurrState = STATE_HW_INTERFACE_SELECTED;

    return nReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nDisconnectFromDriver()
|———Node:identifier Text: nDisconnectFromDriver
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nReturn = 0;
    XLstatus xlStatus;

    for ( UINT i = 0; i< sg_unClientCnt; i++ )
    {
        if (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
        {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
        else
        {
            nReturn = -1;
        }
    }
    sg_bCurrState = STATE_HW_INTERFACE_SELECTED;

    return nReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: int nReturn = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nReturn = 0
|—————Node:identifier Text: nReturn
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus;
|————Node:type_identifier Text: XLstatus
|————Node:identifier Text: xlStatus
|————Node:; Text: ;
|———Node:for_statement Text: for ( UINT i = 0; i< sg_unClientCnt; i++ )
    {
        if (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
        {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
        else
        {
            nReturn = -1;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i< sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
        {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
        else
        {
            nReturn = -1;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
        {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
        else
        {
            nReturn = -1;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (g_xlPortHandle[i] != XL_INVALID_PORTHANDLE)
|———————Node:( Text: (
|———————Node:binary_expression Text: g_xlPortHandle[i] != XL_INVALID_PORTHANDLE
|————————Node:subscript_expression Text: g_xlPortHandle[i]
|—————————Node:identifier Text: g_xlPortHandle
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|————————Node:!= Text: !=
|————————Node:identifier Text: XL_INVALID_PORTHANDLE
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
            xlStatus = xlClosePort(g_xlPortHandle[i]);
            g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask );
|————————Node:assignment_expression Text: xlStatus = xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask )
|—————————Node:identifier Text: xlStatus
|—————————Node:= Text: =
|—————————Node:call_expression Text: xlDeactivateChannel( g_xlPortHandle[i], g_xlChannelMask )
|——————————Node:identifier Text: xlDeactivateChannel
|——————————Node:argument_list Text: ( g_xlPortHandle[i], g_xlChannelMask )
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: g_xlPortHandle[i]
|————————————Node:identifier Text: g_xlPortHandle
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:identifier Text: g_xlChannelMask
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: xlStatus = xlClosePort(g_xlPortHandle[i]);
|————————Node:assignment_expression Text: xlStatus = xlClosePort(g_xlPortHandle[i])
|—————————Node:identifier Text: xlStatus
|—————————Node:= Text: =
|—————————Node:call_expression Text: xlClosePort(g_xlPortHandle[i])
|——————————Node:identifier Text: xlClosePort
|——————————Node:argument_list Text: (g_xlPortHandle[i])
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: g_xlPortHandle[i]
|————————————Node:identifier Text: g_xlPortHandle
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: g_xlPortHandle[i] = XL_INVALID_PORTHANDLE;
|————————Node:assignment_expression Text: g_xlPortHandle[i] = XL_INVALID_PORTHANDLE
|—————————Node:subscript_expression Text: g_xlPortHandle[i]
|——————————Node:identifier Text: g_xlPortHandle
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:identifier Text: XL_INVALID_PORTHANDLE
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            nReturn = -1;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            nReturn = -1;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: nReturn = -1;
|—————————Node:assignment_expression Text: nReturn = -1
|——————————Node:identifier Text: nReturn
|——————————Node:= Text: =
|——————————Node:number_literal Text: -1
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
|————Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED
|—————Node:identifier Text: sg_bCurrState
|—————Node:= Text: =
|—————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|————Node:; Text: ;
|———Node:return_statement Text: return nReturn;
|————Node:return Text: return
|————Node:identifier Text: nReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to map device channels with BUSMASTER channel order
* \param         void
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static void vMapDeviceChannelIndex()
{
    //Reset previous channel ID assignment if any
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i;
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: vMapDeviceChannelIndex()
|———Node:identifier Text: vMapDeviceChannelIndex
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    //Reset previous channel ID assignment if any
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i;
    }
}
|———Node:{ Text: {
|———Node:comment Text: //Reset previous channel ID assignment if any
|———Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_nNoOfChannels
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_nNoOfChannels
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i;
|——————Node:assignment_expression Text: sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex] = i
|———————Node:subscript_expression Text: sg_unDevChannelMap[sg_aodChannels[i].m_pXLChannelInfo->channelIndex]
|————————Node:identifier Text: sg_unDevChannelMap
|————————Node:subscript_argument_list Text: [sg_aodChannels[i].m_pXLChannelInfo->channelIndex]
|—————————Node:[ Text: [
|—————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo->channelIndex
|——————————Node:field_expression Text: sg_aodChannels[i].m_pXLChannelInfo
|———————————Node:subscript_expression Text: sg_aodChannels[i]
|————————————Node:identifier Text: sg_aodChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_pXLChannelInfo
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: channelIndex
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will connect the tool with hardware. This will
*                establish the data link between the application and hardware.
* \param[in]     bConnect TRUE to Connect, FALSE to Disconnect
* \return        Returns defERR_OK if successful otherwise corresponding Error code.
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nConnect(BOOL bConnect)
{
    int nReturn = -1;
    XLstatus xlStatus;

    if (!sg_bIsConnected && bConnect) // Disconnected and to be connected
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }

        if (XL_SUCCESS == xlStatus)
        {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
    }
    else if (sg_bIsConnected && !bConnect) // Connected & to be disconnected
    {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
    else
    {
        nReturn = defERR_OK;
    }
    if ( sg_bIsConnected )
    {
        InitializeCriticalSection(&sg_CritSectForWrite);
    }
    else
    {
        DeleteCriticalSection(&sg_CritSectForWrite);
    }

    return nReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nConnect(BOOL bConnect)
|———Node:identifier Text: nConnect
|———Node:parameter_list Text: (BOOL bConnect)
|————Node:( Text: (
|————Node:parameter_declaration Text: BOOL bConnect
|—————Node:type_identifier Text: BOOL
|—————Node:identifier Text: bConnect
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nReturn = -1;
    XLstatus xlStatus;

    if (!sg_bIsConnected && bConnect) // Disconnected and to be connected
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }

        if (XL_SUCCESS == xlStatus)
        {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
    }
    else if (sg_bIsConnected && !bConnect) // Connected & to be disconnected
    {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
    else
    {
        nReturn = defERR_OK;
    }
    if ( sg_bIsConnected )
    {
        InitializeCriticalSection(&sg_CritSectForWrite);
    }
    else
    {
        DeleteCriticalSection(&sg_CritSectForWrite);
    }

    return nReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: int nReturn = -1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nReturn = -1
|—————Node:identifier Text: nReturn
|—————Node:= Text: =
|—————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus;
|————Node:type_identifier Text: XLstatus
|————Node:identifier Text: xlStatus
|————Node:; Text: ;
|———Node:if_statement Text: if (!sg_bIsConnected && bConnect) // Disconnected and to be connected
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }

        if (XL_SUCCESS == xlStatus)
        {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
    }
    else if (sg_bIsConnected && !bConnect) // Connected & to be disconnected
    {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
    else
    {
        nReturn = defERR_OK;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (!sg_bIsConnected && bConnect)
|—————Node:( Text: (
|—————Node:binary_expression Text: !sg_bIsConnected && bConnect
|——————Node:unary_expression Text: !sg_bIsConnected
|———————Node:! Text: !
|———————Node:identifier Text: sg_bIsConnected
|——————Node:&& Text: &&
|——————Node:identifier Text: bConnect
|—————Node:) Text: )
|————Node:comment Text: // Disconnected and to be connected
|————Node:compound_statement Text: {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }

        if (XL_SUCCESS == xlStatus)
        {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: UINT i = 0;
|———————Node:type_identifier Text: UINT
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < sg_unClientCnt
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: sg_unClientCnt
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            // ------------------------------------
            // open ONE port PER each node including all channels
            // ------------------------------------
            xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
        }
|———————Node:{ Text: {
|———————Node:comment Text: // ------------------------------------
|———————Node:comment Text: // open ONE port PER each node including all channels
|———————Node:comment Text: // ------------------------------------
|———————Node:expression_statement Text: xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN);
|————————Node:assignment_expression Text: xlStatus = xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN)
|—————————Node:identifier Text: xlStatus
|—————————Node:= Text: =
|—————————Node:call_expression Text: xlOpenPort(&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN)
|——————————Node:identifier Text: xlOpenPort
|——————————Node:argument_list Text: (&g_xlPortHandle[i], g_AppName, g_xlChannelMask, &g_xlPermissionMask,
                                  RX_QUEUE_SIZE, XL_INTERFACE_VERSION, XL_BUS_TYPE_CAN)
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &g_xlPortHandle[i]
|————————————Node:& Text: &
|————————————Node:subscript_expression Text: g_xlPortHandle[i]
|—————————————Node:identifier Text: g_xlPortHandle
|—————————————Node:subscript_argument_list Text: [i]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: i
|——————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:identifier Text: g_AppName
|———————————Node:, Text: ,
|———————————Node:identifier Text: g_xlChannelMask
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &g_xlPermissionMask
|————————————Node:& Text: &
|————————————Node:identifier Text: g_xlPermissionMask
|———————————Node:, Text: ,
|———————————Node:identifier Text: RX_QUEUE_SIZE
|———————————Node:, Text: ,
|———————————Node:identifier Text: XL_INTERFACE_VERSION
|———————————Node:, Text: ,
|———————————Node:identifier Text: XL_BUS_TYPE_CAN
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (XL_SUCCESS == xlStatus)
        {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (XL_SUCCESS == xlStatus)
|———————Node:( Text: (
|———————Node:binary_expression Text: XL_SUCCESS == xlStatus
|————————Node:identifier Text: XL_SUCCESS
|————————Node:== Text: ==
|————————Node:identifier Text: xlStatus
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            //Calculate connected Timestamp
            QueryPerformanceCounter(&sg_QueryTickCount);
            // Get frequency of the performance counter
            QueryPerformanceFrequency(&sg_lnFrequency);
            // Convert it to time stamp with the granularity of hundreds of microsecond
            //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
            if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }

            /* Transit into 'CREATE TIME MAP' state */
            sg_byCurrState = CREATE_MAP_TIMESTAMP;
            vMapDeviceChannelIndex();
            sg_bIsConnected = bConnect;
            // ------------------------------------
            // go with all selected channels on bus
            // ------------------------------------
            for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
            if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
        }
|———————Node:{ Text: {
|———————Node:comment Text: //Calculate connected Timestamp
|———————Node:expression_statement Text: QueryPerformanceCounter(&sg_QueryTickCount);
|————————Node:call_expression Text: QueryPerformanceCounter(&sg_QueryTickCount)
|—————————Node:identifier Text: QueryPerformanceCounter
|—————————Node:argument_list Text: (&sg_QueryTickCount)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &sg_QueryTickCount
|———————————Node:& Text: &
|———————————Node:identifier Text: sg_QueryTickCount
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // Get frequency of the performance counter
|———————Node:expression_statement Text: QueryPerformanceFrequency(&sg_lnFrequency);
|————————Node:call_expression Text: QueryPerformanceFrequency(&sg_lnFrequency)
|—————————Node:identifier Text: QueryPerformanceFrequency
|—————————Node:argument_list Text: (&sg_lnFrequency)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &sg_lnFrequency
|———————————Node:& Text: &
|———————————Node:identifier Text: sg_lnFrequency
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // Convert it to time stamp with the granularity of hundreds of microsecond
|———————Node:comment Text: //if (sg_QueryTickCount.QuadPart * 10000 > sg_QueryTickCount.QuadPart)
|———————Node:if_statement Text: if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
            else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart
|——————————Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart * 10000)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: sg_QueryTickCount.QuadPart * 10000
|————————————Node:field_expression Text: sg_QueryTickCount.QuadPart
|—————————————Node:identifier Text: sg_QueryTickCount
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: QuadPart
|————————————Node:* Text: *
|————————————Node:number_literal Text: 10000
|———————————Node:) Text: )
|——————————Node:> Text: >
|——————————Node:field_expression Text: sg_lnFrequency.QuadPart
|———————————Node:identifier Text: sg_lnFrequency
|———————————Node:. Text: .
|———————————Node:field_identifier Text: QuadPart
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
|——————————Node:assignment_expression Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|———————————Node:identifier Text: sg_TimeStamp
|———————————Node:= Text: =
|———————————Node:binary_expression Text: (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|————————————Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart * 10000)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: sg_QueryTickCount.QuadPart * 10000
|——————————————Node:field_expression Text: sg_QueryTickCount.QuadPart
|———————————————Node:identifier Text: sg_QueryTickCount
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: QuadPart
|——————————————Node:* Text: *
|——————————————Node:number_literal Text: 10000
|—————————————Node:) Text: )
|————————————Node:/ Text: /
|————————————Node:field_expression Text: sg_lnFrequency.QuadPart
|—————————————Node:identifier Text: sg_lnFrequency
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: QuadPart
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else
            {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
                sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
|———————————Node:assignment_expression Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000
|————————————Node:identifier Text: sg_TimeStamp
|————————————Node:= Text: =
|————————————Node:binary_expression Text: (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000
|—————————————Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart
|———————————————Node:field_expression Text: sg_QueryTickCount.QuadPart
|————————————————Node:identifier Text: sg_QueryTickCount
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: QuadPart
|———————————————Node:/ Text: /
|———————————————Node:field_expression Text: sg_lnFrequency.QuadPart
|————————————————Node:identifier Text: sg_lnFrequency
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: QuadPart
|——————————————Node:) Text: )
|—————————————Node:* Text: *
|—————————————Node:number_literal Text: 10000
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:comment Text: /* Transit into 'CREATE TIME MAP' state */
|———————Node:expression_statement Text: sg_byCurrState = CREATE_MAP_TIMESTAMP;
|————————Node:assignment_expression Text: sg_byCurrState = CREATE_MAP_TIMESTAMP
|—————————Node:identifier Text: sg_byCurrState
|—————————Node:= Text: =
|—————————Node:identifier Text: CREATE_MAP_TIMESTAMP
|————————Node:; Text: ;
|———————Node:expression_statement Text: vMapDeviceChannelIndex();
|————————Node:call_expression Text: vMapDeviceChannelIndex()
|—————————Node:identifier Text: vMapDeviceChannelIndex
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: sg_bIsConnected = bConnect;
|————————Node:assignment_expression Text: sg_bIsConnected = bConnect
|—————————Node:identifier Text: sg_bIsConnected
|—————————Node:= Text: =
|—————————Node:identifier Text: bConnect
|————————Node:; Text: ;
|———————Node:comment Text: // ------------------------------------
|———————Node:comment Text: // go with all selected channels on bus
|———————Node:comment Text: // ------------------------------------
|———————Node:for_statement Text: for ( UINT i = 0; i< sg_unClientCnt; i++ )
            {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: UINT i = 0;
|—————————Node:type_identifier Text: UINT
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i< sg_unClientCnt
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:identifier Text: sg_unClientCnt
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
                xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
|——————————Node:assignment_expression Text: xlStatus = xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|———————————Node:identifier Text: xlStatus
|———————————Node:= Text: =
|———————————Node:call_expression Text: xlActivateChannel(g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|————————————Node:identifier Text: xlActivateChannel
|————————————Node:argument_list Text: (g_xlPortHandle[i], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|—————————————Node:( Text: (
|—————————————Node:subscript_expression Text: g_xlPortHandle[i]
|——————————————Node:identifier Text: g_xlPortHandle
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: g_xlChannelMask
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: XL_BUS_TYPE_CAN
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: XL_ACTIVATE_RESET_CLOCK
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:if_statement Text: if(xlStatus == XL_SUCCESS)
            {
                nReturn = defERR_OK;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (xlStatus == XL_SUCCESS)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: xlStatus == XL_SUCCESS
|——————————Node:identifier Text: xlStatus
|——————————Node:== Text: ==
|——————————Node:identifier Text: XL_SUCCESS
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                nReturn = defERR_OK;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: nReturn = defERR_OK;
|——————————Node:assignment_expression Text: nReturn = defERR_OK
|———————————Node:identifier Text: nReturn
|———————————Node:= Text: =
|———————————Node:identifier Text: defERR_OK
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else if (sg_bIsConnected && !bConnect) // Connected & to be disconnected
    {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
    else
    {
        nReturn = defERR_OK;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (sg_bIsConnected && !bConnect) // Connected & to be disconnected
    {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
    else
    {
        nReturn = defERR_OK;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sg_bIsConnected && !bConnect)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_bIsConnected && !bConnect
|————————Node:identifier Text: sg_bIsConnected
|————————Node:&& Text: &&
|————————Node:unary_expression Text: !bConnect
|—————————Node:! Text: !
|—————————Node:identifier Text: bConnect
|———————Node:) Text: )
|——————Node:comment Text: // Connected & to be disconnected
|——————Node:compound_statement Text: {
        sg_bIsConnected = bConnect;
        Sleep(0); // Let other threads run for once
        nReturn = nDisconnectFromDriver();
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sg_bIsConnected = bConnect;
|————————Node:assignment_expression Text: sg_bIsConnected = bConnect
|—————————Node:identifier Text: sg_bIsConnected
|—————————Node:= Text: =
|—————————Node:identifier Text: bConnect
|————————Node:; Text: ;
|———————Node:expression_statement Text: Sleep(0);
|————————Node:call_expression Text: Sleep(0)
|—————————Node:identifier Text: Sleep
|—————————Node:argument_list Text: (0)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // Let other threads run for once
|———————Node:expression_statement Text: nReturn = nDisconnectFromDriver();
|————————Node:assignment_expression Text: nReturn = nDisconnectFromDriver()
|—————————Node:identifier Text: nReturn
|—————————Node:= Text: =
|—————————Node:call_expression Text: nDisconnectFromDriver()
|——————————Node:identifier Text: nDisconnectFromDriver
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
    {
        nReturn = defERR_OK;
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
        nReturn = defERR_OK;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: nReturn = defERR_OK;
|—————————Node:assignment_expression Text: nReturn = defERR_OK
|——————————Node:identifier Text: nReturn
|——————————Node:= Text: =
|——————————Node:identifier Text: defERR_OK
|—————————Node:; Text: ;
|————————Node:} Text: }
|———Node:if_statement Text: if ( sg_bIsConnected )
    {
        InitializeCriticalSection(&sg_CritSectForWrite);
    }
    else
    {
        DeleteCriticalSection(&sg_CritSectForWrite);
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( sg_bIsConnected )
|—————Node:( Text: (
|—————Node:identifier Text: sg_bIsConnected
|—————Node:) Text: )
|————Node:compound_statement Text: {
        InitializeCriticalSection(&sg_CritSectForWrite);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: InitializeCriticalSection(&sg_CritSectForWrite);
|——————Node:call_expression Text: InitializeCriticalSection(&sg_CritSectForWrite)
|———————Node:identifier Text: InitializeCriticalSection
|———————Node:argument_list Text: (&sg_CritSectForWrite)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &sg_CritSectForWrite
|—————————Node:& Text: &
|—————————Node:identifier Text: sg_CritSectForWrite
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        DeleteCriticalSection(&sg_CritSectForWrite);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        DeleteCriticalSection(&sg_CritSectForWrite);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: DeleteCriticalSection(&sg_CritSectForWrite);
|———————Node:call_expression Text: DeleteCriticalSection(&sg_CritSectForWrite)
|————————Node:identifier Text: DeleteCriticalSection
|————————Node:argument_list Text: (&sg_CritSectForWrite)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &sg_CritSectForWrite
|——————————Node:& Text: &
|——————————Node:identifier Text: sg_CritSectForWrite
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return nReturn;
|————Node:return Text: return
|————Node:identifier Text: nReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Stops the controller.
* \param         void
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_StopHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;

    //Terminate the read thread
    sg_sParmRThread.bTerminateThread();

    hResult = nConnect(FALSE);
    if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_StopHardware(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_StopHardware
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_StopHardware
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;

    //Terminate the read thread
    sg_sParmRThread.bTerminateThread();

    hResult = nConnect(FALSE);
    if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_CONNECTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:comment Text: //Terminate the read thread
|———Node:expression_statement Text: sg_sParmRThread.bTerminateThread();
|————Node:call_expression Text: sg_sParmRThread.bTerminateThread()
|—————Node:field_expression Text: sg_sParmRThread.bTerminateThread
|——————Node:identifier Text: sg_sParmRThread
|——————Node:. Text: .
|——————Node:field_identifier Text: bTerminateThread
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hResult = nConnect(FALSE);
|————Node:assignment_expression Text: hResult = nConnect(FALSE)
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:call_expression Text: nConnect(FALSE)
|——————Node:identifier Text: nConnect
|——————Node:argument_list Text: (FALSE)
|———————Node:( Text: (
|———————Node:false Text: FALSE
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (hResult == defERR_OK)
    {
        hResult = S_OK;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hResult == defERR_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: hResult == defERR_OK
|——————Node:identifier Text: hResult
|——————Node:== Text: ==
|——————Node:identifier Text: defERR_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        hResult = S_OK;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: hResult = S_OK;
|——————Node:assignment_expression Text: hResult = S_OK
|———————Node:identifier Text: hResult
|———————Node:= Text: =
|———————Node:identifier Text: S_OK
|——————Node:; Text: ;
|—————Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
|——————Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED
|———————Node:identifier Text: sg_bCurrState
|———————Node:= Text: =
|———————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        //log the error for open port failure
        vRetrieveAndLog(hResult, __FILE__, __LINE__);
        hResult = ERR_LOAD_HW_INTERFACE;
    }
|——————Node:{ Text: {
|——————Node:comment Text: //log the error for open port failure
|——————Node:expression_statement Text: vRetrieveAndLog(hResult, __FILE__, __LINE__);
|———————Node:call_expression Text: vRetrieveAndLog(hResult, __FILE__, __LINE__)
|————————Node:identifier Text: vRetrieveAndLog
|————————Node:argument_list Text: (hResult, __FILE__, __LINE__)
|—————————Node:( Text: (
|—————————Node:identifier Text: hResult
|—————————Node:, Text: ,
|—————————Node:identifier Text: __FILE__
|—————————Node:, Text: ,
|—————————Node:identifier Text: __LINE__
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|———————Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: ERR_LOAD_HW_INTERFACE
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Resets the controller.
* \param         void
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_ResetHardware(void)
{
    HRESULT hResult = S_OK;

    /* Stop the hardware if connected */
    /*hResult = */
    CAN_StopHardware(); // return value not necessary ..fix for git issue 204 by Srinivas

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_ResetHardware(void)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_ResetHardware
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_ResetHardware
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;

    /* Stop the hardware if connected */
    /*hResult = */
    CAN_StopHardware(); // return value not necessary ..fix for git issue 204 by Srinivas

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:comment Text: /* Stop the hardware if connected */
|———Node:comment Text: /*hResult = */
|———Node:expression_statement Text: CAN_StopHardware();
|————Node:call_expression Text: CAN_StopHardware()
|—————Node:identifier Text: CAN_StopHardware
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // return value not necessary ..fix for git issue 204 by Srinivas
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to get Controller status
* \param[out]    StatusData, is s_STATUSMSG structure
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
{
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetCurrStatus
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetCurrStatus
|———Node:parameter_list Text: (s_STATUSMSG& StatusData)
|————Node:( Text: (
|————Node:parameter_declaration Text: s_STATUSMSG& StatusData
|—————Node:type_identifier Text: s_STATUSMSG
|—————Node:reference_declarator Text: & StatusData
|——————Node:& Text: &
|——————Node:identifier Text: StatusData
|————Node:) Text: )
|——Node:compound_statement Text: {
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: StatusData.wControllerStatus = NORMAL_ACTIVE;
|————Node:assignment_expression Text: StatusData.wControllerStatus = NORMAL_ACTIVE
|—————Node:field_expression Text: StatusData.wControllerStatus
|——————Node:identifier Text: StatusData
|——————Node:. Text: .
|——————Node:field_identifier Text: wControllerStatus
|—————Node:= Text: =
|—————Node:identifier Text: NORMAL_ACTIVE
|————Node:; Text: ;
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Gets the Tx queue configured.
* \param[out]    pouFlxTxMsgBuffer, is BYTE*
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetTxMsgBuffer(BYTE*& /*pouFlxTxMsgBuffer*/)
{
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetTxMsgBuffer(BYTE*& /*pouFlxTxMsgBuffer*/)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetTxMsgBuffer
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetTxMsgBuffer
|———Node:parameter_list Text: (BYTE*& /*pouFlxTxMsgBuffer*/)
|————Node:( Text: (
|————Node:parameter_declaration Text: BYTE*&
|—————Node:type_identifier Text: BYTE
|—————Node:abstract_pointer_declarator Text: *&
|——————Node:* Text: *
|——————Node:abstract_reference_declarator Text: &
|———————Node:& Text: &
|————Node:comment Text: /*pouFlxTxMsgBuffer*/
|————Node:) Text: )
|——Node:compound_statement Text: {
    return S_OK;
}
|———Node:{ Text: {
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This will send a CAN message to the driver. In case of USB
*                this will write the message in to the driver buffer and will
*                return. In case if parallel port mode this will write the
*                message and will wait for the ACK event from the driver. If
*                the event fired this will return 0. Otherwise this will return
*                wait time out error. In parallel port it is a blocking call
*                and in case of failure condition this will take 2 seconds.
* \param[in]     sMessage Message to Transmit
* \return        Operation Result. 0 incase of no errors. Failure Error codes otherwise.
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nWriteMessage(STCAN_MSG sMessage, DWORD dwClientID)
{
    int nReturn = -1;
    XLaccess xlChanMaskTx = 0;
    UINT unClientIndex = (UINT)-1;

    if ((sMessage.m_ucChannel > 0) &&
            (sMessage.m_ucChannel <= sg_nNoOfChannels))
    {
        static XLevent       xlEvent;
        // PTV CPP
        XLstatus             xlStatus = 0;
        unsigned int         messageCount = 1;

        memset(&xlEvent, 0, sizeof(xlEvent));

        xlEvent.tag                 = XL_TRANSMIT_MSG;
        /* if it is an extended frame */
        if (sMessage.m_ucEXTENDED == 1)
        {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
        /* in case of remote frame */
        if (sMessage.m_ucRTR == 1)
        {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
        else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
        xlEvent.tagData.msg.id      = sMessage.m_unMsgID;
        xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen;
        memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen);

        //Get channel mask
        xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask;
        //Transmit message
        if ( bGetClientObj(dwClientID, unClientIndex) )
        {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
        //set result
        nReturn = xlStatus;
    }

    return nReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nWriteMessage(STCAN_MSG sMessage, DWORD dwClientID)
|———Node:identifier Text: nWriteMessage
|———Node:parameter_list Text: (STCAN_MSG sMessage, DWORD dwClientID)
|————Node:( Text: (
|————Node:parameter_declaration Text: STCAN_MSG sMessage
|—————Node:type_identifier Text: STCAN_MSG
|—————Node:identifier Text: sMessage
|————Node:, Text: ,
|————Node:parameter_declaration Text: DWORD dwClientID
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientID
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nReturn = -1;
    XLaccess xlChanMaskTx = 0;
    UINT unClientIndex = (UINT)-1;

    if ((sMessage.m_ucChannel > 0) &&
            (sMessage.m_ucChannel <= sg_nNoOfChannels))
    {
        static XLevent       xlEvent;
        // PTV CPP
        XLstatus             xlStatus = 0;
        unsigned int         messageCount = 1;

        memset(&xlEvent, 0, sizeof(xlEvent));

        xlEvent.tag                 = XL_TRANSMIT_MSG;
        /* if it is an extended frame */
        if (sMessage.m_ucEXTENDED == 1)
        {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
        /* in case of remote frame */
        if (sMessage.m_ucRTR == 1)
        {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
        else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
        xlEvent.tagData.msg.id      = sMessage.m_unMsgID;
        xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen;
        memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen);

        //Get channel mask
        xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask;
        //Transmit message
        if ( bGetClientObj(dwClientID, unClientIndex) )
        {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
        //set result
        nReturn = xlStatus;
    }

    return nReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: int nReturn = -1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nReturn = -1
|—————Node:identifier Text: nReturn
|—————Node:= Text: =
|—————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:declaration Text: XLaccess xlChanMaskTx = 0;
|————Node:type_identifier Text: XLaccess
|————Node:init_declarator Text: xlChanMaskTx = 0
|—————Node:identifier Text: xlChanMaskTx
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: UINT unClientIndex = (UINT)-1;
|————Node:type_identifier Text: UINT
|————Node:init_declarator Text: unClientIndex = (UINT)-1
|—————Node:identifier Text: unClientIndex
|—————Node:= Text: =
|—————Node:binary_expression Text: (UINT)-1
|——————Node:parenthesized_expression Text: (UINT)
|———————Node:( Text: (
|———————Node:identifier Text: UINT
|———————Node:) Text: )
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:if_statement Text: if ((sMessage.m_ucChannel > 0) &&
            (sMessage.m_ucChannel <= sg_nNoOfChannels))
    {
        static XLevent       xlEvent;
        // PTV CPP
        XLstatus             xlStatus = 0;
        unsigned int         messageCount = 1;

        memset(&xlEvent, 0, sizeof(xlEvent));

        xlEvent.tag                 = XL_TRANSMIT_MSG;
        /* if it is an extended frame */
        if (sMessage.m_ucEXTENDED == 1)
        {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
        /* in case of remote frame */
        if (sMessage.m_ucRTR == 1)
        {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
        else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
        xlEvent.tagData.msg.id      = sMessage.m_unMsgID;
        xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen;
        memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen);

        //Get channel mask
        xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask;
        //Transmit message
        if ( bGetClientObj(dwClientID, unClientIndex) )
        {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
        //set result
        nReturn = xlStatus;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ((sMessage.m_ucChannel > 0) &&
            (sMessage.m_ucChannel <= sg_nNoOfChannels))
|—————Node:( Text: (
|—————Node:binary_expression Text: (sMessage.m_ucChannel > 0) &&
            (sMessage.m_ucChannel <= sg_nNoOfChannels)
|——————Node:parenthesized_expression Text: (sMessage.m_ucChannel > 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: sMessage.m_ucChannel > 0
|————————Node:field_expression Text: sMessage.m_ucChannel
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucChannel
|————————Node:> Text: >
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (sMessage.m_ucChannel <= sg_nNoOfChannels)
|———————Node:( Text: (
|———————Node:binary_expression Text: sMessage.m_ucChannel <= sg_nNoOfChannels
|————————Node:field_expression Text: sMessage.m_ucChannel
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucChannel
|————————Node:<= Text: <=
|————————Node:identifier Text: sg_nNoOfChannels
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        static XLevent       xlEvent;
        // PTV CPP
        XLstatus             xlStatus = 0;
        unsigned int         messageCount = 1;

        memset(&xlEvent, 0, sizeof(xlEvent));

        xlEvent.tag                 = XL_TRANSMIT_MSG;
        /* if it is an extended frame */
        if (sMessage.m_ucEXTENDED == 1)
        {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
        /* in case of remote frame */
        if (sMessage.m_ucRTR == 1)
        {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
        else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
        xlEvent.tagData.msg.id      = sMessage.m_unMsgID;
        xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen;
        memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen);

        //Get channel mask
        xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask;
        //Transmit message
        if ( bGetClientObj(dwClientID, unClientIndex) )
        {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
        //set result
        nReturn = xlStatus;
    }
|—————Node:{ Text: {
|—————Node:declaration Text: static XLevent       xlEvent;
|——————Node:storage_class_specifier Text: static
|———————Node:static Text: static
|——————Node:type_identifier Text: XLevent
|——————Node:identifier Text: xlEvent
|——————Node:; Text: ;
|—————Node:comment Text: // PTV CPP
|—————Node:declaration Text: XLstatus             xlStatus = 0;
|——————Node:type_identifier Text: XLstatus
|——————Node:init_declarator Text: xlStatus = 0
|———————Node:identifier Text: xlStatus
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:declaration Text: unsigned int         messageCount = 1;
|——————Node:sized_type_specifier Text: unsigned int
|———————Node:unsigned Text: unsigned
|———————Node:primitive_type Text: int
|——————Node:init_declarator Text: messageCount = 1
|———————Node:identifier Text: messageCount
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: memset(&xlEvent, 0, sizeof(xlEvent));
|——————Node:call_expression Text: memset(&xlEvent, 0, sizeof(xlEvent))
|———————Node:identifier Text: memset
|———————Node:argument_list Text: (&xlEvent, 0, sizeof(xlEvent))
|————————Node:( Text: (
|————————Node:pointer_expression Text: &xlEvent
|—————————Node:& Text: &
|—————————Node:identifier Text: xlEvent
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(xlEvent)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (xlEvent)
|——————————Node:( Text: (
|——————————Node:identifier Text: xlEvent
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: xlEvent.tag                 = XL_TRANSMIT_MSG;
|——————Node:assignment_expression Text: xlEvent.tag                 = XL_TRANSMIT_MSG
|———————Node:field_expression Text: xlEvent.tag
|————————Node:identifier Text: xlEvent
|————————Node:. Text: .
|————————Node:field_identifier Text: tag
|———————Node:= Text: =
|———————Node:identifier Text: XL_TRANSMIT_MSG
|——————Node:; Text: ;
|—————Node:comment Text: /* if it is an extended frame */
|—————Node:if_statement Text: if (sMessage.m_ucEXTENDED == 1)
        {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sMessage.m_ucEXTENDED == 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: sMessage.m_ucEXTENDED == 1
|————————Node:field_expression Text: sMessage.m_ucEXTENDED
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucEXTENDED
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID; // toggle ext/std
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID;
|————————Node:assignment_expression Text: sMessage.m_unMsgID ^= XL_CAN_EXT_MSG_ID
|—————————Node:field_expression Text: sMessage.m_unMsgID
|——————————Node:identifier Text: sMessage
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_unMsgID
|—————————Node:^= Text: ^=
|—————————Node:identifier Text: XL_CAN_EXT_MSG_ID
|————————Node:; Text: ;
|———————Node:comment Text: // toggle ext/std
|———————Node:} Text: }
|—————Node:comment Text: /* in case of remote frame */
|—————Node:if_statement Text: if (sMessage.m_ucRTR == 1)
        {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
        else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sMessage.m_ucRTR == 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: sMessage.m_ucRTR == 1
|————————Node:field_expression Text: sMessage.m_ucRTR
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucRTR
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME;
|————————Node:assignment_expression Text: xlEvent.tagData.msg.flags   = XL_CAN_MSG_FLAG_REMOTE_FRAME
|—————————Node:field_expression Text: xlEvent.tagData.msg.flags
|——————————Node:field_expression Text: xlEvent.tagData.msg
|———————————Node:field_expression Text: xlEvent.tagData
|————————————Node:identifier Text: xlEvent
|————————————Node:. Text: .
|————————————Node:field_identifier Text: tagData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: flags
|—————————Node:= Text: =
|—————————Node:identifier Text: XL_CAN_MSG_FLAG_REMOTE_FRAME
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            xlEvent.tagData.msg.flags   = 0;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            xlEvent.tagData.msg.flags   = 0;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: xlEvent.tagData.msg.flags   = 0;
|—————————Node:assignment_expression Text: xlEvent.tagData.msg.flags   = 0
|——————————Node:field_expression Text: xlEvent.tagData.msg.flags
|———————————Node:field_expression Text: xlEvent.tagData.msg
|————————————Node:field_expression Text: xlEvent.tagData
|—————————————Node:identifier Text: xlEvent
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: tagData
|————————————Node:. Text: .
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:expression_statement Text: xlEvent.tagData.msg.id      = sMessage.m_unMsgID;
|——————Node:assignment_expression Text: xlEvent.tagData.msg.id      = sMessage.m_unMsgID
|———————Node:field_expression Text: xlEvent.tagData.msg.id
|————————Node:field_expression Text: xlEvent.tagData.msg
|—————————Node:field_expression Text: xlEvent.tagData
|——————————Node:identifier Text: xlEvent
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tagData
|—————————Node:. Text: .
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:field_expression Text: sMessage.m_unMsgID
|————————Node:identifier Text: sMessage
|————————Node:. Text: .
|————————Node:field_identifier Text: m_unMsgID
|——————Node:; Text: ;
|—————Node:expression_statement Text: xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen;
|——————Node:assignment_expression Text: xlEvent.tagData.msg.dlc     = (unsigned short)sMessage.m_ucDataLen
|———————Node:field_expression Text: xlEvent.tagData.msg.dlc
|————————Node:field_expression Text: xlEvent.tagData.msg
|—————————Node:field_expression Text: xlEvent.tagData
|——————————Node:identifier Text: xlEvent
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tagData
|—————————Node:. Text: .
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: dlc
|———————Node:= Text: =
|———————Node:cast_expression Text: (unsigned short)sMessage.m_ucDataLen
|————————Node:( Text: (
|————————Node:type_descriptor Text: unsigned short
|—————————Node:sized_type_specifier Text: unsigned short
|——————————Node:unsigned Text: unsigned
|——————————Node:short Text: short
|————————Node:) Text: )
|————————Node:field_expression Text: sMessage.m_ucDataLen
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucDataLen
|——————Node:; Text: ;
|—————Node:expression_statement Text: memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen);
|——————Node:call_expression Text: memcpy(&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen)
|———————Node:identifier Text: memcpy
|———————Node:argument_list Text: (&xlEvent.tagData.msg.data, &sMessage.m_ucData, sMessage.m_ucDataLen)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &xlEvent.tagData.msg.data
|—————————Node:& Text: &
|—————————Node:field_expression Text: xlEvent.tagData.msg.data
|——————————Node:field_expression Text: xlEvent.tagData.msg
|———————————Node:field_expression Text: xlEvent.tagData
|————————————Node:identifier Text: xlEvent
|————————————Node:. Text: .
|————————————Node:field_identifier Text: tagData
|———————————Node:. Text: .
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: data
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &sMessage.m_ucData
|—————————Node:& Text: &
|—————————Node:field_expression Text: sMessage.m_ucData
|——————————Node:identifier Text: sMessage
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_ucData
|————————Node:, Text: ,
|————————Node:field_expression Text: sMessage.m_ucDataLen
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucDataLen
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: //Get channel mask
|—————Node:expression_statement Text: xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask;
|——————Node:assignment_expression Text: xlChanMaskTx = sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask
|———————Node:identifier Text: xlChanMaskTx
|———————Node:= Text: =
|———————Node:field_expression Text: sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo->channelMask
|————————Node:field_expression Text: sg_aodChannels[sMessage.m_ucChannel - 1].m_pXLChannelInfo
|—————————Node:subscript_expression Text: sg_aodChannels[sMessage.m_ucChannel - 1]
|——————————Node:identifier Text: sg_aodChannels
|——————————Node:subscript_argument_list Text: [sMessage.m_ucChannel - 1]
|———————————Node:[ Text: [
|———————————Node:binary_expression Text: sMessage.m_ucChannel - 1
|————————————Node:field_expression Text: sMessage.m_ucChannel
|—————————————Node:identifier Text: sMessage
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: m_ucChannel
|————————————Node:- Text: -
|————————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_pXLChannelInfo
|————————Node:-> Text: ->
|————————Node:field_identifier Text: channelMask
|——————Node:; Text: ;
|—————Node:comment Text: //Transmit message
|—————Node:if_statement Text: if ( bGetClientObj(dwClientID, unClientIndex) )
        {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( bGetClientObj(dwClientID, unClientIndex) )
|———————Node:( Text: (
|———————Node:call_expression Text: bGetClientObj(dwClientID, unClientIndex)
|————————Node:identifier Text: bGetClientObj
|————————Node:argument_list Text: (dwClientID, unClientIndex)
|—————————Node:( Text: (
|—————————Node:identifier Text: dwClientID
|—————————Node:, Text: ,
|—————————Node:identifier Text: unClientIndex
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent);
|————————Node:assignment_expression Text: xlStatus = xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent)
|—————————Node:identifier Text: xlStatus
|—————————Node:= Text: =
|—————————Node:call_expression Text: xlCanTransmit(g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent)
|——————————Node:identifier Text: xlCanTransmit
|——————————Node:argument_list Text: (g_xlPortHandle[unClientIndex], xlChanMaskTx, &messageCount, &xlEvent)
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: g_xlPortHandle[unClientIndex]
|————————————Node:identifier Text: g_xlPortHandle
|————————————Node:subscript_argument_list Text: [unClientIndex]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:identifier Text: xlChanMaskTx
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &messageCount
|————————————Node:& Text: &
|————————————Node:identifier Text: messageCount
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &xlEvent
|————————————Node:& Text: &
|————————————Node:identifier Text: xlEvent
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment Text: //set result
|—————Node:expression_statement Text: nReturn = xlStatus;
|——————Node:assignment_expression Text: nReturn = xlStatus
|———————Node:identifier Text: nReturn
|———————Node:= Text: =
|———————Node:identifier Text: xlStatus
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return nReturn;
|————Node:return Text: return
|————Node:identifier Text: nReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Sends STCAN_MSG structure from the client dwClientID.
* \param[in]     dwClientID is the client ID
* \param[in]     sMessage is the application specific CAN message structure
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sMessage)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_FALSE;
    if (bClientIdExist(dwClientID))
    {
        if (sMessage.m_ucChannel <= sg_nNoOfChannels)
        {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sMessage)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_SendMsg
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_SendMsg
|———Node:parameter_list Text: (DWORD dwClientID, const STCAN_MSG& sMessage)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD dwClientID
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientID
|————Node:, Text: ,
|————Node:parameter_declaration Text: const STCAN_MSG& sMessage
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: STCAN_MSG
|—————Node:reference_declarator Text: & sMessage
|——————Node:& Text: &
|——————Node:identifier Text: sMessage
|————Node:) Text: )
|——Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_FALSE;
    if (bClientIdExist(dwClientID))
    {
        if (sMessage.m_ucChannel <= sg_nNoOfChannels)
        {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
|————Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|—————Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|—————Node:argument_list Text: (sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|——————Node:( Text: (
|——————Node:identifier Text: sg_bCurrState
|——————Node:, Text: ,
|——————Node:identifier Text: STATE_CONNECTED
|——————Node:, Text: ,
|——————Node:identifier Text: ERR_IMPROPER_STATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: HRESULT hResult = S_FALSE;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_FALSE
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_FALSE
|————Node:; Text: ;
|———Node:if_statement Text: if (bClientIdExist(dwClientID))
    {
        if (sMessage.m_ucChannel <= sg_nNoOfChannels)
        {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (bClientIdExist(dwClientID))
|—————Node:( Text: (
|—————Node:call_expression Text: bClientIdExist(dwClientID)
|——————Node:identifier Text: bClientIdExist
|——————Node:argument_list Text: (dwClientID)
|———————Node:( Text: (
|———————Node:identifier Text: dwClientID
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (sMessage.m_ucChannel <= sg_nNoOfChannels)
        {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (sMessage.m_ucChannel <= sg_nNoOfChannels)
        {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sMessage.m_ucChannel <= sg_nNoOfChannels)
|———————Node:( Text: (
|———————Node:binary_expression Text: sMessage.m_ucChannel <= sg_nNoOfChannels
|————————Node:field_expression Text: sMessage.m_ucChannel
|—————————Node:identifier Text: sMessage
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_ucChannel
|————————Node:<= Text: <=
|————————Node:identifier Text: sg_nNoOfChannels
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            EnterCriticalSection(&sg_CritSectForWrite); // Lock the buffer
            if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
            LeaveCriticalSection(&sg_CritSectForWrite); // Unlock the buffer
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: EnterCriticalSection(&sg_CritSectForWrite);
|————————Node:call_expression Text: EnterCriticalSection(&sg_CritSectForWrite)
|—————————Node:identifier Text: EnterCriticalSection
|—————————Node:argument_list Text: (&sg_CritSectForWrite)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &sg_CritSectForWrite
|———————————Node:& Text: &
|———————————Node:identifier Text: sg_CritSectForWrite
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // Lock the buffer
|———————Node:if_statement Text: if (nWriteMessage(sMessage, dwClientID) == defERR_OK)
            {
                hResult = S_OK;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (nWriteMessage(sMessage, dwClientID) == defERR_OK)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nWriteMessage(sMessage, dwClientID) == defERR_OK
|——————————Node:call_expression Text: nWriteMessage(sMessage, dwClientID)
|———————————Node:identifier Text: nWriteMessage
|———————————Node:argument_list Text: (sMessage, dwClientID)
|————————————Node:( Text: (
|————————————Node:identifier Text: sMessage
|————————————Node:, Text: ,
|————————————Node:identifier Text: dwClientID
|————————————Node:) Text: )
|——————————Node:== Text: ==
|——————————Node:identifier Text: defERR_OK
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                hResult = S_OK;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: hResult = S_OK;
|——————————Node:assignment_expression Text: hResult = S_OK
|———————————Node:identifier Text: hResult
|———————————Node:= Text: =
|———————————Node:identifier Text: S_OK
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: LeaveCriticalSection(&sg_CritSectForWrite);
|————————Node:call_expression Text: LeaveCriticalSection(&sg_CritSectForWrite)
|—————————Node:identifier Text: LeaveCriticalSection
|—————————Node:argument_list Text: (&sg_CritSectForWrite)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &sg_CritSectForWrite
|———————————Node:& Text: &
|———————————Node:identifier Text: sg_CritSectForWrite
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // Unlock the buffer
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            hResult = ERR_INVALID_CHANNEL;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: hResult = ERR_INVALID_CHANNEL;
|—————————Node:assignment_expression Text: hResult = ERR_INVALID_CHANNEL
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: ERR_INVALID_CHANNEL
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|———————Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: ERR_NO_CLIENT_EXIST
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Gets bus config info.
* \param[out]    BusInfo, is BYTE
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetBusConfigInfo(BYTE* /*BusInfo*/)
{
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetBusConfigInfo(BYTE* /*BusInfo*/)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetBusConfigInfo
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetBusConfigInfo
|———Node:parameter_list Text: (BYTE* /*BusInfo*/)
|————Node:( Text: (
|————Node:parameter_declaration Text: BYTE*
|—————Node:type_identifier Text: BYTE
|—————Node:abstract_pointer_declarator Text: *
|——————Node:* Text: *
|————Node:comment Text: /*BusInfo*/
|————Node:) Text: )
|——Node:compound_statement Text: {
    return S_OK;
}
|———Node:{ Text: {
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Gets last occured error and puts inside acErrorStr.
* \param[out]    acErrorStr, is CHAR contains error string
* \param[in]     nLength, is INT
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetLastErrorString(string& acErrorStr)
{
    acErrorStr = sg_acErrStr;
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetLastErrorString(string& acErrorStr)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetLastErrorString
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetLastErrorString
|———Node:parameter_list Text: (string& acErrorStr)
|————Node:( Text: (
|————Node:parameter_declaration Text: string& acErrorStr
|—————Node:type_identifier Text: string
|—————Node:reference_declarator Text: & acErrorStr
|——————Node:& Text: &
|——————Node:identifier Text: acErrorStr
|————Node:) Text: )
|——Node:compound_statement Text: {
    acErrorStr = sg_acErrStr;
    return S_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: acErrorStr = sg_acErrStr;
|————Node:assignment_expression Text: acErrorStr = sg_acErrStr
|—————Node:identifier Text: acErrorStr
|—————Node:= Text: =
|—————Node:identifier Text: sg_acErrStr
|————Node:; Text: ;
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Applies FilterType(PASS/STOP) filter for corresponding
*                channel. Frame ids are supplied by punMsgIds.
* \param[in]     FilterType, holds one of the FILTER_TYPE enum value.
* \param[in]     Channel, is TYPE_CHANNEL
* \param[in]     punMsgIds, is UINT*
* \param[in]     nLength, is UINT
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_FilterFrames(FILTER_TYPE /*FilterType*/, TYPE_CHANNEL /*Channel*/, UINT* /*punMsgIds*/, UINT /*nLength*/)
{
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_FilterFrames(FILTER_TYPE /*FilterType*/, TYPE_CHANNEL /*Channel*/, UINT* /*punMsgIds*/, UINT /*nLength*/)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_FilterFrames
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_FilterFrames
|———Node:parameter_list Text: (FILTER_TYPE /*FilterType*/, TYPE_CHANNEL /*Channel*/, UINT* /*punMsgIds*/, UINT /*nLength*/)
|————Node:( Text: (
|————Node:parameter_declaration Text: FILTER_TYPE
|—————Node:type_identifier Text: FILTER_TYPE
|————Node:comment Text: /*FilterType*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: TYPE_CHANNEL
|—————Node:type_identifier Text: TYPE_CHANNEL
|————Node:comment Text: /*Channel*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT*
|—————Node:type_identifier Text: UINT
|—————Node:abstract_pointer_declarator Text: *
|——————Node:* Text: *
|————Node:comment Text: /*punMsgIds*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT
|—————Node:type_identifier Text: UINT
|————Node:comment Text: /*nLength*/
|————Node:) Text: )
|——Node:compound_statement Text: {
    return S_OK;
}
|———Node:{ Text: {
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will check all hardware connectivity by activating selected channels.
* \param[out]    ucaTestResult Array that will hold test result.
                 TRUE if hardware present and false if not connected
* \param[in]     nChannel, indicates channel ID
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nTestHardwareConnection(UCHAR& ucaTestResult, UINT nChannel) //const
{
    int nReturn = 0;
    XLstatus xlStatus;
    if (nChannel < sg_nNoOfChannels)
    {
        // ------------------------------------
        // go with all selected channels on bus
        // ------------------------------------
        xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
        if ( xlStatus == XL_SUCCESS )
        {
            ucaTestResult = TRUE;
        }
        else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
    }
    return nReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nTestHardwareConnection(UCHAR& ucaTestResult, UINT nChannel)
|———Node:identifier Text: nTestHardwareConnection
|———Node:parameter_list Text: (UCHAR& ucaTestResult, UINT nChannel)
|————Node:( Text: (
|————Node:parameter_declaration Text: UCHAR& ucaTestResult
|—————Node:type_identifier Text: UCHAR
|—————Node:reference_declarator Text: & ucaTestResult
|——————Node:& Text: &
|——————Node:identifier Text: ucaTestResult
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT nChannel
|—————Node:type_identifier Text: UINT
|—————Node:identifier Text: nChannel
|————Node:) Text: )
|——Node:comment Text: //const
|——Node:compound_statement Text: {
    int nReturn = 0;
    XLstatus xlStatus;
    if (nChannel < sg_nNoOfChannels)
    {
        // ------------------------------------
        // go with all selected channels on bus
        // ------------------------------------
        xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
        if ( xlStatus == XL_SUCCESS )
        {
            ucaTestResult = TRUE;
        }
        else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
    }
    return nReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: int nReturn = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nReturn = 0
|—————Node:identifier Text: nReturn
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus;
|————Node:type_identifier Text: XLstatus
|————Node:identifier Text: xlStatus
|————Node:; Text: ;
|———Node:if_statement Text: if (nChannel < sg_nNoOfChannels)
    {
        // ------------------------------------
        // go with all selected channels on bus
        // ------------------------------------
        xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
        if ( xlStatus == XL_SUCCESS )
        {
            ucaTestResult = TRUE;
        }
        else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (nChannel < sg_nNoOfChannels)
|—————Node:( Text: (
|—————Node:binary_expression Text: nChannel < sg_nNoOfChannels
|——————Node:identifier Text: nChannel
|——————Node:< Text: <
|——————Node:identifier Text: sg_nNoOfChannels
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // ------------------------------------
        // go with all selected channels on bus
        // ------------------------------------
        xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
        if ( xlStatus == XL_SUCCESS )
        {
            ucaTestResult = TRUE;
        }
        else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // ------------------------------------
|—————Node:comment Text: // go with all selected channels on bus
|—————Node:comment Text: // ------------------------------------
|—————Node:expression_statement Text: xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK);
|——————Node:assignment_expression Text: xlStatus = xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|———————Node:identifier Text: xlStatus
|———————Node:= Text: =
|———————Node:call_expression Text: xlActivateChannel(g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|————————Node:identifier Text: xlActivateChannel
|————————Node:argument_list Text: (g_xlPortHandle[0], g_xlChannelMask, XL_BUS_TYPE_CAN, XL_ACTIVATE_RESET_CLOCK)
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: g_xlPortHandle[0]
|——————————Node:identifier Text: g_xlPortHandle
|——————————Node:subscript_argument_list Text: [0]
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 0
|———————————Node:] Text: ]
|—————————Node:, Text: ,
|—————————Node:identifier Text: g_xlChannelMask
|—————————Node:, Text: ,
|—————————Node:identifier Text: XL_BUS_TYPE_CAN
|—————————Node:, Text: ,
|—————————Node:identifier Text: XL_ACTIVATE_RESET_CLOCK
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if ( xlStatus == XL_SUCCESS )
        {
            ucaTestResult = TRUE;
        }
        else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( xlStatus == XL_SUCCESS )
|———————Node:( Text: (
|———————Node:binary_expression Text: xlStatus == XL_SUCCESS
|————————Node:identifier Text: xlStatus
|————————Node:== Text: ==
|————————Node:identifier Text: XL_SUCCESS
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            ucaTestResult = TRUE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: ucaTestResult = TRUE;
|————————Node:assignment_expression Text: ucaTestResult = TRUE
|—————————Node:identifier Text: ucaTestResult
|—————————Node:= Text: =
|—————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            sg_bIsConnected = FALSE;
            ucaTestResult = FALSE;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: sg_bIsConnected = FALSE;
|—————————Node:assignment_expression Text: sg_bIsConnected = FALSE
|——————————Node:identifier Text: sg_bIsConnected
|——————————Node:= Text: =
|——————————Node:false Text: FALSE
|—————————Node:; Text: ;
|————————Node:expression_statement Text: ucaTestResult = FALSE;
|—————————Node:assignment_expression Text: ucaTestResult = FALSE
|——————————Node:identifier Text: ucaTestResult
|——————————Node:= Text: =
|——————————Node:false Text: FALSE
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return nReturn;
|————Node:return Text: return
|————Node:identifier Text: nReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Gets the controller parametes of the channel based on the request.
* \param[out]    lParam, the value of the controller parameter requested.
* \param[in]     nChannel, indicates channel ID
* \param[in]     eContrParam, indicates controller parameter
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }

    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetControllerParams
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetControllerParams
|———Node:parameter_list Text: (LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|————Node:( Text: (
|————Node:parameter_declaration Text: LONG& lParam
|—————Node:type_identifier Text: LONG
|—————Node:reference_declarator Text: & lParam
|——————Node:& Text: &
|——————Node:identifier Text: lParam
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT nChannel
|—————Node:type_identifier Text: UINT
|—————Node:identifier Text: nChannel
|————Node:, Text: ,
|————Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|—————Node:type_identifier Text: ECONTR_PARAM
|—————Node:identifier Text: eContrParam
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }

    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:if_statement Text: if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
|—————Node:( Text: (
|—————Node:binary_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED)
|——————Node:parenthesized_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_bCurrState == STATE_HW_INTERFACE_SELECTED
|————————Node:identifier Text: sg_bCurrState
|————————Node:== Text: ==
|————————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|———————Node:) Text: )
|——————Node:|| Text: ||
|——————Node:parenthesized_expression Text: (sg_bCurrState == STATE_CONNECTED)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_bCurrState == STATE_CONNECTED
|————————Node:identifier Text: sg_bCurrState
|————————Node:== Text: ==
|————————Node:identifier Text: STATE_CONNECTED
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        switch (eContrParam)
        {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
    }
|—————Node:{ Text: {
|—————Node:switch_statement Text: switch (eContrParam)
        {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
|——————Node:switch Text: switch
|——————Node:condition_clause Text: (eContrParam)
|———————Node:( Text: (
|———————Node:identifier Text: eContrParam
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
            case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
            case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
            case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
            case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
            default:
            {
                hResult = S_FALSE;
            }
            break;

        }
|———————Node:{ Text: {
|———————Node:case_statement Text: case NUMBER_HW:
            {
                lParam = sg_nNoOfChannels;
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: NUMBER_HW
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                lParam = sg_nNoOfChannels;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: lParam = sg_nNoOfChannels;
|——————————Node:assignment_expression Text: lParam = sg_nNoOfChannels
|———————————Node:identifier Text: lParam
|———————————Node:= Text: =
|———————————Node:identifier Text: sg_nNoOfChannels
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case NUMBER_CONNECTED_HW:
            {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: NUMBER_CONNECTED_HW
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nGetNoOfConnectedHardware() > 0)
                {
                    lParam = sg_nNoOfChannels;
                }
                else
                {
                    hResult = S_FALSE;
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nGetNoOfConnectedHardware() > 0)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nGetNoOfConnectedHardware() > 0
|————————————Node:call_expression Text: nGetNoOfConnectedHardware()
|—————————————Node:identifier Text: nGetNoOfConnectedHardware
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:> Text: >
|————————————Node:number_literal Text: 0
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    lParam = sg_nNoOfChannels;
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: lParam = sg_nNoOfChannels;
|————————————Node:assignment_expression Text: lParam = sg_nNoOfChannels
|—————————————Node:identifier Text: lParam
|—————————————Node:= Text: =
|—————————————Node:identifier Text: sg_nNoOfChannels
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else
                {
                    hResult = S_FALSE;
                }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                    hResult = S_FALSE;
                }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: hResult = S_FALSE;
|—————————————Node:assignment_expression Text: hResult = S_FALSE
|——————————————Node:identifier Text: hResult
|——————————————Node:= Text: =
|——————————————Node:identifier Text: S_FALSE
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case DRIVER_STATUS:
            {
                lParam = true;
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: DRIVER_STATUS
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                lParam = true;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: lParam = true;
|——————————Node:assignment_expression Text: lParam = true
|———————————Node:identifier Text: lParam
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case HW_MODE:
            {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: HW_MODE
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nChannel < sg_nNoOfChannels)
                {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nChannel < sg_nNoOfChannels)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nChannel < sg_nNoOfChannels
|————————————Node:identifier Text: nChannel
|————————————Node:< Text: <
|————————————Node:identifier Text: sg_nNoOfChannels
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    lParam = sg_ucControllerMode;
                    if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: lParam = sg_ucControllerMode;
|————————————Node:assignment_expression Text: lParam = sg_ucControllerMode
|—————————————Node:identifier Text: lParam
|—————————————Node:= Text: =
|—————————————Node:identifier Text: sg_ucControllerMode
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
                    {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
|————————————Node:if Text: if
|————————————Node:condition_clause Text: ( sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE )
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: sg_ucControllerMode == 0 || sg_ucControllerMode > defMODE_SIMULATE
|——————————————Node:binary_expression Text: sg_ucControllerMode == 0
|———————————————Node:identifier Text: sg_ucControllerMode
|———————————————Node:== Text: ==
|———————————————Node:number_literal Text: 0
|——————————————Node:|| Text: ||
|——————————————Node:binary_expression Text: sg_ucControllerMode > defMODE_SIMULATE
|———————————————Node:identifier Text: sg_ucControllerMode
|———————————————Node:> Text: >
|———————————————Node:identifier Text: defMODE_SIMULATE
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        lParam = defCONTROLLER_BUSOFF;
                        hResult = S_FALSE;
                    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: lParam = defCONTROLLER_BUSOFF;
|——————————————Node:assignment_expression Text: lParam = defCONTROLLER_BUSOFF
|———————————————Node:identifier Text: lParam
|———————————————Node:= Text: =
|———————————————Node:identifier Text: defCONTROLLER_BUSOFF
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: hResult = S_FALSE;
|——————————————Node:assignment_expression Text: hResult = S_FALSE
|———————————————Node:identifier Text: hResult
|———————————————Node:= Text: =
|———————————————Node:identifier Text: S_FALSE
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:else_clause Text: else
                {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                    //Unknown
                    lParam = defCONTROLLER_BUSOFF + 1;
                }
|————————————Node:{ Text: {
|————————————Node:comment Text: //Unknown
|————————————Node:expression_statement Text: lParam = defCONTROLLER_BUSOFF + 1;
|—————————————Node:assignment_expression Text: lParam = defCONTROLLER_BUSOFF + 1
|——————————————Node:identifier Text: lParam
|——————————————Node:= Text: =
|——————————————Node:binary_expression Text: defCONTROLLER_BUSOFF + 1
|———————————————Node:identifier Text: defCONTROLLER_BUSOFF
|———————————————Node:+ Text: +
|———————————————Node:number_literal Text: 1
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case CON_TEST:
            {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
            break;
|————————Node:case Text: case
|————————Node:identifier Text: CON_TEST
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                UCHAR ucResult;
                if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
            }
|—————————Node:{ Text: {
|—————————Node:declaration Text: UCHAR ucResult;
|——————————Node:type_identifier Text: UCHAR
|——————————Node:identifier Text: ucResult
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
                {
                    lParam = (LONG)ucResult;
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nTestHardwareConnection(ucResult, nChannel) == defERR_OK)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nTestHardwareConnection(ucResult, nChannel) == defERR_OK
|————————————Node:call_expression Text: nTestHardwareConnection(ucResult, nChannel)
|—————————————Node:identifier Text: nTestHardwareConnection
|—————————————Node:argument_list Text: (ucResult, nChannel)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: ucResult
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: nChannel
|——————————————Node:) Text: )
|————————————Node:== Text: ==
|————————————Node:identifier Text: defERR_OK
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    lParam = (LONG)ucResult;
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: lParam = (LONG)ucResult;
|————————————Node:assignment_expression Text: lParam = (LONG)ucResult
|—————————————Node:identifier Text: lParam
|—————————————Node:= Text: =
|—————————————Node:cast_expression Text: (LONG)ucResult
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: LONG
|———————————————Node:type_identifier Text: LONG
|——————————————Node:) Text: )
|——————————————Node:identifier Text: ucResult
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: default:
            {
                hResult = S_FALSE;
            }
            break;
|————————Node:default Text: default
|————————Node:: Text: :
|————————Node:compound_statement Text: {
                hResult = S_FALSE;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: hResult = S_FALSE;
|——————————Node:assignment_expression Text: hResult = S_FALSE
|———————————Node:identifier Text: hResult
|———————————Node:= Text: =
|———————————Node:identifier Text: S_FALSE
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        hResult = ERR_IMPROPER_STATE;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: hResult = ERR_IMPROPER_STATE;
|———————Node:assignment_expression Text: hResult = ERR_IMPROPER_STATE
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: ERR_IMPROPER_STATE
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: //MVN
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_SetControllerParams(INT nValue, ECONTR_PARAM eContrparam)
{
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
    }
    return S_OK;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_SetControllerParams(INT nValue, ECONTR_PARAM eContrparam)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_SetControllerParams
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_SetControllerParams
|———Node:parameter_list Text: (INT nValue, ECONTR_PARAM eContrparam)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT nValue
|—————Node:type_identifier Text: INT
|—————Node:identifier Text: nValue
|————Node:, Text: ,
|————Node:parameter_declaration Text: ECONTR_PARAM eContrparam
|—————Node:type_identifier Text: ECONTR_PARAM
|—————Node:identifier Text: eContrparam
|————Node:) Text: )
|——Node:compound_statement Text: {
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
    }
    return S_OK;
}
|———Node:{ Text: {
|———Node:switch_statement Text: switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (eContrparam)
|—————Node:( Text: (
|—————Node:identifier Text: eContrparam
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
|——————Node:case Text: case
|——————Node:identifier Text: HW_MODE
|——————Node:: Text: :
|——————Node:compound_statement Text: {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
        }
|———————Node:{ Text: {
|———————Node:switch_statement Text: switch(nValue)
            {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
|————————Node:switch Text: switch
|————————Node:condition_clause Text: (nValue)
|—————————Node:( Text: (
|—————————Node:identifier Text: nValue
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
            }
|—————————Node:{ Text: {
|—————————Node:case_statement Text: case defMODE_ACTIVE:
                {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
                break;
|——————————Node:case Text: case
|——————————Node:identifier Text: defMODE_ACTIVE
|——————————Node:: Text: :
|——————————Node:compound_statement Text: {

                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
                }
|———————————Node:{ Text: {
|———————————Node:for_statement Text: for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: UINT unClientIndex = 0;
|—————————————Node:type_identifier Text: UINT
|—————————————Node:init_declarator Text: unClientIndex = 0
|——————————————Node:identifier Text: unClientIndex
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: unClientIndex < sg_nNoOfChannels
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:< Text: <
|—————————————Node:identifier Text: sg_nNoOfChannels
|————————————Node:; Text: ;
|————————————Node:update_expression Text: unClientIndex++
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
                    }
|—————————————Node:{ Text: {
|—————————————Node:comment Text: //Get channel mask
|—————————————Node:declaration Text: XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
|——————————————Node:type_identifier Text: XLuint64
|——————————————Node:init_declarator Text: xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask
|———————————————Node:identifier Text: xlChanMaskTx
|———————————————Node:= Text: =
|———————————————Node:field_expression Text: sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask
|————————————————Node:field_expression Text: sg_aodChannels[unClientIndex].m_pXLChannelInfo
|—————————————————Node:subscript_expression Text: sg_aodChannels[unClientIndex]
|——————————————————Node:identifier Text: sg_aodChannels
|——————————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: unClientIndex
|———————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: m_pXLChannelInfo
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: channelMask
|——————————————Node:; Text: ;
|—————————————Node:comment Text: //Transmit message
|—————————————Node:comment Text: //if ( bGetClientObj(dwClientID, unClientIndex) )
|—————————————Node:compound_statement Text: {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
                        }
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1);
|———————————————Node:call_expression Text: xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 1)
|————————————————Node:identifier Text: xlCanSetChannelOutput
|————————————————Node:argument_list Text: (g_xlPortHandle[unClientIndex], xlChanMaskTx, 1)
|—————————————————Node:( Text: (
|—————————————————Node:subscript_expression Text: g_xlPortHandle[unClientIndex]
|——————————————————Node:identifier Text: g_xlPortHandle
|——————————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: unClientIndex
|———————————————————Node:] Text: ]
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: xlChanMaskTx
|—————————————————Node:, Text: ,
|—————————————————Node:number_literal Text: 1
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:break_statement Text: break;
|———————————Node:break Text: break
|———————————Node:; Text: ;
|—————————Node:case_statement Text: case defMODE_PASSIVE:
                {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
                break;
|——————————Node:case Text: case
|——————————Node:identifier Text: defMODE_PASSIVE
|——————————Node:: Text: :
|——————————Node:compound_statement Text: {
                    for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
                }
|———————————Node:{ Text: {
|———————————Node:for_statement Text: for( UINT unClientIndex = 0; unClientIndex < sg_nNoOfChannels; unClientIndex++ )
                    {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: UINT unClientIndex = 0;
|—————————————Node:type_identifier Text: UINT
|—————————————Node:init_declarator Text: unClientIndex = 0
|——————————————Node:identifier Text: unClientIndex
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: unClientIndex < sg_nNoOfChannels
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:< Text: <
|—————————————Node:identifier Text: sg_nNoOfChannels
|————————————Node:; Text: ;
|————————————Node:update_expression Text: unClientIndex++
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        //Get channel mask
                        XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
                        //Transmit message
                        //if ( bGetClientObj(dwClientID, unClientIndex) )
                        {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
                    }
|—————————————Node:{ Text: {
|—————————————Node:comment Text: //Get channel mask
|—————————————Node:declaration Text: XLuint64 xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask;
|——————————————Node:type_identifier Text: XLuint64
|——————————————Node:init_declarator Text: xlChanMaskTx = sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask
|———————————————Node:identifier Text: xlChanMaskTx
|———————————————Node:= Text: =
|———————————————Node:field_expression Text: sg_aodChannels[unClientIndex].m_pXLChannelInfo->channelMask
|————————————————Node:field_expression Text: sg_aodChannels[unClientIndex].m_pXLChannelInfo
|—————————————————Node:subscript_expression Text: sg_aodChannels[unClientIndex]
|——————————————————Node:identifier Text: sg_aodChannels
|——————————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: unClientIndex
|———————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: m_pXLChannelInfo
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: channelMask
|——————————————Node:; Text: ;
|—————————————Node:comment Text: //Transmit message
|—————————————Node:comment Text: //if ( bGetClientObj(dwClientID, unClientIndex) )
|—————————————Node:compound_statement Text: {
                            xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
                        }
|——————————————Node:{ Text: {
|——————————————Node:expression_statement Text: xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3);
|———————————————Node:call_expression Text: xlCanSetChannelOutput(g_xlPortHandle[unClientIndex], xlChanMaskTx, 3)
|————————————————Node:identifier Text: xlCanSetChannelOutput
|————————————————Node:argument_list Text: (g_xlPortHandle[unClientIndex], xlChanMaskTx, 3)
|—————————————————Node:( Text: (
|—————————————————Node:subscript_expression Text: g_xlPortHandle[unClientIndex]
|——————————————————Node:identifier Text: g_xlPortHandle
|——————————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: unClientIndex
|———————————————————Node:] Text: ]
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: xlChanMaskTx
|—————————————————Node:, Text: ,
|—————————————————Node:number_literal Text: 3
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:} Text: }
|——————————Node:break_statement Text: break;
|———————————Node:break Text: break
|———————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return S_OK;
|————Node:return Text: return
|————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: //~MVN
|—Node:comment Text: /**
* \brief         Gets the error counter for corresponding channel.
* \param[out]    sErrorCnt, is SERROR_CNT structure
* \param[in]     nChannel, indicates channel ID
* \param[in]     eContrParam, indicates controller parameter
* \return        S_OK for success, S_FALSE for failure
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: HRESULT CDIL_CAN_VectorXL::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|——Node:type_identifier Text: HRESULT
|——Node:function_declarator Text: CDIL_CAN_VectorXL::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|———Node:qualified_identifier Text: CDIL_CAN_VectorXL::CAN_GetErrorCount
|————Node:namespace_identifier Text: CDIL_CAN_VectorXL
|————Node::: Text: ::
|————Node:identifier Text: CAN_GetErrorCount
|———Node:parameter_list Text: (SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|————Node:( Text: (
|————Node:parameter_declaration Text: SERROR_CNT& sErrorCnt
|—————Node:type_identifier Text: SERROR_CNT
|—————Node:reference_declarator Text: & sErrorCnt
|——————Node:& Text: &
|——————Node:identifier Text: sErrorCnt
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT nChannel
|—————Node:type_identifier Text: UINT
|—————Node:identifier Text: nChannel
|————Node:, Text: ,
|————Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|—————Node:type_identifier Text: ECONTR_PARAM
|—————Node:identifier Text: eContrParam
|————Node:) Text: )
|——Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|———Node:{ Text: {
|———Node:declaration Text: HRESULT hResult = S_OK;
|————Node:type_identifier Text: HRESULT
|————Node:init_declarator Text: hResult = S_OK
|—————Node:identifier Text: hResult
|—————Node:= Text: =
|—————Node:identifier Text: S_OK
|————Node:; Text: ;
|———Node:if_statement Text: if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|————Node:if Text: if
|————Node:condition_clause Text: ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
|—————Node:( Text: (
|—————Node:binary_expression Text: (sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|——————Node:parenthesized_expression Text: (sg_bCurrState == STATE_CONNECTED)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_bCurrState == STATE_CONNECTED
|————————Node:identifier Text: sg_bCurrState
|————————Node:== Text: ==
|————————Node:identifier Text: STATE_CONNECTED
|———————Node:) Text: )
|——————Node:|| Text: ||
|——————Node:parenthesized_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_bCurrState == STATE_HW_INTERFACE_SELECTED
|————————Node:identifier Text: sg_bCurrState
|————————Node:== Text: ==
|————————Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (nChannel <= sg_nNoOfChannels)
|———————Node:( Text: (
|———————Node:binary_expression Text: nChannel <= sg_nNoOfChannels
|————————Node:identifier Text: nChannel
|————————Node:<= Text: <=
|————————Node:identifier Text: sg_nNoOfChannels
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
        }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (eContrParam == ERR_CNT)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: eContrParam == ERR_CNT
|——————————Node:identifier Text: eContrParam
|——————————Node:== Text: ==
|——————————Node:identifier Text: ERR_CNT
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter;
|——————————Node:assignment_expression Text: sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucTxErrorCounter
|———————————Node:field_expression Text: sErrorCnt.m_ucTxErrCount
|————————————Node:identifier Text: sErrorCnt
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_ucTxErrCount
|———————————Node:= Text: =
|———————————Node:field_expression Text: sg_aodChannels[nChannel].m_ucTxErrorCounter
|————————————Node:subscript_expression Text: sg_aodChannels[nChannel]
|—————————————Node:identifier Text: sg_aodChannels
|—————————————Node:subscript_argument_list Text: [nChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: nChannel
|——————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_ucTxErrorCounter
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter;
|——————————Node:assignment_expression Text: sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucRxErrorCounter
|———————————Node:field_expression Text: sErrorCnt.m_ucRxErrCount
|————————————Node:identifier Text: sErrorCnt
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_ucRxErrCount
|———————————Node:= Text: =
|———————————Node:field_expression Text: sg_aodChannels[nChannel].m_ucRxErrorCounter
|————————————Node:subscript_expression Text: sg_aodChannels[nChannel]
|—————————————Node:identifier Text: sg_aodChannels
|—————————————Node:subscript_argument_list Text: [nChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: nChannel
|——————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: m_ucRxErrorCounter
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (eContrParam == PEAK_ERR_CNT)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: eContrParam == PEAK_ERR_CNT
|————————————Node:identifier Text: eContrParam
|————————————Node:== Text: ==
|————————————Node:identifier Text: PEAK_ERR_CNT
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
            }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter;
|————————————Node:assignment_expression Text: sErrorCnt.m_ucTxErrCount = sg_aodChannels[nChannel].m_ucPeakTxErrorCounter
|—————————————Node:field_expression Text: sErrorCnt.m_ucTxErrCount
|——————————————Node:identifier Text: sErrorCnt
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: m_ucTxErrCount
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: sg_aodChannels[nChannel].m_ucPeakTxErrorCounter
|——————————————Node:subscript_expression Text: sg_aodChannels[nChannel]
|———————————————Node:identifier Text: sg_aodChannels
|———————————————Node:subscript_argument_list Text: [nChannel]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: nChannel
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: m_ucPeakTxErrorCounter
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter;
|————————————Node:assignment_expression Text: sErrorCnt.m_ucRxErrCount = sg_aodChannels[nChannel].m_ucPeakRxErrorCounter
|—————————————Node:field_expression Text: sErrorCnt.m_ucRxErrCount
|——————————————Node:identifier Text: sErrorCnt
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: m_ucRxErrCount
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: sg_aodChannels[nChannel].m_ucPeakRxErrorCounter
|——————————————Node:subscript_expression Text: sg_aodChannels[nChannel]
|———————————————Node:identifier Text: sg_aodChannels
|———————————————Node:subscript_argument_list Text: [nChannel]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: nChannel
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: m_ucPeakRxErrorCounter
|————————————Node:; Text: ;
|———————————Node:} Text: }
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            hResult = ERR_INVALID_CHANNEL;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: hResult = ERR_INVALID_CHANNEL;
|—————————Node:assignment_expression Text: hResult = ERR_INVALID_CHANNEL
|——————————Node:identifier Text: hResult
|——————————Node:= Text: =
|——————————Node:identifier Text: ERR_INVALID_CHANNEL
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        hResult = ERR_IMPROPER_STATE;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: hResult = ERR_IMPROPER_STATE;
|———————Node:assignment_expression Text: hResult = ERR_IMPROPER_STATE
|————————Node:identifier Text: hResult
|————————Node:= Text: =
|————————Node:identifier Text: ERR_IMPROPER_STATE
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return hResult;
|————Node:return Text: return
|————Node:identifier Text: hResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* HELPER FUNCTIONS START */
|—Node:comment Text: /**
* \brief         Finds the number of hardware connected.
* \param         void
* \return        defERR_OK if successful otherwise corresponding Error code.
*                0, Query successful, but no device found
*                > 0, Number of devices found
*                < 0, query for devices unsuccessful
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nGetNoOfConnectedHardware(void)
{
    int nResult = 0;
    XLstatus xlStatus = XL_SUCCESS;

    // ------------------------------------
    // get the hardware configuration
    // ------------------------------------
    if ( XL_SUCCESS == xlStatus )
    {
        xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    }

    if (XL_SUCCESS == xlStatus)
    {
        // ------------------------------------
        // select the wanted channels
        // ------------------------------------
        g_xlChannelMask = 0;
        for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
        {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
        if (!nResult)
        {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
    }
    else
    {
        _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
        nResult = -1;
    }
    /* Return the operation result */
    return nResult;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nGetNoOfConnectedHardware(void)
|———Node:identifier Text: nGetNoOfConnectedHardware
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nResult = 0;
    XLstatus xlStatus = XL_SUCCESS;

    // ------------------------------------
    // get the hardware configuration
    // ------------------------------------
    if ( XL_SUCCESS == xlStatus )
    {
        xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    }

    if (XL_SUCCESS == xlStatus)
    {
        // ------------------------------------
        // select the wanted channels
        // ------------------------------------
        g_xlChannelMask = 0;
        for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
        {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
        if (!nResult)
        {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
    }
    else
    {
        _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
        nResult = -1;
    }
    /* Return the operation result */
    return nResult;
}
|———Node:{ Text: {
|———Node:declaration Text: int nResult = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nResult = 0
|—————Node:identifier Text: nResult
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: XLstatus xlStatus = XL_SUCCESS;
|————Node:type_identifier Text: XLstatus
|————Node:init_declarator Text: xlStatus = XL_SUCCESS
|—————Node:identifier Text: xlStatus
|—————Node:= Text: =
|—————Node:identifier Text: XL_SUCCESS
|————Node:; Text: ;
|———Node:comment Text: // ------------------------------------
|———Node:comment Text: // get the hardware configuration
|———Node:comment Text: // ------------------------------------
|———Node:if_statement Text: if ( XL_SUCCESS == xlStatus )
    {
        xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( XL_SUCCESS == xlStatus )
|—————Node:( Text: (
|—————Node:binary_expression Text: XL_SUCCESS == xlStatus
|——————Node:identifier Text: XL_SUCCESS
|——————Node:== Text: ==
|——————Node:identifier Text: xlStatus
|—————Node:) Text: )
|————Node:compound_statement Text: {
        xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
|——————Node:assignment_expression Text: xlStatus = xlGetDriverConfig(&g_xlDrvConfig)
|———————Node:identifier Text: xlStatus
|———————Node:= Text: =
|———————Node:call_expression Text: xlGetDriverConfig(&g_xlDrvConfig)
|————————Node:identifier Text: xlGetDriverConfig
|————————Node:argument_list Text: (&g_xlDrvConfig)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &g_xlDrvConfig
|——————————Node:& Text: &
|——————————Node:identifier Text: g_xlDrvConfig
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (XL_SUCCESS == xlStatus)
    {
        // ------------------------------------
        // select the wanted channels
        // ------------------------------------
        g_xlChannelMask = 0;
        for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
        {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
        if (!nResult)
        {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
    }
    else
    {
        _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
        nResult = -1;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (XL_SUCCESS == xlStatus)
|—————Node:( Text: (
|—————Node:binary_expression Text: XL_SUCCESS == xlStatus
|——————Node:identifier Text: XL_SUCCESS
|——————Node:== Text: ==
|——————Node:identifier Text: xlStatus
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // ------------------------------------
        // select the wanted channels
        // ------------------------------------
        g_xlChannelMask = 0;
        for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
        {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
        if (!nResult)
        {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // ------------------------------------
|—————Node:comment Text: // select the wanted channels
|—————Node:comment Text: // ------------------------------------
|—————Node:expression_statement Text: g_xlChannelMask = 0;
|——————Node:assignment_expression Text: g_xlChannelMask = 0
|———————Node:identifier Text: g_xlChannelMask
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:for_statement Text: for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
        {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: UINT i=0;
|———————Node:type_identifier Text: UINT
|———————Node:init_declarator Text: i=0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < g_xlDrvConfig.channelCount
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:field_expression Text: g_xlDrvConfig.channelCount
|————————Node:identifier Text: g_xlDrvConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: channelCount
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            // we take all hardware we found and
            // check that we have only CAN cabs/piggy's
            // at the moment there is no VN8910 XLAPI support!
            if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
        }
|———————Node:{ Text: {
|———————Node:comment Text: // we take all hardware we found and
|———————Node:comment Text: // check that we have only CAN cabs/piggy's
|———————Node:comment Text: // at the moment there is no VN8910 XLAPI support!
|———————Node:if_statement Text: if ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
            {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: ( /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/ (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
|—————————Node:( Text: (
|—————————Node:comment Text: /*(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              &&*/
|—————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900
|———————————Node:field_expression Text: g_xlDrvConfig.channel[i].hwType
|————————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|—————————————Node:field_expression Text: g_xlDrvConfig.channel
|——————————————Node:identifier Text: g_xlDrvConfig
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: channel
|—————————————Node:subscript_argument_list Text: [i]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: i
|——————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: hwType
|———————————Node:!= Text: !=
|———————————Node:identifier Text: XL_HWTYPE_VN8900
|——————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }

                nResult++;
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
                {
                    continue;
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: ( (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL) &&
                        !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|————————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: g_xlDrvConfig.channel[i].hwType == XL_HWTYPE_CANCASEXL
|——————————————Node:field_expression Text: g_xlDrvConfig.channel[i].hwType
|———————————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|————————————————Node:field_expression Text: g_xlDrvConfig.channel
|—————————————————Node:identifier Text: g_xlDrvConfig
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: channel
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: hwType
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: XL_HWTYPE_CANCASEXL
|—————————————Node:) Text: )
|————————————Node:&& Text: &&
|————————————Node:unary_expression Text: !(g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|—————————————Node:! Text: !
|—————————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN
|———————————————Node:field_expression Text: g_xlDrvConfig.channel[i].channelBusCapabilities
|————————————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|—————————————————Node:field_expression Text: g_xlDrvConfig.channel
|——————————————————Node:identifier Text: g_xlDrvConfig
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: channel
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: channelBusCapabilities
|———————————————Node:& Text: &
|———————————————Node:identifier Text: XL_BUS_ACTIVE_CAP_CAN
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    continue;
                }
|———————————Node:{ Text: {
|———————————Node:continue_statement Text: continue;
|————————————Node:continue Text: continue
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: nResult++;
|——————————Node:update_expression Text: nResult++
|———————————Node:identifier Text: nResult
|———————————Node:++ Text: ++
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:if_statement Text: if (!nResult)
        {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (!nResult)
|———————Node:( Text: (
|———————Node:unary_expression Text: !nResult
|————————Node:! Text: !
|————————Node:identifier Text: nResult
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
            xlStatus = XL_ERROR;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"));
|————————Node:call_expression Text: _tcscpy(sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"))
|—————————Node:identifier Text: _tcscpy
|—————————Node:argument_list Text: (sg_omErrStr, _T("No available channels found! (e.g. no CANcabs...)\r\n"))
|——————————Node:( Text: (
|——————————Node:identifier Text: sg_omErrStr
|——————————Node:, Text: ,
|——————————Node:call_expression Text: _T("No available channels found! (e.g. no CANcabs...)\r\n")
|———————————Node:identifier Text: _T
|———————————Node:argument_list Text: ("No available channels found! (e.g. no CANcabs...)\r\n")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "No available channels found! (e.g. no CANcabs...)\r\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: No available channels found! (e.g. no CANcabs...)
|—————————————Node:escape_sequence Text: \r
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: xlStatus = XL_ERROR;
|————————Node:assignment_expression Text: xlStatus = XL_ERROR
|—————————Node:identifier Text: xlStatus
|—————————Node:= Text: =
|—————————Node:identifier Text: XL_ERROR
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
    {
        _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
        nResult = -1;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
        nResult = -1;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: _tcscpy(sg_omErrStr, _T("Problem Finding Device!"));
|———————Node:call_expression Text: _tcscpy(sg_omErrStr, _T("Problem Finding Device!"))
|————————Node:identifier Text: _tcscpy
|————————Node:argument_list Text: (sg_omErrStr, _T("Problem Finding Device!"))
|—————————Node:( Text: (
|—————————Node:identifier Text: sg_omErrStr
|—————————Node:, Text: ,
|—————————Node:call_expression Text: _T("Problem Finding Device!")
|——————————Node:identifier Text: _T
|——————————Node:argument_list Text: ("Problem Finding Device!")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "Problem Finding Device!"
|————————————Node:" Text: "
|————————————Node:string_content Text: Problem Finding Device!
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: nResult = -1;
|———————Node:assignment_expression Text: nResult = -1
|————————Node:identifier Text: nResult
|————————Node:= Text: =
|————————Node:number_literal Text: -1
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:comment Text: /* Return the operation result */
|———Node:return_statement Text: return nResult;
|————Node:return Text: return
|————Node:identifier Text: nResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will popup hardware selection dialog and gets the user selection of channels.
* \param[in]     psInterfaces, is INTERFACE_HW structue
* \param[out]    pnSelList, contains channels selected array
* \param[out]    nCount, contains selected channel count
* \return        returns 0 (always)
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: int ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    HwList.DoModal();
    objMainWnd.Detach();
    nCount = HwList.nGetSelectedList(pnSelList);
    return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
|———Node:identifier Text: ListHardwareInterfaces
|———Node:parameter_list Text: (HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
|————Node:( Text: (
|————Node:parameter_declaration Text: HWND hParent
|—————Node:type_identifier Text: HWND
|—————Node:identifier Text: hParent
|————Node:, Text: ,
|————Node:parameter_declaration Text: DWORD
|—————Node:type_identifier Text: DWORD
|————Node:comment Text: /*dwDriver*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: INTERFACE_HW* psInterfaces
|—————Node:type_identifier Text: INTERFACE_HW
|—————Node:pointer_declarator Text: * psInterfaces
|——————Node:* Text: *
|——————Node:identifier Text: psInterfaces
|————Node:, Text: ,
|————Node:parameter_declaration Text: int* pnSelList
|—————Node:primitive_type Text: int
|—————Node:pointer_declarator Text: * pnSelList
|——————Node:* Text: *
|——————Node:identifier Text: pnSelList
|————Node:, Text: ,
|————Node:parameter_declaration Text: int& nCount
|—————Node:primitive_type Text: int
|—————Node:reference_declarator Text: & nCount
|——————Node:& Text: &
|——————Node:identifier Text: nCount
|————Node:) Text: )
|——Node:compound_statement Text: {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    HwList.DoModal();
    objMainWnd.Detach();
    nCount = HwList.nGetSelectedList(pnSelList);
    return 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: AFX_MANAGE_STATE(AfxGetStaticModuleState());
|————Node:call_expression Text: AFX_MANAGE_STATE(AfxGetStaticModuleState())
|—————Node:identifier Text: AFX_MANAGE_STATE
|—————Node:argument_list Text: (AfxGetStaticModuleState())
|——————Node:( Text: (
|——————Node:call_expression Text: AfxGetStaticModuleState()
|———————Node:identifier Text: AfxGetStaticModuleState
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: CWnd objMainWnd;
|————Node:type_identifier Text: CWnd
|————Node:identifier Text: objMainWnd
|————Node:; Text: ;
|———Node:expression_statement Text: objMainWnd.Attach(hParent);
|————Node:call_expression Text: objMainWnd.Attach(hParent)
|—————Node:field_expression Text: objMainWnd.Attach
|——————Node:identifier Text: objMainWnd
|——————Node:. Text: .
|——————Node:field_identifier Text: Attach
|—————Node:argument_list Text: (hParent)
|——————Node:( Text: (
|——————Node:identifier Text: hParent
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
|————Node:type_identifier Text: CHardwareListing
|————Node:init_declarator Text: HwList(psInterfaces, nCount, pnSelList, &objMainWnd)
|—————Node:identifier Text: HwList
|—————Node:argument_list Text: (psInterfaces, nCount, pnSelList, &objMainWnd)
|——————Node:( Text: (
|——————Node:identifier Text: psInterfaces
|——————Node:, Text: ,
|——————Node:identifier Text: nCount
|——————Node:, Text: ,
|——————Node:identifier Text: pnSelList
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &objMainWnd
|———————Node:& Text: &
|———————Node:identifier Text: objMainWnd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: HwList.DoModal();
|————Node:call_expression Text: HwList.DoModal()
|—————Node:field_expression Text: HwList.DoModal
|——————Node:identifier Text: HwList
|——————Node:. Text: .
|——————Node:field_identifier Text: DoModal
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: objMainWnd.Detach();
|————Node:call_expression Text: objMainWnd.Detach()
|—————Node:field_expression Text: objMainWnd.Detach
|——————Node:identifier Text: objMainWnd
|——————Node:. Text: .
|——————Node:field_identifier Text: Detach
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: nCount = HwList.nGetSelectedList(pnSelList);
|————Node:assignment_expression Text: nCount = HwList.nGetSelectedList(pnSelList)
|—————Node:identifier Text: nCount
|—————Node:= Text: =
|—————Node:call_expression Text: HwList.nGetSelectedList(pnSelList)
|——————Node:field_expression Text: HwList.nGetSelectedList
|———————Node:identifier Text: HwList
|———————Node:. Text: .
|———————Node:field_identifier Text: nGetSelectedList
|——————Node:argument_list Text: (pnSelList)
|———————Node:( Text: (
|———————Node:identifier Text: pnSelList
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will get the hardware selection from the user
*                and will create essential networks.
* \param         void
* \return        returns defERR_OK (always)
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nCreateMultipleHardwareNetwork()
{
    int nHwCount = sg_ucNoOfHardware;
    int nChannels = 0;
    // Get Hardware Network Map
    for (unsigned int nCount = 0; nCount < g_xlDrvConfig.channelCount; nCount++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
        {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
    }
    nHwCount = nChannels;   //Reassign hardware count according to final list of channels supported.
    ListHardwareInterfaces(sg_hOwnerWnd, DRIVER_CAN_VECTOR_XL, sg_HardwareIntr, sg_anSelectedItems, nHwCount);

    sg_ucNoOfHardware = (UCHAR)nHwCount;
    sg_nNoOfChannels = (UINT)nHwCount;
    g_xlChannelMask = 0;
    //Reorder hardware interface as per the user selection
    for (int nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface];
        g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask;
    }
    g_xlPermissionMask = g_xlChannelMask;

    return defERR_OK;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nCreateMultipleHardwareNetwork()
|———Node:identifier Text: nCreateMultipleHardwareNetwork
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nHwCount = sg_ucNoOfHardware;
    int nChannels = 0;
    // Get Hardware Network Map
    for (unsigned int nCount = 0; nCount < g_xlDrvConfig.channelCount; nCount++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
        {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
    }
    nHwCount = nChannels;   //Reassign hardware count according to final list of channels supported.
    ListHardwareInterfaces(sg_hOwnerWnd, DRIVER_CAN_VECTOR_XL, sg_HardwareIntr, sg_anSelectedItems, nHwCount);

    sg_ucNoOfHardware = (UCHAR)nHwCount;
    sg_nNoOfChannels = (UINT)nHwCount;
    g_xlChannelMask = 0;
    //Reorder hardware interface as per the user selection
    for (int nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface];
        g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask;
    }
    g_xlPermissionMask = g_xlChannelMask;

    return defERR_OK;
}
|———Node:{ Text: {
|———Node:declaration Text: int nHwCount = sg_ucNoOfHardware;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nHwCount = sg_ucNoOfHardware
|—————Node:identifier Text: nHwCount
|—————Node:= Text: =
|—————Node:identifier Text: sg_ucNoOfHardware
|————Node:; Text: ;
|———Node:declaration Text: int nChannels = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nChannels = 0
|—————Node:identifier Text: nChannels
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // Get Hardware Network Map
|———Node:for_statement Text: for (unsigned int nCount = 0; nCount < g_xlDrvConfig.channelCount; nCount++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
        {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: unsigned int nCount = 0;
|—————Node:sized_type_specifier Text: unsigned int
|——————Node:unsigned Text: unsigned
|——————Node:primitive_type Text: int
|—————Node:init_declarator Text: nCount = 0
|——————Node:identifier Text: nCount
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: nCount < g_xlDrvConfig.channelCount
|—————Node:identifier Text: nCount
|—————Node:< Text: <
|—————Node:field_expression Text: g_xlDrvConfig.channelCount
|——————Node:identifier Text: g_xlDrvConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: channelCount
|————Node:; Text: ;
|————Node:update_expression Text: nCount++
|—————Node:identifier Text: nCount
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
        {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // we take all hardware we found and
|—————Node:comment Text: // check that we have only CAN cabs/piggy's
|—————Node:comment Text: // at the moment there is no VN8910 XLAPI support!
|—————Node:if_statement Text: if ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
        {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */(g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900) )
|———————Node:( Text: (
|———————Node:comment Text: /*(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
              && */
|———————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900)
|————————Node:( Text: (
|————————Node:binary_expression Text: g_xlDrvConfig.channel[nCount].hwType != XL_HWTYPE_VN8900
|—————————Node:field_expression Text: g_xlDrvConfig.channel[nCount].hwType
|——————————Node:subscript_expression Text: g_xlDrvConfig.channel[nCount]
|———————————Node:field_expression Text: g_xlDrvConfig.channel
|————————————Node:identifier Text: g_xlDrvConfig
|————————————Node:. Text: .
|————————————Node:field_identifier Text: channel
|———————————Node:subscript_argument_list Text: [nCount]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nCount
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: hwType
|—————————Node:!= Text: !=
|—————————Node:identifier Text: XL_HWTYPE_VN8900
|————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
            sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
            sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
            /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
            sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
            nChannels++;
        }
|———————Node:{ Text: {
|———————Node:if_statement Text: if ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
            {
                continue;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: ( (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN) )
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL) &&
                    !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|——————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: g_xlDrvConfig.channel[nCount].hwType == XL_HWTYPE_CANCASEXL
|————————————Node:field_expression Text: g_xlDrvConfig.channel[nCount].hwType
|—————————————Node:subscript_expression Text: g_xlDrvConfig.channel[nCount]
|——————————————Node:field_expression Text: g_xlDrvConfig.channel
|———————————————Node:identifier Text: g_xlDrvConfig
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: channel
|——————————————Node:subscript_argument_list Text: [nCount]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: nCount
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: hwType
|————————————Node:== Text: ==
|————————————Node:identifier Text: XL_HWTYPE_CANCASEXL
|———————————Node:) Text: )
|——————————Node:&& Text: &&
|——————————Node:unary_expression Text: !(g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|———————————Node:! Text: !
|———————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: g_xlDrvConfig.channel[nCount].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN
|—————————————Node:field_expression Text: g_xlDrvConfig.channel[nCount].channelBusCapabilities
|——————————————Node:subscript_expression Text: g_xlDrvConfig.channel[nCount]
|———————————————Node:field_expression Text: g_xlDrvConfig.channel
|————————————————Node:identifier Text: g_xlDrvConfig
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: channel
|———————————————Node:subscript_argument_list Text: [nCount]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: nCount
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: channelBusCapabilities
|—————————————Node:& Text: &
|—————————————Node:identifier Text: XL_BUS_ACTIVE_CAP_CAN
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                continue;
            }
|—————————Node:{ Text: {
|—————————Node:continue_statement Text: continue;
|——————————Node:continue Text: continue
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: sg_HardwareIntr[nChannels].m_dwIdInterface = nCount;
|————————Node:assignment_expression Text: sg_HardwareIntr[nChannels].m_dwIdInterface = nCount
|—————————Node:field_expression Text: sg_HardwareIntr[nChannels].m_dwIdInterface
|——————————Node:subscript_expression Text: sg_HardwareIntr[nChannels]
|———————————Node:identifier Text: sg_HardwareIntr
|———————————Node:subscript_argument_list Text: [nChannels]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nChannels
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_dwIdInterface
|—————————Node:= Text: =
|—————————Node:identifier Text: nCount
|————————Node:; Text: ;
|———————Node:expression_statement Text: sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber;
|————————Node:assignment_expression Text: sg_HardwareIntr[nChannels].m_dwVendor = g_xlDrvConfig.channel[nCount].serialNumber
|—————————Node:field_expression Text: sg_HardwareIntr[nChannels].m_dwVendor
|——————————Node:subscript_expression Text: sg_HardwareIntr[nChannels]
|———————————Node:identifier Text: sg_HardwareIntr
|———————————Node:subscript_argument_list Text: [nChannels]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nChannels
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_dwVendor
|—————————Node:= Text: =
|—————————Node:field_expression Text: g_xlDrvConfig.channel[nCount].serialNumber
|——————————Node:subscript_expression Text: g_xlDrvConfig.channel[nCount]
|———————————Node:field_expression Text: g_xlDrvConfig.channel
|————————————Node:identifier Text: g_xlDrvConfig
|————————————Node:. Text: .
|————————————Node:field_identifier Text: channel
|———————————Node:subscript_argument_list Text: [nCount]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nCount
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: serialNumber
|————————Node:; Text: ;
|———————Node:comment Text: /*_stprintf(acTempStr, _T("SN: %d, Port ID: %d"), sg_HardwareIntr[nChannels].m_dwVendor,
                                                                    sg_HardwareIntr[nChannels].m_dwIdInterface);*/
|———————Node:expression_statement Text: sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name;
|————————Node:assignment_expression Text: sg_HardwareIntr[nChannels].m_acDescription = g_xlDrvConfig.channel[nCount].name
|—————————Node:field_expression Text: sg_HardwareIntr[nChannels].m_acDescription
|——————————Node:subscript_expression Text: sg_HardwareIntr[nChannels]
|———————————Node:identifier Text: sg_HardwareIntr
|———————————Node:subscript_argument_list Text: [nChannels]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nChannels
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_acDescription
|—————————Node:= Text: =
|—————————Node:field_expression Text: g_xlDrvConfig.channel[nCount].name
|——————————Node:subscript_expression Text: g_xlDrvConfig.channel[nCount]
|———————————Node:field_expression Text: g_xlDrvConfig.channel
|————————————Node:identifier Text: g_xlDrvConfig
|————————————Node:. Text: .
|————————————Node:field_identifier Text: channel
|———————————Node:subscript_argument_list Text: [nCount]
|————————————Node:[ Text: [
|————————————Node:identifier Text: nCount
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: name
|————————Node:; Text: ;
|———————Node:expression_statement Text: nChannels++;
|————————Node:update_expression Text: nChannels++
|—————————Node:identifier Text: nChannels
|—————————Node:++ Text: ++
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: nHwCount = nChannels;
|————Node:assignment_expression Text: nHwCount = nChannels
|—————Node:identifier Text: nHwCount
|—————Node:= Text: =
|—————Node:identifier Text: nChannels
|————Node:; Text: ;
|———Node:comment Text: //Reassign hardware count according to final list of channels supported.
|———Node:expression_statement Text: ListHardwareInterfaces(sg_hOwnerWnd, DRIVER_CAN_VECTOR_XL, sg_HardwareIntr, sg_anSelectedItems, nHwCount);
|————Node:call_expression Text: ListHardwareInterfaces(sg_hOwnerWnd, DRIVER_CAN_VECTOR_XL, sg_HardwareIntr, sg_anSelectedItems, nHwCount)
|—————Node:identifier Text: ListHardwareInterfaces
|—————Node:argument_list Text: (sg_hOwnerWnd, DRIVER_CAN_VECTOR_XL, sg_HardwareIntr, sg_anSelectedItems, nHwCount)
|——————Node:( Text: (
|——————Node:identifier Text: sg_hOwnerWnd
|——————Node:, Text: ,
|——————Node:identifier Text: DRIVER_CAN_VECTOR_XL
|——————Node:, Text: ,
|——————Node:identifier Text: sg_HardwareIntr
|——————Node:, Text: ,
|——————Node:identifier Text: sg_anSelectedItems
|——————Node:, Text: ,
|——————Node:identifier Text: nHwCount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sg_ucNoOfHardware = (UCHAR)nHwCount;
|————Node:assignment_expression Text: sg_ucNoOfHardware = (UCHAR)nHwCount
|—————Node:identifier Text: sg_ucNoOfHardware
|—————Node:= Text: =
|—————Node:cast_expression Text: (UCHAR)nHwCount
|——————Node:( Text: (
|——————Node:type_descriptor Text: UCHAR
|———————Node:type_identifier Text: UCHAR
|——————Node:) Text: )
|——————Node:identifier Text: nHwCount
|————Node:; Text: ;
|———Node:expression_statement Text: sg_nNoOfChannels = (UINT)nHwCount;
|————Node:assignment_expression Text: sg_nNoOfChannels = (UINT)nHwCount
|—————Node:identifier Text: sg_nNoOfChannels
|—————Node:= Text: =
|—————Node:cast_expression Text: (UINT)nHwCount
|——————Node:( Text: (
|——————Node:type_descriptor Text: UINT
|———————Node:type_identifier Text: UINT
|——————Node:) Text: )
|——————Node:identifier Text: nHwCount
|————Node:; Text: ;
|———Node:expression_statement Text: g_xlChannelMask = 0;
|————Node:assignment_expression Text: g_xlChannelMask = 0
|—————Node:identifier Text: g_xlChannelMask
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: //Reorder hardware interface as per the user selection
|———Node:for_statement Text: for (int nCount = 0; nCount < sg_ucNoOfHardware; nCount++)
    {
        sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface];
        g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask;
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int nCount = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: nCount = 0
|——————Node:identifier Text: nCount
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: nCount < sg_ucNoOfHardware
|—————Node:identifier Text: nCount
|—————Node:< Text: <
|—————Node:identifier Text: sg_ucNoOfHardware
|————Node:; Text: ;
|————Node:update_expression Text: nCount++
|—————Node:identifier Text: nCount
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface];
        g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface];
|——————Node:assignment_expression Text: sg_aodChannels[nCount].m_pXLChannelInfo  = &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface]
|———————Node:field_expression Text: sg_aodChannels[nCount].m_pXLChannelInfo
|————————Node:subscript_expression Text: sg_aodChannels[nCount]
|—————————Node:identifier Text: sg_aodChannels
|—————————Node:subscript_argument_list Text: [nCount]
|——————————Node:[ Text: [
|——————————Node:identifier Text: nCount
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: m_pXLChannelInfo
|———————Node:= Text: =
|———————Node:pointer_expression Text: &g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface]
|————————Node:& Text: &
|————————Node:subscript_expression Text: g_xlDrvConfig.channel[sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface]
|—————————Node:field_expression Text: g_xlDrvConfig.channel
|——————————Node:identifier Text: g_xlDrvConfig
|——————————Node:. Text: .
|——————————Node:field_identifier Text: channel
|—————————Node:subscript_argument_list Text: [sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface]
|——————————Node:[ Text: [
|——————————Node:field_expression Text: sg_HardwareIntr[sg_anSelectedItems[nCount]].m_dwIdInterface
|———————————Node:subscript_expression Text: sg_HardwareIntr[sg_anSelectedItems[nCount]]
|————————————Node:identifier Text: sg_HardwareIntr
|————————————Node:subscript_argument_list Text: [sg_anSelectedItems[nCount]]
|—————————————Node:[ Text: [
|—————————————Node:subscript_expression Text: sg_anSelectedItems[nCount]
|——————————————Node:identifier Text: sg_anSelectedItems
|——————————————Node:subscript_argument_list Text: [nCount]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: nCount
|———————————————Node:] Text: ]
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_dwIdInterface
|——————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask;
|——————Node:assignment_expression Text: g_xlChannelMask |= sg_aodChannels[nCount].m_pXLChannelInfo->channelMask
|———————Node:identifier Text: g_xlChannelMask
|———————Node:|= Text: |=
|———————Node:field_expression Text: sg_aodChannels[nCount].m_pXLChannelInfo->channelMask
|————————Node:field_expression Text: sg_aodChannels[nCount].m_pXLChannelInfo
|—————————Node:subscript_expression Text: sg_aodChannels[nCount]
|——————————Node:identifier Text: sg_aodChannels
|——————————Node:subscript_argument_list Text: [nCount]
|———————————Node:[ Text: [
|———————————Node:identifier Text: nCount
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: m_pXLChannelInfo
|————————Node:-> Text: ->
|————————Node:field_identifier Text: channelMask
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: g_xlPermissionMask = g_xlChannelMask;
|————Node:assignment_expression Text: g_xlPermissionMask = g_xlChannelMask
|—————Node:identifier Text: g_xlPermissionMask
|—————Node:= Text: =
|—————Node:identifier Text: g_xlChannelMask
|————Node:; Text: ;
|———Node:return_statement Text: return defERR_OK;
|————Node:return Text: return
|————Node:identifier Text: defERR_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will create a single network with available single hardware.
* \param         void
* \return        returns defERR_OK (always)
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nCreateSingleHardwareNetwork()
{
    g_xlChannelMask = 0;

    // Set the number of channels as 1
    sg_ucNoOfHardware = (UCHAR)1;
    sg_nNoOfChannels = 1;

    for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
        {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
    }

    g_xlPermissionMask = g_xlChannelMask;

    return defERR_OK;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nCreateSingleHardwareNetwork()
|———Node:identifier Text: nCreateSingleHardwareNetwork
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    g_xlChannelMask = 0;

    // Set the number of channels as 1
    sg_ucNoOfHardware = (UCHAR)1;
    sg_nNoOfChannels = 1;

    for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
        {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
    }

    g_xlPermissionMask = g_xlChannelMask;

    return defERR_OK;
}
|———Node:{ Text: {
|———Node:expression_statement Text: g_xlChannelMask = 0;
|————Node:assignment_expression Text: g_xlChannelMask = 0
|—————Node:identifier Text: g_xlChannelMask
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // Set the number of channels as 1
|———Node:expression_statement Text: sg_ucNoOfHardware = (UCHAR)1;
|————Node:assignment_expression Text: sg_ucNoOfHardware = (UCHAR)1
|—————Node:identifier Text: sg_ucNoOfHardware
|—————Node:= Text: =
|—————Node:cast_expression Text: (UCHAR)1
|——————Node:( Text: (
|——————Node:type_descriptor Text: UCHAR
|———————Node:type_identifier Text: UCHAR
|——————Node:) Text: )
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: sg_nNoOfChannels = 1;
|————Node:assignment_expression Text: sg_nNoOfChannels = 1
|—————Node:identifier Text: sg_nNoOfChannels
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i=0; i < g_xlDrvConfig.channelCount; i++)
    {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
        {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i=0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i=0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < g_xlDrvConfig.channelCount
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:field_expression Text: g_xlDrvConfig.channelCount
|——————Node:identifier Text: g_xlDrvConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: channelCount
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        // we take all hardware we found and
        // check that we have only CAN cabs/piggy's
        // at the moment there is no VN8910 XLAPI support!
        if ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
        {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // we take all hardware we found and
|—————Node:comment Text: // check that we have only CAN cabs/piggy's
|—————Node:comment Text: // at the moment there is no VN8910 XLAPI support!
|—————Node:if_statement Text: if ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
        {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900) )
|———————Node:( Text: (
|———————Node:binary_expression Text: (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
                && (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900)
|————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_CAN
|——————————Node:field_expression Text: g_xlDrvConfig.channel[i].channelBusCapabilities
|———————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|————————————Node:field_expression Text: g_xlDrvConfig.channel
|—————————————Node:identifier Text: g_xlDrvConfig
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: channel
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: channelBusCapabilities
|——————————Node:& Text: &
|——————————Node:identifier Text: XL_BUS_ACTIVE_CAP_CAN
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: g_xlDrvConfig.channel[i].hwType != XL_HWTYPE_VN8900
|——————————Node:field_expression Text: g_xlDrvConfig.channel[i].hwType
|———————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|————————————Node:field_expression Text: g_xlDrvConfig.channel
|—————————————Node:identifier Text: g_xlDrvConfig
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: channel
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: hwType
|——————————Node:!= Text: !=
|——————————Node:identifier Text: XL_HWTYPE_VN8900
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
            g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
            break;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i];
|————————Node:assignment_expression Text: sg_aodChannels[0].m_pXLChannelInfo  = &g_xlDrvConfig.channel[i]
|—————————Node:field_expression Text: sg_aodChannels[0].m_pXLChannelInfo
|——————————Node:subscript_expression Text: sg_aodChannels[0]
|———————————Node:identifier Text: sg_aodChannels
|———————————Node:subscript_argument_list Text: [0]
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 0
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: m_pXLChannelInfo
|—————————Node:= Text: =
|—————————Node:pointer_expression Text: &g_xlDrvConfig.channel[i]
|——————————Node:& Text: &
|——————————Node:subscript_expression Text: g_xlDrvConfig.channel[i]
|———————————Node:field_expression Text: g_xlDrvConfig.channel
|————————————Node:identifier Text: g_xlDrvConfig
|————————————Node:. Text: .
|————————————Node:field_identifier Text: channel
|———————————Node:subscript_argument_list Text: [i]
|————————————Node:[ Text: [
|————————————Node:identifier Text: i
|————————————Node:] Text: ]
|————————Node:; Text: ;
|———————Node:expression_statement Text: g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask;
|————————Node:assignment_expression Text: g_xlChannelMask |= sg_aodChannels[0].m_pXLChannelInfo->channelMask
|—————————Node:identifier Text: g_xlChannelMask
|—————————Node:|= Text: |=
|—————————Node:field_expression Text: sg_aodChannels[0].m_pXLChannelInfo->channelMask
|——————————Node:field_expression Text: sg_aodChannels[0].m_pXLChannelInfo
|———————————Node:subscript_expression Text: sg_aodChannels[0]
|————————————Node:identifier Text: sg_aodChannels
|————————————Node:subscript_argument_list Text: [0]
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 0
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: m_pXLChannelInfo
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: channelMask
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: g_xlPermissionMask = g_xlChannelMask;
|————Node:assignment_expression Text: g_xlPermissionMask = g_xlChannelMask
|—————Node:identifier Text: g_xlPermissionMask
|—————Node:= Text: =
|—————Node:identifier Text: g_xlChannelMask
|————Node:; Text: ;
|———Node:return_statement Text: return defERR_OK;
|————Node:return Text: return
|————Node:identifier Text: defERR_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will find number of hardwares connected.
*                It will create network as per hardware count.
*                This will popup hardware selection dialog in case there are more hardwares present.
* \param         void
* \return        Operation Result. 0 incase of no errors. Failure Error codes otherwise.
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static int nInitHwNetwork()
{
    int nChannelCount = 0;
    int nResult = -1;

    /* Select Hardware */
    nChannelCount = nGetNoOfConnectedHardware();

    // Assign the channel count
    sg_ucNoOfHardware = (UCHAR)nChannelCount;

    /* Capture only Driver Not Running event
     * Take action based on number of Hardware Available
     */
    char acNo_Of_Hw[MAX_STRING] = {0};
    _stprintf(acNo_Of_Hw, _T("Number of Vector hardwares Available: %d"), nChannelCount);

    /* No Hardware found */
    if( nChannelCount == 0 )
    {
        MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR);
        nChannelCount = -1;
    }
    /* Available hardware is lesser then the supported channels */
    else
    {
        // Check whether channel selection dialog is required
        if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
    }
    return nResult;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: nInitHwNetwork()
|———Node:identifier Text: nInitHwNetwork
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nChannelCount = 0;
    int nResult = -1;

    /* Select Hardware */
    nChannelCount = nGetNoOfConnectedHardware();

    // Assign the channel count
    sg_ucNoOfHardware = (UCHAR)nChannelCount;

    /* Capture only Driver Not Running event
     * Take action based on number of Hardware Available
     */
    char acNo_Of_Hw[MAX_STRING] = {0};
    _stprintf(acNo_Of_Hw, _T("Number of Vector hardwares Available: %d"), nChannelCount);

    /* No Hardware found */
    if( nChannelCount == 0 )
    {
        MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR);
        nChannelCount = -1;
    }
    /* Available hardware is lesser then the supported channels */
    else
    {
        // Check whether channel selection dialog is required
        if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
    }
    return nResult;
}
|———Node:{ Text: {
|———Node:declaration Text: int nChannelCount = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nChannelCount = 0
|—————Node:identifier Text: nChannelCount
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: int nResult = -1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: nResult = -1
|—————Node:identifier Text: nResult
|—————Node:= Text: =
|—————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:comment Text: /* Select Hardware */
|———Node:expression_statement Text: nChannelCount = nGetNoOfConnectedHardware();
|————Node:assignment_expression Text: nChannelCount = nGetNoOfConnectedHardware()
|—————Node:identifier Text: nChannelCount
|—————Node:= Text: =
|—————Node:call_expression Text: nGetNoOfConnectedHardware()
|——————Node:identifier Text: nGetNoOfConnectedHardware
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Assign the channel count
|———Node:expression_statement Text: sg_ucNoOfHardware = (UCHAR)nChannelCount;
|————Node:assignment_expression Text: sg_ucNoOfHardware = (UCHAR)nChannelCount
|—————Node:identifier Text: sg_ucNoOfHardware
|—————Node:= Text: =
|—————Node:cast_expression Text: (UCHAR)nChannelCount
|——————Node:( Text: (
|——————Node:type_descriptor Text: UCHAR
|———————Node:type_identifier Text: UCHAR
|——————Node:) Text: )
|——————Node:identifier Text: nChannelCount
|————Node:; Text: ;
|———Node:comment Text: /* Capture only Driver Not Running event
     * Take action based on number of Hardware Available
     */
|———Node:declaration Text: char acNo_Of_Hw[MAX_STRING] = {0};
|————Node:primitive_type Text: char
|————Node:init_declarator Text: acNo_Of_Hw[MAX_STRING] = {0}
|—————Node:array_declarator Text: acNo_Of_Hw[MAX_STRING]
|——————Node:identifier Text: acNo_Of_Hw
|——————Node:[ Text: [
|——————Node:identifier Text: MAX_STRING
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {0}
|——————Node:{ Text: {
|——————Node:number_literal Text: 0
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:expression_statement Text: _stprintf(acNo_Of_Hw, _T("Number of Vector hardwares Available: %d"), nChannelCount);
|————Node:call_expression Text: _stprintf(acNo_Of_Hw, _T("Number of Vector hardwares Available: %d"), nChannelCount)
|—————Node:identifier Text: _stprintf
|—————Node:argument_list Text: (acNo_Of_Hw, _T("Number of Vector hardwares Available: %d"), nChannelCount)
|——————Node:( Text: (
|——————Node:identifier Text: acNo_Of_Hw
|——————Node:, Text: ,
|——————Node:call_expression Text: _T("Number of Vector hardwares Available: %d")
|———————Node:identifier Text: _T
|———————Node:argument_list Text: ("Number of Vector hardwares Available: %d")
|————————Node:( Text: (
|————————Node:string_literal Text: "Number of Vector hardwares Available: %d"
|—————————Node:" Text: "
|—————————Node:string_content Text: Number of Vector hardwares Available: %d
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:, Text: ,
|——————Node:identifier Text: nChannelCount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* No Hardware found */
|———Node:if_statement Text: if( nChannelCount == 0 )
    {
        MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR);
        nChannelCount = -1;
    }
    /* Available hardware is lesser then the supported channels */
    else
    {
        // Check whether channel selection dialog is required
        if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( nChannelCount == 0 )
|—————Node:( Text: (
|—————Node:binary_expression Text: nChannelCount == 0
|——————Node:identifier Text: nChannelCount
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR);
        nChannelCount = -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR);
|——————Node:call_expression Text: MessageBox(NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR)
|———————Node:identifier Text: MessageBox
|———————Node:argument_list Text: (NULL,sg_omErrStr, NULL, MB_OK | MB_ICONERROR)
|————————Node:( Text: (
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:, Text: ,
|————————Node:identifier Text: sg_omErrStr
|————————Node:, Text: ,
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:, Text: ,
|————————Node:binary_expression Text: MB_OK | MB_ICONERROR
|—————————Node:identifier Text: MB_OK
|—————————Node:| Text: |
|—————————Node:identifier Text: MB_ICONERROR
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: nChannelCount = -1;
|——————Node:assignment_expression Text: nChannelCount = -1
|———————Node:identifier Text: nChannelCount
|———————Node:= Text: =
|———————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:comment Text: /* Available hardware is lesser then the supported channels */
|————Node:else_clause Text: else
    {
        // Check whether channel selection dialog is required
        if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        // Check whether channel selection dialog is required
        if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
    }
|——————Node:{ Text: {
|——————Node:comment Text: // Check whether channel selection dialog is required
|——————Node:if_statement Text: if( nChannelCount > 1)
        {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
        else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: ( nChannelCount > 1)
|————————Node:( Text: (
|————————Node:binary_expression Text: nChannelCount > 1
|—————————Node:identifier Text: nChannelCount
|—————————Node:> Text: >
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            // Get the selection from the user. This will also
            // create and assign the networks
            nResult = nCreateMultipleHardwareNetwork();
        }
|————————Node:{ Text: {
|————————Node:comment Text: // Get the selection from the user. This will also
|————————Node:comment Text: // create and assign the networks
|————————Node:expression_statement Text: nResult = nCreateMultipleHardwareNetwork();
|—————————Node:assignment_expression Text: nResult = nCreateMultipleHardwareNetwork()
|——————————Node:identifier Text: nResult
|——————————Node:= Text: =
|——————————Node:call_expression Text: nCreateMultipleHardwareNetwork()
|———————————Node:identifier Text: nCreateMultipleHardwareNetwork
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
        {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            // Use available one hardware
            nResult = nCreateSingleHardwareNetwork();
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Use available one hardware
|—————————Node:expression_statement Text: nResult = nCreateSingleHardwareNetwork();
|——————————Node:assignment_expression Text: nResult = nCreateSingleHardwareNetwork()
|———————————Node:identifier Text: nResult
|———————————Node:= Text: =
|———————————Node:call_expression Text: nCreateSingleHardwareNetwork()
|————————————Node:identifier Text: nCreateSingleHardwareNetwork
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:} Text: }
|———Node:return_statement Text: return nResult;
|————Node:return Text: return
|————Node:identifier Text: nResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will check if the client exists and gives back the client index.
* \param[in]     pcClientName, client name as TCHAR*
* \param[out]    Index, client index if found
* \return        TRUE if client name is found, else FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bClientExist(string pcClientName, INT& Index)
{
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
        {
            Index = i;
            return TRUE;
        }
    }
    return FALSE;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bClientExist(string pcClientName, INT& Index)
|———Node:identifier Text: bClientExist
|———Node:parameter_list Text: (string pcClientName, INT& Index)
|————Node:( Text: (
|————Node:parameter_declaration Text: string pcClientName
|—————Node:type_identifier Text: string
|—————Node:identifier Text: pcClientName
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT& Index
|—————Node:type_identifier Text: INT
|—————Node:reference_declarator Text: & Index
|——————Node:& Text: &
|——————Node:identifier Text: Index
|————Node:) Text: )
|——Node:compound_statement Text: {
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
        {
            Index = i;
            return TRUE;
        }
    }
    return FALSE;
}
|———Node:{ Text: {
|———Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
        {
            Index = i;
            return TRUE;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
        {
            Index = i;
            return TRUE;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
        {
            Index = i;
            return TRUE;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (!_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName))
|———————Node:( Text: (
|———————Node:unary_expression Text: !_tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName)
|————————Node:! Text: !
|————————Node:call_expression Text: _tcscmp(pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName)
|—————————Node:identifier Text: _tcscmp
|—————————Node:argument_list Text: (pcClientName.c_str(), sg_asClientToBufMap[i].pacClientName)
|——————————Node:( Text: (
|——————————Node:call_expression Text: pcClientName.c_str()
|———————————Node:field_expression Text: pcClientName.c_str
|————————————Node:identifier Text: pcClientName
|————————————Node:. Text: .
|————————————Node:field_identifier Text: c_str
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:field_expression Text: sg_asClientToBufMap[i].pacClientName
|———————————Node:subscript_expression Text: sg_asClientToBufMap[i]
|————————————Node:identifier Text: sg_asClientToBufMap
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: pacClientName
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            Index = i;
            return TRUE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: Index = i;
|————————Node:assignment_expression Text: Index = i
|—————————Node:identifier Text: Index
|—————————Node:= Text: =
|—————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:return_statement Text: return TRUE;
|————————Node:return Text: return
|————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return FALSE;
|————Node:return Text: return
|————Node:false Text: FALSE
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will get available client slot
* \param         void
* \return        Returns the available client ID
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static DWORD dwGetAvailableClientSlot()
{
    DWORD nClientId = 2;
    for (int i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }

    return nClientId;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: DWORD
|——Node:function_declarator Text: dwGetAvailableClientSlot()
|———Node:identifier Text: dwGetAvailableClientSlot
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    DWORD nClientId = 2;
    for (int i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }

    return nClientId;
}
|———Node:{ Text: {
|———Node:declaration Text: DWORD nClientId = 2;
|————Node:type_identifier Text: DWORD
|————Node:init_declarator Text: nClientId = 2
|—————Node:identifier Text: nClientId
|—————Node:= Text: =
|—————Node:number_literal Text: 2
|————Node:; Text: ;
|———Node:for_statement Text: for (int i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < MAX_CLIENT_ALLOWED
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: MAX_CLIENT_ALLOWED
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (bClientIdExist(nClientId))
|———————Node:( Text: (
|———————Node:call_expression Text: bClientIdExist(nClientId)
|————————Node:identifier Text: bClientIdExist
|————————Node:argument_list Text: (nClientId)
|—————————Node:( Text: (
|—————————Node:identifier Text: nClientId
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            nClientId += 1;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: nClientId += 1;
|————————Node:assignment_expression Text: nClientId += 1
|—————————Node:identifier Text: nClientId
|—————————Node:+= Text: +=
|—————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: i = MAX_CLIENT_ALLOWED;
|—————————Node:assignment_expression Text: i = MAX_CLIENT_ALLOWED
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:identifier Text: MAX_CLIENT_ALLOWED
|—————————Node:; Text: ;
|————————Node:comment Text: // break the loop
|————————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return nClientId;
|————Node:return Text: return
|————Node:identifier Text: nClientId
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will remove the existing client ID
* \param[in]     dwClientId, client ID to be removed
* \return        Returns TRUE if client ID removal is success, else FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bRemoveClient(DWORD dwClientId)
{
    BOOL bResult = FALSE;
    if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = (UINT)-1;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
    }
    return bResult;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bRemoveClient(DWORD dwClientId)
|———Node:identifier Text: bRemoveClient
|———Node:parameter_list Text: (DWORD dwClientId)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD dwClientId
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientId
|————Node:) Text: )
|——Node:compound_statement Text: {
    BOOL bResult = FALSE;
    if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = (UINT)-1;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
    }
    return bResult;
}
|———Node:{ Text: {
|———Node:declaration Text: BOOL bResult = FALSE;
|————Node:type_identifier Text: BOOL
|————Node:init_declarator Text: bResult = FALSE
|—————Node:identifier Text: bResult
|—————Node:= Text: =
|—————Node:false Text: FALSE
|————Node:; Text: ;
|———Node:if_statement Text: if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = (UINT)-1;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
    }
|————Node:if Text: if
|————Node:condition_clause Text: (sg_unClientCnt > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: sg_unClientCnt > 0
|——————Node:identifier Text: sg_unClientCnt
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        UINT unClientIndex = (UINT)-1;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:declaration Text: UINT unClientIndex = (UINT)-1;
|——————Node:type_identifier Text: UINT
|——————Node:init_declarator Text: unClientIndex = (UINT)-1
|———————Node:identifier Text: unClientIndex
|———————Node:= Text: =
|———————Node:binary_expression Text: (UINT)-1
|————————Node:parenthesized_expression Text: (UINT)
|—————————Node:( Text: (
|—————————Node:identifier Text: UINT
|—————————Node:) Text: )
|————————Node:- Text: -
|————————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:if_statement Text: if (bGetClientObj(dwClientId, unClientIndex))
        {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (bGetClientObj(dwClientId, unClientIndex))
|———————Node:( Text: (
|———————Node:call_expression Text: bGetClientObj(dwClientId, unClientIndex)
|————————Node:identifier Text: bGetClientObj
|————————Node:argument_list Text: (dwClientId, unClientIndex)
|—————————Node:( Text: (
|—————————Node:identifier Text: dwClientId
|—————————Node:, Text: ,
|—————————Node:identifier Text: unClientIndex
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            /* clear the client first */
            if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
            if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
        }
|———————Node:{ Text: {
|———————Node:comment Text: /* clear the client first */
|———————Node:if_statement Text: if (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
            {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
            else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (sg_asClientToBufMap[unClientIndex].hClientHandle != NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: sg_asClientToBufMap[unClientIndex].hClientHandle != NULL
|——————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].hClientHandle
|———————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|————————————Node:identifier Text: sg_asClientToBufMap
|————————————Node:subscript_argument_list Text: [unClientIndex]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: unClientIndex
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: hClientHandle
|——————————Node:!= Text: !=
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                HRESULT hResult = S_OK;//(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
                if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
            }
|—————————Node:{ Text: {
|—————————Node:declaration Text: HRESULT hResult = S_OK;
|——————————Node:type_identifier Text: HRESULT
|——————————Node:init_declarator Text: hResult = S_OK
|———————————Node:identifier Text: hResult
|———————————Node:= Text: =
|———————————Node:identifier Text: S_OK
|——————————Node:; Text: ;
|—————————Node:comment Text: //(*pfCAN_RemoveClient)(sg_asClientToBufMap[unClientIndex].hClientHandle);
|—————————Node:if_statement Text: if (hResult == S_OK)
                {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
                else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (hResult == S_OK)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: hResult == S_OK
|————————————Node:identifier Text: hResult
|————————————Node:== Text: ==
|————————————Node:identifier Text: S_OK
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                    sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
                    memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                    for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
                    sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                    bResult = TRUE;
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].dwClientID = 0;
|————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].dwClientID = 0
|—————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].dwClientID
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [unClientIndex]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: unClientIndex
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: dwClientID
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].hClientHandle = NULL;
|————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].hClientHandle = NULL
|—————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].hClientHandle
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [unClientIndex]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: unClientIndex
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: hClientHandle
|—————————————Node:= Text: =
|—————————————Node:null Text: NULL
|——————————————Node:NULL Text: NULL
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
|————————————Node:call_expression Text: memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH)
|—————————————Node:identifier Text: memset
|—————————————Node:argument_list Text: (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH)
|——————————————Node:( Text: (
|——————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pacClientName
|———————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|————————————————Node:identifier Text: sg_asClientToBufMap
|————————————————Node:subscript_argument_list Text: [unClientIndex]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: unClientIndex
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: pacClientName
|——————————————Node:, Text: ,
|——————————————Node:number_literal Text: 0
|——————————————Node:, Text: ,
|——————————————Node:binary_expression Text: sizeof (char) * MAX_PATH
|———————————————Node:sizeof_expression Text: sizeof (char)
|————————————————Node:sizeof Text: sizeof
|————————————————Node:( Text: (
|————————————————Node:type_descriptor Text: char
|—————————————————Node:primitive_type Text: char
|————————————————Node:) Text: )
|———————————————Node:* Text: *
|———————————————Node:identifier Text: MAX_PATH
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:for_statement Text: for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                    {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: int i = 0;
|—————————————Node:primitive_type Text: int
|—————————————Node:init_declarator Text: i = 0
|——————————————Node:identifier Text: i
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: i < MAX_BUFF_ALLOWED
|—————————————Node:identifier Text: i
|—————————————Node:< Text: <
|—————————————Node:identifier Text: MAX_BUFF_ALLOWED
|————————————Node:; Text: ;
|————————————Node:update_expression Text: i++
|—————————————Node:identifier Text: i
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
|——————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL
|———————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i]
|————————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf
|—————————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|——————————————————Node:identifier Text: sg_asClientToBufMap
|——————————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: unClientIndex
|———————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: pClientBuf
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:= Text: =
|———————————————Node:null Text: NULL
|————————————————Node:NULL Text: NULL
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].unBufCount = 0;
|————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].unBufCount = 0
|—————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].unBufCount
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [unClientIndex]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: unClientIndex
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unBufCount
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: bResult = TRUE;
|————————————Node:assignment_expression Text: bResult = TRUE
|—————————————Node:identifier Text: bResult
|—————————————Node:= Text: =
|—————————————Node:true Text: TRUE
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else
                {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                    vRetrieveAndLog(hResult, __FILE__, __LINE__);
                }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: vRetrieveAndLog(hResult, __FILE__, __LINE__);
|—————————————Node:call_expression Text: vRetrieveAndLog(hResult, __FILE__, __LINE__)
|——————————————Node:identifier Text: vRetrieveAndLog
|——————————————Node:argument_list Text: (hResult, __FILE__, __LINE__)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: hResult
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: __FILE__
|———————————————Node:, Text: ,
|———————————————Node:identifier Text: __LINE__
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:else_clause Text: else
            {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
                sg_asClientToBufMap[unClientIndex].dwClientID = 0;
                memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
                for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
                sg_asClientToBufMap[unClientIndex].unBufCount = 0;
                bResult = TRUE;

            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].dwClientID = 0;
|———————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].dwClientID = 0
|————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].dwClientID
|—————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|——————————————Node:identifier Text: sg_asClientToBufMap
|——————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: unClientIndex
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dwClientID
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH);
|———————————Node:call_expression Text: memset (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH)
|————————————Node:identifier Text: memset
|————————————Node:argument_list Text: (sg_asClientToBufMap[unClientIndex].pacClientName, 0, sizeof (char) * MAX_PATH)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pacClientName
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|———————————————Node:identifier Text: sg_asClientToBufMap
|———————————————Node:subscript_argument_list Text: [unClientIndex]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: unClientIndex
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: pacClientName
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 0
|—————————————Node:, Text: ,
|—————————————Node:binary_expression Text: sizeof (char) * MAX_PATH
|——————————————Node:sizeof_expression Text: sizeof (char)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: char
|————————————————Node:primitive_type Text: char
|———————————————Node:) Text: )
|——————————————Node:* Text: *
|——————————————Node:identifier Text: MAX_PATH
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:for_statement Text: for (int i = 0; i < MAX_BUFF_ALLOWED; i++)
                {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
|———————————Node:for Text: for
|———————————Node:( Text: (
|———————————Node:declaration Text: int i = 0;
|————————————Node:primitive_type Text: int
|————————————Node:init_declarator Text: i = 0
|—————————————Node:identifier Text: i
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:binary_expression Text: i < MAX_BUFF_ALLOWED
|————————————Node:identifier Text: i
|————————————Node:< Text: <
|————————————Node:identifier Text: MAX_BUFF_ALLOWED
|———————————Node:; Text: ;
|———————————Node:update_expression Text: i++
|————————————Node:identifier Text: i
|————————————Node:++ Text: ++
|———————————Node:) Text: )
|———————————Node:compound_statement Text: {
                    sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
                }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL;
|—————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i] = NULL
|——————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf[i]
|———————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].pClientBuf
|————————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|—————————————————Node:identifier Text: sg_asClientToBufMap
|—————————————————Node:subscript_argument_list Text: [unClientIndex]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: unClientIndex
|——————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: pClientBuf
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:= Text: =
|——————————————Node:null Text: NULL
|———————————————Node:NULL Text: NULL
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|——————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].unBufCount = 0;
|———————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].unBufCount = 0
|————————————Node:field_expression Text: sg_asClientToBufMap[unClientIndex].unBufCount
|—————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|——————————————Node:identifier Text: sg_asClientToBufMap
|——————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: unClientIndex
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: unBufCount
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: bResult = TRUE;
|———————————Node:assignment_expression Text: bResult = TRUE
|————————————Node:identifier Text: bResult
|————————————Node:= Text: =
|————————————Node:true Text: TRUE
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:if_statement Text: if (bResult == TRUE)
            {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (bResult == TRUE)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: bResult == TRUE
|——————————Node:identifier Text: bResult
|——————————Node:== Text: ==
|——————————Node:true Text: TRUE
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
                sg_unClientCnt--;
            }
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if ((unClientIndex + 1) < sg_unClientCnt)
                {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: ((unClientIndex + 1) < sg_unClientCnt)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (unClientIndex + 1) < sg_unClientCnt
|————————————Node:parenthesized_expression Text: (unClientIndex + 1)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: unClientIndex + 1
|——————————————Node:identifier Text: unClientIndex
|——————————————Node:+ Text: +
|——————————————Node:number_literal Text: 1
|—————————————Node:) Text: )
|————————————Node:< Text: <
|————————————Node:identifier Text: sg_unClientCnt
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
                }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
|————————————Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1]
|—————————————Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|——————————————Node:identifier Text: sg_asClientToBufMap
|——————————————Node:subscript_argument_list Text: [unClientIndex]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: unClientIndex
|———————————————Node:] Text: ]
|—————————————Node:= Text: =
|—————————————Node:subscript_expression Text: sg_asClientToBufMap[sg_unClientCnt - 1]
|——————————————Node:identifier Text: sg_asClientToBufMap
|——————————————Node:subscript_argument_list Text: [sg_unClientCnt - 1]
|———————————————Node:[ Text: [
|———————————————Node:binary_expression Text: sg_unClientCnt - 1
|————————————————Node:identifier Text: sg_unClientCnt
|————————————————Node:- Text: -
|————————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: sg_unClientCnt--;
|——————————Node:update_expression Text: sg_unClientCnt--
|———————————Node:identifier Text: sg_unClientCnt
|———————————Node:-- Text: --
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return bResult;
|————Node:return Text: return
|————Node:identifier Text: bResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will check if the client ID exists
* \param[in]     dwClientId, client ID to be checked for existance
* \return        Returns TRUE if client ID existance is success, else FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bClientIdExist(const DWORD& dwClientId)
{
    BOOL bReturn = FALSE;
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
    return bReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bClientIdExist(const DWORD& dwClientId)
|———Node:identifier Text: bClientIdExist
|———Node:parameter_list Text: (const DWORD& dwClientId)
|————Node:( Text: (
|————Node:parameter_declaration Text: const DWORD& dwClientId
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: DWORD
|—————Node:reference_declarator Text: & dwClientId
|——————Node:& Text: &
|——————Node:identifier Text: dwClientId
|————Node:) Text: )
|——Node:compound_statement Text: {
    BOOL bReturn = FALSE;
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
    return bReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: BOOL bReturn = FALSE;
|————Node:type_identifier Text: BOOL
|————Node:init_declarator Text: bReturn = FALSE
|—————Node:identifier Text: bReturn
|—————Node:= Text: =
|—————Node:false Text: FALSE
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (sg_asClientToBufMap[i].dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (sg_asClientToBufMap[i].dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sg_asClientToBufMap[i].dwClientID == dwClientId)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_asClientToBufMap[i].dwClientID == dwClientId
|————————Node:field_expression Text: sg_asClientToBufMap[i].dwClientID
|—————————Node:subscript_expression Text: sg_asClientToBufMap[i]
|——————————Node:identifier Text: sg_asClientToBufMap
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: dwClientID
|————————Node:== Text: ==
|————————Node:identifier Text: dwClientId
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: bReturn = TRUE;
|————————Node:assignment_expression Text: bReturn = TRUE
|—————————Node:identifier Text: bReturn
|—————————Node:= Text: =
|—————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:expression_statement Text: i = sg_unClientCnt;
|————————Node:assignment_expression Text: i = sg_unClientCnt
|—————————Node:identifier Text: i
|—————————Node:= Text: =
|—————————Node:identifier Text: sg_unClientCnt
|————————Node:; Text: ;
|———————Node:comment Text: // break the loop
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return bReturn;
|————Node:return Text: return
|————Node:identifier Text: bReturn
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         This function will return the client index based on clientID
* \param[in]     dwClientId, client ID whose client index is needed
* \param[out]    unClientIndex, client index to be returned
* \return        Returns TRUE if client ID existance is success, else FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
{
    BOOL bResult = FALSE;
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
    }
    return bResult;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
|———Node:identifier Text: bGetClientObj
|———Node:parameter_list Text: (DWORD dwClientID, UINT& unClientIndex)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD dwClientID
|—————Node:type_identifier Text: DWORD
|—————Node:identifier Text: dwClientID
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT& unClientIndex
|—————Node:type_identifier Text: UINT
|—————Node:reference_declarator Text: & unClientIndex
|——————Node:& Text: &
|——————Node:identifier Text: unClientIndex
|————Node:) Text: )
|——Node:compound_statement Text: {
    BOOL bResult = FALSE;
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
    }
    return bResult;
}
|———Node:{ Text: {
|———Node:declaration Text: BOOL bResult = FALSE;
|————Node:type_identifier Text: BOOL
|————Node:init_declarator Text: bResult = FALSE
|—————Node:identifier Text: bResult
|—————Node:= Text: =
|—————Node:false Text: FALSE
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        if (sg_asClientToBufMap[i].dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sg_unClientCnt
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: sg_unClientCnt
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (sg_asClientToBufMap[i].dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (sg_asClientToBufMap[i].dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (sg_asClientToBufMap[i].dwClientID == dwClientID)
|———————Node:( Text: (
|———————Node:binary_expression Text: sg_asClientToBufMap[i].dwClientID == dwClientID
|————————Node:field_expression Text: sg_asClientToBufMap[i].dwClientID
|—————————Node:subscript_expression Text: sg_asClientToBufMap[i]
|——————————Node:identifier Text: sg_asClientToBufMap
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: dwClientID
|————————Node:== Text: ==
|————————Node:identifier Text: dwClientID
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: unClientIndex = i;
|————————Node:assignment_expression Text: unClientIndex = i
|—————————Node:identifier Text: unClientIndex
|—————————Node:= Text: =
|—————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:expression_statement Text: i = sg_unClientCnt;
|————————Node:assignment_expression Text: i = sg_unClientCnt
|—————————Node:identifier Text: i
|—————————Node:= Text: =
|—————————Node:identifier Text: sg_unClientCnt
|————————Node:; Text: ;
|———————Node:comment Text: // break the loop
|———————Node:expression_statement Text: bResult = TRUE;
|————————Node:assignment_expression Text: bResult = TRUE
|—————————Node:identifier Text: bResult
|—————————Node:= Text: =
|—————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return bResult;
|————Node:return Text: return
|————Node:identifier Text: bResult
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to retreive error occurred and log it
* \param[in]     File, pointer to log file
* \param[in]     Line, indicates line number in log file
* \return        void
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static void vRetrieveAndLog(DWORD /*dwErrorCode*/, char* File, int Line)
{
    USES_CONVERSION;

    char acErrText[MAX_PATH] = {'\0'};

    /* Get the error text for the corresponding error code */
    sg_pIlog->vLogAMessage(A2T(File), Line, A2T(acErrText));

    size_t nStrLen = strlen(acErrText);
    if (nStrLen > CAN_MAX_ERRSTR)
    {
        nStrLen = CAN_MAX_ERRSTR;
    }
    sg_acErrStr = acErrText;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: vRetrieveAndLog(DWORD /*dwErrorCode*/, char* File, int Line)
|———Node:identifier Text: vRetrieveAndLog
|———Node:parameter_list Text: (DWORD /*dwErrorCode*/, char* File, int Line)
|————Node:( Text: (
|————Node:parameter_declaration Text: DWORD
|—————Node:type_identifier Text: DWORD
|————Node:comment Text: /*dwErrorCode*/
|————Node:, Text: ,
|————Node:parameter_declaration Text: char* File
|—————Node:primitive_type Text: char
|—————Node:pointer_declarator Text: * File
|——————Node:* Text: *
|——————Node:identifier Text: File
|————Node:, Text: ,
|————Node:parameter_declaration Text: int Line
|—————Node:primitive_type Text: int
|—————Node:identifier Text: Line
|————Node:) Text: )
|——Node:compound_statement Text: {
    USES_CONVERSION;

    char acErrText[MAX_PATH] = {'\0'};

    /* Get the error text for the corresponding error code */
    sg_pIlog->vLogAMessage(A2T(File), Line, A2T(acErrText));

    size_t nStrLen = strlen(acErrText);
    if (nStrLen > CAN_MAX_ERRSTR)
    {
        nStrLen = CAN_MAX_ERRSTR;
    }
    sg_acErrStr = acErrText;
}
|———Node:{ Text: {
|———Node:expression_statement Text: USES_CONVERSION;
|————Node:identifier Text: USES_CONVERSION
|————Node:; Text: ;
|———Node:declaration Text: char acErrText[MAX_PATH] = {'\0'};
|————Node:primitive_type Text: char
|————Node:init_declarator Text: acErrText[MAX_PATH] = {'\0'}
|—————Node:array_declarator Text: acErrText[MAX_PATH]
|——————Node:identifier Text: acErrText
|——————Node:[ Text: [
|——————Node:identifier Text: MAX_PATH
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {'\0'}
|——————Node:{ Text: {
|——————Node:char_literal Text: '\0'
|———————Node:' Text: '
|———————Node:escape_sequence Text: \0
|———————Node:' Text: '
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:comment Text: /* Get the error text for the corresponding error code */
|———Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(File), Line, A2T(acErrText));
|————Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(File), Line, A2T(acErrText))
|—————Node:field_expression Text: sg_pIlog->vLogAMessage
|——————Node:identifier Text: sg_pIlog
|——————Node:-> Text: ->
|——————Node:field_identifier Text: vLogAMessage
|—————Node:argument_list Text: (A2T(File), Line, A2T(acErrText))
|——————Node:( Text: (
|——————Node:call_expression Text: A2T(File)
|———————Node:identifier Text: A2T
|———————Node:argument_list Text: (File)
|————————Node:( Text: (
|————————Node:identifier Text: File
|————————Node:) Text: )
|——————Node:, Text: ,
|——————Node:identifier Text: Line
|——————Node:, Text: ,
|——————Node:call_expression Text: A2T(acErrText)
|———————Node:identifier Text: A2T
|———————Node:argument_list Text: (acErrText)
|————————Node:( Text: (
|————————Node:identifier Text: acErrText
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: size_t nStrLen = strlen(acErrText);
|————Node:primitive_type Text: size_t
|————Node:init_declarator Text: nStrLen = strlen(acErrText)
|—————Node:identifier Text: nStrLen
|—————Node:= Text: =
|—————Node:call_expression Text: strlen(acErrText)
|——————Node:identifier Text: strlen
|——————Node:argument_list Text: (acErrText)
|———————Node:( Text: (
|———————Node:identifier Text: acErrText
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nStrLen > CAN_MAX_ERRSTR)
    {
        nStrLen = CAN_MAX_ERRSTR;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (nStrLen > CAN_MAX_ERRSTR)
|—————Node:( Text: (
|—————Node:binary_expression Text: nStrLen > CAN_MAX_ERRSTR
|——————Node:identifier Text: nStrLen
|——————Node:> Text: >
|——————Node:identifier Text: CAN_MAX_ERRSTR
|—————Node:) Text: )
|————Node:compound_statement Text: {
        nStrLen = CAN_MAX_ERRSTR;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: nStrLen = CAN_MAX_ERRSTR;
|——————Node:assignment_expression Text: nStrLen = CAN_MAX_ERRSTR
|———————Node:identifier Text: nStrLen
|———————Node:= Text: =
|———————Node:identifier Text: CAN_MAX_ERRSTR
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: sg_acErrStr = acErrText;
|————Node:assignment_expression Text: sg_acErrStr = acErrText
|—————Node:identifier Text: sg_acErrStr
|—————Node:= Text: =
|—————Node:identifier Text: acErrText
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to check if client buffer exists
* \param[in]     sClientObj, alias to SCLIENTBUFMAP object
* \param[in]     pBuf, pointer to CBaseCANBufFSE object
* \return        TRUE if buffer exists, else FALSE
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
{
    BOOL bExist = FALSE;
    for (UINT i = 0; i < sClientObj.unBufCount; i++)
    {
        if (pBuf == sClientObj.pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
    }

    return bExist;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|———Node:identifier Text: bIsBufferExists
|———Node:parameter_list Text: (const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|————Node:( Text: (
|————Node:parameter_declaration Text: const SCLIENTBUFMAP& sClientObj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: SCLIENTBUFMAP
|—————Node:reference_declarator Text: & sClientObj
|——————Node:& Text: &
|——————Node:identifier Text: sClientObj
|————Node:, Text: ,
|————Node:parameter_declaration Text: const CBaseCANBufFSE* pBuf
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * pBuf
|——————Node:* Text: *
|——————Node:identifier Text: pBuf
|————Node:) Text: )
|——Node:compound_statement Text: {
    BOOL bExist = FALSE;
    for (UINT i = 0; i < sClientObj.unBufCount; i++)
    {
        if (pBuf == sClientObj.pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
    }

    return bExist;
}
|———Node:{ Text: {
|———Node:declaration Text: BOOL bExist = FALSE;
|————Node:type_identifier Text: BOOL
|————Node:init_declarator Text: bExist = FALSE
|—————Node:identifier Text: bExist
|—————Node:= Text: =
|—————Node:false Text: FALSE
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i = 0; i < sClientObj.unBufCount; i++)
    {
        if (pBuf == sClientObj.pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < sClientObj.unBufCount
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:field_expression Text: sClientObj.unBufCount
|——————Node:identifier Text: sClientObj
|——————Node:. Text: .
|——————Node:field_identifier Text: unBufCount
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (pBuf == sClientObj.pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (pBuf == sClientObj.pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (pBuf == sClientObj.pClientBuf[i])
|———————Node:( Text: (
|———————Node:binary_expression Text: pBuf == sClientObj.pClientBuf[i]
|————————Node:identifier Text: pBuf
|————————Node:== Text: ==
|————————Node:subscript_expression Text: sClientObj.pClientBuf[i]
|—————————Node:field_expression Text: sClientObj.pClientBuf
|——————————Node:identifier Text: sClientObj
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pClientBuf
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            bExist = TRUE;
            i = sClientObj.unBufCount; // break the loop
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: bExist = TRUE;
|————————Node:assignment_expression Text: bExist = TRUE
|—————————Node:identifier Text: bExist
|—————————Node:= Text: =
|—————————Node:true Text: TRUE
|————————Node:; Text: ;
|———————Node:expression_statement Text: i = sClientObj.unBufCount;
|————————Node:assignment_expression Text: i = sClientObj.unBufCount
|—————————Node:identifier Text: i
|—————————Node:= Text: =
|—————————Node:field_expression Text: sClientObj.unBufCount
|——————————Node:identifier Text: sClientObj
|——————————Node:. Text: .
|——————————Node:field_identifier Text: unBufCount
|————————Node:; Text: ;
|———————Node:comment Text: // break the loop
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return bExist;
|————Node:return Text: return
|————Node:identifier Text: bExist
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief         Function to remove exissting client buffer
* \param[in]     RootBufferArray, pointer to CBaseCANBufFSE class array
* \param[out]    unCount, indicates buffer count which will get reduced
* \param[in]     BufferToRemove, pointer to the buffer to be removed
* \return        TRUE if removed
* \authors       Arunkumar Karri
* \date          07.10.2011 Created
*/
|—Node:function_definition Text: static BOOL bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
{
    BOOL bReturn = TRUE;
    for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
    return bReturn;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: BOOL
|——Node:function_declarator Text: bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|———Node:identifier Text: bRemoveClientBuffer
|———Node:parameter_list Text: (CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|————Node:( Text: (
|————Node:parameter_declaration Text: CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED]
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * RootBufferArray[MAX_BUFF_ALLOWED]
|——————Node:* Text: *
|——————Node:array_declarator Text: RootBufferArray[MAX_BUFF_ALLOWED]
|———————Node:identifier Text: RootBufferArray
|———————Node:[ Text: [
|———————Node:identifier Text: MAX_BUFF_ALLOWED
|———————Node:] Text: ]
|————Node:, Text: ,
|————Node:parameter_declaration Text: UINT& unCount
|—————Node:type_identifier Text: UINT
|—————Node:reference_declarator Text: & unCount
|——————Node:& Text: &
|——————Node:identifier Text: unCount
|————Node:, Text: ,
|————Node:parameter_declaration Text: CBaseCANBufFSE* BufferToRemove
|—————Node:type_identifier Text: CBaseCANBufFSE
|—————Node:pointer_declarator Text: * BufferToRemove
|——————Node:* Text: *
|——————Node:identifier Text: BufferToRemove
|————Node:) Text: )
|——Node:compound_statement Text: {
    BOOL bReturn = TRUE;
    for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
    return bReturn;
}
|———Node:{ Text: {
|———Node:declaration Text: BOOL bReturn = TRUE;
|————Node:type_identifier Text: BOOL
|————Node:init_declarator Text: bReturn = TRUE
|—————Node:identifier Text: bReturn
|—————Node:= Text: =
|—————Node:true Text: TRUE
|————Node:; Text: ;
|———Node:for_statement Text: for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: UINT i = 0;
|—————Node:type_identifier Text: UINT
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < unCount
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: unCount
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (RootBufferArray[i] == BufferToRemove)
|———————Node:( Text: (
|———————Node:binary_expression Text: RootBufferArray[i] == BufferToRemove
|————————Node:subscript_expression Text: RootBufferArray[i]
|—————————Node:identifier Text: RootBufferArray
|—————————Node:subscript_argument_list Text: [i]
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|————————Node:== Text: ==
|————————Node:identifier Text: BufferToRemove
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (i < (unCount - 1)) /* If not the last bufffer */
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (i < (unCount - 1))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: i < (unCount - 1)
|——————————Node:identifier Text: i
|——————————Node:< Text: <
|——————————Node:parenthesized_expression Text: (unCount - 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: unCount - 1
|————————————Node:identifier Text: unCount
|————————————Node:- Text: -
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:comment Text: /* If not the last bufffer */
|————————Node:compound_statement Text: {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: RootBufferArray[i] = RootBufferArray[unCount - 1];
|——————————Node:assignment_expression Text: RootBufferArray[i] = RootBufferArray[unCount - 1]
|———————————Node:subscript_expression Text: RootBufferArray[i]
|————————————Node:identifier Text: RootBufferArray
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:subscript_expression Text: RootBufferArray[unCount - 1]
|————————————Node:identifier Text: RootBufferArray
|————————————Node:subscript_argument_list Text: [unCount - 1]
|—————————————Node:[ Text: [
|—————————————Node:binary_expression Text: unCount - 1
|——————————————Node:identifier Text: unCount
|——————————————Node:- Text: -
|——————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: unCount--;
|————————Node:update_expression Text: unCount--
|—————————Node:identifier Text: unCount
|—————————Node:-- Text: --
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return bReturn;
|————Node:return Text: return
|————Node:identifier Text: bReturn
|————Node:; Text: ;
|———Node:} Text: }
