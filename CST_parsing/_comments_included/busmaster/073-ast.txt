busmaster-Sources\CAN_ETAS_BOA\CAN_ETAS_BOA.cpp

|Node:ERROR Text: /*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @brief Source file for BOA DIL functions
 * @author Pradeep Kadoor, Tobias Lorenz
 * @copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for BOA DIL functions
 * Defines the initialization routines for the DLL.
 */

/* C includes */
#include <search.h>             /* For qsort */

/* C++ includes */
#include <string>
#include <vector>

/* Project includes */
#include "CAN_ETAS_BOA_stdafx.h"
#include "CAN_ETAS_BOA.h"
#include "DataTypes/Base_WrapperErrorLogger.h"
#include "DataTypes/MsgBufAll_DataTypes.h"
#include "DataTypes/DIL_Datatypes.h"
#include "Include/BaseDefs.h"
#include "Include/DIL_CommonDefs.h"
#include "Include/Can_Error_Defs.h"
#include "DIL_Interface/BaseDIL_CAN_Controller.h"
#include "HardwareListing.h"
#include "ChangeRegisters_CAN_ETAS_BOA.h"
#include "../Application/MultiLanguage.h"
#include "Utility\MultiLanguageSupport.h"
//#include "../Application/GettextBusmaster.h"

#define USAGE_EXPORT
#include "CAN_ETAS_BOA_Extern.h"

/* ETAS BOA includes */
#ifndef BOA_VERSION
#error "No BOA version defined"
#endif
#if BOA_VERSION == BOA_VERSION_1_4
#include "EXTERNAL/BOA 1.4/Include/OCI/ocican.h"
#include "EXTERNAL/BOA 1.4/Include/CSI/csisfs.h"
#elif BOA_VERSION == BOA_VERSION_1_5
#include "EXTERNAL/BOA 1.5/Include/OCI/ocican.h"
#include "EXTERNAL/BOA 1.5/Include/CSI/csisfs.h"
#elif BOA_VERSION == BOA_VERSION_2_0
#include "EXTERNAL/BOA_V2/Include/OCI/ocican.h"
#include "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"
#else
#error "Unknown BOA version defined"
#endif

BEGIN_MESSAGE_MAP(CCAN_ETAS_BOA, CWinApp)
END_MESSAGE_MAP()

/**
 * CCAN_ETAS_BOA construction
 */
CCAN_ETAS_BOA::CCAN_ETAS_BOA()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/** The one and only CCAN_ETAS_BOA object */
static CCAN_ETAS_BOA theApp;

/**
 * CCAN_ETAS_BOA initialization
 */
static HINSTANCE ghLangInst=NULL;

BOOL CCAN_ETAS_BOA::InitInstance()
{
    /* Begin of Multiple Language support */
    if ( CMultiLanguage::m_nLocales <= 0 ) // Not detected yet
    {
        CMultiLanguage::DetectLangID(); // Detect language as user locale
        CMultiLanguage::DetectUILanguage(); // Detect language in MUI OS
    }
    TCHAR szModuleFileName[MAX_PATH]; // Get Module File Name and path
    int ret = ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH);
    if ( ret == 0 || ret == MAX_PATH )
    {
        ASSERT(FALSE);
    }

    /*
     * Load resource-only language DLL. It will use the languages
     * detected above, take first available language,
     * or you can specify another language as second parameter to
     * LoadLangResourceDLL. And try that first.
     */
    ghLangInst = CMultiLanguage::LoadLangResourceDLL( szModuleFileName );
    if (ghLangInst)
    {
        AfxSetResourceHandle( ghLangInst );
    }

    CWinApp::InitInstance();

    return TRUE;
}

static const BYTE FILTER_ADD = 0x01;
static const BYTE FILTER_REMOVE = 0x02;
static const BYTE QUEUE_ADD = 0x01;
static const BYTE QUEUE_DESTROY = 0x02;

/**
 * Channel information
 */
typedef struct tagCHANNEL
{
    OCI_URIName m_acURI; /**< URI of the Controller */
    OCI_ControllerHandle m_OCI_HwHandle; /**< Controller handle */
    OCI_CANConfiguration m_OCI_CANConfig; /**< Controller configuration */
    OCI_CANControllerProperties m_OCI_CntrlProp; /**< Controller properties */
    OCI_QueueHandle m_OCI_RxQueueHandle; /**< Controller receive queue handle */
    OCI_CANRxQueueConfiguration m_OCI_RxQueueCfg; /**< Controller receive queue configuration */
    OCI_QueueHandle m_OCI_TxQueueHandle; /**< Controller transmit queue handle */
    OCI_CANTxQueueConfiguration m_OCI_TxQueueCfg; /**< Controller transmit queue configuration */
    OCI_CANRxFilter m_OCI_FrameFilter; /**< Controller frame filter */
    OCI_CANEventFilter m_OCI_EventFilter; /**< Controller event filter */
    OCI_CANErrorFrameFilter m_OCI_ErrorFilter; /**< Controller error filter */
    OCI_InternalErrorEventFilter m_OCI_InternalErrorFilter;
    UCHAR m_ucControllerState; /**< Controller state */
    UCHAR m_ucTxErrorCounter; /**< Controller Tx error counter */
    UCHAR m_ucRxErrorCounter; /**< Controller Rx error counter */
    UCHAR m_ucPeakRxErrorCounter; /**< Controller peak Rx error counter */
    UCHAR m_ucPeakTxErrorCounter; /**< Controller peak Tx error counter */
    OCI_TimerCapabilities m_OCI_TimerCapabilities;
    FLOAT m_fResolution;
    bool m_bSupportCANFD; /**< controller capability of CAN_FD */
} SCHANNEL;

/**
 * Client and Client Buffer map
 */
#define MAX_BUFF_ALLOWED 16
#define MAX_CLIENT_ALLOWED 16
static UINT sg_unClientCnt = 0;

class SCLIENTBUFMAP
{
public:
    DWORD m_dwClientID;
    CBaseCANBufFSE* m_pClientBuf[MAX_BUFF_ALLOWED];
    string m_acClientName;
    UINT m_unBufCount;
    SCLIENTBUFMAP()
    {
        m_dwClientID = 0;
        m_unBufCount = 0;
        m_acClientName = "";

        for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
    }
};

/**
 * Array of clients
 */
static vector<SCLIENTBUFMAP> sg_asClientToBufMap(MAX_CLIENT_ALLOWED);

static const INT MAX_MAP_SIZE = 3000;

typedef struct tagAckMap
{
    UINT m_MsgID;
    UINT m_ClientID;
    UINT m_Channel;

    BOOL operator == (const tagAckMap& RefObj)
    {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
} SACK_MAP;

typedef list<SACK_MAP> CACK_MAP_LIST;
static CACK_MAP_LIST sg_asAckMapBuf;
static  CRITICAL_SECTION sg_CritSectForAckBuf; // To make it thread safe

/**
 * Channel instances
 */
static vector<SCHANNEL> sg_asChannel(defNO_OF_CHANNELS);

/**
 * Number of current channel selected
 */
static UINT sg_nNoOfChannels = 0;

static BOOL sg_bIsDriverRunning = FALSE;

static HWND sg_hOwnerWnd = NULL;

static const BYTE CREATE_MAP_TIMESTAMP = 0x1;

static const BYTE CALC_TIMESTAMP_READY = 0x2;

/**
 * Current state machine
 */
static BYTE sg_byCurrState = CREATE_MAP_TIMESTAMP;

static HANDLE sg_hEvent = NULL;

static CRITICAL_SECTION sg_DIL_CriticalSection;

static INT sg_anSelectedItems[CHANNEL_ALLOWED];

/**
 * Timer variables
 */
static SYSTEMTIME sg_CurrSysTime;
static UINT64 sg_TimeStamp = 0;
static LARGE_INTEGER sg_QueryTickCount;
static LARGE_INTEGER sg_lnFrequency;

/**
 * Required libraries
 */
static HMODULE sg_hLibCSI = NULL;
static HMODULE sg_hLibOCI = NULL;

/**
 * Declarations of CSI API pointers
 */
typedef CSI_DECLSPEC OCI_ErrorCode (*PROC1)(const char* uriName, CSI_NodeRange range, CSI_Tree* *tree);
typedef CSI_DECLSPEC OCI_ErrorCode (*PROC2)(CSI_Tree* tree);
typedef CSI_DECLSPEC OCI_ErrorCode (*PROC3)(CSI_Tree* tree, const BOA_UuidVersion* uuid, OCI_URIName uriName[], int size, int* count);

typedef OCI_ErrorCode (*PF_OCI_CreateCANControllerVersion)(const char* uriLocation, const BOA_Version* apiVersion, OCI_ControllerHandle* controller);

/* Macro definitions */
#if BOA_VERSION == BOA_VERSION_1_4
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.4"
#define LIB_CSL_NAME    "dll-csiBind_1_4.dll"
#define LIB_OCI_NAME    "dll-ocdProxy_1_4.dll"
#elif BOA_VERSION == BOA_VERSION_1_5
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.5"
#define LIB_CSL_NAME    "dll-csiBind_1_5.dll"
#define LIB_OCI_NAME    "dll-ocdProxy_1_5.dll"
#elif BOA_VERSION == BOA_VERSION_2_0
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\2"
#define LIB_CSL_NAME    "dll-csiBind.dll"
#define LIB_OCI_NAME    "dll-ocdProxy.dll"
#else
#error "Unknown BOA version defined"
#endif

/**
 * CSI pointers table
 */
typedef struct tagCSI_VTABLE
{
    PROC1 createProtocolTree;
    PROC2 destroyProtocolTree;
    PROC3 getUriForUuid;
} CSI_VTABLE;

/**
 * Complete pointers of OCI, OCI CAN, CSI
 */
typedef struct tagBOA_POINTER_TABLE
{
    CSI_VTABLE       m_sCSI;
    OCI_CAN_VTable   m_sOCI;
#if BOA_VERSION >= BOA_VERSION_2_0
    PF_OCI_CreateCANControllerVersion createCANController;
#endif
} SBOA_POINTER_TABLE;

static SBOA_POINTER_TABLE sBOA_PTRS;

/**
 * Starts code for the state machine
 */
enum
{
    STATE_DRIVER_SELECTED    = 0x0,
    STATE_HW_INTERFACE_LISTED,
    STATE_HW_INTERFACE_SELECTED,
    STATE_CONNECTED
};

static BYTE sg_bCurrState = STATE_DRIVER_SELECTED;

/* CDIL_CAN_ETAS_BOA class definition */
class CDIL_CAN_ETAS_BOA : public CBaseDIL_CAN_Controller
{
public:
    /* overloaded functions */
    HRESULT CAN_PerformInitOperations(void);
    HRESULT CAN_PerformClosureOperations(void);
    HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
    HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
    HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
    HRESULT CAN_DeselectHwInterface(void);
    HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
    HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
    HRESULT CAN_StartHardware(void);
    HRESULT CAN_StopHardware(void);
    HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
    HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
    HRESULT CAN_GetLastErrorString(string& acErrorStr);
    HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
    HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
    HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
    HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
    HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
    HRESULT CAN_LoadDriverLibrary(void);
    HRESULT CAN_UnloadDriverLibrary(void);
};

static CDIL_CAN_ETAS_BOA* sg_pouDIL_CAN_ETAS_BOA = NULL;

USAGEMODE HRESULT GetIDIL_CAN_Controller(void** ppvInterface)
{
    HRESULT hResult = S_OK;
    if ( NULL == sg_pouDIL_CAN_ETAS_BOA )
    {
        if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    *ppvInterface = (void*) sg_pouDIL_CAN_ETAS_BOA; // Doesn't matter even if sg_pouDIL_CAN_Kvaser is null

    return hResult;
}

/**
 * Error logger
 */
static Base_WrapperErrorLogger* sg_pIlog   = NULL;

/**
 * Declarations of ProcessCanData. This is a call back function
 * which will be called by BOA framework whenever there is a msg
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg);
#else
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg);
#endif

/**
 * Declarations of ProcessEvents. This is a call back function
 * which will be called by BOA framework whenever there are internal events
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg);
#else
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg);
#endif

/**
 * CallBack function used by the qsort Function
 */
static INT nCallBackStrCompareFn( const void* str1, const void* str2)
{
    return( strcmp((char*)str1,(char*)str2) );
}

static BOOL bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
{
    BOOL bExist = FALSE;
    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
    {
        if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
    }
    return bExist;
}

static BOOL bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
{
    BOOL bReturn = TRUE;
    for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
    return bReturn;
}

/**
 * Gets the CSI API function pointer from the cslproxy.dll
 */
static BOOL bGetBOAInstallationPath(string& pcPath)
{
    USES_CONVERSION;

    BOOL bResult = FALSE;
    LONG lError = 0;
    HKEY sKey;

    /* Get the installation path for BOA */
    lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey);

    /* If the registry key open successfully, get the value in "path" sub key */
    if(lError==ERROR_SUCCESS)
    {
        ULONG ulType = REG_SZ;
        BYTE acGCCPath[1024];
        DWORD dwSize = sizeof(acGCCPath);
        lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
        pcPath = A2T((char*)acGCCPath);
        RegCloseKey(sKey);
        bResult = TRUE;
    }
    return bResult;
}

/**
 * Gets the CSI API function pointer from the cslproxy.dll
 */
static HRESULT GetCSI_API_Pointers(HMODULE hLibCSI)
{
    HRESULT hResult = S_OK;
    if (hLibCSI != NULL)
    {
        if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}

/**
 * Gets the OCI API function pointer from the ocdproxy.dll
 */
static HRESULT GetOCI_API_Pointers(HMODULE hLibOCI)
{
    HRESULT hResult = S_OK;
    if (hLibOCI != NULL)
    {
#if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
#if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}

/**
 * Search for all connected Hardware, that supports the OCI
 * CAN interface and deliver the URI location of the hardware.
 */
static void findCanNodes( CSI_Tree* sfsTree, OCI_URIName uriPrefix, OCI_URIName uriNames[], uint32 size, uint32* position )
{
    /* Uncomment the next line to get a view of the items in the tree */
    // printf( "uriPrefix is %s; node is %s\n", uriPrefix, sfsTree->item.uriNames );

    /* Basic error checking */
    if ( !sfsTree || !uriNames || !uriPrefix || !position )
    {
        return;
    }

    /*
     * Does the current tree node have the URI name which begins with "CAN:"?
     * (Each node which represents a CAN port always has a URI name of the form "CAN:n".
     */
    if( 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 ) )
    {
        if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
    }

    /* If the current tree node has a child, recurse into it */
    if (sfsTree->child)
    {
        OCI_URIName newUriPrefix;

        strcpy( newUriPrefix, uriPrefix );
        strcat( newUriPrefix, "/" );
        strcat( newUriPrefix, sfsTree->item.uriName );
        findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
    }

    /* If the current tree node has a sibling, recurse into it */
    if (sfsTree->sibling)
    {
        findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
    }
}

static BOA_ResultCode OCI_FindCANController(OCI_URIName uriName[], INT nSize, INT* nFound)
{
    if ( !nFound )
    {
        return S_FALSE;
    }

    OCI_ErrorCode   ec;

    /* Container for search results */
    CSI_Tree* sfsTree = NULL;

    /* Specify that we want to search for physical hardware nodes */
    const CSI_NodeRange nodeRange = {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE };

    /* The prefix of the URI of the root of the device tree */
    OCI_URIName uriPrefix = "ETAS:/";

    /* Search for all connected hardware and latch the result for further processing */
    ec = sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    /* Search the tree and fill array with the results */
    *nFound = 0;
    uint32 unFound = 0;
    findCanNodes( sfsTree, uriPrefix, uriName, nSize, &unFound );
    *nFound = unFound;

    /* Clean up the protocol tree. */
    ec = sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    return ec;
}

/**
 * unClientIndex will have index to client array which has clientId dwClientID.
 *
 * @return Returns true if found else false.
 */
static BOOL bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
{
    BOOL bResult = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
    }
    return bResult;
}

/**
 * Checks for the existance of the client with the name pcClientName.
 *
 * @return TRUE if client exists else FALSE
 */
static BOOL bClientExist(string pcClientName, INT& Index)
{
    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
    }
    return FALSE;
}

/**
 * Removes the client with client id dwClientId.
 *
 * @return TRUE if client removed else FALSE
 */
static BOOL bRemoveClient(DWORD dwClientId)
{
    BOOL bResult = FALSE;
    if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = 0;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
    }
    return bResult;
}

/**
 * Searches for the client with the id dwClientId.
 *
 * @return TRUE if client exists else FALSE
 */
static BOOL bClientIdExist(const DWORD& dwClientId)
{
    BOOL bReturn = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
    return bReturn;
}

/**
 * Returns the available slot
 */
static DWORD dwGetAvailableClientSlot()
{
    DWORD nClientId = 2;
    for (INT i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
    return nClientId;
}

/**
 * Pushes an entry into the list at the last position
 */
static void vMarkEntryIntoMap(const SACK_MAP& RefObj)
{
    //EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    sg_asAckMapBuf.push_back(RefObj);
    //LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
}

static BOOL bRemoveMapEntry(const SACK_MAP& RefObj, UINT& ClientID)
{
    EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    BOOL bResult = FALSE;
    CACK_MAP_LIST::iterator  iResult =
        find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj );

    //if ((*iResult).m_ClientID > 0)
    if (iResult != sg_asAckMapBuf.end())
    {
        bResult = TRUE;
        ClientID = (*iResult).m_ClientID;
        sg_asAckMapBuf.erase(iResult);
    }
    LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
    return bResult;
}

/**
 * Initialize default values for controller configuration
 *
 * @param[in] nChannel Channel information
 */
static void vInitializeControllerConfig(UINT nChannel)
{
    sg_asChannel[nChannel].m_OCI_CANConfig.baudrate = 500000;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit = OCI_CAN_THREE_SAMPLES_PER_BIT;
    sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.SJW = 16;
    sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
    sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
    sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* Set controller property to SUSPENDED */
    sg_asChannel[nChannel].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;

#if BOA_VERSION >= BOA_VERSION_2_0
    /* Set CAN FD default values */
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF;
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = 0;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED;
    //
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;

    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;

    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE_PADDING;

    // sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
    sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
}

/**
 * Initialize default values for queue confgiuration
 *
 * @param[in] nChannel Channel information
 */
static void vInitializeQueueConfig(UINT nChannel)
{
    /* configure Rx Queue*/
#if BOA_VERSION >= BOA_VERSION_2_0
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents;
#else
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
#endif
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* configure Tx Queue*/
    sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved = 0;
}

/**
 * Initialize default values for filter confgiuration
 *
 * @param[in] nChannel Channel information
 */
static void vInitializeFilterConfig(UINT nChannel)
{
    /* configure frame filter*/
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.tag = 0;

    /* configure event filter*/
    sg_asChannel[nChannel].m_OCI_EventFilter.destination = OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_EventFilter.eventCode = OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE ;
    sg_asChannel[nChannel].m_OCI_EventFilter.tag = 0;

    /* configure error filter */
    sg_asChannel[nChannel].m_OCI_ErrorFilter.destination =  OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame =   OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.tag = 0;

    /* configure internal error filter */
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode = OCI_INTERNAL_GENERAL_ERROR;
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag = 0;
}

/**
 * Adds or removes the HW filter to/from the channel.
 *
 * @return S_OK for success, S_FALSE for failure
 */
static HRESULT ManageFilters(BYTE byCode, UINT nChannel)
{
    HRESULT hResult = S_FALSE;
    BOA_ResultCode ErrCode = OCI_FAILURE;
    if (byCode == FILTER_ADD)
    {
        /* Add frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }

        /* Add bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }

        /* Add error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

        /* Add internal error filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

    }
    else if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
    return hResult;
}

/**
 * Adds or removes the queue to/from the channel.
 *
 * @return S_OK for success, S_FALSE for failure
 */
static HRESULT ManageQueue(BYTE byCode, UINT nChannel)
{
    HRESULT hResult = S_FALSE;
    BOA_ResultCode Err = OCI_ERR_FLAG_ERROR;
    if (byCode == QUEUE_ADD)
    {
        /* Create CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    else if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    return hResult;
}

/**
 * copies from OCI_CANRxMessage struct into STCANDATA struct
 */
static void vCopyOCI_CAN_RX_2_DATA(const OCI_CANRxMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }

    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData));
}

/**
 * copies from OCI_CANRxMessage struct into STCANDATA struct
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vCopyOCI_CAN_FD_RX_2_DATA(const OCI_CANFDRxMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size);
}
#endif

/**
 * Gets the channel with handle OCI_ControllerHandle
 *
 * @return Returns channel number
 */
static UINT nGetChannel(const OCI_ControllerHandle hHandle)
{
    UINT i;
    for (i = 0; i < sg_nNoOfChannels; i++)
    {
        if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
    }
    return (i+1);
}

/**
 * Create time mod mapping
 */
static void vCreateTimeModeMapping(HANDLE hEvent)
{
    WaitForSingleObject(hEvent, INFINITE);
    GetLocalTime(&sg_CurrSysTime);
    /* Query Tick Count */
    QueryPerformanceCounter(&sg_QueryTickCount);
}

/**
 * This function writes the message to the corresponding clients buffer
 */
static void vWriteIntoClientsBuffer(STCANDATA& sCanData)
{
    /* Write into the client's buffer and Increment message Count */
    if (sCanData.m_ucDataType == TX_FLAG)
    {
        static SACK_MAP sAckMap;
        UINT ClientId = 0;
        static UINT Index = (UINT)-1;
        sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
        sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;

        if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
    }
    else // provide it to everybody
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
}

/**
 * Processes Rx msg and writes into regiastered clients buffer.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessRxMsg(void* userData, struct OCI_CANMessageEx* msg)
#else
static void vProcessRxMsg(void* userData, struct OCI_CANMessage* msg)
#endif
{
    /* First calculate timestamp for first message*/
    EnterCriticalSection(&sg_DIL_CriticalSection);

    static STCANDATA sCanData;
    static OCI_ControllerHandle hHandle;

    hHandle = (OCI_ControllerHandle)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel(hHandle);

    if ( msg->type == OCI_CAN_RX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
        vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
    }
#if BOA_VERSION >= BOA_VERSION_2_0
    /* Check if its a CAN FD message */
    else if ( msg->type ==  OCI_CANFDRX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
        vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
    }
#endif

    if (sg_byCurrState == CREATE_MAP_TIMESTAMP)
    {
        // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);
        sg_byCurrState = CALC_TIMESTAMP_READY;


        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;

        /* Time difference should be +ve value */
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
    }

    /* Write the msg into registered client's buffer */
    vWriteIntoClientsBuffer(sCanData);

    LeaveCriticalSection(&sg_DIL_CriticalSection);
}

/**
 * Processes Tx msg.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessTxMsg(void* /*userData*/, OCI_CANMessageEx* /*msg*/)
#else
static void vProcessTxMsg(void* /*userData*/, OCI_CANMessage* /*msg*/)
#endif
{
}

/**
 * Copies OCI_CANErrorFrameMessage struct into STCANDATA.
 */
static void vCopyOCI_CAN_ERR_2_DATA(const OCI_CANErrorFrameMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_lTickCount.QuadPart = SrcMsg->timeStamp;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0;
    DestMsg->m_ucDataType = ERR_FLAG;
    BOOL bIsTx = (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION;
    if (bIsTx)
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
    }
    else
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
    switch (SrcMsg->type)
    {
        /* stuff error */
        case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;

        /* form error */
        case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;

        /* bit error */
        case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;

        /* other error */
        case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;

        /* crc error */
        case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;

        /* acknowledgement error */
        case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;

        /* other error categories currently just map to ERROR_UNKNOWN */
        case OCI_CAN_ERR_TYPE_OVERLOAD:
        case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
        case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
        default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
    }
}

/**
 * Updates Tx and Rx error counter of the nChannel
 */
static void vUpdateErrorCounter(UCHAR ucTxError, UCHAR ucRxError, UINT nChannel)
{
    /* Update Tx Error counter and peak Tx Error Counter */
    sg_asChannel[nChannel].m_ucTxErrorCounter = sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError;

    /* Update Peak Value */
    if( ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
    }

    /* Update Rx Error counter and peak Rx Error Counter */
    sg_asChannel[nChannel].m_ucRxErrorCounter = sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError;

    /* Update Peak Value */
    if( ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
    }
}

/**
 * Processes error msg and writes into registered clients buffer.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessErrMsg(void* userData, struct OCI_CANMessageEx* msg)
#else
static void vProcessErrMsg(void* userData, struct OCI_CANMessage* msg)
#endif
{
    static STCANDATA sCanData;
    vCopyOCI_CAN_ERR_2_DATA(&(msg->data.errorFrameMessage), &sCanData);
    // int32* pUserData = (int32*)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = 0;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel((OCI_ControllerHandle)userData);
    sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;

    /*  Update channel error counter */
    vUpdateErrorCounter(sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel);

    /* Write the msg into registered client's buffer */
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
    }
}

/**
 * Callback function called by the BOA framework
 * when there is presence of msg in the bus.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg)
#else
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->type)
    {
        case OCI_CAN_RX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
            vProcessRxMsg(userData, msg);
            break;
        case OCI_CAN_TX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
            vProcessTxMsg(userData, msg);
            break;

    }
}

/**
 * processes bus event.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessBusEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
#else
static void vProcessBusEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}

/**
 * processes internal event.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
#else
static void vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}

/**
 * process queue event.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
#else
static void vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}

/**
 * process tmer event.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessageEx* msg)
#else
static void vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->data.timerEventMessage.eventCode)
    {
        case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
        case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
    }
}

/**
 * Callback function called by the BOA framework
 * when there is internal bus event.
 */
#if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg)
#else
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->type)
    {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
{
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_UnloadDriverLibrary(void)
{
    /* Unload OCI library */
    if (sg_hLibOCI != NULL)
    {
        FreeLibrary(sg_hLibOCI);
    }

    /* Unload CSI library */
    if (sg_hLibCSI != NULL)
    {
        FreeLibrary(sg_hLibCSI);
    }

    /* Invalidate all API pointers */
    memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE));
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
{
    HRESULT hResult = S_FALSE;
    if (ClientID != 0)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
{
    HRESULT hResult = S_FALSE;
    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& unCntrlStatus)
{
    unCntrlStatus = defCONTROLLER_ACTIVE; /* Temporary solution. TODO */
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_LoadDriverLibrary(void)
{
    HRESULT hResult = S_FALSE;
    string acPath;

    /* Get BOA installation path from the registery */
    bGetBOAInstallationPath(acPath);

    /* Load cslproxy.dll library */
    string acLIB_CSL = "";
    acLIB_CSL.append(acPath);
    acLIB_CSL.append("\\");
    acLIB_CSL.append(LIB_CSL_NAME);

    /* LoadLibraryEx instead of LoadLibrary seems to be necessary under Windows 7 when the library is not in DLL search path (system32) */
    sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (sg_hLibCSI != NULL)
    {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
    else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformInitOperations(void)
{
    /*
     * Create critical section for ensuring thread
     * safeness of read message function
     */
    InitializeCriticalSection(&sg_DIL_CriticalSection);

    /* Create an event for timestamp calculations */
    sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    /*
     * Initial Channel info with default values.
     * 1. Controller configuration
     * 2. Queue configuration
     * 3. Filter configuration
     */
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }

    /* Register monitor client */
    DWORD dwClient = 0;
    CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE);

    /* Initialize the selected channel items array to -1 */
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return S_OK;
}

/**
 * Copies the controller config values into channel's
 * controller config structure.
 *
 * @return TRUE for success, FALSE for failure
 */
static BOOL bLoadDataFromContr(PSCONTROLLER_DETAILS pControllerDetails)
{
    BOOL bReturn = FALSE;

    /* If successful */
    if (pControllerDetails != NULL)
    {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
    return bReturn;
}

/**
 * Copies from STCAN_MSG structure into OCI_CANTxMessage message structure
 */
static void vCopy_2_OCI_CAN_Data(OCI_CANTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.dlc     = SrcMsg.m_ucDataLen;
    DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
}


#if BOA_VERSION >= BOA_VERSION_2_0
static BOOL vCopy_2_OCI_CANFD_Data(OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.size     = SrcMsg.m_ucDataLen;
    if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
    DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
    return TRUE;
}
#endif

HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformClosureOperations(void)
{
    HRESULT hResult = S_OK;

    CAN_StopHardware();

    /* deselect hw interface */
    hResult = CAN_DeselectHwInterface();

    /* close the existing handle */
    CloseHandle(sg_hEvent);
    sg_hEvent = NULL;

    /* Remove all the existing clients */
    UINT ClientIndex = 0;
    while (sg_unClientCnt > 0)
    {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }

    /* Delete the critical section */
    DeleteCriticalSection(&sg_DIL_CriticalSection);
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
{
    CurrSysTime = sg_CurrSysTime;
    TimeStamp   = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
    return S_OK;
}

/**
 * This function will popup hardware selection dialog and gets the user selection of channels.
 *
 * @return Operation Result. 0 incase of no errors. Failure Error codes otherwise.
 */
static int ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    INT nRet = HwList.DoModal();
    objMainWnd.Detach();

    if ( nRet == IDOK)
    {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
    else
    {
        return -1;
    }
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
{
    // VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_DRIVER_SELECTED, ERR_IMPROPER_STATE);
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;
    OCI_URIName acURI[defNO_OF_CHANNELS];
    INT nFound = 0;

    UINT unDefaultChannelCnt = nCount;

    if (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
    {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SelectHwInterface(const INTERFACE_HW_LIST& asSelHwInterface, INT /*nCount*/)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    /* First select only supported number of HW interfaces */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }

    /* Create the controller instance. */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_DeselectHwInterface(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }

    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
    return hResult;
}

/**
 * Call back function called from ConfigDialogDIL
 *
 * @return TRUE for success, FALSE for failure
 */
static BOOL Callback_DILBOA(BYTE /*Argument*/, PSCONTROLLER_DETAILS pDatStream, INT /*Length*/)
{
    return (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK);
}

/**
 * Displays the configuration dialog for controller
 *
 * @return S_OK for success, S_FALSE for failure
 */
static int DisplayConfigurationDlg(HWND hParent, DILCALLBACK /*ProcDIL*/,
                            PSCONTROLLER_DETAILS pControllerDetails, UINT nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int nResult = WARNING_NOTCONFIRMED;

    SCONTROLLER_DETAILS sController[defNO_OF_CHANNELS];

    for(int i =0 ; i < defNO_OF_CHANNELS; i++)
    {
        sController[i] = pControllerDetails[i];
    }

    CChangeRegisters_CAN_ETAS_BOA ouChangeRegister(NULL, pControllerDetails, nCount);
    ouChangeRegister.DoModal();

    nResult = ouChangeRegister.nGetInitStatus();

    return nResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM);

    USES_CONVERSION;

    INT Result = WARN_INITDAT_NCONFIRM;
    PSCONTROLLER_DETAILS psContrlDets = (PSCONTROLLER_DETAILS)InitData;

    /* First initialize with existing hw description */
    for (INT i = 0; i < min(Length, (INT)sg_nNoOfChannels); i++)
    {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
    if (sg_nNoOfChannels > 0)
    {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }

    return Result;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetConfigData(PSCONTROLLER_DETAILS pInitData, int /*Length*/)
{
    HRESULT hResult = WARNING_NOTCONFIRMED;

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(pInitData, hResult);

    BOA_ResultCode ErrCode = OCI_FAILURE;
    PSCONTROLLER_DETAILS pControllerDetails = (PSCONTROLLER_DETAILS)pInitData;
    bLoadDataFromContr(pControllerDetails);
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_StartHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_StopHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
{
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
    HRESULT hResult = S_FALSE;

    if (bClientIdExist(dwClientID))
    {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetLastErrorString(string& /*acErrorStr*/)
{
    return WARN_DUMMY_API;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
{
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}

|Node:comment Text: /*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
|Node:comment Text: /**
 * @brief Source file for BOA DIL functions
 * @author Pradeep Kadoor, Tobias Lorenz
 * @copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for BOA DIL functions
 * Defines the initialization routines for the DLL.
 */
|Node:comment Text: /* C includes */
|Node:preproc_include Text: #include <search.h>             /* For qsort */

|Node:#include Text: #include
|Node:system_lib_string Text: <search.h>
|Node:comment Text: /* For qsort */
|Node:comment Text: /* C++ includes */
|Node:preproc_include Text: #include <string>

|Node:#include Text: #include
|Node:system_lib_string Text: <string>
|Node:preproc_include Text: #include <vector>

|Node:#include Text: #include
|Node:system_lib_string Text: <vector>
|Node:comment Text: /* Project includes */
|Node:preproc_include Text: #include "CAN_ETAS_BOA_stdafx.h"

|Node:#include Text: #include
|Node:string_literal Text: "CAN_ETAS_BOA_stdafx.h"
|Node:" Text: "
|Node:string_content Text: CAN_ETAS_BOA_stdafx.h
|Node:" Text: "
|Node:preproc_include Text: #include "CAN_ETAS_BOA.h"

|Node:#include Text: #include
|Node:string_literal Text: "CAN_ETAS_BOA.h"
|Node:" Text: "
|Node:string_content Text: CAN_ETAS_BOA.h
|Node:" Text: "
|Node:preproc_include Text: #include "DataTypes/Base_WrapperErrorLogger.h"

|Node:#include Text: #include
|Node:string_literal Text: "DataTypes/Base_WrapperErrorLogger.h"
|Node:" Text: "
|Node:string_content Text: DataTypes/Base_WrapperErrorLogger.h
|Node:" Text: "
|Node:preproc_include Text: #include "DataTypes/MsgBufAll_DataTypes.h"

|Node:#include Text: #include
|Node:string_literal Text: "DataTypes/MsgBufAll_DataTypes.h"
|Node:" Text: "
|Node:string_content Text: DataTypes/MsgBufAll_DataTypes.h
|Node:" Text: "
|Node:preproc_include Text: #include "DataTypes/DIL_Datatypes.h"

|Node:#include Text: #include
|Node:string_literal Text: "DataTypes/DIL_Datatypes.h"
|Node:" Text: "
|Node:string_content Text: DataTypes/DIL_Datatypes.h
|Node:" Text: "
|Node:preproc_include Text: #include "Include/BaseDefs.h"

|Node:#include Text: #include
|Node:string_literal Text: "Include/BaseDefs.h"
|Node:" Text: "
|Node:string_content Text: Include/BaseDefs.h
|Node:" Text: "
|Node:preproc_include Text: #include "Include/DIL_CommonDefs.h"

|Node:#include Text: #include
|Node:string_literal Text: "Include/DIL_CommonDefs.h"
|Node:" Text: "
|Node:string_content Text: Include/DIL_CommonDefs.h
|Node:" Text: "
|Node:preproc_include Text: #include "Include/Can_Error_Defs.h"

|Node:#include Text: #include
|Node:string_literal Text: "Include/Can_Error_Defs.h"
|Node:" Text: "
|Node:string_content Text: Include/Can_Error_Defs.h
|Node:" Text: "
|Node:preproc_include Text: #include "DIL_Interface/BaseDIL_CAN_Controller.h"

|Node:#include Text: #include
|Node:string_literal Text: "DIL_Interface/BaseDIL_CAN_Controller.h"
|Node:" Text: "
|Node:string_content Text: DIL_Interface/BaseDIL_CAN_Controller.h
|Node:" Text: "
|Node:preproc_include Text: #include "HardwareListing.h"

|Node:#include Text: #include
|Node:string_literal Text: "HardwareListing.h"
|Node:" Text: "
|Node:string_content Text: HardwareListing.h
|Node:" Text: "
|Node:preproc_include Text: #include "ChangeRegisters_CAN_ETAS_BOA.h"

|Node:#include Text: #include
|Node:string_literal Text: "ChangeRegisters_CAN_ETAS_BOA.h"
|Node:" Text: "
|Node:string_content Text: ChangeRegisters_CAN_ETAS_BOA.h
|Node:" Text: "
|Node:preproc_include Text: #include "../Application/MultiLanguage.h"

|Node:#include Text: #include
|Node:string_literal Text: "../Application/MultiLanguage.h"
|Node:" Text: "
|Node:string_content Text: ../Application/MultiLanguage.h
|Node:" Text: "
|Node:preproc_include Text: #include "Utility\MultiLanguageSupport.h"

|Node:#include Text: #include
|Node:string_literal Text: "Utility\MultiLanguageSupport.h"
|Node:" Text: "
|Node:string_content Text: Utility
|Node:escape_sequence Text: \M
|Node:string_content Text: ultiLanguageSupport.h
|Node:" Text: "
|Node:comment Text: //#include "../Application/GettextBusmaster.h"
|Node:preproc_def Text: #define USAGE_EXPORT

|Node:#define Text: #define
|Node:identifier Text: USAGE_EXPORT
|Node:preproc_include Text: #include "CAN_ETAS_BOA_Extern.h"

|Node:#include Text: #include
|Node:string_literal Text: "CAN_ETAS_BOA_Extern.h"
|Node:" Text: "
|Node:string_content Text: CAN_ETAS_BOA_Extern.h
|Node:" Text: "
|Node:comment Text: /* ETAS BOA includes */
|Node:preproc_ifdef Text: #ifndef BOA_VERSION
#error "No BOA version defined"
#endif
|Node:#ifndef Text: #ifndef
|Node:identifier Text: BOA_VERSION
|Node:preproc_call Text: #error "No BOA version defined"

|Node:preproc_directive Text: #error
|Node:preproc_arg Text: "No BOA version defined"
|Node:#endif Text: #endif
|Node:preproc_if Text: #if BOA_VERSION == BOA_VERSION_1_4
#include "EXTERNAL/BOA 1.4/Include/OCI/ocican.h"
#include "EXTERNAL/BOA 1.4/Include/CSI/csisfs.h"
#elif BOA_VERSION == BOA_VERSION_1_5
#include "EXTERNAL/BOA 1.5/Include/OCI/ocican.h"
#include "EXTERNAL/BOA 1.5/Include/CSI/csisfs.h"
#elif BOA_VERSION == BOA_VERSION_2_0
#include "EXTERNAL/BOA_V2/Include/OCI/ocican.h"
#include "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"
#else
#error "Unknown BOA version defined"
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_1_4
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_1_4
|Node:
 Text: 

|Node:preproc_include Text: #include "EXTERNAL/BOA 1.4/Include/OCI/ocican.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA 1.4/Include/OCI/ocican.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA 1.4/Include/OCI/ocican.h
|Node:" Text: "
|Node:preproc_include Text: #include "EXTERNAL/BOA 1.4/Include/CSI/csisfs.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA 1.4/Include/CSI/csisfs.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA 1.4/Include/CSI/csisfs.h
|Node:" Text: "
|Node:preproc_elif Text: #elif BOA_VERSION == BOA_VERSION_1_5
#include "EXTERNAL/BOA 1.5/Include/OCI/ocican.h"
#include "EXTERNAL/BOA 1.5/Include/CSI/csisfs.h"
#elif BOA_VERSION == BOA_VERSION_2_0
#include "EXTERNAL/BOA_V2/Include/OCI/ocican.h"
#include "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"
#else
#error "Unknown BOA version defined"

|Node:#elif Text: #elif
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_1_5
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_1_5
|Node:
 Text: 

|Node:preproc_include Text: #include "EXTERNAL/BOA 1.5/Include/OCI/ocican.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA 1.5/Include/OCI/ocican.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA 1.5/Include/OCI/ocican.h
|Node:" Text: "
|Node:preproc_include Text: #include "EXTERNAL/BOA 1.5/Include/CSI/csisfs.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA 1.5/Include/CSI/csisfs.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA 1.5/Include/CSI/csisfs.h
|Node:" Text: "
|Node:preproc_elif Text: #elif BOA_VERSION == BOA_VERSION_2_0
#include "EXTERNAL/BOA_V2/Include/OCI/ocican.h"
#include "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"
#else
#error "Unknown BOA version defined"

|Node:#elif Text: #elif
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:preproc_include Text: #include "EXTERNAL/BOA_V2/Include/OCI/ocican.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA_V2/Include/OCI/ocican.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA_V2/Include/OCI/ocican.h
|Node:" Text: "
|Node:preproc_include Text: #include "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"

|Node:#include Text: #include
|Node:string_literal Text: "EXTERNAL/BOA_V2/Include/CSI/csisfs.h"
|Node:" Text: "
|Node:string_content Text: EXTERNAL/BOA_V2/Include/CSI/csisfs.h
|Node:" Text: "
|Node:preproc_else Text: #else
#error "Unknown BOA version defined"

|Node:#else Text: #else
|Node:preproc_call Text: #error "Unknown BOA version defined"

|Node:preproc_directive Text: #error
|Node:preproc_arg Text: "Unknown BOA version defined"
|Node:#endif Text: #endif
|Node:expression_statement Text: BEGIN_MESSAGE_MAP(CCAN_ETAS_BOA, CWinApp)
|Node:call_expression Text: BEGIN_MESSAGE_MAP(CCAN_ETAS_BOA, CWinApp)
|Node:identifier Text: BEGIN_MESSAGE_MAP
|Node:argument_list Text: (CCAN_ETAS_BOA, CWinApp)
|Node:( Text: (
|Node:identifier Text: CCAN_ETAS_BOA
|Node:, Text: ,
|Node:identifier Text: CWinApp
|Node:) Text: )
|Node:; Text: 
|Node:expression_statement Text: END_MESSAGE_MAP()

/**
 * CCAN_ETAS_BOA construction
 */
|Node:call_expression Text: END_MESSAGE_MAP()
|Node:identifier Text: END_MESSAGE_MAP
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:comment Text: /**
 * CCAN_ETAS_BOA construction
 */
|Node:; Text: 
|Node:function_definition Text: CCAN_ETAS_BOA::CCAN_ETAS_BOA()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}
|Node:function_declarator Text: CCAN_ETAS_BOA::CCAN_ETAS_BOA()
|Node:qualified_identifier Text: CCAN_ETAS_BOA::CCAN_ETAS_BOA
|Node:namespace_identifier Text: CCAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CCAN_ETAS_BOA
|Node:parameter_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:compound_statement Text: {
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}
|Node:{ Text: {
|Node:comment Text: // TODO: add construction code here,
|Node:comment Text: // Place all significant initialization in InitInstance
|Node:} Text: }
|Node:comment Text: /** The one and only CCAN_ETAS_BOA object */
|Node:declaration Text: static CCAN_ETAS_BOA theApp;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: CCAN_ETAS_BOA
|Node:identifier Text: theApp
|Node:; Text: ;
|Node:comment Text: /**
 * CCAN_ETAS_BOA initialization
 */
|Node:declaration Text: static HINSTANCE ghLangInst=NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HINSTANCE
|Node:init_declarator Text: ghLangInst=NULL
|Node:identifier Text: ghLangInst
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:function_definition Text: BOOL CCAN_ETAS_BOA::InitInstance()
{
    /* Begin of Multiple Language support */
    if ( CMultiLanguage::m_nLocales <= 0 ) // Not detected yet
    {
        CMultiLanguage::DetectLangID(); // Detect language as user locale
        CMultiLanguage::DetectUILanguage(); // Detect language in MUI OS
    }
    TCHAR szModuleFileName[MAX_PATH]; // Get Module File Name and path
    int ret = ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH);
    if ( ret == 0 || ret == MAX_PATH )
    {
        ASSERT(FALSE);
    }

    /*
     * Load resource-only language DLL. It will use the languages
     * detected above, take first available language,
     * or you can specify another language as second parameter to
     * LoadLangResourceDLL. And try that first.
     */
    ghLangInst = CMultiLanguage::LoadLangResourceDLL( szModuleFileName );
    if (ghLangInst)
    {
        AfxSetResourceHandle( ghLangInst );
    }

    CWinApp::InitInstance();

    return TRUE;
}
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: CCAN_ETAS_BOA::InitInstance()
|Node:qualified_identifier Text: CCAN_ETAS_BOA::InitInstance
|Node:namespace_identifier Text: CCAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: InitInstance
|Node:parameter_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:compound_statement Text: {
    /* Begin of Multiple Language support */
    if ( CMultiLanguage::m_nLocales <= 0 ) // Not detected yet
    {
        CMultiLanguage::DetectLangID(); // Detect language as user locale
        CMultiLanguage::DetectUILanguage(); // Detect language in MUI OS
    }
    TCHAR szModuleFileName[MAX_PATH]; // Get Module File Name and path
    int ret = ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH);
    if ( ret == 0 || ret == MAX_PATH )
    {
        ASSERT(FALSE);
    }

    /*
     * Load resource-only language DLL. It will use the languages
     * detected above, take first available language,
     * or you can specify another language as second parameter to
     * LoadLangResourceDLL. And try that first.
     */
    ghLangInst = CMultiLanguage::LoadLangResourceDLL( szModuleFileName );
    if (ghLangInst)
    {
        AfxSetResourceHandle( ghLangInst );
    }

    CWinApp::InitInstance();

    return TRUE;
}
|Node:{ Text: {
|Node:comment Text: /* Begin of Multiple Language support */
|Node:if_statement Text: if ( CMultiLanguage::m_nLocales <= 0 ) // Not detected yet
    {
        CMultiLanguage::DetectLangID(); // Detect language as user locale
        CMultiLanguage::DetectUILanguage(); // Detect language in MUI OS
    }
|Node:if Text: if
|Node:condition_clause Text: ( CMultiLanguage::m_nLocales <= 0 )
|Node:( Text: (
|Node:binary_expression Text: CMultiLanguage::m_nLocales <= 0
|Node:qualified_identifier Text: CMultiLanguage::m_nLocales
|Node:namespace_identifier Text: CMultiLanguage
|Node::: Text: ::
|Node:identifier Text: m_nLocales
|Node:<= Text: <=
|Node:number_literal Text: 0
|Node:) Text: )
|Node:comment Text: // Not detected yet
|Node:compound_statement Text: {
        CMultiLanguage::DetectLangID(); // Detect language as user locale
        CMultiLanguage::DetectUILanguage(); // Detect language in MUI OS
    }
|Node:{ Text: {
|Node:expression_statement Text: CMultiLanguage::DetectLangID();
|Node:call_expression Text: CMultiLanguage::DetectLangID()
|Node:qualified_identifier Text: CMultiLanguage::DetectLangID
|Node:namespace_identifier Text: CMultiLanguage
|Node::: Text: ::
|Node:identifier Text: DetectLangID
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Detect language as user locale
|Node:expression_statement Text: CMultiLanguage::DetectUILanguage();
|Node:call_expression Text: CMultiLanguage::DetectUILanguage()
|Node:qualified_identifier Text: CMultiLanguage::DetectUILanguage
|Node:namespace_identifier Text: CMultiLanguage
|Node::: Text: ::
|Node:identifier Text: DetectUILanguage
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Detect language in MUI OS
|Node:} Text: }
|Node:declaration Text: TCHAR szModuleFileName[MAX_PATH];
|Node:type_identifier Text: TCHAR
|Node:array_declarator Text: szModuleFileName[MAX_PATH]
|Node:identifier Text: szModuleFileName
|Node:[ Text: [
|Node:identifier Text: MAX_PATH
|Node:] Text: ]
|Node:; Text: ;
|Node:comment Text: // Get Module File Name and path
|Node:declaration Text: int ret = ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH);
|Node:primitive_type Text: int
|Node:init_declarator Text: ret = ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH)
|Node:identifier Text: ret
|Node:= Text: =
|Node:call_expression Text: ::GetModuleFileName(theApp.m_hInstance, szModuleFileName, MAX_PATH)
|Node:qualified_identifier Text: ::GetModuleFileName
|Node::: Text: ::
|Node:identifier Text: GetModuleFileName
|Node:argument_list Text: (theApp.m_hInstance, szModuleFileName, MAX_PATH)
|Node:( Text: (
|Node:field_expression Text: theApp.m_hInstance
|Node:identifier Text: theApp
|Node:. Text: .
|Node:field_identifier Text: m_hInstance
|Node:, Text: ,
|Node:identifier Text: szModuleFileName
|Node:, Text: ,
|Node:identifier Text: MAX_PATH
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if ( ret == 0 || ret == MAX_PATH )
    {
        ASSERT(FALSE);
    }
|Node:if Text: if
|Node:condition_clause Text: ( ret == 0 || ret == MAX_PATH )
|Node:( Text: (
|Node:binary_expression Text: ret == 0 || ret == MAX_PATH
|Node:binary_expression Text: ret == 0
|Node:identifier Text: ret
|Node:== Text: ==
|Node:number_literal Text: 0
|Node:|| Text: ||
|Node:binary_expression Text: ret == MAX_PATH
|Node:identifier Text: ret
|Node:== Text: ==
|Node:identifier Text: MAX_PATH
|Node:) Text: )
|Node:compound_statement Text: {
        ASSERT(FALSE);
    }
|Node:{ Text: {
|Node:expression_statement Text: ASSERT(FALSE);
|Node:call_expression Text: ASSERT(FALSE)
|Node:identifier Text: ASSERT
|Node:argument_list Text: (FALSE)
|Node:( Text: (
|Node:false Text: FALSE
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /*
     * Load resource-only language DLL. It will use the languages
     * detected above, take first available language,
     * or you can specify another language as second parameter to
     * LoadLangResourceDLL. And try that first.
     */
|Node:expression_statement Text: ghLangInst = CMultiLanguage::LoadLangResourceDLL( szModuleFileName );
|Node:assignment_expression Text: ghLangInst = CMultiLanguage::LoadLangResourceDLL( szModuleFileName )
|Node:identifier Text: ghLangInst
|Node:= Text: =
|Node:call_expression Text: CMultiLanguage::LoadLangResourceDLL( szModuleFileName )
|Node:qualified_identifier Text: CMultiLanguage::LoadLangResourceDLL
|Node:namespace_identifier Text: CMultiLanguage
|Node::: Text: ::
|Node:identifier Text: LoadLangResourceDLL
|Node:argument_list Text: ( szModuleFileName )
|Node:( Text: (
|Node:identifier Text: szModuleFileName
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (ghLangInst)
    {
        AfxSetResourceHandle( ghLangInst );
    }
|Node:if Text: if
|Node:condition_clause Text: (ghLangInst)
|Node:( Text: (
|Node:identifier Text: ghLangInst
|Node:) Text: )
|Node:compound_statement Text: {
        AfxSetResourceHandle( ghLangInst );
    }
|Node:{ Text: {
|Node:expression_statement Text: AfxSetResourceHandle( ghLangInst );
|Node:call_expression Text: AfxSetResourceHandle( ghLangInst )
|Node:identifier Text: AfxSetResourceHandle
|Node:argument_list Text: ( ghLangInst )
|Node:( Text: (
|Node:identifier Text: ghLangInst
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: CWinApp::InitInstance();
|Node:call_expression Text: CWinApp::InitInstance()
|Node:qualified_identifier Text: CWinApp::InitInstance
|Node:namespace_identifier Text: CWinApp
|Node::: Text: ::
|Node:identifier Text: InitInstance
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return TRUE;
|Node:return Text: return
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: static const BYTE FILTER_ADD = 0x01;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: FILTER_ADD = 0x01
|Node:identifier Text: FILTER_ADD
|Node:= Text: =
|Node:number_literal Text: 0x01
|Node:; Text: ;
|Node:declaration Text: static const BYTE FILTER_REMOVE = 0x02;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: FILTER_REMOVE = 0x02
|Node:identifier Text: FILTER_REMOVE
|Node:= Text: =
|Node:number_literal Text: 0x02
|Node:; Text: ;
|Node:declaration Text: static const BYTE QUEUE_ADD = 0x01;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: QUEUE_ADD = 0x01
|Node:identifier Text: QUEUE_ADD
|Node:= Text: =
|Node:number_literal Text: 0x01
|Node:; Text: ;
|Node:declaration Text: static const BYTE QUEUE_DESTROY = 0x02;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: QUEUE_DESTROY = 0x02
|Node:identifier Text: QUEUE_DESTROY
|Node:= Text: =
|Node:number_literal Text: 0x02
|Node:; Text: ;
|Node:comment Text: /**
 * Channel information
 */
|Node:type_definition Text: typedef struct tagCHANNEL
{
    OCI_URIName m_acURI; /**< URI of the Controller */
    OCI_ControllerHandle m_OCI_HwHandle; /**< Controller handle */
    OCI_CANConfiguration m_OCI_CANConfig; /**< Controller configuration */
    OCI_CANControllerProperties m_OCI_CntrlProp; /**< Controller properties */
    OCI_QueueHandle m_OCI_RxQueueHandle; /**< Controller receive queue handle */
    OCI_CANRxQueueConfiguration m_OCI_RxQueueCfg; /**< Controller receive queue configuration */
    OCI_QueueHandle m_OCI_TxQueueHandle; /**< Controller transmit queue handle */
    OCI_CANTxQueueConfiguration m_OCI_TxQueueCfg; /**< Controller transmit queue configuration */
    OCI_CANRxFilter m_OCI_FrameFilter; /**< Controller frame filter */
    OCI_CANEventFilter m_OCI_EventFilter; /**< Controller event filter */
    OCI_CANErrorFrameFilter m_OCI_ErrorFilter; /**< Controller error filter */
    OCI_InternalErrorEventFilter m_OCI_InternalErrorFilter;
    UCHAR m_ucControllerState; /**< Controller state */
    UCHAR m_ucTxErrorCounter; /**< Controller Tx error counter */
    UCHAR m_ucRxErrorCounter; /**< Controller Rx error counter */
    UCHAR m_ucPeakRxErrorCounter; /**< Controller peak Rx error counter */
    UCHAR m_ucPeakTxErrorCounter; /**< Controller peak Tx error counter */
    OCI_TimerCapabilities m_OCI_TimerCapabilities;
    FLOAT m_fResolution;
    bool m_bSupportCANFD; /**< controller capability of CAN_FD */
} SCHANNEL;
|Node:typedef Text: typedef
|Node:struct_specifier Text: struct tagCHANNEL
{
    OCI_URIName m_acURI; /**< URI of the Controller */
    OCI_ControllerHandle m_OCI_HwHandle; /**< Controller handle */
    OCI_CANConfiguration m_OCI_CANConfig; /**< Controller configuration */
    OCI_CANControllerProperties m_OCI_CntrlProp; /**< Controller properties */
    OCI_QueueHandle m_OCI_RxQueueHandle; /**< Controller receive queue handle */
    OCI_CANRxQueueConfiguration m_OCI_RxQueueCfg; /**< Controller receive queue configuration */
    OCI_QueueHandle m_OCI_TxQueueHandle; /**< Controller transmit queue handle */
    OCI_CANTxQueueConfiguration m_OCI_TxQueueCfg; /**< Controller transmit queue configuration */
    OCI_CANRxFilter m_OCI_FrameFilter; /**< Controller frame filter */
    OCI_CANEventFilter m_OCI_EventFilter; /**< Controller event filter */
    OCI_CANErrorFrameFilter m_OCI_ErrorFilter; /**< Controller error filter */
    OCI_InternalErrorEventFilter m_OCI_InternalErrorFilter;
    UCHAR m_ucControllerState; /**< Controller state */
    UCHAR m_ucTxErrorCounter; /**< Controller Tx error counter */
    UCHAR m_ucRxErrorCounter; /**< Controller Rx error counter */
    UCHAR m_ucPeakRxErrorCounter; /**< Controller peak Rx error counter */
    UCHAR m_ucPeakTxErrorCounter; /**< Controller peak Tx error counter */
    OCI_TimerCapabilities m_OCI_TimerCapabilities;
    FLOAT m_fResolution;
    bool m_bSupportCANFD; /**< controller capability of CAN_FD */
}
|Node:struct Text: struct
|Node:type_identifier Text: tagCHANNEL
|Node:field_declaration_list Text: {
    OCI_URIName m_acURI; /**< URI of the Controller */
    OCI_ControllerHandle m_OCI_HwHandle; /**< Controller handle */
    OCI_CANConfiguration m_OCI_CANConfig; /**< Controller configuration */
    OCI_CANControllerProperties m_OCI_CntrlProp; /**< Controller properties */
    OCI_QueueHandle m_OCI_RxQueueHandle; /**< Controller receive queue handle */
    OCI_CANRxQueueConfiguration m_OCI_RxQueueCfg; /**< Controller receive queue configuration */
    OCI_QueueHandle m_OCI_TxQueueHandle; /**< Controller transmit queue handle */
    OCI_CANTxQueueConfiguration m_OCI_TxQueueCfg; /**< Controller transmit queue configuration */
    OCI_CANRxFilter m_OCI_FrameFilter; /**< Controller frame filter */
    OCI_CANEventFilter m_OCI_EventFilter; /**< Controller event filter */
    OCI_CANErrorFrameFilter m_OCI_ErrorFilter; /**< Controller error filter */
    OCI_InternalErrorEventFilter m_OCI_InternalErrorFilter;
    UCHAR m_ucControllerState; /**< Controller state */
    UCHAR m_ucTxErrorCounter; /**< Controller Tx error counter */
    UCHAR m_ucRxErrorCounter; /**< Controller Rx error counter */
    UCHAR m_ucPeakRxErrorCounter; /**< Controller peak Rx error counter */
    UCHAR m_ucPeakTxErrorCounter; /**< Controller peak Tx error counter */
    OCI_TimerCapabilities m_OCI_TimerCapabilities;
    FLOAT m_fResolution;
    bool m_bSupportCANFD; /**< controller capability of CAN_FD */
}
|Node:{ Text: {
|Node:field_declaration Text: OCI_URIName m_acURI;
|Node:type_identifier Text: OCI_URIName
|Node:field_identifier Text: m_acURI
|Node:; Text: ;
|Node:comment Text: /**< URI of the Controller */
|Node:field_declaration Text: OCI_ControllerHandle m_OCI_HwHandle;
|Node:type_identifier Text: OCI_ControllerHandle
|Node:field_identifier Text: m_OCI_HwHandle
|Node:; Text: ;
|Node:comment Text: /**< Controller handle */
|Node:field_declaration Text: OCI_CANConfiguration m_OCI_CANConfig;
|Node:type_identifier Text: OCI_CANConfiguration
|Node:field_identifier Text: m_OCI_CANConfig
|Node:; Text: ;
|Node:comment Text: /**< Controller configuration */
|Node:field_declaration Text: OCI_CANControllerProperties m_OCI_CntrlProp;
|Node:type_identifier Text: OCI_CANControllerProperties
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:; Text: ;
|Node:comment Text: /**< Controller properties */
|Node:field_declaration Text: OCI_QueueHandle m_OCI_RxQueueHandle;
|Node:type_identifier Text: OCI_QueueHandle
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:; Text: ;
|Node:comment Text: /**< Controller receive queue handle */
|Node:field_declaration Text: OCI_CANRxQueueConfiguration m_OCI_RxQueueCfg;
|Node:type_identifier Text: OCI_CANRxQueueConfiguration
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:; Text: ;
|Node:comment Text: /**< Controller receive queue configuration */
|Node:field_declaration Text: OCI_QueueHandle m_OCI_TxQueueHandle;
|Node:type_identifier Text: OCI_QueueHandle
|Node:field_identifier Text: m_OCI_TxQueueHandle
|Node:; Text: ;
|Node:comment Text: /**< Controller transmit queue handle */
|Node:field_declaration Text: OCI_CANTxQueueConfiguration m_OCI_TxQueueCfg;
|Node:type_identifier Text: OCI_CANTxQueueConfiguration
|Node:field_identifier Text: m_OCI_TxQueueCfg
|Node:; Text: ;
|Node:comment Text: /**< Controller transmit queue configuration */
|Node:field_declaration Text: OCI_CANRxFilter m_OCI_FrameFilter;
|Node:type_identifier Text: OCI_CANRxFilter
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:; Text: ;
|Node:comment Text: /**< Controller frame filter */
|Node:field_declaration Text: OCI_CANEventFilter m_OCI_EventFilter;
|Node:type_identifier Text: OCI_CANEventFilter
|Node:field_identifier Text: m_OCI_EventFilter
|Node:; Text: ;
|Node:comment Text: /**< Controller event filter */
|Node:field_declaration Text: OCI_CANErrorFrameFilter m_OCI_ErrorFilter;
|Node:type_identifier Text: OCI_CANErrorFrameFilter
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:; Text: ;
|Node:comment Text: /**< Controller error filter */
|Node:field_declaration Text: OCI_InternalErrorEventFilter m_OCI_InternalErrorFilter;
|Node:type_identifier Text: OCI_InternalErrorEventFilter
|Node:field_identifier Text: m_OCI_InternalErrorFilter
|Node:; Text: ;
|Node:field_declaration Text: UCHAR m_ucControllerState;
|Node:type_identifier Text: UCHAR
|Node:field_identifier Text: m_ucControllerState
|Node:; Text: ;
|Node:comment Text: /**< Controller state */
|Node:field_declaration Text: UCHAR m_ucTxErrorCounter;
|Node:type_identifier Text: UCHAR
|Node:field_identifier Text: m_ucTxErrorCounter
|Node:; Text: ;
|Node:comment Text: /**< Controller Tx error counter */
|Node:field_declaration Text: UCHAR m_ucRxErrorCounter;
|Node:type_identifier Text: UCHAR
|Node:field_identifier Text: m_ucRxErrorCounter
|Node:; Text: ;
|Node:comment Text: /**< Controller Rx error counter */
|Node:field_declaration Text: UCHAR m_ucPeakRxErrorCounter;
|Node:type_identifier Text: UCHAR
|Node:field_identifier Text: m_ucPeakRxErrorCounter
|Node:; Text: ;
|Node:comment Text: /**< Controller peak Rx error counter */
|Node:field_declaration Text: UCHAR m_ucPeakTxErrorCounter;
|Node:type_identifier Text: UCHAR
|Node:field_identifier Text: m_ucPeakTxErrorCounter
|Node:; Text: ;
|Node:comment Text: /**< Controller peak Tx error counter */
|Node:field_declaration Text: OCI_TimerCapabilities m_OCI_TimerCapabilities;
|Node:type_identifier Text: OCI_TimerCapabilities
|Node:field_identifier Text: m_OCI_TimerCapabilities
|Node:; Text: ;
|Node:field_declaration Text: FLOAT m_fResolution;
|Node:type_identifier Text: FLOAT
|Node:field_identifier Text: m_fResolution
|Node:; Text: ;
|Node:field_declaration Text: bool m_bSupportCANFD;
|Node:primitive_type Text: bool
|Node:field_identifier Text: m_bSupportCANFD
|Node:; Text: ;
|Node:comment Text: /**< controller capability of CAN_FD */
|Node:} Text: }
|Node:type_identifier Text: SCHANNEL
|Node:; Text: ;
|Node:comment Text: /**
 * Client and Client Buffer map
 */
|Node:preproc_def Text: #define MAX_BUFF_ALLOWED 16

|Node:#define Text: #define
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:preproc_arg Text: 16
|Node:preproc_def Text: #define MAX_CLIENT_ALLOWED 16

|Node:#define Text: #define
|Node:identifier Text: MAX_CLIENT_ALLOWED
|Node:preproc_arg Text: 16
|Node:declaration Text: static UINT sg_unClientCnt = 0;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: UINT
|Node:init_declarator Text: sg_unClientCnt = 0
|Node:identifier Text: sg_unClientCnt
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:class_specifier Text: class SCLIENTBUFMAP
{
public:
    DWORD m_dwClientID;
    CBaseCANBufFSE* m_pClientBuf[MAX_BUFF_ALLOWED];
    string m_acClientName;
    UINT m_unBufCount;
    SCLIENTBUFMAP()
    {
        m_dwClientID = 0;
        m_unBufCount = 0;
        m_acClientName = "";

        for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
    }
}
|Node:class Text: class
|Node:type_identifier Text: SCLIENTBUFMAP
|Node:field_declaration_list Text: {
public:
    DWORD m_dwClientID;
    CBaseCANBufFSE* m_pClientBuf[MAX_BUFF_ALLOWED];
    string m_acClientName;
    UINT m_unBufCount;
    SCLIENTBUFMAP()
    {
        m_dwClientID = 0;
        m_unBufCount = 0;
        m_acClientName = "";

        for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
    }
}
|Node:{ Text: {
|Node:access_specifier Text: public
|Node:public Text: public
|Node:: Text: :
|Node:field_declaration Text: DWORD m_dwClientID;
|Node:type_identifier Text: DWORD
|Node:field_identifier Text: m_dwClientID
|Node:; Text: ;
|Node:field_declaration Text: CBaseCANBufFSE* m_pClientBuf[MAX_BUFF_ALLOWED];
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * m_pClientBuf[MAX_BUFF_ALLOWED]
|Node:* Text: *
|Node:array_declarator Text: m_pClientBuf[MAX_BUFF_ALLOWED]
|Node:field_identifier Text: m_pClientBuf
|Node:[ Text: [
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:] Text: ]
|Node:; Text: ;
|Node:field_declaration Text: string m_acClientName;
|Node:type_identifier Text: string
|Node:field_identifier Text: m_acClientName
|Node:; Text: ;
|Node:field_declaration Text: UINT m_unBufCount;
|Node:type_identifier Text: UINT
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:function_definition Text: SCLIENTBUFMAP()
    {
        m_dwClientID = 0;
        m_unBufCount = 0;
        m_acClientName = "";

        for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
    }
|Node:function_declarator Text: SCLIENTBUFMAP()
|Node:identifier Text: SCLIENTBUFMAP
|Node:parameter_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:compound_statement Text: {
        m_dwClientID = 0;
        m_unBufCount = 0;
        m_acClientName = "";

        for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
    }
|Node:{ Text: {
|Node:expression_statement Text: m_dwClientID = 0;
|Node:assignment_expression Text: m_dwClientID = 0
|Node:identifier Text: m_dwClientID
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: m_unBufCount = 0;
|Node:assignment_expression Text: m_unBufCount = 0
|Node:identifier Text: m_unBufCount
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: m_acClientName = "";
|Node:assignment_expression Text: m_acClientName = ""
|Node:identifier Text: m_acClientName
|Node:= Text: =
|Node:string_literal Text: ""
|Node:" Text: "
|Node:" Text: "
|Node:; Text: ;
|Node:for_statement Text: for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
        {
            m_pClientBuf[i] = NULL;
        }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: INT i = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < MAX_BUFF_ALLOWED
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
            m_pClientBuf[i] = NULL;
        }
|Node:{ Text: {
|Node:expression_statement Text: m_pClientBuf[i] = NULL;
|Node:assignment_expression Text: m_pClientBuf[i] = NULL
|Node:subscript_expression Text: m_pClientBuf[i]
|Node:identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:; Text: ;
|Node:comment Text: /**
 * Array of clients
 */
|Node:declaration Text: static vector<SCLIENTBUFMAP> sg_asClientToBufMap(MAX_CLIENT_ALLOWED);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:template_type Text: vector<SCLIENTBUFMAP>
|Node:type_identifier Text: vector
|Node:template_argument_list Text: <SCLIENTBUFMAP>
|Node:< Text: <
|Node:type_descriptor Text: SCLIENTBUFMAP
|Node:type_identifier Text: SCLIENTBUFMAP
|Node:> Text: >
|Node:function_declarator Text: sg_asClientToBufMap(MAX_CLIENT_ALLOWED)
|Node:identifier Text: sg_asClientToBufMap
|Node:parameter_list Text: (MAX_CLIENT_ALLOWED)
|Node:( Text: (
|Node:parameter_declaration Text: MAX_CLIENT_ALLOWED
|Node:type_identifier Text: MAX_CLIENT_ALLOWED
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: static const INT MAX_MAP_SIZE = 3000;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: INT
|Node:init_declarator Text: MAX_MAP_SIZE = 3000
|Node:identifier Text: MAX_MAP_SIZE
|Node:= Text: =
|Node:number_literal Text: 3000
|Node:; Text: ;
|Node:type_definition Text: typedef struct tagAckMap
{
    UINT m_MsgID;
    UINT m_ClientID;
    UINT m_Channel;

    BOOL operator == (const tagAckMap& RefObj)
    {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
} SACK_MAP;
|Node:typedef Text: typedef
|Node:struct_specifier Text: struct tagAckMap
{
    UINT m_MsgID;
    UINT m_ClientID;
    UINT m_Channel;

    BOOL operator == (const tagAckMap& RefObj)
    {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
}
|Node:struct Text: struct
|Node:type_identifier Text: tagAckMap
|Node:field_declaration_list Text: {
    UINT m_MsgID;
    UINT m_ClientID;
    UINT m_Channel;

    BOOL operator == (const tagAckMap& RefObj)
    {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
}
|Node:{ Text: {
|Node:field_declaration Text: UINT m_MsgID;
|Node:type_identifier Text: UINT
|Node:field_identifier Text: m_MsgID
|Node:; Text: ;
|Node:field_declaration Text: UINT m_ClientID;
|Node:type_identifier Text: UINT
|Node:field_identifier Text: m_ClientID
|Node:; Text: ;
|Node:field_declaration Text: UINT m_Channel;
|Node:type_identifier Text: UINT
|Node:field_identifier Text: m_Channel
|Node:; Text: ;
|Node:function_definition Text: BOOL operator == (const tagAckMap& RefObj)
    {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: operator == (const tagAckMap& RefObj)
|Node:operator_name Text: operator ==
|Node:operator Text: operator
|Node:== Text: ==
|Node:parameter_list Text: (const tagAckMap& RefObj)
|Node:( Text: (
|Node:parameter_declaration Text: const tagAckMap& RefObj
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: tagAckMap
|Node:reference_declarator Text: & RefObj
|Node:& Text: &
|Node:identifier Text: RefObj
|Node:) Text: )
|Node:compound_statement Text: {
        return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
    }
|Node:{ Text: {
|Node:return_statement Text: return ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel));
|Node:return Text: return
|Node:parenthesized_expression Text: ((m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel))
|Node:( Text: (
|Node:binary_expression Text: (m_MsgID == RefObj.m_MsgID) && (m_Channel == RefObj.m_Channel)
|Node:parenthesized_expression Text: (m_MsgID == RefObj.m_MsgID)
|Node:( Text: (
|Node:binary_expression Text: m_MsgID == RefObj.m_MsgID
|Node:identifier Text: m_MsgID
|Node:== Text: ==
|Node:field_expression Text: RefObj.m_MsgID
|Node:identifier Text: RefObj
|Node:. Text: .
|Node:field_identifier Text: m_MsgID
|Node:) Text: )
|Node:&& Text: &&
|Node:parenthesized_expression Text: (m_Channel == RefObj.m_Channel)
|Node:( Text: (
|Node:binary_expression Text: m_Channel == RefObj.m_Channel
|Node:identifier Text: m_Channel
|Node:== Text: ==
|Node:field_expression Text: RefObj.m_Channel
|Node:identifier Text: RefObj
|Node:. Text: .
|Node:field_identifier Text: m_Channel
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:type_identifier Text: SACK_MAP
|Node:; Text: ;
|Node:type_definition Text: typedef list<SACK_MAP> CACK_MAP_LIST;
|Node:typedef Text: typedef
|Node:template_type Text: list<SACK_MAP>
|Node:type_identifier Text: list
|Node:template_argument_list Text: <SACK_MAP>
|Node:< Text: <
|Node:type_descriptor Text: SACK_MAP
|Node:type_identifier Text: SACK_MAP
|Node:> Text: >
|Node:type_identifier Text: CACK_MAP_LIST
|Node:; Text: ;
|Node:declaration Text: static CACK_MAP_LIST sg_asAckMapBuf;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: CACK_MAP_LIST
|Node:identifier Text: sg_asAckMapBuf
|Node:; Text: ;
|Node:declaration Text: static  CRITICAL_SECTION sg_CritSectForAckBuf;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: CRITICAL_SECTION
|Node:identifier Text: sg_CritSectForAckBuf
|Node:; Text: ;
|Node:comment Text: // To make it thread safe
|Node:comment Text: /**
 * Channel instances
 */
|Node:declaration Text: static vector<SCHANNEL> sg_asChannel(defNO_OF_CHANNELS);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:template_type Text: vector<SCHANNEL>
|Node:type_identifier Text: vector
|Node:template_argument_list Text: <SCHANNEL>
|Node:< Text: <
|Node:type_descriptor Text: SCHANNEL
|Node:type_identifier Text: SCHANNEL
|Node:> Text: >
|Node:function_declarator Text: sg_asChannel(defNO_OF_CHANNELS)
|Node:identifier Text: sg_asChannel
|Node:parameter_list Text: (defNO_OF_CHANNELS)
|Node:( Text: (
|Node:parameter_declaration Text: defNO_OF_CHANNELS
|Node:type_identifier Text: defNO_OF_CHANNELS
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /**
 * Number of current channel selected
 */
|Node:declaration Text: static UINT sg_nNoOfChannels = 0;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: UINT
|Node:init_declarator Text: sg_nNoOfChannels = 0
|Node:identifier Text: sg_nNoOfChannels
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: static BOOL sg_bIsDriverRunning = FALSE;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: sg_bIsDriverRunning = FALSE
|Node:identifier Text: sg_bIsDriverRunning
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:declaration Text: static HWND sg_hOwnerWnd = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HWND
|Node:init_declarator Text: sg_hOwnerWnd = NULL
|Node:identifier Text: sg_hOwnerWnd
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:declaration Text: static const BYTE CREATE_MAP_TIMESTAMP = 0x1;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: CREATE_MAP_TIMESTAMP = 0x1
|Node:identifier Text: CREATE_MAP_TIMESTAMP
|Node:= Text: =
|Node:number_literal Text: 0x1
|Node:; Text: ;
|Node:declaration Text: static const BYTE CALC_TIMESTAMP_READY = 0x2;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: CALC_TIMESTAMP_READY = 0x2
|Node:identifier Text: CALC_TIMESTAMP_READY
|Node:= Text: =
|Node:number_literal Text: 0x2
|Node:; Text: ;
|Node:comment Text: /**
 * Current state machine
 */
|Node:declaration Text: static BYTE sg_byCurrState = CREATE_MAP_TIMESTAMP;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: sg_byCurrState = CREATE_MAP_TIMESTAMP
|Node:identifier Text: sg_byCurrState
|Node:= Text: =
|Node:identifier Text: CREATE_MAP_TIMESTAMP
|Node:; Text: ;
|Node:declaration Text: static HANDLE sg_hEvent = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HANDLE
|Node:init_declarator Text: sg_hEvent = NULL
|Node:identifier Text: sg_hEvent
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:declaration Text: static CRITICAL_SECTION sg_DIL_CriticalSection;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: CRITICAL_SECTION
|Node:identifier Text: sg_DIL_CriticalSection
|Node:; Text: ;
|Node:declaration Text: static INT sg_anSelectedItems[CHANNEL_ALLOWED];
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: INT
|Node:array_declarator Text: sg_anSelectedItems[CHANNEL_ALLOWED]
|Node:identifier Text: sg_anSelectedItems
|Node:[ Text: [
|Node:identifier Text: CHANNEL_ALLOWED
|Node:] Text: ]
|Node:; Text: ;
|Node:comment Text: /**
 * Timer variables
 */
|Node:declaration Text: static SYSTEMTIME sg_CurrSysTime;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: SYSTEMTIME
|Node:identifier Text: sg_CurrSysTime
|Node:; Text: ;
|Node:declaration Text: static UINT64 sg_TimeStamp = 0;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: UINT64
|Node:init_declarator Text: sg_TimeStamp = 0
|Node:identifier Text: sg_TimeStamp
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: static LARGE_INTEGER sg_QueryTickCount;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: LARGE_INTEGER
|Node:identifier Text: sg_QueryTickCount
|Node:; Text: ;
|Node:declaration Text: static LARGE_INTEGER sg_lnFrequency;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: LARGE_INTEGER
|Node:identifier Text: sg_lnFrequency
|Node:; Text: ;
|Node:comment Text: /**
 * Required libraries
 */
|Node:declaration Text: static HMODULE sg_hLibCSI = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HMODULE
|Node:init_declarator Text: sg_hLibCSI = NULL
|Node:identifier Text: sg_hLibCSI
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:declaration Text: static HMODULE sg_hLibOCI = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HMODULE
|Node:init_declarator Text: sg_hLibOCI = NULL
|Node:identifier Text: sg_hLibOCI
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:comment Text: /**
 * Declarations of CSI API pointers
 */
|Node:type_definition Text: typedef CSI_DECLSPEC OCI_ErrorCode (*PROC1)(const char* uriName, CSI_NodeRange range, CSI_Tree* *tree);
|Node:typedef Text: typedef
|Node:type_identifier Text: CSI_DECLSPEC
|Node:function_declarator Text: OCI_ErrorCode (*PROC1)(const char* uriName, CSI_NodeRange range, CSI_Tree* *tree)
|Node:function_declarator Text: OCI_ErrorCode (*PROC1)
|Node:type_identifier Text: OCI_ErrorCode
|Node:parameter_list Text: (*PROC1)
|Node:( Text: (
|Node:ERROR Text: *
|Node:* Text: *
|Node:parameter_declaration Text: PROC1
|Node:type_identifier Text: PROC1
|Node:) Text: )
|Node:parameter_list Text: (const char* uriName, CSI_NodeRange range, CSI_Tree* *tree)
|Node:( Text: (
|Node:parameter_declaration Text: const char* uriName
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:primitive_type Text: char
|Node:pointer_declarator Text: * uriName
|Node:* Text: *
|Node:identifier Text: uriName
|Node:, Text: ,
|Node:parameter_declaration Text: CSI_NodeRange range
|Node:type_identifier Text: CSI_NodeRange
|Node:identifier Text: range
|Node:, Text: ,
|Node:parameter_declaration Text: CSI_Tree* *tree
|Node:type_identifier Text: CSI_Tree
|Node:pointer_declarator Text: * *tree
|Node:* Text: *
|Node:pointer_declarator Text: *tree
|Node:* Text: *
|Node:identifier Text: tree
|Node:) Text: )
|Node:; Text: ;
|Node:type_definition Text: typedef CSI_DECLSPEC OCI_ErrorCode (*PROC2)(CSI_Tree* tree);
|Node:typedef Text: typedef
|Node:type_identifier Text: CSI_DECLSPEC
|Node:function_declarator Text: OCI_ErrorCode (*PROC2)(CSI_Tree* tree)
|Node:function_declarator Text: OCI_ErrorCode (*PROC2)
|Node:type_identifier Text: OCI_ErrorCode
|Node:parameter_list Text: (*PROC2)
|Node:( Text: (
|Node:ERROR Text: *
|Node:* Text: *
|Node:parameter_declaration Text: PROC2
|Node:type_identifier Text: PROC2
|Node:) Text: )
|Node:parameter_list Text: (CSI_Tree* tree)
|Node:( Text: (
|Node:parameter_declaration Text: CSI_Tree* tree
|Node:type_identifier Text: CSI_Tree
|Node:pointer_declarator Text: * tree
|Node:* Text: *
|Node:identifier Text: tree
|Node:) Text: )
|Node:; Text: ;
|Node:type_definition Text: typedef CSI_DECLSPEC OCI_ErrorCode (*PROC3)(CSI_Tree* tree, const BOA_UuidVersion* uuid, OCI_URIName uriName[], int size, int* count);
|Node:typedef Text: typedef
|Node:type_identifier Text: CSI_DECLSPEC
|Node:function_declarator Text: OCI_ErrorCode (*PROC3)(CSI_Tree* tree, const BOA_UuidVersion* uuid, OCI_URIName uriName[], int size, int* count)
|Node:function_declarator Text: OCI_ErrorCode (*PROC3)
|Node:type_identifier Text: OCI_ErrorCode
|Node:parameter_list Text: (*PROC3)
|Node:( Text: (
|Node:ERROR Text: *
|Node:* Text: *
|Node:parameter_declaration Text: PROC3
|Node:type_identifier Text: PROC3
|Node:) Text: )
|Node:parameter_list Text: (CSI_Tree* tree, const BOA_UuidVersion* uuid, OCI_URIName uriName[], int size, int* count)
|Node:( Text: (
|Node:parameter_declaration Text: CSI_Tree* tree
|Node:type_identifier Text: CSI_Tree
|Node:pointer_declarator Text: * tree
|Node:* Text: *
|Node:identifier Text: tree
|Node:, Text: ,
|Node:parameter_declaration Text: const BOA_UuidVersion* uuid
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BOA_UuidVersion
|Node:pointer_declarator Text: * uuid
|Node:* Text: *
|Node:identifier Text: uuid
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_URIName uriName[]
|Node:type_identifier Text: OCI_URIName
|Node:array_declarator Text: uriName[]
|Node:identifier Text: uriName
|Node:[ Text: [
|Node:] Text: ]
|Node:, Text: ,
|Node:parameter_declaration Text: int size
|Node:primitive_type Text: int
|Node:identifier Text: size
|Node:, Text: ,
|Node:parameter_declaration Text: int* count
|Node:primitive_type Text: int
|Node:pointer_declarator Text: * count
|Node:* Text: *
|Node:identifier Text: count
|Node:) Text: )
|Node:; Text: ;
|Node:type_definition Text: typedef OCI_ErrorCode (*PF_OCI_CreateCANControllerVersion)(const char* uriLocation, const BOA_Version* apiVersion, OCI_ControllerHandle* controller);
|Node:typedef Text: typedef
|Node:type_identifier Text: OCI_ErrorCode
|Node:function_declarator Text: (*PF_OCI_CreateCANControllerVersion)(const char* uriLocation, const BOA_Version* apiVersion, OCI_ControllerHandle* controller)
|Node:parenthesized_declarator Text: (*PF_OCI_CreateCANControllerVersion)
|Node:( Text: (
|Node:pointer_declarator Text: *PF_OCI_CreateCANControllerVersion
|Node:* Text: *
|Node:type_identifier Text: PF_OCI_CreateCANControllerVersion
|Node:) Text: )
|Node:parameter_list Text: (const char* uriLocation, const BOA_Version* apiVersion, OCI_ControllerHandle* controller)
|Node:( Text: (
|Node:parameter_declaration Text: const char* uriLocation
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:primitive_type Text: char
|Node:pointer_declarator Text: * uriLocation
|Node:* Text: *
|Node:identifier Text: uriLocation
|Node:, Text: ,
|Node:parameter_declaration Text: const BOA_Version* apiVersion
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: BOA_Version
|Node:pointer_declarator Text: * apiVersion
|Node:* Text: *
|Node:identifier Text: apiVersion
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_ControllerHandle* controller
|Node:type_identifier Text: OCI_ControllerHandle
|Node:pointer_declarator Text: * controller
|Node:* Text: *
|Node:identifier Text: controller
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Macro definitions */
|Node:preproc_if Text: #if BOA_VERSION == BOA_VERSION_1_4
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.4"
#define LIB_CSL_NAME    "dll-csiBind_1_4.dll"
#define LIB_OCI_NAME    "dll-ocdProxy_1_4.dll"
#elif BOA_VERSION == BOA_VERSION_1_5
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.5"
#define LIB_CSL_NAME    "dll-csiBind_1_5.dll"
#define LIB_OCI_NAME    "dll-ocdProxy_1_5.dll"
#elif BOA_VERSION == BOA_VERSION_2_0
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\2"
#define LIB_CSL_NAME    "dll-csiBind.dll"
#define LIB_OCI_NAME    "dll-ocdProxy.dll"
#else
#error "Unknown BOA version defined"
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_1_4
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_1_4
|Node:
 Text: 

|Node:preproc_def Text: #define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.4"

|Node:#define Text: #define
|Node:identifier Text: BOA_REGISTRY_LOCATION
|Node:preproc_arg Text: "SOFTWARE\\ETAS\\BOA\\1.4"
|Node:preproc_def Text: #define LIB_CSL_NAME    "dll-csiBind_1_4.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_CSL_NAME
|Node:preproc_arg Text: "dll-csiBind_1_4.dll"
|Node:preproc_def Text: #define LIB_OCI_NAME    "dll-ocdProxy_1_4.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_OCI_NAME
|Node:preproc_arg Text: "dll-ocdProxy_1_4.dll"
|Node:preproc_elif Text: #elif BOA_VERSION == BOA_VERSION_1_5
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.5"
#define LIB_CSL_NAME    "dll-csiBind_1_5.dll"
#define LIB_OCI_NAME    "dll-ocdProxy_1_5.dll"
#elif BOA_VERSION == BOA_VERSION_2_0
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\2"
#define LIB_CSL_NAME    "dll-csiBind.dll"
#define LIB_OCI_NAME    "dll-ocdProxy.dll"
#else
#error "Unknown BOA version defined"

|Node:#elif Text: #elif
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_1_5
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_1_5
|Node:
 Text: 

|Node:preproc_def Text: #define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\1.5"

|Node:#define Text: #define
|Node:identifier Text: BOA_REGISTRY_LOCATION
|Node:preproc_arg Text: "SOFTWARE\\ETAS\\BOA\\1.5"
|Node:preproc_def Text: #define LIB_CSL_NAME    "dll-csiBind_1_5.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_CSL_NAME
|Node:preproc_arg Text: "dll-csiBind_1_5.dll"
|Node:preproc_def Text: #define LIB_OCI_NAME    "dll-ocdProxy_1_5.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_OCI_NAME
|Node:preproc_arg Text: "dll-ocdProxy_1_5.dll"
|Node:preproc_elif Text: #elif BOA_VERSION == BOA_VERSION_2_0
#define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\2"
#define LIB_CSL_NAME    "dll-csiBind.dll"
#define LIB_OCI_NAME    "dll-ocdProxy.dll"
#else
#error "Unknown BOA version defined"

|Node:#elif Text: #elif
|Node:binary_expression Text: BOA_VERSION == BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:== Text: ==
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:preproc_def Text: #define BOA_REGISTRY_LOCATION "SOFTWARE\\ETAS\\BOA\\2"

|Node:#define Text: #define
|Node:identifier Text: BOA_REGISTRY_LOCATION
|Node:preproc_arg Text: "SOFTWARE\\ETAS\\BOA\\2"
|Node:preproc_def Text: #define LIB_CSL_NAME    "dll-csiBind.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_CSL_NAME
|Node:preproc_arg Text: "dll-csiBind.dll"
|Node:preproc_def Text: #define LIB_OCI_NAME    "dll-ocdProxy.dll"

|Node:#define Text: #define
|Node:identifier Text: LIB_OCI_NAME
|Node:preproc_arg Text: "dll-ocdProxy.dll"
|Node:preproc_else Text: #else
#error "Unknown BOA version defined"

|Node:#else Text: #else
|Node:preproc_call Text: #error "Unknown BOA version defined"

|Node:preproc_directive Text: #error
|Node:preproc_arg Text: "Unknown BOA version defined"
|Node:#endif Text: #endif
|Node:comment Text: /**
 * CSI pointers table
 */
|Node:type_definition Text: typedef struct tagCSI_VTABLE
{
    PROC1 createProtocolTree;
    PROC2 destroyProtocolTree;
    PROC3 getUriForUuid;
} CSI_VTABLE;
|Node:typedef Text: typedef
|Node:struct_specifier Text: struct tagCSI_VTABLE
{
    PROC1 createProtocolTree;
    PROC2 destroyProtocolTree;
    PROC3 getUriForUuid;
}
|Node:struct Text: struct
|Node:type_identifier Text: tagCSI_VTABLE
|Node:field_declaration_list Text: {
    PROC1 createProtocolTree;
    PROC2 destroyProtocolTree;
    PROC3 getUriForUuid;
}
|Node:{ Text: {
|Node:field_declaration Text: PROC1 createProtocolTree;
|Node:type_identifier Text: PROC1
|Node:field_identifier Text: createProtocolTree
|Node:; Text: ;
|Node:field_declaration Text: PROC2 destroyProtocolTree;
|Node:type_identifier Text: PROC2
|Node:field_identifier Text: destroyProtocolTree
|Node:; Text: ;
|Node:field_declaration Text: PROC3 getUriForUuid;
|Node:type_identifier Text: PROC3
|Node:field_identifier Text: getUriForUuid
|Node:; Text: ;
|Node:} Text: }
|Node:type_identifier Text: CSI_VTABLE
|Node:; Text: ;
|Node:comment Text: /**
 * Complete pointers of OCI, OCI CAN, CSI
 */
|Node:type_definition Text: typedef struct tagBOA_POINTER_TABLE
{
    CSI_VTABLE       m_sCSI;
    OCI_CAN_VTable   m_sOCI;
#if BOA_VERSION >= BOA_VERSION_2_0
    PF_OCI_CreateCANControllerVersion createCANController;
#endif
} SBOA_POINTER_TABLE;
|Node:typedef Text: typedef
|Node:struct_specifier Text: struct tagBOA_POINTER_TABLE
{
    CSI_VTABLE       m_sCSI;
    OCI_CAN_VTable   m_sOCI;
#if BOA_VERSION >= BOA_VERSION_2_0
    PF_OCI_CreateCANControllerVersion createCANController;
#endif
}
|Node:struct Text: struct
|Node:type_identifier Text: tagBOA_POINTER_TABLE
|Node:field_declaration_list Text: {
    CSI_VTABLE       m_sCSI;
    OCI_CAN_VTable   m_sOCI;
#if BOA_VERSION >= BOA_VERSION_2_0
    PF_OCI_CreateCANControllerVersion createCANController;
#endif
}
|Node:{ Text: {
|Node:field_declaration Text: CSI_VTABLE       m_sCSI;
|Node:type_identifier Text: CSI_VTABLE
|Node:field_identifier Text: m_sCSI
|Node:; Text: ;
|Node:field_declaration Text: OCI_CAN_VTable   m_sOCI;
|Node:type_identifier Text: OCI_CAN_VTable
|Node:field_identifier Text: m_sOCI
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
    PF_OCI_CreateCANControllerVersion createCANController;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:field_declaration Text: PF_OCI_CreateCANControllerVersion createCANController;
|Node:type_identifier Text: PF_OCI_CreateCANControllerVersion
|Node:field_identifier Text: createCANController
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:} Text: }
|Node:type_identifier Text: SBOA_POINTER_TABLE
|Node:; Text: ;
|Node:declaration Text: static SBOA_POINTER_TABLE sBOA_PTRS;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: SBOA_POINTER_TABLE
|Node:identifier Text: sBOA_PTRS
|Node:; Text: ;
|Node:comment Text: /**
 * Starts code for the state machine
 */
|Node:enum_specifier Text: enum
{
    STATE_DRIVER_SELECTED    = 0x0,
    STATE_HW_INTERFACE_LISTED,
    STATE_HW_INTERFACE_SELECTED,
    STATE_CONNECTED
}
|Node:enum Text: enum
|Node:enumerator_list Text: {
    STATE_DRIVER_SELECTED    = 0x0,
    STATE_HW_INTERFACE_LISTED,
    STATE_HW_INTERFACE_SELECTED,
    STATE_CONNECTED
}
|Node:{ Text: {
|Node:enumerator Text: STATE_DRIVER_SELECTED    = 0x0
|Node:identifier Text: STATE_DRIVER_SELECTED
|Node:= Text: =
|Node:number_literal Text: 0x0
|Node:, Text: ,
|Node:enumerator Text: STATE_HW_INTERFACE_LISTED
|Node:identifier Text: STATE_HW_INTERFACE_LISTED
|Node:, Text: ,
|Node:enumerator Text: STATE_HW_INTERFACE_SELECTED
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:, Text: ,
|Node:enumerator Text: STATE_CONNECTED
|Node:identifier Text: STATE_CONNECTED
|Node:} Text: }
|Node:; Text: ;
|Node:declaration Text: static BYTE sg_bCurrState = STATE_DRIVER_SELECTED;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BYTE
|Node:init_declarator Text: sg_bCurrState = STATE_DRIVER_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_DRIVER_SELECTED
|Node:; Text: ;
|Node:comment Text: /* CDIL_CAN_ETAS_BOA class definition */
|Node:class_specifier Text: class CDIL_CAN_ETAS_BOA : public CBaseDIL_CAN_Controller
{
public:
    /* overloaded functions */
    HRESULT CAN_PerformInitOperations(void);
    HRESULT CAN_PerformClosureOperations(void);
    HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
    HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
    HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
    HRESULT CAN_DeselectHwInterface(void);
    HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
    HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
    HRESULT CAN_StartHardware(void);
    HRESULT CAN_StopHardware(void);
    HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
    HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
    HRESULT CAN_GetLastErrorString(string& acErrorStr);
    HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
    HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
    HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
    HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
    HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
    HRESULT CAN_LoadDriverLibrary(void);
    HRESULT CAN_UnloadDriverLibrary(void);
}
|Node:class Text: class
|Node:type_identifier Text: CDIL_CAN_ETAS_BOA
|Node:base_class_clause Text: : public CBaseDIL_CAN_Controller
|Node:: Text: :
|Node:access_specifier Text: public
|Node:public Text: public
|Node:type_identifier Text: CBaseDIL_CAN_Controller
|Node:field_declaration_list Text: {
public:
    /* overloaded functions */
    HRESULT CAN_PerformInitOperations(void);
    HRESULT CAN_PerformClosureOperations(void);
    HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
    HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
    HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
    HRESULT CAN_DeselectHwInterface(void);
    HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
    HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
    HRESULT CAN_StartHardware(void);
    HRESULT CAN_StopHardware(void);
    HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
    HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
    HRESULT CAN_GetLastErrorString(string& acErrorStr);
    HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
    HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);
    HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
    HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
    HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
    HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
    HRESULT CAN_LoadDriverLibrary(void);
    HRESULT CAN_UnloadDriverLibrary(void);
}
|Node:{ Text: {
|Node:access_specifier Text: public
|Node:public Text: public
|Node:: Text: :
|Node:comment Text: /* overloaded functions */
|Node:field_declaration Text: HRESULT CAN_PerformInitOperations(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_PerformInitOperations(void)
|Node:field_identifier Text: CAN_PerformInitOperations
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_PerformClosureOperations(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_PerformClosureOperations(void)
|Node:field_identifier Text: CAN_PerformClosureOperations
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL)
|Node:field_identifier Text: CAN_GetTimeModeMapping
|Node:parameter_list Text: (SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount = NULL)
|Node:( Text: (
|Node:parameter_declaration Text: SYSTEMTIME& CurrSysTime
|Node:type_identifier Text: SYSTEMTIME
|Node:reference_declarator Text: & CurrSysTime
|Node:& Text: &
|Node:identifier Text: CurrSysTime
|Node:, Text: ,
|Node:parameter_declaration Text: UINT64& TimeStamp
|Node:type_identifier Text: UINT64
|Node:reference_declarator Text: & TimeStamp
|Node:& Text: &
|Node:identifier Text: TimeStamp
|Node:, Text: ,
|Node:optional_parameter_declaration Text: LARGE_INTEGER* QueryTickCount = NULL
|Node:type_identifier Text: LARGE_INTEGER
|Node:pointer_declarator Text: * QueryTickCount
|Node:* Text: *
|Node:identifier Text: QueryTickCount
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_ListHwInterfaces(INTERFACE_HW_LIST& sSelHwInterface, INT& nCount)
|Node:field_identifier Text: CAN_ListHwInterfaces
|Node:parameter_list Text: (INTERFACE_HW_LIST& sSelHwInterface, INT& nCount)
|Node:( Text: (
|Node:parameter_declaration Text: INTERFACE_HW_LIST& sSelHwInterface
|Node:type_identifier Text: INTERFACE_HW_LIST
|Node:reference_declarator Text: & sSelHwInterface
|Node:& Text: &
|Node:identifier Text: sSelHwInterface
|Node:, Text: ,
|Node:parameter_declaration Text: INT& nCount
|Node:type_identifier Text: INT
|Node:reference_declarator Text: & nCount
|Node:& Text: &
|Node:identifier Text: nCount
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_SelectHwInterface(const INTERFACE_HW_LIST& sSelHwInterface, INT nCount)
|Node:field_identifier Text: CAN_SelectHwInterface
|Node:parameter_list Text: (const INTERFACE_HW_LIST& sSelHwInterface, INT nCount)
|Node:( Text: (
|Node:parameter_declaration Text: const INTERFACE_HW_LIST& sSelHwInterface
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: INTERFACE_HW_LIST
|Node:reference_declarator Text: & sSelHwInterface
|Node:& Text: &
|Node:identifier Text: sSelHwInterface
|Node:, Text: ,
|Node:parameter_declaration Text: INT nCount
|Node:type_identifier Text: INT
|Node:identifier Text: nCount
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_DeselectHwInterface(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_DeselectHwInterface(void)
|Node:field_identifier Text: CAN_DeselectHwInterface
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
|Node:field_identifier Text: CAN_DisplayConfigDlg
|Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int& Length)
|Node:( Text: (
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: InitData
|Node:, Text: ,
|Node:parameter_declaration Text: int& Length
|Node:primitive_type Text: int
|Node:reference_declarator Text: & Length
|Node:& Text: &
|Node:identifier Text: Length
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_SetConfigData(PSCONTROLLER_DETAILS InitData, int Length)
|Node:field_identifier Text: CAN_SetConfigData
|Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int Length)
|Node:( Text: (
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: InitData
|Node:, Text: ,
|Node:parameter_declaration Text: int Length
|Node:primitive_type Text: int
|Node:identifier Text: Length
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_StartHardware(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_StartHardware(void)
|Node:field_identifier Text: CAN_StartHardware
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_StopHardware(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_StopHardware(void)
|Node:field_identifier Text: CAN_StopHardware
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetCurrStatus(s_STATUSMSG& StatusData);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetCurrStatus(s_STATUSMSG& StatusData)
|Node:field_identifier Text: CAN_GetCurrStatus
|Node:parameter_list Text: (s_STATUSMSG& StatusData)
|Node:( Text: (
|Node:parameter_declaration Text: s_STATUSMSG& StatusData
|Node:type_identifier Text: s_STATUSMSG
|Node:reference_declarator Text: & StatusData
|Node:& Text: &
|Node:identifier Text: StatusData
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|Node:field_identifier Text: CAN_SendMsg
|Node:parameter_list Text: (DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|Node:( Text: (
|Node:parameter_declaration Text: DWORD dwClientID
|Node:type_identifier Text: DWORD
|Node:identifier Text: dwClientID
|Node:, Text: ,
|Node:parameter_declaration Text: const STCAN_MSG& sCanTxMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: STCAN_MSG
|Node:reference_declarator Text: & sCanTxMsg
|Node:& Text: &
|Node:identifier Text: sCanTxMsg
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetLastErrorString(string& acErrorStr);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetLastErrorString(string& acErrorStr)
|Node:field_identifier Text: CAN_GetLastErrorString
|Node:parameter_list Text: (string& acErrorStr)
|Node:( Text: (
|Node:parameter_declaration Text: string& acErrorStr
|Node:type_identifier Text: string
|Node:reference_declarator Text: & acErrorStr
|Node:& Text: &
|Node:identifier Text: acErrorStr
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:field_identifier Text: CAN_GetControllerParams
|Node:parameter_list Text: (LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:( Text: (
|Node:parameter_declaration Text: LONG& lParam
|Node:type_identifier Text: LONG
|Node:reference_declarator Text: & lParam
|Node:& Text: &
|Node:identifier Text: lParam
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrParam
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
|Node:field_identifier Text: CAN_SetControllerParams
|Node:parameter_list Text: (int nValue, ECONTR_PARAM eContrparam)
|Node:( Text: (
|Node:parameter_declaration Text: int nValue
|Node:primitive_type Text: int
|Node:identifier Text: nValue
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrparam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrparam
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:field_identifier Text: CAN_GetErrorCount
|Node:parameter_list Text: (SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:( Text: (
|Node:parameter_declaration Text: SERROR_CNT& sErrorCnt
|Node:type_identifier Text: SERROR_CNT
|Node:reference_declarator Text: & sErrorCnt
|Node:& Text: &
|Node:identifier Text: sErrorCnt
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrParam
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|Node:field_identifier Text: CAN_SetAppParams
|Node:parameter_list Text: (HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|Node:( Text: (
|Node:parameter_declaration Text: HWND hWndOwner
|Node:type_identifier Text: HWND
|Node:identifier Text: hWndOwner
|Node:, Text: ,
|Node:parameter_declaration Text: Base_WrapperErrorLogger* pILog
|Node:type_identifier Text: Base_WrapperErrorLogger
|Node:pointer_declarator Text: * pILog
|Node:* Text: *
|Node:identifier Text: pILog
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|Node:field_identifier Text: CAN_ManageMsgBuf
|Node:parameter_list Text: (BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|Node:( Text: (
|Node:parameter_declaration Text: BYTE bAction
|Node:type_identifier Text: BYTE
|Node:identifier Text: bAction
|Node:, Text: ,
|Node:parameter_declaration Text: DWORD ClientID
|Node:type_identifier Text: DWORD
|Node:identifier Text: ClientID
|Node:, Text: ,
|Node:parameter_declaration Text: CBaseCANBufFSE* pBufObj
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * pBufObj
|Node:* Text: *
|Node:identifier Text: pBufObj
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
|Node:field_identifier Text: CAN_RegisterClient
|Node:parameter_list Text: (BOOL bRegister, DWORD& ClientID, char* pacClientName)
|Node:( Text: (
|Node:parameter_declaration Text: BOOL bRegister
|Node:type_identifier Text: BOOL
|Node:identifier Text: bRegister
|Node:, Text: ,
|Node:parameter_declaration Text: DWORD& ClientID
|Node:type_identifier Text: DWORD
|Node:reference_declarator Text: & ClientID
|Node:& Text: &
|Node:identifier Text: ClientID
|Node:, Text: ,
|Node:parameter_declaration Text: char* pacClientName
|Node:primitive_type Text: char
|Node:pointer_declarator Text: * pacClientName
|Node:* Text: *
|Node:identifier Text: pacClientName
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_GetCntrlStatus(const HANDLE& hEvent, UINT& unCntrlStatus)
|Node:field_identifier Text: CAN_GetCntrlStatus
|Node:parameter_list Text: (const HANDLE& hEvent, UINT& unCntrlStatus)
|Node:( Text: (
|Node:parameter_declaration Text: const HANDLE& hEvent
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: HANDLE
|Node:reference_declarator Text: & hEvent
|Node:& Text: &
|Node:identifier Text: hEvent
|Node:, Text: ,
|Node:parameter_declaration Text: UINT& unCntrlStatus
|Node:type_identifier Text: UINT
|Node:reference_declarator Text: & unCntrlStatus
|Node:& Text: &
|Node:identifier Text: unCntrlStatus
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_LoadDriverLibrary(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_LoadDriverLibrary(void)
|Node:field_identifier Text: CAN_LoadDriverLibrary
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:field_declaration Text: HRESULT CAN_UnloadDriverLibrary(void);
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CAN_UnloadDriverLibrary(void)
|Node:field_identifier Text: CAN_UnloadDriverLibrary
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:; Text: ;
|Node:declaration Text: static CDIL_CAN_ETAS_BOA* sg_pouDIL_CAN_ETAS_BOA = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: CDIL_CAN_ETAS_BOA
|Node:init_declarator Text: * sg_pouDIL_CAN_ETAS_BOA = NULL
|Node:pointer_declarator Text: * sg_pouDIL_CAN_ETAS_BOA
|Node:* Text: *
|Node:identifier Text: sg_pouDIL_CAN_ETAS_BOA
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:function_definition Text: USAGEMODE HRESULT GetIDIL_CAN_Controller(void** ppvInterface)
{
    HRESULT hResult = S_OK;
    if ( NULL == sg_pouDIL_CAN_ETAS_BOA )
    {
        if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    *ppvInterface = (void*) sg_pouDIL_CAN_ETAS_BOA; // Doesn't matter even if sg_pouDIL_CAN_Kvaser is null

    return hResult;
}
|Node:type_identifier Text: USAGEMODE
|Node:ERROR Text: HRESULT
|Node:identifier Text: HRESULT
|Node:function_declarator Text: GetIDIL_CAN_Controller(void** ppvInterface)
|Node:identifier Text: GetIDIL_CAN_Controller
|Node:parameter_list Text: (void** ppvInterface)
|Node:( Text: (
|Node:parameter_declaration Text: void** ppvInterface
|Node:primitive_type Text: void
|Node:pointer_declarator Text: ** ppvInterface
|Node:* Text: *
|Node:pointer_declarator Text: * ppvInterface
|Node:* Text: *
|Node:identifier Text: ppvInterface
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ( NULL == sg_pouDIL_CAN_ETAS_BOA )
    {
        if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    *ppvInterface = (void*) sg_pouDIL_CAN_ETAS_BOA; // Doesn't matter even if sg_pouDIL_CAN_Kvaser is null

    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:if_statement Text: if ( NULL == sg_pouDIL_CAN_ETAS_BOA )
    {
        if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: ( NULL == sg_pouDIL_CAN_ETAS_BOA )
|Node:( Text: (
|Node:binary_expression Text: NULL == sg_pouDIL_CAN_ETAS_BOA
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:== Text: ==
|Node:identifier Text: sg_pouDIL_CAN_ETAS_BOA
|Node:) Text: )
|Node:compound_statement Text: {
        if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA) == NULL
|Node:parenthesized_expression Text: (sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA)
|Node:( Text: (
|Node:assignment_expression Text: sg_pouDIL_CAN_ETAS_BOA = new CDIL_CAN_ETAS_BOA
|Node:identifier Text: sg_pouDIL_CAN_ETAS_BOA
|Node:= Text: =
|Node:new_expression Text: new CDIL_CAN_ETAS_BOA
|Node:new Text: new
|Node:type_identifier Text: CDIL_CAN_ETAS_BOA
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:expression_statement Text: *ppvInterface = (void*) sg_pouDIL_CAN_ETAS_BOA;
|Node:assignment_expression Text: *ppvInterface = (void*) sg_pouDIL_CAN_ETAS_BOA
|Node:pointer_expression Text: *ppvInterface
|Node:* Text: *
|Node:identifier Text: ppvInterface
|Node:= Text: =
|Node:cast_expression Text: (void*) sg_pouDIL_CAN_ETAS_BOA
|Node:( Text: (
|Node:type_descriptor Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:identifier Text: sg_pouDIL_CAN_ETAS_BOA
|Node:; Text: ;
|Node:comment Text: // Doesn't matter even if sg_pouDIL_CAN_Kvaser is null
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Error logger
 */
|Node:declaration Text: static Base_WrapperErrorLogger* sg_pIlog   = NULL;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: Base_WrapperErrorLogger
|Node:init_declarator Text: * sg_pIlog   = NULL
|Node:pointer_declarator Text: * sg_pIlog
|Node:* Text: *
|Node:identifier Text: sg_pIlog
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:comment Text: /**
 * Declarations of ProcessCanData. This is a call back function
 * which will be called by BOA framework whenever there is a msg
 */
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg);
#else
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg);
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessCanData)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessCanData
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessCanData
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:preproc_else Text: #else
static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg);
|Node:#else Text: #else
|Node:declaration Text: static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessCanData)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessCanData
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessCanData
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:comment Text: /**
 * Declarations of ProcessEvents. This is a call back function
 * which will be called by BOA framework whenever there are internal events
 */
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg);
#else
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg);
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessEvents)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessEvents
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessEvents
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:preproc_else Text: #else
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg);
|Node:#else Text: #else
|Node:declaration Text: static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg);
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessEvents)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessEvents
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessEvents
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:comment Text: /**
 * CallBack function used by the qsort Function
 */
|Node:function_definition Text: static INT nCallBackStrCompareFn( const void* str1, const void* str2)
{
    return( strcmp((char*)str1,(char*)str2) );
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: INT
|Node:function_declarator Text: nCallBackStrCompareFn( const void* str1, const void* str2)
|Node:identifier Text: nCallBackStrCompareFn
|Node:parameter_list Text: ( const void* str1, const void* str2)
|Node:( Text: (
|Node:parameter_declaration Text: const void* str1
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * str1
|Node:* Text: *
|Node:identifier Text: str1
|Node:, Text: ,
|Node:parameter_declaration Text: const void* str2
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * str2
|Node:* Text: *
|Node:identifier Text: str2
|Node:) Text: )
|Node:compound_statement Text: {
    return( strcmp((char*)str1,(char*)str2) );
}
|Node:{ Text: {
|Node:return_statement Text: return( strcmp((char*)str1,(char*)str2) );
|Node:return Text: return
|Node:parenthesized_expression Text: ( strcmp((char*)str1,(char*)str2) )
|Node:( Text: (
|Node:call_expression Text: strcmp((char*)str1,(char*)str2)
|Node:identifier Text: strcmp
|Node:argument_list Text: ((char*)str1,(char*)str2)
|Node:( Text: (
|Node:cast_expression Text: (char*)str1
|Node:( Text: (
|Node:type_descriptor Text: char*
|Node:primitive_type Text: char
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:identifier Text: str1
|Node:, Text: ,
|Node:cast_expression Text: (char*)str2
|Node:( Text: (
|Node:type_descriptor Text: char*
|Node:primitive_type Text: char
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:identifier Text: str2
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: static BOOL bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
{
    BOOL bExist = FALSE;
    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
    {
        if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
    }
    return bExist;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bIsBufferExists(const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|Node:identifier Text: bIsBufferExists
|Node:parameter_list Text: (const SCLIENTBUFMAP& sClientObj, const CBaseCANBufFSE* pBuf)
|Node:( Text: (
|Node:parameter_declaration Text: const SCLIENTBUFMAP& sClientObj
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: SCLIENTBUFMAP
|Node:reference_declarator Text: & sClientObj
|Node:& Text: &
|Node:identifier Text: sClientObj
|Node:, Text: ,
|Node:parameter_declaration Text: const CBaseCANBufFSE* pBuf
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * pBuf
|Node:* Text: *
|Node:identifier Text: pBuf
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bExist = FALSE;
    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
    {
        if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
    }
    return bExist;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bExist = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bExist = FALSE
|Node:identifier Text: bExist
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
    {
        if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sClientObj.m_unBufCount
|Node:identifier Text: i
|Node:< Text: <
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (pBuf == sClientObj.m_pClientBuf[i])
        {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
|Node:if Text: if
|Node:condition_clause Text: (pBuf == sClientObj.m_pClientBuf[i])
|Node:( Text: (
|Node:binary_expression Text: pBuf == sClientObj.m_pClientBuf[i]
|Node:identifier Text: pBuf
|Node:== Text: ==
|Node:subscript_expression Text: sClientObj.m_pClientBuf[i]
|Node:field_expression Text: sClientObj.m_pClientBuf
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:) Text: )
|Node:compound_statement Text: {
            bExist = TRUE;
            i = sClientObj.m_unBufCount; // break the loop
        }
|Node:{ Text: {
|Node:expression_statement Text: bExist = TRUE;
|Node:assignment_expression Text: bExist = TRUE
|Node:identifier Text: bExist
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:expression_statement Text: i = sClientObj.m_unBufCount;
|Node:assignment_expression Text: i = sClientObj.m_unBufCount
|Node:identifier Text: i
|Node:= Text: =
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:comment Text: // break the loop
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return bExist;
|Node:return Text: return
|Node:identifier Text: bExist
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: static BOOL bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
{
    BOOL bReturn = TRUE;
    for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
    return bReturn;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bRemoveClientBuffer(CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|Node:identifier Text: bRemoveClientBuffer
|Node:parameter_list Text: (CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED], UINT& unCount, CBaseCANBufFSE* BufferToRemove)
|Node:( Text: (
|Node:parameter_declaration Text: CBaseCANBufFSE* RootBufferArray[MAX_BUFF_ALLOWED]
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * RootBufferArray[MAX_BUFF_ALLOWED]
|Node:* Text: *
|Node:array_declarator Text: RootBufferArray[MAX_BUFF_ALLOWED]
|Node:identifier Text: RootBufferArray
|Node:[ Text: [
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:] Text: ]
|Node:, Text: ,
|Node:parameter_declaration Text: UINT& unCount
|Node:type_identifier Text: UINT
|Node:reference_declarator Text: & unCount
|Node:& Text: &
|Node:identifier Text: unCount
|Node:, Text: ,
|Node:parameter_declaration Text: CBaseCANBufFSE* BufferToRemove
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * BufferToRemove
|Node:* Text: *
|Node:identifier Text: BufferToRemove
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bReturn = TRUE;
    for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
    return bReturn;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bReturn = TRUE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bReturn = TRUE
|Node:identifier Text: bReturn
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < unCount; i++)
    {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < unCount
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: unCount
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (RootBufferArray[i] == BufferToRemove)
        {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
|Node:if Text: if
|Node:condition_clause Text: (RootBufferArray[i] == BufferToRemove)
|Node:( Text: (
|Node:binary_expression Text: RootBufferArray[i] == BufferToRemove
|Node:subscript_expression Text: RootBufferArray[i]
|Node:identifier Text: RootBufferArray
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:== Text: ==
|Node:identifier Text: BufferToRemove
|Node:) Text: )
|Node:compound_statement Text: {
            if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
            unCount--;
        }
|Node:{ Text: {
|Node:if_statement Text: if (i < (unCount - 1)) // If not the last bufffer
            {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
|Node:if Text: if
|Node:condition_clause Text: (i < (unCount - 1))
|Node:( Text: (
|Node:binary_expression Text: i < (unCount - 1)
|Node:identifier Text: i
|Node:< Text: <
|Node:parenthesized_expression Text: (unCount - 1)
|Node:( Text: (
|Node:binary_expression Text: unCount - 1
|Node:identifier Text: unCount
|Node:- Text: -
|Node:number_literal Text: 1
|Node:) Text: )
|Node:) Text: )
|Node:comment Text: // If not the last bufffer
|Node:compound_statement Text: {
                RootBufferArray[i] = RootBufferArray[unCount - 1];
            }
|Node:{ Text: {
|Node:expression_statement Text: RootBufferArray[i] = RootBufferArray[unCount - 1];
|Node:assignment_expression Text: RootBufferArray[i] = RootBufferArray[unCount - 1]
|Node:subscript_expression Text: RootBufferArray[i]
|Node:identifier Text: RootBufferArray
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:subscript_expression Text: RootBufferArray[unCount - 1]
|Node:identifier Text: RootBufferArray
|Node:subscript_argument_list Text: [unCount - 1]
|Node:[ Text: [
|Node:binary_expression Text: unCount - 1
|Node:identifier Text: unCount
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: unCount--;
|Node:update_expression Text: unCount--
|Node:identifier Text: unCount
|Node:-- Text: --
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return bReturn;
|Node:return Text: return
|Node:identifier Text: bReturn
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Gets the CSI API function pointer from the cslproxy.dll
 */
|Node:function_definition Text: static BOOL bGetBOAInstallationPath(string& pcPath)
{
    USES_CONVERSION;

    BOOL bResult = FALSE;
    LONG lError = 0;
    HKEY sKey;

    /* Get the installation path for BOA */
    lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey);

    /* If the registry key open successfully, get the value in "path" sub key */
    if(lError==ERROR_SUCCESS)
    {
        ULONG ulType = REG_SZ;
        BYTE acGCCPath[1024];
        DWORD dwSize = sizeof(acGCCPath);
        lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
        pcPath = A2T((char*)acGCCPath);
        RegCloseKey(sKey);
        bResult = TRUE;
    }
    return bResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bGetBOAInstallationPath(string& pcPath)
|Node:identifier Text: bGetBOAInstallationPath
|Node:parameter_list Text: (string& pcPath)
|Node:( Text: (
|Node:parameter_declaration Text: string& pcPath
|Node:type_identifier Text: string
|Node:reference_declarator Text: & pcPath
|Node:& Text: &
|Node:identifier Text: pcPath
|Node:) Text: )
|Node:compound_statement Text: {
    USES_CONVERSION;

    BOOL bResult = FALSE;
    LONG lError = 0;
    HKEY sKey;

    /* Get the installation path for BOA */
    lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey);

    /* If the registry key open successfully, get the value in "path" sub key */
    if(lError==ERROR_SUCCESS)
    {
        ULONG ulType = REG_SZ;
        BYTE acGCCPath[1024];
        DWORD dwSize = sizeof(acGCCPath);
        lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
        pcPath = A2T((char*)acGCCPath);
        RegCloseKey(sKey);
        bResult = TRUE;
    }
    return bResult;
}
|Node:{ Text: {
|Node:expression_statement Text: USES_CONVERSION;
|Node:identifier Text: USES_CONVERSION
|Node:; Text: ;
|Node:declaration Text: BOOL bResult = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bResult = FALSE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:declaration Text: LONG lError = 0;
|Node:type_identifier Text: LONG
|Node:init_declarator Text: lError = 0
|Node:identifier Text: lError
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: HKEY sKey;
|Node:type_identifier Text: HKEY
|Node:identifier Text: sKey
|Node:; Text: ;
|Node:comment Text: /* Get the installation path for BOA */
|Node:expression_statement Text: lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey);
|Node:assignment_expression Text: lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey)
|Node:identifier Text: lError
|Node:= Text: =
|Node:call_expression Text: RegOpenKeyEx( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey)
|Node:identifier Text: RegOpenKeyEx
|Node:argument_list Text: ( HKEY_LOCAL_MACHINE, BOA_REGISTRY_LOCATION, 0, KEY_READ, &sKey)
|Node:( Text: (
|Node:identifier Text: HKEY_LOCAL_MACHINE
|Node:, Text: ,
|Node:identifier Text: BOA_REGISTRY_LOCATION
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:, Text: ,
|Node:identifier Text: KEY_READ
|Node:, Text: ,
|Node:pointer_expression Text: &sKey
|Node:& Text: &
|Node:identifier Text: sKey
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* If the registry key open successfully, get the value in "path" sub key */
|Node:if_statement Text: if(lError==ERROR_SUCCESS)
    {
        ULONG ulType = REG_SZ;
        BYTE acGCCPath[1024];
        DWORD dwSize = sizeof(acGCCPath);
        lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
        pcPath = A2T((char*)acGCCPath);
        RegCloseKey(sKey);
        bResult = TRUE;
    }
|Node:if Text: if
|Node:condition_clause Text: (lError==ERROR_SUCCESS)
|Node:( Text: (
|Node:binary_expression Text: lError==ERROR_SUCCESS
|Node:identifier Text: lError
|Node:== Text: ==
|Node:identifier Text: ERROR_SUCCESS
|Node:) Text: )
|Node:compound_statement Text: {
        ULONG ulType = REG_SZ;
        BYTE acGCCPath[1024];
        DWORD dwSize = sizeof(acGCCPath);
        lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
        pcPath = A2T((char*)acGCCPath);
        RegCloseKey(sKey);
        bResult = TRUE;
    }
|Node:{ Text: {
|Node:declaration Text: ULONG ulType = REG_SZ;
|Node:type_identifier Text: ULONG
|Node:init_declarator Text: ulType = REG_SZ
|Node:identifier Text: ulType
|Node:= Text: =
|Node:identifier Text: REG_SZ
|Node:; Text: ;
|Node:declaration Text: BYTE acGCCPath[1024];
|Node:type_identifier Text: BYTE
|Node:array_declarator Text: acGCCPath[1024]
|Node:identifier Text: acGCCPath
|Node:[ Text: [
|Node:number_literal Text: 1024
|Node:] Text: ]
|Node:; Text: ;
|Node:declaration Text: DWORD dwSize = sizeof(acGCCPath);
|Node:type_identifier Text: DWORD
|Node:init_declarator Text: dwSize = sizeof(acGCCPath)
|Node:identifier Text: dwSize
|Node:= Text: =
|Node:sizeof_expression Text: sizeof(acGCCPath)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (acGCCPath)
|Node:( Text: (
|Node:identifier Text: acGCCPath
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize);
|Node:assignment_expression Text: lError = RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize)
|Node:identifier Text: lError
|Node:= Text: =
|Node:call_expression Text: RegQueryValueEx(sKey, "path", 0, &ulType, acGCCPath, &dwSize)
|Node:identifier Text: RegQueryValueEx
|Node:argument_list Text: (sKey, "path", 0, &ulType, acGCCPath, &dwSize)
|Node:( Text: (
|Node:identifier Text: sKey
|Node:, Text: ,
|Node:string_literal Text: "path"
|Node:" Text: "
|Node:string_content Text: path
|Node:" Text: "
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:, Text: ,
|Node:pointer_expression Text: &ulType
|Node:& Text: &
|Node:identifier Text: ulType
|Node:, Text: ,
|Node:identifier Text: acGCCPath
|Node:, Text: ,
|Node:pointer_expression Text: &dwSize
|Node:& Text: &
|Node:identifier Text: dwSize
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: pcPath = A2T((char*)acGCCPath);
|Node:assignment_expression Text: pcPath = A2T((char*)acGCCPath)
|Node:identifier Text: pcPath
|Node:= Text: =
|Node:call_expression Text: A2T((char*)acGCCPath)
|Node:identifier Text: A2T
|Node:argument_list Text: ((char*)acGCCPath)
|Node:( Text: (
|Node:cast_expression Text: (char*)acGCCPath
|Node:( Text: (
|Node:type_descriptor Text: char*
|Node:primitive_type Text: char
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:identifier Text: acGCCPath
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: RegCloseKey(sKey);
|Node:call_expression Text: RegCloseKey(sKey)
|Node:identifier Text: RegCloseKey
|Node:argument_list Text: (sKey)
|Node:( Text: (
|Node:identifier Text: sKey
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: bResult = TRUE;
|Node:assignment_expression Text: bResult = TRUE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return bResult;
|Node:return Text: return
|Node:identifier Text: bResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Gets the CSI API function pointer from the cslproxy.dll
 */
|Node:function_definition Text: static HRESULT GetCSI_API_Pointers(HMODULE hLibCSI)
{
    HRESULT hResult = S_OK;
    if (hLibCSI != NULL)
    {
        if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: GetCSI_API_Pointers(HMODULE hLibCSI)
|Node:identifier Text: GetCSI_API_Pointers
|Node:parameter_list Text: (HMODULE hLibCSI)
|Node:( Text: (
|Node:parameter_declaration Text: HMODULE hLibCSI
|Node:type_identifier Text: HMODULE
|Node:identifier Text: hLibCSI
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if (hLibCSI != NULL)
    {
        if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:if_statement Text: if (hLibCSI != NULL)
    {
        if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (hLibCSI != NULL)
|Node:( Text: (
|Node:binary_expression Text: hLibCSI != NULL
|Node:identifier Text: hLibCSI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sCSI.createProtocolTree        = (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")
|Node:field_expression Text: sBOA_PTRS.m_sCSI.createProtocolTree
|Node:field_expression Text: sBOA_PTRS.m_sCSI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sCSI
|Node:. Text: .
|Node:field_identifier Text: createProtocolTree
|Node:= Text: =
|Node:cast_expression Text: (PROC1)GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")
|Node:( Text: (
|Node:type_descriptor Text: PROC1
|Node:type_identifier Text: PROC1
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibCSI, "CSI_CreateProtocolTree")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibCSI, "CSI_CreateProtocolTree")
|Node:( Text: (
|Node:identifier Text: hLibCSI
|Node:, Text: ,
|Node:string_literal Text: "CSI_CreateProtocolTree"
|Node:" Text: "
|Node:string_content Text: CSI_CreateProtocolTree
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:else Text: else
|Node:if_statement Text: if ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sCSI.destroyProtocolTree  = (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")
|Node:field_expression Text: sBOA_PTRS.m_sCSI.destroyProtocolTree
|Node:field_expression Text: sBOA_PTRS.m_sCSI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sCSI
|Node:. Text: .
|Node:field_identifier Text: destroyProtocolTree
|Node:= Text: =
|Node:cast_expression Text: (PROC2)GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")
|Node:( Text: (
|Node:type_descriptor Text: PROC2
|Node:type_identifier Text: PROC2
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibCSI, "CSI_DestroyProtocolTree")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibCSI, "CSI_DestroyProtocolTree")
|Node:( Text: (
|Node:identifier Text: hLibCSI
|Node:, Text: ,
|Node:string_literal Text: "CSI_DestroyProtocolTree"
|Node:" Text: "
|Node:string_content Text: CSI_DestroyProtocolTree
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:else Text: else
|Node:if_statement Text: if ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sCSI.getUriForUuid        = (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")
|Node:field_expression Text: sBOA_PTRS.m_sCSI.getUriForUuid
|Node:field_expression Text: sBOA_PTRS.m_sCSI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sCSI
|Node:. Text: .
|Node:field_identifier Text: getUriForUuid
|Node:= Text: =
|Node:cast_expression Text: (PROC3)GetProcAddress(hLibCSI, "CSI_GetUriForUuid")
|Node:( Text: (
|Node:type_descriptor Text: PROC3
|Node:type_identifier Text: PROC3
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibCSI, "CSI_GetUriForUuid")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibCSI, "CSI_GetUriForUuid")
|Node:( Text: (
|Node:identifier Text: hLibCSI
|Node:, Text: ,
|Node:string_literal Text: "CSI_GetUriForUuid"
|Node:" Text: "
|Node:string_content Text: CSI_GetUriForUuid
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Gets the OCI API function pointer from the ocdproxy.dll
 */
|Node:function_definition Text: static HRESULT GetOCI_API_Pointers(HMODULE hLibOCI)
{
    HRESULT hResult = S_OK;
    if (hLibOCI != NULL)
    {
#if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
#if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: GetOCI_API_Pointers(HMODULE hLibOCI)
|Node:identifier Text: GetOCI_API_Pointers
|Node:parameter_list Text: (HMODULE hLibOCI)
|Node:( Text: (
|Node:parameter_declaration Text: HMODULE hLibOCI
|Node:type_identifier Text: HMODULE
|Node:identifier Text: hLibOCI
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if (hLibOCI != NULL)
    {
#if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
#if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:if_statement Text: if (hLibOCI != NULL)
    {
#if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
#if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (hLibOCI != NULL)
|Node:( Text: (
|Node:binary_expression Text: hLibOCI != NULL
|Node:identifier Text: hLibOCI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
#if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
#if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
        else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
        else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
        {
            hResult = S_FALSE;
        }
    }
|Node:{ Text: {
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
#else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:if_statement Text: if ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.createCANController  = (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")
|Node:field_expression Text: sBOA_PTRS.createCANController
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: createCANController
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_CreateCANControllerVersion)
                GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_CreateCANControllerVersion
|Node:type_identifier Text: PF_OCI_CreateCANControllerVersion
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_CreateCANControllerVersion")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_CreateCANControllerVersion")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_CreateCANControllerVersion"
|Node:" Text: "
|Node:string_content Text: OCI_CreateCANControllerVersion
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:preproc_else Text: #else
        if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:#else Text: #else
|Node:if_statement Text: if ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
        {
            hResult = S_FALSE;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.createCANController = (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.createCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: createCANController
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_CreateCANController)
                GetProcAddress(hLibOCI, "OCI_CreateCANController")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_CreateCANController
|Node:type_identifier Text: PF_OCI_CreateCANController
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_CreateCANController")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_CreateCANController")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_CreateCANController"
|Node:" Text: "
|Node:string_content Text: OCI_CreateCANController
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.destroyCANController = (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.destroyCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: destroyCANController
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_DestroyCANController)
                GetProcAddress(hLibOCI, "OCI_DestroyCANController")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_DestroyCANController
|Node:type_identifier Text: PF_OCI_DestroyCANController
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_DestroyCANController")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_DestroyCANController")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_DestroyCANController"
|Node:" Text: "
|Node:string_content Text: OCI_DestroyCANController
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.openCANController = (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.openCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: openCANController
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_OpenCANController)
                GetProcAddress(hLibOCI, "OCI_OpenCANController")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_OpenCANController
|Node:type_identifier Text: PF_OCI_OpenCANController
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_OpenCANController")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_OpenCANController")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_OpenCANController"
|Node:" Text: "
|Node:string_content Text: OCI_OpenCANController
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.closeCANController = (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.closeCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: closeCANController
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_CloseCANController)
                GetProcAddress(hLibOCI, "OCI_CloseCANController")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_CloseCANController
|Node:type_identifier Text: PF_OCI_CloseCANController
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_CloseCANController")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_CloseCANController")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_CloseCANController"
|Node:" Text: "
|Node:string_content Text: OCI_CloseCANController
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.getCANConfiguration = (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.getCANConfiguration
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: getCANConfiguration
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetCANConfiguration)
                GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetCANConfiguration
|Node:type_identifier Text: PF_OCI_GetCANConfiguration
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetCANConfiguration")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetCANConfiguration")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetCANConfiguration"
|Node:" Text: "
|Node:string_content Text: OCI_GetCANConfiguration
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.getCANControllerProperties = (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.getCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: getCANControllerProperties
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetCANControllerProperties
|Node:type_identifier Text: PF_OCI_GetCANControllerProperties
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetCANControllerProperties")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetCANControllerProperties")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetCANControllerProperties"
|Node:" Text: "
|Node:string_content Text: OCI_GetCANControllerProperties
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties = (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: setCANControllerProperties
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_SetCANControllerProperties)
                GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_SetCANControllerProperties
|Node:type_identifier Text: PF_OCI_SetCANControllerProperties
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_SetCANControllerProperties")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_SetCANControllerProperties")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_SetCANControllerProperties"
|Node:" Text: "
|Node:string_content Text: OCI_SetCANControllerProperties
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities = (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: getCANControllerCapabilities
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetCANControllerCapabilities)
                GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetCANControllerCapabilities
|Node:type_identifier Text: PF_OCI_GetCANControllerCapabilities
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetCANControllerCapabilities")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetCANControllerCapabilities")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetCANControllerCapabilities"
|Node:" Text: "
|Node:string_content Text: OCI_GetCANControllerCapabilities
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus = (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.getCANControllerStatus
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: getCANControllerStatus
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetCANControllerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetCANControllerStatus
|Node:type_identifier Text: PF_OCI_GetCANControllerStatus
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetCANControllerStatus")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetCANControllerStatus")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetCANControllerStatus"
|Node:" Text: "
|Node:string_content Text: OCI_GetCANControllerStatus
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue = (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: createCANTxQueue
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_CreateCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_CreateCANTxQueue
|Node:type_identifier Text: PF_OCI_CreateCANTxQueue
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_CreateCANTxQueue")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_CreateCANTxQueue")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_CreateCANTxQueue"
|Node:" Text: "
|Node:string_content Text: OCI_CreateCANTxQueue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
        {
            hResult = S_FALSE;
        }
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.writeCANDataEx = (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.writeCANDataEx
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: writeCANDataEx
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_WriteCANDataEx)
                  GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_WriteCANDataEx
|Node:type_identifier Text: PF_OCI_WriteCANDataEx
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_WriteCANDataEx")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_WriteCANDataEx")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_WriteCANDataEx"
|Node:" Text: "
|Node:string_content Text: OCI_WriteCANDataEx
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.writeCANData = (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.writeCANData
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: writeCANData
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_WriteCANData)
                  GetProcAddress(hLibOCI, "OCI_WriteCANData")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_WriteCANData
|Node:type_identifier Text: PF_OCI_WriteCANData
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_WriteCANData")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_WriteCANData")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_WriteCANData"
|Node:" Text: "
|Node:string_content Text: OCI_WriteCANData
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue = (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: destroyCANTxQueue
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_DestroyCANTxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_DestroyCANTxQueue
|Node:type_identifier Text: PF_OCI_DestroyCANTxQueue
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_DestroyCANTxQueue")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_DestroyCANTxQueue")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_DestroyCANTxQueue"
|Node:" Text: "
|Node:string_content Text: OCI_DestroyCANTxQueue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue = (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: createCANRxQueue
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_CreateCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_CreateCANRxQueue
|Node:type_identifier Text: PF_OCI_CreateCANRxQueue
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_CreateCANRxQueue")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_CreateCANRxQueue")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_CreateCANRxQueue"
|Node:" Text: "
|Node:string_content Text: OCI_CreateCANRxQueue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.readCANData = (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.readCANData
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: readCANData
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_ReadCANData)
                  GetProcAddress(hLibOCI, "OCI_ReadCANData")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_ReadCANData
|Node:type_identifier Text: PF_OCI_ReadCANData
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_ReadCANData")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_ReadCANData")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_ReadCANData"
|Node:" Text: "
|Node:string_content Text: OCI_ReadCANData
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue = (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: destroyCANRxQueue
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_DestroyCANRxQueue)
                  GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_DestroyCANRxQueue
|Node:type_identifier Text: PF_OCI_DestroyCANRxQueue
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_DestroyCANRxQueue")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_DestroyCANRxQueue")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_DestroyCANRxQueue"
|Node:" Text: "
|Node:string_content Text: OCI_DestroyCANRxQueue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter = (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANFrameFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_AddCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_AddCANFrameFilter
|Node:type_identifier Text: PF_OCI_AddCANFrameFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_AddCANFrameFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_AddCANFrameFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_AddCANFrameFilter"
|Node:" Text: "
|Node:string_content Text: OCI_AddCANFrameFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter = (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANFrameFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_RemoveCANFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_RemoveCANFrameFilter
|Node:type_identifier Text: PF_OCI_RemoveCANFrameFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_RemoveCANFrameFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_RemoveCANFrameFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_RemoveCANFrameFilter"
|Node:" Text: "
|Node:string_content Text: OCI_RemoveCANFrameFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter = (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANBusEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_AddCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_AddCANBusEventFilter
|Node:type_identifier Text: PF_OCI_AddCANBusEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_AddCANBusEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_AddCANBusEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_AddCANBusEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_AddCANBusEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter = (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANBusEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_RemoveCANBusEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_RemoveCANBusEventFilter
|Node:type_identifier Text: PF_OCI_RemoveCANBusEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_RemoveCANBusEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_RemoveCANBusEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_RemoveCANBusEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_RemoveCANBusEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter = (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANErrorFrameFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_AddCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_AddCANErrorFrameFilter
|Node:type_identifier Text: PF_OCI_AddCANErrorFrameFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_AddCANErrorFrameFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_AddCANErrorFrameFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_AddCANErrorFrameFilter"
|Node:" Text: "
|Node:string_content Text: OCI_AddCANErrorFrameFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter = (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANErrorFrameFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_RemoveCANErrorFrameFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_RemoveCANErrorFrameFilter
|Node:type_identifier Text: PF_OCI_RemoveCANErrorFrameFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_RemoveCANErrorFrameFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_RemoveCANErrorFrameFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_RemoveCANErrorFrameFilter"
|Node:" Text: "
|Node:string_content Text: OCI_RemoveCANErrorFrameFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: getTimerStatus
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetTimerStatus
|Node:type_identifier Text: PF_OCI_GetTimerStatus
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetTimerStatus")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetTimerStatus"
|Node:" Text: "
|Node:string_content Text: OCI_GetTimerStatus
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus = (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerStatus
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: getTimerStatus
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetTimerStatus)
                  GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetTimerStatus
|Node:type_identifier Text: PF_OCI_GetTimerStatus
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetTimerStatus")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetTimerStatus")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetTimerStatus"
|Node:" Text: "
|Node:string_content Text: OCI_GetTimerStatus
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities = (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: getTimerCapabilities
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetTimerCapabilities)
                  GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetTimerCapabilities
|Node:type_identifier Text: PF_OCI_GetTimerCapabilities
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetTimerCapabilities")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetTimerCapabilities")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetTimerCapabilities"
|Node:" Text: "
|Node:string_content Text: OCI_GetTimerCapabilities
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerValue = (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerValue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: getTimerValue
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetTimerValue)
                  GetProcAddress(hLibOCI, "OCI_GetTimerValue")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetTimerValue
|Node:type_identifier Text: PF_OCI_GetTimerValue
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetTimerValue")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetTimerValue")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetTimerValue"
|Node:" Text: "
|Node:string_content Text: OCI_GetTimerValue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter = (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.addTimerEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: addTimerEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_AddTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_AddTimerEventFilter
|Node:type_identifier Text: PF_OCI_AddTimerEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_AddTimerEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_AddTimerEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_AddTimerEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_AddTimerEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter = (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.removeTimerEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: removeTimerEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_RemoveTimerEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_RemoveTimerEventFilter
|Node:type_identifier Text: PF_OCI_RemoveTimerEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_RemoveTimerEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_RemoveTimerEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_RemoveTimerEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_RemoveTimerEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.errorVTable.getError = (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable.getError
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: errorVTable
|Node:. Text: .
|Node:field_identifier Text: getError
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_GetError)
                  GetProcAddress(hLibOCI, "OCI_GetError")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_GetError
|Node:type_identifier Text: PF_OCI_GetError
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_GetError")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_GetError")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_GetError"
|Node:" Text: "
|Node:string_content Text: OCI_GetError
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter = (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: errorVTable
|Node:. Text: .
|Node:field_identifier Text: addInternalErrorEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_AddInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_AddInternalErrorEventFilter
|Node:type_identifier Text: PF_OCI_AddInternalErrorEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_AddInternalErrorEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_AddInternalErrorEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_AddInternalErrorEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_AddInternalErrorEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: else if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
|Node:type_identifier Text: else
|Node:init_declarator Text: if ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
|Node:identifier Text: if
|Node:argument_list Text: ((sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL)
|Node:( Text: (
|Node:binary_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")) == NULL
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter"))
|Node:( Text: (
|Node:assignment_expression Text: sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter = (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: errorVTable
|Node:. Text: .
|Node:field_identifier Text: removeInternalErrorEventFilter
|Node:= Text: =
|Node:cast_expression Text: (PF_OCI_RemoveInternalErrorEventFilter)
                  GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")
|Node:( Text: (
|Node:type_descriptor Text: PF_OCI_RemoveInternalErrorEventFilter
|Node:type_identifier Text: PF_OCI_RemoveInternalErrorEventFilter
|Node:) Text: )
|Node:call_expression Text: GetProcAddress(hLibOCI, "OCI_RemoveInternalErrorEventFilter")
|Node:identifier Text: GetProcAddress
|Node:argument_list Text: (hLibOCI, "OCI_RemoveInternalErrorEventFilter")
|Node:( Text: (
|Node:identifier Text: hLibOCI
|Node:, Text: ,
|Node:string_literal Text: "OCI_RemoveInternalErrorEventFilter"
|Node:" Text: "
|Node:string_content Text: OCI_RemoveInternalErrorEventFilter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
            hResult = S_FALSE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Search for all connected Hardware, that supports the OCI
 * CAN interface and deliver the URI location of the hardware.
 */
|Node:function_definition Text: static void findCanNodes( CSI_Tree* sfsTree, OCI_URIName uriPrefix, OCI_URIName uriNames[], uint32 size, uint32* position )
{
    /* Uncomment the next line to get a view of the items in the tree */
    // printf( "uriPrefix is %s; node is %s\n", uriPrefix, sfsTree->item.uriNames );

    /* Basic error checking */
    if ( !sfsTree || !uriNames || !uriPrefix || !position )
    {
        return;
    }

    /*
     * Does the current tree node have the URI name which begins with "CAN:"?
     * (Each node which represents a CAN port always has a URI name of the form "CAN:n".
     */
    if( 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 ) )
    {
        if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
    }

    /* If the current tree node has a child, recurse into it */
    if (sfsTree->child)
    {
        OCI_URIName newUriPrefix;

        strcpy( newUriPrefix, uriPrefix );
        strcat( newUriPrefix, "/" );
        strcat( newUriPrefix, sfsTree->item.uriName );
        findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
    }

    /* If the current tree node has a sibling, recurse into it */
    if (sfsTree->sibling)
    {
        findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: findCanNodes( CSI_Tree* sfsTree, OCI_URIName uriPrefix, OCI_URIName uriNames[], uint32 size, uint32* position )
|Node:identifier Text: findCanNodes
|Node:parameter_list Text: ( CSI_Tree* sfsTree, OCI_URIName uriPrefix, OCI_URIName uriNames[], uint32 size, uint32* position )
|Node:( Text: (
|Node:parameter_declaration Text: CSI_Tree* sfsTree
|Node:type_identifier Text: CSI_Tree
|Node:pointer_declarator Text: * sfsTree
|Node:* Text: *
|Node:identifier Text: sfsTree
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_URIName uriPrefix
|Node:type_identifier Text: OCI_URIName
|Node:identifier Text: uriPrefix
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_URIName uriNames[]
|Node:type_identifier Text: OCI_URIName
|Node:array_declarator Text: uriNames[]
|Node:identifier Text: uriNames
|Node:[ Text: [
|Node:] Text: ]
|Node:, Text: ,
|Node:parameter_declaration Text: uint32 size
|Node:type_identifier Text: uint32
|Node:identifier Text: size
|Node:, Text: ,
|Node:parameter_declaration Text: uint32* position
|Node:type_identifier Text: uint32
|Node:pointer_declarator Text: * position
|Node:* Text: *
|Node:identifier Text: position
|Node:) Text: )
|Node:compound_statement Text: {
    /* Uncomment the next line to get a view of the items in the tree */
    // printf( "uriPrefix is %s; node is %s\n", uriPrefix, sfsTree->item.uriNames );

    /* Basic error checking */
    if ( !sfsTree || !uriNames || !uriPrefix || !position )
    {
        return;
    }

    /*
     * Does the current tree node have the URI name which begins with "CAN:"?
     * (Each node which represents a CAN port always has a URI name of the form "CAN:n".
     */
    if( 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 ) )
    {
        if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
    }

    /* If the current tree node has a child, recurse into it */
    if (sfsTree->child)
    {
        OCI_URIName newUriPrefix;

        strcpy( newUriPrefix, uriPrefix );
        strcat( newUriPrefix, "/" );
        strcat( newUriPrefix, sfsTree->item.uriName );
        findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
    }

    /* If the current tree node has a sibling, recurse into it */
    if (sfsTree->sibling)
    {
        findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
    }
}
|Node:{ Text: {
|Node:comment Text: /* Uncomment the next line to get a view of the items in the tree */
|Node:comment Text: // printf( "uriPrefix is %s; node is %s\n", uriPrefix, sfsTree->item.uriNames );
|Node:comment Text: /* Basic error checking */
|Node:if_statement Text: if ( !sfsTree || !uriNames || !uriPrefix || !position )
    {
        return;
    }
|Node:if Text: if
|Node:condition_clause Text: ( !sfsTree || !uriNames || !uriPrefix || !position )
|Node:( Text: (
|Node:binary_expression Text: !sfsTree || !uriNames || !uriPrefix || !position
|Node:binary_expression Text: !sfsTree || !uriNames || !uriPrefix
|Node:binary_expression Text: !sfsTree || !uriNames
|Node:unary_expression Text: !sfsTree
|Node:! Text: !
|Node:identifier Text: sfsTree
|Node:|| Text: ||
|Node:unary_expression Text: !uriNames
|Node:! Text: !
|Node:identifier Text: uriNames
|Node:|| Text: ||
|Node:unary_expression Text: !uriPrefix
|Node:! Text: !
|Node:identifier Text: uriPrefix
|Node:|| Text: ||
|Node:unary_expression Text: !position
|Node:! Text: !
|Node:identifier Text: position
|Node:) Text: )
|Node:compound_statement Text: {
        return;
    }
|Node:{ Text: {
|Node:return_statement Text: return;
|Node:return Text: return
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /*
     * Does the current tree node have the URI name which begins with "CAN:"?
     * (Each node which represents a CAN port always has a URI name of the form "CAN:n".
     */
|Node:if_statement Text: if( 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 ) )
    {
        if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: ( 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 ) )
|Node:( Text: (
|Node:binary_expression Text: 0 == strncmp( sfsTree->item.uriName, "CAN:", 4 )
|Node:number_literal Text: 0
|Node:== Text: ==
|Node:call_expression Text: strncmp( sfsTree->item.uriName, "CAN:", 4 )
|Node:identifier Text: strncmp
|Node:argument_list Text: ( sfsTree->item.uriName, "CAN:", 4 )
|Node:( Text: (
|Node:field_expression Text: sfsTree->item.uriName
|Node:field_expression Text: sfsTree->item
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: item
|Node:. Text: .
|Node:field_identifier Text: uriName
|Node:, Text: ,
|Node:string_literal Text: "CAN:"
|Node:" Text: "
|Node:string_content Text: CAN:
|Node:" Text: "
|Node:, Text: ,
|Node:number_literal Text: 4
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (*position < size)
        {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
        else
        {
            return;
        }
|Node:if Text: if
|Node:condition_clause Text: (*position < size)
|Node:( Text: (
|Node:binary_expression Text: *position < size
|Node:pointer_expression Text: *position
|Node:* Text: *
|Node:identifier Text: position
|Node:< Text: <
|Node:identifier Text: size
|Node:) Text: )
|Node:compound_statement Text: {
            strcpy( uriNames[ *position ], uriPrefix );
            strcat( uriNames[ *position ], "/" );
            strcat( uriNames[ *position ], sfsTree->item.uriName );
            (*position)++;
        }
|Node:{ Text: {
|Node:expression_statement Text: strcpy( uriNames[ *position ], uriPrefix );
|Node:call_expression Text: strcpy( uriNames[ *position ], uriPrefix )
|Node:identifier Text: strcpy
|Node:argument_list Text: ( uriNames[ *position ], uriPrefix )
|Node:( Text: (
|Node:subscript_expression Text: uriNames[ *position ]
|Node:identifier Text: uriNames
|Node:subscript_argument_list Text: [ *position ]
|Node:[ Text: [
|Node:pointer_expression Text: *position
|Node:* Text: *
|Node:identifier Text: position
|Node:] Text: ]
|Node:, Text: ,
|Node:identifier Text: uriPrefix
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: strcat( uriNames[ *position ], "/" );
|Node:call_expression Text: strcat( uriNames[ *position ], "/" )
|Node:identifier Text: strcat
|Node:argument_list Text: ( uriNames[ *position ], "/" )
|Node:( Text: (
|Node:subscript_expression Text: uriNames[ *position ]
|Node:identifier Text: uriNames
|Node:subscript_argument_list Text: [ *position ]
|Node:[ Text: [
|Node:pointer_expression Text: *position
|Node:* Text: *
|Node:identifier Text: position
|Node:] Text: ]
|Node:, Text: ,
|Node:string_literal Text: "/"
|Node:" Text: "
|Node:string_content Text: /
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: strcat( uriNames[ *position ], sfsTree->item.uriName );
|Node:call_expression Text: strcat( uriNames[ *position ], sfsTree->item.uriName )
|Node:identifier Text: strcat
|Node:argument_list Text: ( uriNames[ *position ], sfsTree->item.uriName )
|Node:( Text: (
|Node:subscript_expression Text: uriNames[ *position ]
|Node:identifier Text: uriNames
|Node:subscript_argument_list Text: [ *position ]
|Node:[ Text: [
|Node:pointer_expression Text: *position
|Node:* Text: *
|Node:identifier Text: position
|Node:] Text: ]
|Node:, Text: ,
|Node:field_expression Text: sfsTree->item.uriName
|Node:field_expression Text: sfsTree->item
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: item
|Node:. Text: .
|Node:field_identifier Text: uriName
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: (*position)++;
|Node:update_expression Text: (*position)++
|Node:parenthesized_expression Text: (*position)
|Node:( Text: (
|Node:pointer_expression Text: *position
|Node:* Text: *
|Node:identifier Text: position
|Node:) Text: )
|Node:++ Text: ++
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            return;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            return;
        }
|Node:{ Text: {
|Node:return_statement Text: return;
|Node:return Text: return
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* If the current tree node has a child, recurse into it */
|Node:if_statement Text: if (sfsTree->child)
    {
        OCI_URIName newUriPrefix;

        strcpy( newUriPrefix, uriPrefix );
        strcat( newUriPrefix, "/" );
        strcat( newUriPrefix, sfsTree->item.uriName );
        findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
    }
|Node:if Text: if
|Node:condition_clause Text: (sfsTree->child)
|Node:( Text: (
|Node:field_expression Text: sfsTree->child
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: child
|Node:) Text: )
|Node:compound_statement Text: {
        OCI_URIName newUriPrefix;

        strcpy( newUriPrefix, uriPrefix );
        strcat( newUriPrefix, "/" );
        strcat( newUriPrefix, sfsTree->item.uriName );
        findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
    }
|Node:{ Text: {
|Node:declaration Text: OCI_URIName newUriPrefix;
|Node:type_identifier Text: OCI_URIName
|Node:identifier Text: newUriPrefix
|Node:; Text: ;
|Node:expression_statement Text: strcpy( newUriPrefix, uriPrefix );
|Node:call_expression Text: strcpy( newUriPrefix, uriPrefix )
|Node:identifier Text: strcpy
|Node:argument_list Text: ( newUriPrefix, uriPrefix )
|Node:( Text: (
|Node:identifier Text: newUriPrefix
|Node:, Text: ,
|Node:identifier Text: uriPrefix
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: strcat( newUriPrefix, "/" );
|Node:call_expression Text: strcat( newUriPrefix, "/" )
|Node:identifier Text: strcat
|Node:argument_list Text: ( newUriPrefix, "/" )
|Node:( Text: (
|Node:identifier Text: newUriPrefix
|Node:, Text: ,
|Node:string_literal Text: "/"
|Node:" Text: "
|Node:string_content Text: /
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: strcat( newUriPrefix, sfsTree->item.uriName );
|Node:call_expression Text: strcat( newUriPrefix, sfsTree->item.uriName )
|Node:identifier Text: strcat
|Node:argument_list Text: ( newUriPrefix, sfsTree->item.uriName )
|Node:( Text: (
|Node:identifier Text: newUriPrefix
|Node:, Text: ,
|Node:field_expression Text: sfsTree->item.uriName
|Node:field_expression Text: sfsTree->item
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: item
|Node:. Text: .
|Node:field_identifier Text: uriName
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position );
|Node:call_expression Text: findCanNodes( sfsTree->child, newUriPrefix, uriNames, size, position )
|Node:identifier Text: findCanNodes
|Node:argument_list Text: ( sfsTree->child, newUriPrefix, uriNames, size, position )
|Node:( Text: (
|Node:field_expression Text: sfsTree->child
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: child
|Node:, Text: ,
|Node:identifier Text: newUriPrefix
|Node:, Text: ,
|Node:identifier Text: uriNames
|Node:, Text: ,
|Node:identifier Text: size
|Node:, Text: ,
|Node:identifier Text: position
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* If the current tree node has a sibling, recurse into it */
|Node:if_statement Text: if (sfsTree->sibling)
    {
        findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
    }
|Node:if Text: if
|Node:condition_clause Text: (sfsTree->sibling)
|Node:( Text: (
|Node:field_expression Text: sfsTree->sibling
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: sibling
|Node:) Text: )
|Node:compound_statement Text: {
        findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
    }
|Node:{ Text: {
|Node:expression_statement Text: findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position );
|Node:call_expression Text: findCanNodes( sfsTree->sibling, uriPrefix, uriNames, size, position )
|Node:identifier Text: findCanNodes
|Node:argument_list Text: ( sfsTree->sibling, uriPrefix, uriNames, size, position )
|Node:( Text: (
|Node:field_expression Text: sfsTree->sibling
|Node:identifier Text: sfsTree
|Node:-> Text: ->
|Node:field_identifier Text: sibling
|Node:, Text: ,
|Node:identifier Text: uriPrefix
|Node:, Text: ,
|Node:identifier Text: uriNames
|Node:, Text: ,
|Node:identifier Text: size
|Node:, Text: ,
|Node:identifier Text: position
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:function_definition Text: static BOA_ResultCode OCI_FindCANController(OCI_URIName uriName[], INT nSize, INT* nFound)
{
    if ( !nFound )
    {
        return S_FALSE;
    }

    OCI_ErrorCode   ec;

    /* Container for search results */
    CSI_Tree* sfsTree = NULL;

    /* Specify that we want to search for physical hardware nodes */
    const CSI_NodeRange nodeRange = {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE };

    /* The prefix of the URI of the root of the device tree */
    OCI_URIName uriPrefix = "ETAS:/";

    /* Search for all connected hardware and latch the result for further processing */
    ec = sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    /* Search the tree and fill array with the results */
    *nFound = 0;
    uint32 unFound = 0;
    findCanNodes( sfsTree, uriPrefix, uriName, nSize, &unFound );
    *nFound = unFound;

    /* Clean up the protocol tree. */
    ec = sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    return ec;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOA_ResultCode
|Node:function_declarator Text: OCI_FindCANController(OCI_URIName uriName[], INT nSize, INT* nFound)
|Node:identifier Text: OCI_FindCANController
|Node:parameter_list Text: (OCI_URIName uriName[], INT nSize, INT* nFound)
|Node:( Text: (
|Node:parameter_declaration Text: OCI_URIName uriName[]
|Node:type_identifier Text: OCI_URIName
|Node:array_declarator Text: uriName[]
|Node:identifier Text: uriName
|Node:[ Text: [
|Node:] Text: ]
|Node:, Text: ,
|Node:parameter_declaration Text: INT nSize
|Node:type_identifier Text: INT
|Node:identifier Text: nSize
|Node:, Text: ,
|Node:parameter_declaration Text: INT* nFound
|Node:type_identifier Text: INT
|Node:pointer_declarator Text: * nFound
|Node:* Text: *
|Node:identifier Text: nFound
|Node:) Text: )
|Node:compound_statement Text: {
    if ( !nFound )
    {
        return S_FALSE;
    }

    OCI_ErrorCode   ec;

    /* Container for search results */
    CSI_Tree* sfsTree = NULL;

    /* Specify that we want to search for physical hardware nodes */
    const CSI_NodeRange nodeRange = {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE };

    /* The prefix of the URI of the root of the device tree */
    OCI_URIName uriPrefix = "ETAS:/";

    /* Search for all connected hardware and latch the result for further processing */
    ec = sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    /* Search the tree and fill array with the results */
    *nFound = 0;
    uint32 unFound = 0;
    findCanNodes( sfsTree, uriPrefix, uriName, nSize, &unFound );
    *nFound = unFound;

    /* Clean up the protocol tree. */
    ec = sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree );
    if ( OCI_FAILED( ec ) )
    {
        return ec;
    }

    return ec;
}
|Node:{ Text: {
|Node:if_statement Text: if ( !nFound )
    {
        return S_FALSE;
    }
|Node:if Text: if
|Node:condition_clause Text: ( !nFound )
|Node:( Text: (
|Node:unary_expression Text: !nFound
|Node:! Text: !
|Node:identifier Text: nFound
|Node:) Text: )
|Node:compound_statement Text: {
        return S_FALSE;
    }
|Node:{ Text: {
|Node:return_statement Text: return S_FALSE;
|Node:return Text: return
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: OCI_ErrorCode   ec;
|Node:type_identifier Text: OCI_ErrorCode
|Node:identifier Text: ec
|Node:; Text: ;
|Node:comment Text: /* Container for search results */
|Node:declaration Text: CSI_Tree* sfsTree = NULL;
|Node:type_identifier Text: CSI_Tree
|Node:init_declarator Text: * sfsTree = NULL
|Node:pointer_declarator Text: * sfsTree
|Node:* Text: *
|Node:identifier Text: sfsTree
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:comment Text: /* Specify that we want to search for physical hardware nodes */
|Node:declaration Text: const CSI_NodeRange nodeRange = {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE };
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: CSI_NodeRange
|Node:init_declarator Text: nodeRange = {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE }
|Node:identifier Text: nodeRange
|Node:= Text: =
|Node:initializer_list Text: {CSI_NODE_MIN_PHYSICAL_NODE , CSI_NODE_MAX_PHYSICAL_NODE }
|Node:{ Text: {
|Node:identifier Text: CSI_NODE_MIN_PHYSICAL_NODE
|Node:, Text: ,
|Node:identifier Text: CSI_NODE_MAX_PHYSICAL_NODE
|Node:} Text: }
|Node:; Text: ;
|Node:comment Text: /* The prefix of the URI of the root of the device tree */
|Node:declaration Text: OCI_URIName uriPrefix = "ETAS:/";
|Node:type_identifier Text: OCI_URIName
|Node:init_declarator Text: uriPrefix = "ETAS:/"
|Node:identifier Text: uriPrefix
|Node:= Text: =
|Node:string_literal Text: "ETAS:/"
|Node:" Text: "
|Node:string_content Text: ETAS:/
|Node:" Text: "
|Node:; Text: ;
|Node:comment Text: /* Search for all connected hardware and latch the result for further processing */
|Node:expression_statement Text: ec = sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree );
|Node:assignment_expression Text: ec = sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree )
|Node:identifier Text: ec
|Node:= Text: =
|Node:call_expression Text: sBOA_PTRS.m_sCSI.createProtocolTree( "", nodeRange, &sfsTree )
|Node:field_expression Text: sBOA_PTRS.m_sCSI.createProtocolTree
|Node:field_expression Text: sBOA_PTRS.m_sCSI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sCSI
|Node:. Text: .
|Node:field_identifier Text: createProtocolTree
|Node:argument_list Text: ( "", nodeRange, &sfsTree )
|Node:( Text: (
|Node:string_literal Text: ""
|Node:" Text: "
|Node:" Text: "
|Node:, Text: ,
|Node:identifier Text: nodeRange
|Node:, Text: ,
|Node:pointer_expression Text: &sfsTree
|Node:& Text: &
|Node:identifier Text: sfsTree
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if ( OCI_FAILED( ec ) )
    {
        return ec;
    }
|Node:if Text: if
|Node:condition_clause Text: ( OCI_FAILED( ec ) )
|Node:( Text: (
|Node:call_expression Text: OCI_FAILED( ec )
|Node:identifier Text: OCI_FAILED
|Node:argument_list Text: ( ec )
|Node:( Text: (
|Node:identifier Text: ec
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        return ec;
    }
|Node:{ Text: {
|Node:return_statement Text: return ec;
|Node:return Text: return
|Node:identifier Text: ec
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Search the tree and fill array with the results */
|Node:expression_statement Text: *nFound = 0;
|Node:assignment_expression Text: *nFound = 0
|Node:pointer_expression Text: *nFound
|Node:* Text: *
|Node:identifier Text: nFound
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: uint32 unFound = 0;
|Node:type_identifier Text: uint32
|Node:init_declarator Text: unFound = 0
|Node:identifier Text: unFound
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: findCanNodes( sfsTree, uriPrefix, uriName, nSize, &unFound );
|Node:call_expression Text: findCanNodes( sfsTree, uriPrefix, uriName, nSize, &unFound )
|Node:identifier Text: findCanNodes
|Node:argument_list Text: ( sfsTree, uriPrefix, uriName, nSize, &unFound )
|Node:( Text: (
|Node:identifier Text: sfsTree
|Node:, Text: ,
|Node:identifier Text: uriPrefix
|Node:, Text: ,
|Node:identifier Text: uriName
|Node:, Text: ,
|Node:identifier Text: nSize
|Node:, Text: ,
|Node:pointer_expression Text: &unFound
|Node:& Text: &
|Node:identifier Text: unFound
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: *nFound = unFound;
|Node:assignment_expression Text: *nFound = unFound
|Node:pointer_expression Text: *nFound
|Node:* Text: *
|Node:identifier Text: nFound
|Node:= Text: =
|Node:identifier Text: unFound
|Node:; Text: ;
|Node:comment Text: /* Clean up the protocol tree. */
|Node:expression_statement Text: ec = sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree );
|Node:assignment_expression Text: ec = sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree )
|Node:identifier Text: ec
|Node:= Text: =
|Node:call_expression Text: sBOA_PTRS.m_sCSI.destroyProtocolTree( sfsTree )
|Node:field_expression Text: sBOA_PTRS.m_sCSI.destroyProtocolTree
|Node:field_expression Text: sBOA_PTRS.m_sCSI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sCSI
|Node:. Text: .
|Node:field_identifier Text: destroyProtocolTree
|Node:argument_list Text: ( sfsTree )
|Node:( Text: (
|Node:identifier Text: sfsTree
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if ( OCI_FAILED( ec ) )
    {
        return ec;
    }
|Node:if Text: if
|Node:condition_clause Text: ( OCI_FAILED( ec ) )
|Node:( Text: (
|Node:call_expression Text: OCI_FAILED( ec )
|Node:identifier Text: OCI_FAILED
|Node:argument_list Text: ( ec )
|Node:( Text: (
|Node:identifier Text: ec
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        return ec;
    }
|Node:{ Text: {
|Node:return_statement Text: return ec;
|Node:return Text: return
|Node:identifier Text: ec
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return ec;
|Node:return Text: return
|Node:identifier Text: ec
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * unClientIndex will have index to client array which has clientId dwClientID.
 *
 * @return Returns true if found else false.
 */
|Node:function_definition Text: static BOOL bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
{
    BOOL bResult = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
    }
    return bResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bGetClientObj(DWORD dwClientID, UINT& unClientIndex)
|Node:identifier Text: bGetClientObj
|Node:parameter_list Text: (DWORD dwClientID, UINT& unClientIndex)
|Node:( Text: (
|Node:parameter_declaration Text: DWORD dwClientID
|Node:type_identifier Text: DWORD
|Node:identifier Text: dwClientID
|Node:, Text: ,
|Node:parameter_declaration Text: UINT& unClientIndex
|Node:type_identifier Text: UINT
|Node:reference_declarator Text: & unClientIndex
|Node:& Text: &
|Node:identifier Text: unClientIndex
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bResult = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
    }
    return bResult;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bResult = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bResult = FALSE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_asClientToBufMap.size()
|Node:identifier Text: i
|Node:< Text: <
|Node:call_expression Text: sg_asClientToBufMap.size()
|Node:field_expression Text: sg_asClientToBufMap.size
|Node:identifier Text: sg_asClientToBufMap
|Node:. Text: .
|Node:field_identifier Text: size
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
        {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
|Node:if Text: if
|Node:condition_clause Text: (sg_asClientToBufMap[i].m_dwClientID == dwClientID)
|Node:( Text: (
|Node:binary_expression Text: sg_asClientToBufMap[i].m_dwClientID == dwClientID
|Node:field_expression Text: sg_asClientToBufMap[i].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:== Text: ==
|Node:identifier Text: dwClientID
|Node:) Text: )
|Node:compound_statement Text: {
            unClientIndex = i;
            i = sg_unClientCnt; // break the loop
            bResult = TRUE;
            break;
        }
|Node:{ Text: {
|Node:expression_statement Text: unClientIndex = i;
|Node:assignment_expression Text: unClientIndex = i
|Node:identifier Text: unClientIndex
|Node:= Text: =
|Node:identifier Text: i
|Node:; Text: ;
|Node:expression_statement Text: i = sg_unClientCnt;
|Node:assignment_expression Text: i = sg_unClientCnt
|Node:identifier Text: i
|Node:= Text: =
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:comment Text: // break the loop
|Node:expression_statement Text: bResult = TRUE;
|Node:assignment_expression Text: bResult = TRUE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return bResult;
|Node:return Text: return
|Node:identifier Text: bResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Checks for the existance of the client with the name pcClientName.
 *
 * @return TRUE if client exists else FALSE
 */
|Node:function_definition Text: static BOOL bClientExist(string pcClientName, INT& Index)
{
    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
    }
    return FALSE;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bClientExist(string pcClientName, INT& Index)
|Node:identifier Text: bClientExist
|Node:parameter_list Text: (string pcClientName, INT& Index)
|Node:( Text: (
|Node:parameter_declaration Text: string pcClientName
|Node:type_identifier Text: string
|Node:identifier Text: pcClientName
|Node:, Text: ,
|Node:parameter_declaration Text: INT& Index
|Node:type_identifier Text: INT
|Node:reference_declarator Text: & Index
|Node:& Text: &
|Node:identifier Text: Index
|Node:) Text: )
|Node:compound_statement Text: {
    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
    }
    return FALSE;
}
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_asClientToBufMap.size()
|Node:identifier Text: i
|Node:< Text: <
|Node:call_expression Text: sg_asClientToBufMap.size()
|Node:field_expression Text: sg_asClientToBufMap.size
|Node:identifier Text: sg_asClientToBufMap
|Node:. Text: .
|Node:field_identifier Text: size
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (pcClientName == sg_asClientToBufMap[i].m_acClientName)
        {
            Index = i;
            return TRUE;
        }
|Node:if Text: if
|Node:condition_clause Text: (pcClientName == sg_asClientToBufMap[i].m_acClientName)
|Node:( Text: (
|Node:binary_expression Text: pcClientName == sg_asClientToBufMap[i].m_acClientName
|Node:identifier Text: pcClientName
|Node:== Text: ==
|Node:field_expression Text: sg_asClientToBufMap[i].m_acClientName
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acClientName
|Node:) Text: )
|Node:compound_statement Text: {
            Index = i;
            return TRUE;
        }
|Node:{ Text: {
|Node:expression_statement Text: Index = i;
|Node:assignment_expression Text: Index = i
|Node:identifier Text: Index
|Node:= Text: =
|Node:identifier Text: i
|Node:; Text: ;
|Node:return_statement Text: return TRUE;
|Node:return Text: return
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return FALSE;
|Node:return Text: return
|Node:false Text: FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Removes the client with client id dwClientId.
 *
 * @return TRUE if client removed else FALSE
 */
|Node:function_definition Text: static BOOL bRemoveClient(DWORD dwClientId)
{
    BOOL bResult = FALSE;
    if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = 0;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
    }
    return bResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bRemoveClient(DWORD dwClientId)
|Node:identifier Text: bRemoveClient
|Node:parameter_list Text: (DWORD dwClientId)
|Node:( Text: (
|Node:parameter_declaration Text: DWORD dwClientId
|Node:type_identifier Text: DWORD
|Node:identifier Text: dwClientId
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bResult = FALSE;
    if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = 0;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
    }
    return bResult;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bResult = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bResult = FALSE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:if_statement Text: if (sg_unClientCnt > 0)
    {
        UINT unClientIndex = 0;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_unClientCnt > 0)
|Node:( Text: (
|Node:binary_expression Text: sg_unClientCnt > 0
|Node:identifier Text: sg_unClientCnt
|Node:> Text: >
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
        UINT unClientIndex = 0;
        if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
    }
|Node:{ Text: {
|Node:declaration Text: UINT unClientIndex = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: unClientIndex = 0
|Node:identifier Text: unClientIndex
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:if_statement Text: if (bGetClientObj(dwClientId, unClientIndex))
        {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
|Node:if Text: if
|Node:condition_clause Text: (bGetClientObj(dwClientId, unClientIndex))
|Node:( Text: (
|Node:call_expression Text: bGetClientObj(dwClientId, unClientIndex)
|Node:identifier Text: bGetClientObj
|Node:argument_list Text: (dwClientId, unClientIndex)
|Node:( Text: (
|Node:identifier Text: dwClientId
|Node:, Text: ,
|Node:identifier Text: unClientIndex
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
            sg_asClientToBufMap[unClientIndex].m_acClientName = "";

            for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
            sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
            if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
            sg_unClientCnt--;
            bResult = TRUE;
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].m_dwClientID = 0;
|Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].m_dwClientID = 0
|Node:field_expression Text: sg_asClientToBufMap[unClientIndex].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].m_acClientName = "";
|Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].m_acClientName = ""
|Node:field_expression Text: sg_asClientToBufMap[unClientIndex].m_acClientName
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acClientName
|Node:= Text: =
|Node:string_literal Text: ""
|Node:" Text: "
|Node:" Text: "
|Node:; Text: ;
|Node:for_statement Text: for (INT i = 0; i < MAX_BUFF_ALLOWED; i++)
            {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: INT i = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < MAX_BUFF_ALLOWED
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL;
|Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].m_pClientBuf[i] = NULL
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex].m_pClientBuf[i]
|Node:field_expression Text: sg_asClientToBufMap[unClientIndex].m_pClientBuf
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sg_asClientToBufMap[unClientIndex].m_unBufCount = 0;
|Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex].m_unBufCount = 0
|Node:field_expression Text: sg_asClientToBufMap[unClientIndex].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:if_statement Text: if ((unClientIndex + 1) < sg_unClientCnt)
            {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
|Node:if Text: if
|Node:condition_clause Text: ((unClientIndex + 1) < sg_unClientCnt)
|Node:( Text: (
|Node:binary_expression Text: (unClientIndex + 1) < sg_unClientCnt
|Node:parenthesized_expression Text: (unClientIndex + 1)
|Node:( Text: (
|Node:binary_expression Text: unClientIndex + 1
|Node:identifier Text: unClientIndex
|Node:+ Text: +
|Node:number_literal Text: 1
|Node:) Text: )
|Node:< Text: <
|Node:identifier Text: sg_unClientCnt
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1];
|Node:assignment_expression Text: sg_asClientToBufMap[unClientIndex] = sg_asClientToBufMap[sg_unClientCnt - 1]
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:= Text: =
|Node:subscript_expression Text: sg_asClientToBufMap[sg_unClientCnt - 1]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [sg_unClientCnt - 1]
|Node:[ Text: [
|Node:binary_expression Text: sg_unClientCnt - 1
|Node:identifier Text: sg_unClientCnt
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sg_unClientCnt--;
|Node:update_expression Text: sg_unClientCnt--
|Node:identifier Text: sg_unClientCnt
|Node:-- Text: --
|Node:; Text: ;
|Node:expression_statement Text: bResult = TRUE;
|Node:assignment_expression Text: bResult = TRUE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return bResult;
|Node:return Text: return
|Node:identifier Text: bResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Searches for the client with the id dwClientId.
 *
 * @return TRUE if client exists else FALSE
 */
|Node:function_definition Text: static BOOL bClientIdExist(const DWORD& dwClientId)
{
    BOOL bReturn = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
    return bReturn;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bClientIdExist(const DWORD& dwClientId)
|Node:identifier Text: bClientIdExist
|Node:parameter_list Text: (const DWORD& dwClientId)
|Node:( Text: (
|Node:parameter_declaration Text: const DWORD& dwClientId
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: DWORD
|Node:reference_declarator Text: & dwClientId
|Node:& Text: &
|Node:identifier Text: dwClientId
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bReturn = FALSE;

    for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
    return bReturn;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bReturn = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bReturn = FALSE
|Node:identifier Text: bReturn
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_asClientToBufMap.size(); i++)
    {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_asClientToBufMap.size()
|Node:identifier Text: i
|Node:< Text: <
|Node:call_expression Text: sg_asClientToBufMap.size()
|Node:field_expression Text: sg_asClientToBufMap.size
|Node:identifier Text: sg_asClientToBufMap
|Node:. Text: .
|Node:field_identifier Text: size
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
        {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
|Node:if Text: if
|Node:condition_clause Text: (sg_asClientToBufMap[i].m_dwClientID == dwClientId)
|Node:( Text: (
|Node:binary_expression Text: sg_asClientToBufMap[i].m_dwClientID == dwClientId
|Node:field_expression Text: sg_asClientToBufMap[i].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:== Text: ==
|Node:identifier Text: dwClientId
|Node:) Text: )
|Node:compound_statement Text: {
            bReturn = TRUE;
            i = sg_unClientCnt; // break the loop
        }
|Node:{ Text: {
|Node:expression_statement Text: bReturn = TRUE;
|Node:assignment_expression Text: bReturn = TRUE
|Node:identifier Text: bReturn
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:expression_statement Text: i = sg_unClientCnt;
|Node:assignment_expression Text: i = sg_unClientCnt
|Node:identifier Text: i
|Node:= Text: =
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:comment Text: // break the loop
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return bReturn;
|Node:return Text: return
|Node:identifier Text: bReturn
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Returns the available slot
 */
|Node:function_definition Text: static DWORD dwGetAvailableClientSlot()
{
    DWORD nClientId = 2;
    for (INT i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
    return nClientId;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: DWORD
|Node:function_declarator Text: dwGetAvailableClientSlot()
|Node:identifier Text: dwGetAvailableClientSlot
|Node:parameter_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:compound_statement Text: {
    DWORD nClientId = 2;
    for (INT i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
    return nClientId;
}
|Node:{ Text: {
|Node:declaration Text: DWORD nClientId = 2;
|Node:type_identifier Text: DWORD
|Node:init_declarator Text: nClientId = 2
|Node:identifier Text: nClientId
|Node:= Text: =
|Node:number_literal Text: 2
|Node:; Text: ;
|Node:for_statement Text: for (INT i = 0; i < MAX_CLIENT_ALLOWED; i++)
    {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: INT i = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < MAX_CLIENT_ALLOWED
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: MAX_CLIENT_ALLOWED
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (bClientIdExist(nClientId))
        {
            nClientId += 1;
        }
        else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|Node:if Text: if
|Node:condition_clause Text: (bClientIdExist(nClientId))
|Node:( Text: (
|Node:call_expression Text: bClientIdExist(nClientId)
|Node:identifier Text: bClientIdExist
|Node:argument_list Text: (nClientId)
|Node:( Text: (
|Node:identifier Text: nClientId
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            nClientId += 1;
        }
|Node:{ Text: {
|Node:expression_statement Text: nClientId += 1;
|Node:assignment_expression Text: nClientId += 1
|Node:identifier Text: nClientId
|Node:+= Text: +=
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|Node:else Text: else
|Node:compound_statement Text: {
            i = MAX_CLIENT_ALLOWED; // break the loop
        }
|Node:{ Text: {
|Node:expression_statement Text: i = MAX_CLIENT_ALLOWED;
|Node:assignment_expression Text: i = MAX_CLIENT_ALLOWED
|Node:identifier Text: i
|Node:= Text: =
|Node:identifier Text: MAX_CLIENT_ALLOWED
|Node:; Text: ;
|Node:comment Text: // break the loop
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return nClientId;
|Node:return Text: return
|Node:identifier Text: nClientId
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Pushes an entry into the list at the last position
 */
|Node:function_definition Text: static void vMarkEntryIntoMap(const SACK_MAP& RefObj)
{
    //EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    sg_asAckMapBuf.push_back(RefObj);
    //LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vMarkEntryIntoMap(const SACK_MAP& RefObj)
|Node:identifier Text: vMarkEntryIntoMap
|Node:parameter_list Text: (const SACK_MAP& RefObj)
|Node:( Text: (
|Node:parameter_declaration Text: const SACK_MAP& RefObj
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: SACK_MAP
|Node:reference_declarator Text: & RefObj
|Node:& Text: &
|Node:identifier Text: RefObj
|Node:) Text: )
|Node:compound_statement Text: {
    //EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    sg_asAckMapBuf.push_back(RefObj);
    //LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
}
|Node:{ Text: {
|Node:comment Text: //EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
|Node:expression_statement Text: sg_asAckMapBuf.push_back(RefObj);
|Node:call_expression Text: sg_asAckMapBuf.push_back(RefObj)
|Node:field_expression Text: sg_asAckMapBuf.push_back
|Node:identifier Text: sg_asAckMapBuf
|Node:. Text: .
|Node:field_identifier Text: push_back
|Node:argument_list Text: (RefObj)
|Node:( Text: (
|Node:identifier Text: RefObj
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: //LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
|Node:} Text: }
|Node:function_definition Text: static BOOL bRemoveMapEntry(const SACK_MAP& RefObj, UINT& ClientID)
{
    EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    BOOL bResult = FALSE;
    CACK_MAP_LIST::iterator  iResult =
        find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj );

    //if ((*iResult).m_ClientID > 0)
    if (iResult != sg_asAckMapBuf.end())
    {
        bResult = TRUE;
        ClientID = (*iResult).m_ClientID;
        sg_asAckMapBuf.erase(iResult);
    }
    LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
    return bResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bRemoveMapEntry(const SACK_MAP& RefObj, UINT& ClientID)
|Node:identifier Text: bRemoveMapEntry
|Node:parameter_list Text: (const SACK_MAP& RefObj, UINT& ClientID)
|Node:( Text: (
|Node:parameter_declaration Text: const SACK_MAP& RefObj
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: SACK_MAP
|Node:reference_declarator Text: & RefObj
|Node:& Text: &
|Node:identifier Text: RefObj
|Node:, Text: ,
|Node:parameter_declaration Text: UINT& ClientID
|Node:type_identifier Text: UINT
|Node:reference_declarator Text: & ClientID
|Node:& Text: &
|Node:identifier Text: ClientID
|Node:) Text: )
|Node:compound_statement Text: {
    EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
    BOOL bResult = FALSE;
    CACK_MAP_LIST::iterator  iResult =
        find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj );

    //if ((*iResult).m_ClientID > 0)
    if (iResult != sg_asAckMapBuf.end())
    {
        bResult = TRUE;
        ClientID = (*iResult).m_ClientID;
        sg_asAckMapBuf.erase(iResult);
    }
    LeaveCriticalSection(&sg_CritSectForAckBuf); // Unlock the buffer
    return bResult;
}
|Node:{ Text: {
|Node:expression_statement Text: EnterCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: EnterCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: EnterCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Lock the buffer
|Node:declaration Text: BOOL bResult = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bResult = FALSE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:declaration Text: CACK_MAP_LIST::iterator  iResult =
        find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj );
|Node:qualified_identifier Text: CACK_MAP_LIST::iterator
|Node:namespace_identifier Text: CACK_MAP_LIST
|Node::: Text: ::
|Node:type_identifier Text: iterator
|Node:init_declarator Text: iResult =
        find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj )
|Node:identifier Text: iResult
|Node:= Text: =
|Node:call_expression Text: find( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj )
|Node:identifier Text: find
|Node:argument_list Text: ( sg_asAckMapBuf.begin(), sg_asAckMapBuf.end(), RefObj )
|Node:( Text: (
|Node:call_expression Text: sg_asAckMapBuf.begin()
|Node:field_expression Text: sg_asAckMapBuf.begin
|Node:identifier Text: sg_asAckMapBuf
|Node:. Text: .
|Node:field_identifier Text: begin
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:call_expression Text: sg_asAckMapBuf.end()
|Node:field_expression Text: sg_asAckMapBuf.end
|Node:identifier Text: sg_asAckMapBuf
|Node:. Text: .
|Node:field_identifier Text: end
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: RefObj
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: //if ((*iResult).m_ClientID > 0)
|Node:if_statement Text: if (iResult != sg_asAckMapBuf.end())
    {
        bResult = TRUE;
        ClientID = (*iResult).m_ClientID;
        sg_asAckMapBuf.erase(iResult);
    }
|Node:if Text: if
|Node:condition_clause Text: (iResult != sg_asAckMapBuf.end())
|Node:( Text: (
|Node:binary_expression Text: iResult != sg_asAckMapBuf.end()
|Node:identifier Text: iResult
|Node:!= Text: !=
|Node:call_expression Text: sg_asAckMapBuf.end()
|Node:field_expression Text: sg_asAckMapBuf.end
|Node:identifier Text: sg_asAckMapBuf
|Node:. Text: .
|Node:field_identifier Text: end
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        bResult = TRUE;
        ClientID = (*iResult).m_ClientID;
        sg_asAckMapBuf.erase(iResult);
    }
|Node:{ Text: {
|Node:expression_statement Text: bResult = TRUE;
|Node:assignment_expression Text: bResult = TRUE
|Node:identifier Text: bResult
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:expression_statement Text: ClientID = (*iResult).m_ClientID;
|Node:assignment_expression Text: ClientID = (*iResult).m_ClientID
|Node:identifier Text: ClientID
|Node:= Text: =
|Node:field_expression Text: (*iResult).m_ClientID
|Node:parenthesized_expression Text: (*iResult)
|Node:( Text: (
|Node:pointer_expression Text: *iResult
|Node:* Text: *
|Node:identifier Text: iResult
|Node:) Text: )
|Node:. Text: .
|Node:field_identifier Text: m_ClientID
|Node:; Text: ;
|Node:expression_statement Text: sg_asAckMapBuf.erase(iResult);
|Node:call_expression Text: sg_asAckMapBuf.erase(iResult)
|Node:field_expression Text: sg_asAckMapBuf.erase
|Node:identifier Text: sg_asAckMapBuf
|Node:. Text: .
|Node:field_identifier Text: erase
|Node:argument_list Text: (iResult)
|Node:( Text: (
|Node:identifier Text: iResult
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: LeaveCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: LeaveCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: LeaveCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Unlock the buffer
|Node:return_statement Text: return bResult;
|Node:return Text: return
|Node:identifier Text: bResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Initialize default values for controller configuration
 *
 * @param[in] nChannel Channel information
 */
|Node:function_definition Text: static void vInitializeControllerConfig(UINT nChannel)
{
    sg_asChannel[nChannel].m_OCI_CANConfig.baudrate = 500000;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit = OCI_CAN_THREE_SAMPLES_PER_BIT;
    sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.SJW = 16;
    sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
    sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
    sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* Set controller property to SUSPENDED */
    sg_asChannel[nChannel].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;

#if BOA_VERSION >= BOA_VERSION_2_0
    /* Set CAN FD default values */
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF;
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = 0;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED;
    //
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;

    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;

    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE_PADDING;

    // sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
    sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vInitializeControllerConfig(UINT nChannel)
|Node:identifier Text: vInitializeControllerConfig
|Node:parameter_list Text: (UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    sg_asChannel[nChannel].m_OCI_CANConfig.baudrate = 500000;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit = OCI_CAN_THREE_SAMPLES_PER_BIT;
    sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles = 80;
    sg_asChannel[nChannel].m_OCI_CANConfig.SJW = 16;
    sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
    sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
    sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* Set controller property to SUSPENDED */
    sg_asChannel[nChannel].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;

#if BOA_VERSION >= BOA_VERSION_2_0
    /* Set CAN FD default values */
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF;
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = 0;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED;
    //
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;

    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;

    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE_PADDING;

    // sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
    sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
}
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.baudrate = 500000;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.baudrate = 500000
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.baudrate
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: baudrate
|Node:= Text: =
|Node:number_literal Text: 500000
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint = 80;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint = 80
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplePoint
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: samplePoint
|Node:= Text: =
|Node:number_literal Text: 80
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit = OCI_CAN_THREE_SAMPLES_PER_BIT;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit = OCI_CAN_THREE_SAMPLES_PER_BIT
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.samplesPerBit
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: samplesPerBit
|Node:= Text: =
|Node:identifier Text: OCI_CAN_THREE_SAMPLES_PER_BIT
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles = 80;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles = 80
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.BTL_Cycles
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: BTL_Cycles
|Node:= Text: =
|Node:number_literal Text: 80
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.SJW = 16;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.SJW = 16
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.SJW
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: SJW
|Node:= Text: =
|Node:number_literal Text: 16
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.syncEdge
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: syncEdge
|Node:= Text: =
|Node:identifier Text: OCI_CAN_SINGLE_SYNC_EDGE
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.physicalMedia
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: physicalMedia
|Node:= Text: =
|Node:identifier Text: OCI_CAN_MEDIA_HIGH_SPEED
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.selfReceptionMode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: selfReceptionMode
|Node:= Text: =
|Node:identifier Text: OCI_SELF_RECEPTION_ON
|Node:; Text: ;
|Node:comment Text: /* Set controller property to SUSPENDED */
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:= Text: =
|Node:identifier Text: OCI_CONTROLLER_MODE_SUSPENDED
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
    /* Set CAN FD default values */
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF;
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = 0;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY;
    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED;
    //
    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;

    sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;

    //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE_PADDING;

    // sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
    sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:comment Text: /* Set CAN FD default values */
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled = true
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDEnabled
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDEnabled
|Node:= Text: =
|Node:true Text: true
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate                  = 2000000
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBitRate
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataBitRate
|Node:= Text: =
|Node:number_literal Text: 2000000
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = 70
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSamplePoint
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataSamplePoint
|Node:= Text: =
|Node:number_literal Text: 70
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = 10
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataBTL_Cycles
|Node:= Text: =
|Node:number_literal Text: 10
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW                      = 3
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.dataSJW
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataSJW
|Node:= Text: =
|Node:number_literal Text: 3
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = OCI_CANFDTX_DELAY_COMPENSATION_OFF
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: txDelayCompensationControl
|Node:= Text: =
|Node:identifier Text: OCI_CANFDTX_DELAY_COMPENSATION_OFF
|Node:; Text: ;
|Node:comment Text: //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = 0;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CANFD_FRAMES_ONLY
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdTxConfig
|Node:= Text: =
|Node:identifier Text: OCI_CANFDTX_USE_CANFD_FRAMES_ONLY
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_IGNORED
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxConfig
|Node:. Text: .
|Node:field_identifier Text: canRxMode
|Node:= Text: =
|Node:identifier Text: OCI_CAN_RXMODE_CAN_FRAMES_IGNORED
|Node:; Text: ;
|Node:comment Text: //
|Node:comment Text: //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxMode
|Node:= Text: =
|Node:identifier Text: OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE
|Node:; Text: ;
|Node:comment Text: //sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE_PADDING;
|Node:comment Text: // sg_asChannel[nChannel].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig.busParticipationMode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: busParticipationMode
|Node:= Text: =
|Node:identifier Text: OCI_BUSMODE_ACTIVE
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:} Text: }
|Node:comment Text: /**
 * Initialize default values for queue confgiuration
 *
 * @param[in] nChannel Channel information
 */
|Node:function_definition Text: static void vInitializeQueueConfig(UINT nChannel)
{
    /* configure Rx Queue*/
#if BOA_VERSION >= BOA_VERSION_2_0
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents;
#else
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
#endif
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* configure Tx Queue*/
    sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved = 0;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vInitializeQueueConfig(UINT nChannel)
|Node:identifier Text: vInitializeQueueConfig
|Node:parameter_list Text: (UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    /* configure Rx Queue*/
#if BOA_VERSION >= BOA_VERSION_2_0
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents;
#else
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
#endif
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    /* configure Tx Queue*/
    sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved = 0;
}
|Node:{ Text: {
|Node:comment Text: /* configure Rx Queue*/
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents;
#else
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx = ProcessCanData
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.functionEx
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onFrame
|Node:. Text: .
|Node:field_identifier Text: functionEx
|Node:= Text: =
|Node:identifier Text: ProcessCanData
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx = ProcessEvents
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.functionEx
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onEvent
|Node:. Text: .
|Node:field_identifier Text: functionEx
|Node:= Text: =
|Node:identifier Text: ProcessEvents
|Node:; Text: ;
|Node:preproc_else Text: #else
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
    sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
|Node:#else Text: #else
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function = ProcessCanData
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame.function
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onFrame
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onFrame
|Node:. Text: .
|Node:field_identifier Text: function
|Node:= Text: =
|Node:identifier Text: ProcessCanData
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function = ProcessEvents
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent.function
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.onEvent
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onEvent
|Node:. Text: .
|Node:field_identifier Text: function
|Node:= Text: =
|Node:identifier Text: ProcessEvents
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode = OCI_SELF_RECEPTION_ON;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode = OCI_SELF_RECEPTION_ON
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg.selfReceptionMode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: selfReceptionMode
|Node:= Text: =
|Node:identifier Text: OCI_SELF_RECEPTION_ON
|Node:; Text: ;
|Node:comment Text: /* configure Tx Queue*/
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueCfg.reserved
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: reserved
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Initialize default values for filter confgiuration
 *
 * @param[in] nChannel Channel information
 */
|Node:function_definition Text: static void vInitializeFilterConfig(UINT nChannel)
{
    /* configure frame filter*/
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.tag = 0;

    /* configure event filter*/
    sg_asChannel[nChannel].m_OCI_EventFilter.destination = OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_EventFilter.eventCode = OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE ;
    sg_asChannel[nChannel].m_OCI_EventFilter.tag = 0;

    /* configure error filter */
    sg_asChannel[nChannel].m_OCI_ErrorFilter.destination =  OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame =   OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.tag = 0;

    /* configure internal error filter */
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode = OCI_INTERNAL_GENERAL_ERROR;
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag = 0;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vInitializeFilterConfig(UINT nChannel)
|Node:identifier Text: vInitializeFilterConfig
|Node:parameter_list Text: (UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    /* configure frame filter*/
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue = 0;
    sg_asChannel[nChannel].m_OCI_FrameFilter.tag = 0;

    /* configure event filter*/
    sg_asChannel[nChannel].m_OCI_EventFilter.destination = OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_EventFilter.eventCode = OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE ;
    sg_asChannel[nChannel].m_OCI_EventFilter.tag = 0;

    /* configure error filter */
    sg_asChannel[nChannel].m_OCI_ErrorFilter.destination =  OCI_EVENT_DESTINATION_CALLBACK;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame =   OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER;
    sg_asChannel[nChannel].m_OCI_ErrorFilter.tag = 0;

    /* configure internal error filter */
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode = OCI_INTERNAL_GENERAL_ERROR;
    sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag = 0;
}
|Node:{ Text: {
|Node:comment Text: /* configure frame filter*/
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDMask
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:. Text: .
|Node:field_identifier Text: frameIDMask
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.frameIDValue
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:. Text: .
|Node:field_identifier Text: frameIDValue
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_FrameFilter.tag = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.tag = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter.tag
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:. Text: .
|Node:field_identifier Text: tag
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:comment Text: /* configure event filter*/
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_EventFilter.destination = OCI_EVENT_DESTINATION_CALLBACK;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.destination = OCI_EVENT_DESTINATION_CALLBACK
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.destination
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_EventFilter
|Node:. Text: .
|Node:field_identifier Text: destination
|Node:= Text: =
|Node:identifier Text: OCI_EVENT_DESTINATION_CALLBACK
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_EventFilter.eventCode = OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE ;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.eventCode = OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.eventCode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_EventFilter
|Node:. Text: .
|Node:field_identifier Text: eventCode
|Node:= Text: =
|Node:binary_expression Text: OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF |
            OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
|Node:binary_expression Text: OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT |
            OCI_CAN_BUS_EVENT_STATE_BUSOFF
|Node:binary_expression Text: OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE |
            OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
|Node:binary_expression Text: OCI_CAN_BUS_EVENT_STATE_ACTIVE |
            OCI_CAN_BUS_EVENT_STATE_PASSIVE
|Node:identifier Text: OCI_CAN_BUS_EVENT_STATE_ACTIVE
|Node:| Text: |
|Node:identifier Text: OCI_CAN_BUS_EVENT_STATE_PASSIVE
|Node:| Text: |
|Node:identifier Text: OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
|Node:| Text: |
|Node:identifier Text: OCI_CAN_BUS_EVENT_STATE_BUSOFF
|Node:| Text: |
|Node:identifier Text: OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_EventFilter.tag = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.tag = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter.tag
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_EventFilter
|Node:. Text: .
|Node:field_identifier Text: tag
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:comment Text: /* configure error filter */
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.destination =  OCI_EVENT_DESTINATION_CALLBACK;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.destination =  OCI_EVENT_DESTINATION_CALLBACK
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.destination
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:. Text: .
|Node:field_identifier Text: destination
|Node:= Text: =
|Node:identifier Text: OCI_EVENT_DESTINATION_CALLBACK
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame =   OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame =   OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.errorFrame
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:. Text: .
|Node:field_identifier Text: errorFrame
|Node:= Text: =
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD |
            OCI_CAN_ERR_TYPE_OTHER
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC |
            OCI_CAN_ERR_TYPE_OVERLOAD
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV |
            OCI_CAN_ERR_TYPE_CRC
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT |
            OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT |
            OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK |
            OCI_CAN_ERR_TYPE_BIT
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT |
            OCI_CAN_ERR_TYPE_ACK
|Node:binary_expression Text: OCI_CAN_ERR_TYPE_BITSTUFF |
            OCI_CAN_ERR_TYPE_FORMAT
|Node:identifier Text: OCI_CAN_ERR_TYPE_BITSTUFF
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_FORMAT
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_ACK
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_CRC
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_OVERLOAD
|Node:| Text: |
|Node:identifier Text: OCI_CAN_ERR_TYPE_OTHER
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.tag = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.tag = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter.tag
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:. Text: .
|Node:field_identifier Text: tag
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:comment Text: /* configure internal error filter */
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode = OCI_INTERNAL_GENERAL_ERROR;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode = OCI_INTERNAL_GENERAL_ERROR
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.eventCode
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_InternalErrorFilter
|Node:. Text: .
|Node:field_identifier Text: eventCode
|Node:= Text: =
|Node:identifier Text: OCI_INTERNAL_GENERAL_ERROR
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag = 0;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag = 0
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter.tag
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_InternalErrorFilter
|Node:. Text: .
|Node:field_identifier Text: tag
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Adds or removes the HW filter to/from the channel.
 *
 * @return S_OK for success, S_FALSE for failure
 */
|Node:function_definition Text: static HRESULT ManageFilters(BYTE byCode, UINT nChannel)
{
    HRESULT hResult = S_FALSE;
    BOA_ResultCode ErrCode = OCI_FAILURE;
    if (byCode == FILTER_ADD)
    {
        /* Add frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }

        /* Add bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }

        /* Add error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

        /* Add internal error filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

    }
    else if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
    return hResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: ManageFilters(BYTE byCode, UINT nChannel)
|Node:identifier Text: ManageFilters
|Node:parameter_list Text: (BYTE byCode, UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: BYTE byCode
|Node:type_identifier Text: BYTE
|Node:identifier Text: byCode
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    BOA_ResultCode ErrCode = OCI_FAILURE;
    if (byCode == FILTER_ADD)
    {
        /* Add frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }

        /* Add bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }

        /* Add error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

        /* Add internal error filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

    }
    else if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:declaration Text: BOA_ResultCode ErrCode = OCI_FAILURE;
|Node:type_identifier Text: BOA_ResultCode
|Node:init_declarator Text: ErrCode = OCI_FAILURE
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:identifier Text: OCI_FAILURE
|Node:; Text: ;
|Node:if_statement Text: if (byCode == FILTER_ADD)
    {
        /* Add frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }

        /* Add bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }

        /* Add error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

        /* Add internal error filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

    }
    else if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (byCode == FILTER_ADD)
|Node:( Text: (
|Node:binary_expression Text: byCode == FILTER_ADD
|Node:identifier Text: byCode
|Node:== Text: ==
|Node:identifier Text: FILTER_ADD
|Node:) Text: )
|Node:compound_statement Text: {
        /* Add frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }

        /* Add bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }

        /* Add error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

        /* Add internal error filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }

    }
|Node:{ Text: {
|Node:comment Text: /* Add frame filter */
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANFrameFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_FrameFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_FrameFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(ErrCode)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add frame filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add frame filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add frame filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add frame filter")
|Node:( Text: (
|Node:string_literal Text: "could not add frame filter"
|Node:" Text: "
|Node:string_content Text: could not add frame filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Add bus event filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);

            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANBusEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANBusEventFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_EventFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_EventFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_EventFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Event filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add Event filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add Event filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add Event filter")
|Node:( Text: (
|Node:string_literal Text: "could not add Event filter"
|Node:" Text: "
|Node:string_content Text: could not add Event filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Add error frame filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.addCANErrorFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: addCANErrorFrameFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_ErrorFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_ErrorFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add Error filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add Error filter")
|Node:( Text: (
|Node:string_literal Text: "could not add Error filter"
|Node:" Text: "
|Node:string_content Text: could not add Error filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Add internal error filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable.addInternalErrorEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: errorVTable
|Node:. Text: .
|Node:field_identifier Text: addInternalErrorEventFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_InternalErrorFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_InternalErrorFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add Error filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add Error filter")
|Node:( Text: (
|Node:string_literal Text: "could not add Error filter"
|Node:" Text: "
|Node:string_content Text: could not add Error filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
|Node:else Text: else
|Node:if_statement Text: if (byCode == FILTER_REMOVE)
    {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (byCode == FILTER_REMOVE)
|Node:( Text: (
|Node:binary_expression Text: byCode == FILTER_REMOVE
|Node:identifier Text: byCode
|Node:== Text: ==
|Node:identifier Text: FILTER_REMOVE
|Node:) Text: )
|Node:compound_statement Text: {
        /* Remove frame filter */
        ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
        if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }

        /* Remove bus event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }

        /* Remove error frame filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }

        /* Remove internal error event filter */
        if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
    }
|Node:{ Text: {
|Node:comment Text: /* Remove frame filter */
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
                  (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANFrameFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                   &(sg_asChannel[nChannel].m_OCI_FrameFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_FrameFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_FrameFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_FrameFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_FrameFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(ErrCode))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(ErrCode)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove frame filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not remove frame filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not remove frame filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not remove frame filter")
|Node:( Text: (
|Node:string_literal Text: "could not remove frame filter"
|Node:" Text: "
|Node:string_content Text: could not remove frame filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Remove bus event filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANBusEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANBusEventFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_EventFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_EventFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_EventFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_EventFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_EventFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Event filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not remove Event filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not remove Event filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not remove Event filter")
|Node:( Text: (
|Node:string_literal Text: "could not remove Event filter"
|Node:" Text: "
|Node:string_content Text: could not remove Event filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Remove error frame filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.removeCANErrorFrameFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: removeCANErrorFrameFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_ErrorFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_ErrorFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_ErrorFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_ErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_ErrorFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove Error filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not remove Error filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not remove Error filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not remove Error filter")
|Node:( Text: (
|Node:string_literal Text: "could not remove Error filter"
|Node:" Text: "
|Node:string_content Text: could not remove Error filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Remove internal error event filter */
|Node:if_statement Text: if (hResult == S_OK)
        {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
            if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
                      (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable.removeInternalErrorEventFilter
|Node:field_expression Text: sBOA_PTRS.m_sOCI.errorVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: errorVTable
|Node:. Text: .
|Node:field_identifier Text: removeInternalErrorEventFilter
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle,
                       &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter), 1)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_InternalErrorFilter)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_InternalErrorFilter)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_InternalErrorFilter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_InternalErrorFilter
|Node:) Text: )
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(ErrCode))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(ErrCode)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add Error filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add Error filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add Error filter")
|Node:( Text: (
|Node:string_literal Text: "could not add Error filter"
|Node:" Text: "
|Node:string_content Text: could not add Error filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Adds or removes the queue to/from the channel.
 *
 * @return S_OK for success, S_FALSE for failure
 */
|Node:function_definition Text: static HRESULT ManageQueue(BYTE byCode, UINT nChannel)
{
    HRESULT hResult = S_FALSE;
    BOA_ResultCode Err = OCI_ERR_FLAG_ERROR;
    if (byCode == QUEUE_ADD)
    {
        /* Create CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    else if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    return hResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: ManageQueue(BYTE byCode, UINT nChannel)
|Node:identifier Text: ManageQueue
|Node:parameter_list Text: (BYTE byCode, UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: BYTE byCode
|Node:type_identifier Text: BYTE
|Node:identifier Text: byCode
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    BOA_ResultCode Err = OCI_ERR_FLAG_ERROR;
    if (byCode == QUEUE_ADD)
    {
        /* Create CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    else if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:declaration Text: BOA_ResultCode Err = OCI_ERR_FLAG_ERROR;
|Node:type_identifier Text: BOA_ResultCode
|Node:init_declarator Text: Err = OCI_ERR_FLAG_ERROR
|Node:identifier Text: Err
|Node:= Text: =
|Node:identifier Text: OCI_ERR_FLAG_ERROR
|Node:; Text: ;
|Node:if_statement Text: if (byCode == QUEUE_ADD)
    {
        /* Create CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
    else if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (byCode == QUEUE_ADD)
|Node:( Text: (
|Node:binary_expression Text: byCode == QUEUE_ADD
|Node:identifier Text: byCode
|Node:== Text: ==
|Node:identifier Text: QUEUE_ADD
|Node:) Text: )
|Node:compound_statement Text: {
        /* Create CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
|Node:{ Text: {
|Node:comment Text: /* Create CAN Rx queue */
|Node:expression_statement Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle));
|Node:assignment_expression Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle))
|Node:identifier Text: Err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
              (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANRxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: createCANRxQueue
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_HwHandle,
               &(sg_asChannel[nChannel].m_OCI_RxQueueCfg),
               &(sg_asChannel[nChannel].m_OCI_RxQueueHandle))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_RxQueueCfg)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_RxQueueCfg)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_RxQueueHandle)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(Err))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(Err)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (Err)
|Node:( Text: (
|Node:identifier Text: Err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not create Rx Queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not create Rx Queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could not create Rx Queue")
|Node:( Text: (
|Node:string_literal Text: "could not create Rx Queue"
|Node:" Text: "
|Node:string_content Text: could not create Rx Queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Create CAN Tx queue */
|Node:if_statement Text: if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle));
|Node:assignment_expression Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle))
|Node:identifier Text: Err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
                  (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.createCANTxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: createCANTxQueue
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_HwHandle,
                   &(sg_asChannel[nChannel].m_OCI_TxQueueCfg),
                   &(sg_asChannel[nChannel].m_OCI_TxQueueHandle))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_TxQueueCfg)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_TxQueueCfg)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueCfg
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueCfg
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[nChannel].m_OCI_TxQueueHandle)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[nChannel].m_OCI_TxQueueHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueHandle
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(Err))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(Err)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (Err)
|Node:( Text: (
|Node:identifier Text: Err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not create TX Queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not create TX Queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could not create TX Queue")
|Node:( Text: (
|Node:string_literal Text: "could not create TX Queue"
|Node:" Text: "
|Node:string_content Text: could not create TX Queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
|Node:else Text: else
|Node:if_statement Text: if (byCode == QUEUE_DESTROY)
    {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (byCode == QUEUE_DESTROY)
|Node:( Text: (
|Node:binary_expression Text: byCode == QUEUE_DESTROY
|Node:identifier Text: byCode
|Node:== Text: ==
|Node:identifier Text: QUEUE_DESTROY
|Node:) Text: )
|Node:compound_statement Text: {
        /* Destroy CAN Rx queue */
        Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
        if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }

        /* Create CAN Tx queue */
        if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
    }
|Node:{ Text: {
|Node:comment Text: /* Destroy CAN Rx queue */
|Node:expression_statement Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle);
|Node:assignment_expression Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle)
|Node:identifier Text: Err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))(sg_asChannel[nChannel].m_OCI_RxQueueHandle)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANRxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: destroyCANRxQueue
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_RxQueueHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_RxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueHandle
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(Err))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(Err))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(Err)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (Err)
|Node:( Text: (
|Node:identifier Text: Err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create Rx Queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not create Rx Queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not create Rx Queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could not create Rx Queue")
|Node:( Text: (
|Node:string_literal Text: "could not create Rx Queue"
|Node:" Text: "
|Node:string_content Text: could not create Rx Queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Create CAN Tx queue */
|Node:if_statement Text: if (hResult == S_OK)
        {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
            if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
        }
|Node:{ Text: {
|Node:expression_statement Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle);
|Node:assignment_expression Text: Err = (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle)
|Node:identifier Text: Err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))(sg_asChannel[nChannel].m_OCI_TxQueueHandle)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.destroyCANTxQueue
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: destroyCANTxQueue
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[nChannel].m_OCI_TxQueueHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[nChannel].m_OCI_TxQueueHandle
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueHandle
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_FAILED(Err))
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(Err))
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(Err)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (Err)
|Node:( Text: (
|Node:identifier Text: Err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create TX Queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not create TX Queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not create TX Queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could not create TX Queue")
|Node:( Text: (
|Node:string_literal Text: "could not create TX Queue"
|Node:" Text: "
|Node:string_content Text: could not create TX Queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * copies from OCI_CANRxMessage struct into STCANDATA struct
 */
|Node:function_definition Text: static void vCopyOCI_CAN_RX_2_DATA(const OCI_CANRxMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }

    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData));
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vCopyOCI_CAN_RX_2_DATA(const OCI_CANRxMessage* SrcMsg, STCANDATA* DestMsg)
|Node:identifier Text: vCopyOCI_CAN_RX_2_DATA
|Node:parameter_list Text: (const OCI_CANRxMessage* SrcMsg, STCANDATA* DestMsg)
|Node:( Text: (
|Node:parameter_declaration Text: const OCI_CANRxMessage* SrcMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: OCI_CANRxMessage
|Node:pointer_declarator Text: * SrcMsg
|Node:* Text: *
|Node:identifier Text: SrcMsg
|Node:, Text: ,
|Node:parameter_declaration Text: STCANDATA* DestMsg
|Node:type_identifier Text: STCANDATA
|Node:pointer_declarator Text: * DestMsg
|Node:* Text: *
|Node:identifier Text: DestMsg
|Node:) Text: )
|Node:compound_statement Text: {
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }

    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData));
}
|Node:{ Text: {
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:= Text: =
|Node:field_expression Text: SrcMsg->frameID
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: frameID
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:= Text: =
|Node:field_expression Text: SrcMsg->dlc
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: dlc
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucEXTENDED
|Node:= Text: =
|Node:conditional_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0
|Node:parenthesized_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:) Text: )
|Node:? Text: ?
|Node:number_literal Text: 1
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucRTR
|Node:= Text: =
|Node:conditional_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)? 1 : 0
|Node:parenthesized_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME)
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) == OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:) Text: )
|Node:? Text: ?
|Node:number_literal Text: 1
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;
|Node:assignment_expression Text: DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG
|Node:field_expression Text: DestMsg->m_ucDataType
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_ucDataType
|Node:= Text: =
|Node:conditional_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG
|Node:parenthesized_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:) Text: )
|Node:? Text: ?
|Node:identifier Text: TX_FLAG
|Node:: Text: :
|Node:identifier Text: RX_FLAG
|Node:; Text: ;
|Node:declaration Text: UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:identifier Text: Channel
|Node:= Text: =
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:; Text: ;
|Node:if_statement Text: if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
|Node:if Text: if
|Node:condition_clause Text: (Channel > defNO_OF_CHANNELS)
|Node:( Text: (
|Node:binary_expression Text: Channel > defNO_OF_CHANNELS
|Node:identifier Text: Channel
|Node:> Text: >
|Node:identifier Text: defNO_OF_CHANNELS
|Node:) Text: )
|Node:compound_statement Text: {
        Channel = 1; // Take appropriate action
    }
|Node:{ Text: {
|Node:expression_statement Text: Channel = 1;
|Node:assignment_expression Text: Channel = 1
|Node:identifier Text: Channel
|Node:= Text: =
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:comment Text: // Take appropriate action
|Node:} Text: }
|Node:expression_statement Text: DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
|Node:assignment_expression Text: DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:field_expression Text: DestMsg->m_lTickCount.QuadPart
|Node:field_expression Text: DestMsg->m_lTickCount
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:= Text: =
|Node:call_expression Text: (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:parenthesized_expression Text: (LONGLONG)
|Node:( Text: (
|Node:identifier Text: LONGLONG
|Node:) Text: )
|Node:argument_list Text: (SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution
|Node:field_expression Text: SrcMsg->timeStamp
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: timeStamp
|Node:* Text: *
|Node:field_expression Text: sg_asChannel[Channel - 1].m_fResolution
|Node:subscript_expression Text: sg_asChannel[Channel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [Channel - 1]
|Node:[ Text: [
|Node:binary_expression Text: Channel - 1
|Node:identifier Text: Channel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_fResolution
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData));
|Node:call_expression Text: memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData))
|Node:identifier Text: memcpy
|Node:argument_list Text: (DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData))
|Node:( Text: (
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucData
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucData
|Node:, Text: ,
|Node:field_expression Text: SrcMsg->data
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:, Text: ,
|Node:sizeof_expression Text: sizeof(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (DestMsg->m_uDataInfo.m_sCANMsg.m_ucData)
|Node:( Text: (
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucData
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucData
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * copies from OCI_CANRxMessage struct into STCANDATA struct
 */
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
static void vCopyOCI_CAN_FD_RX_2_DATA(const OCI_CANFDRxMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size);
}
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:function_definition Text: static void vCopyOCI_CAN_FD_RX_2_DATA(const OCI_CANFDRxMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vCopyOCI_CAN_FD_RX_2_DATA(const OCI_CANFDRxMessage* SrcMsg, STCANDATA* DestMsg)
|Node:identifier Text: vCopyOCI_CAN_FD_RX_2_DATA
|Node:parameter_list Text: (const OCI_CANFDRxMessage* SrcMsg, STCANDATA* DestMsg)
|Node:( Text: (
|Node:parameter_declaration Text: const OCI_CANFDRxMessage* SrcMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: OCI_CANFDRxMessage
|Node:pointer_declarator Text: * SrcMsg
|Node:* Text: *
|Node:identifier Text: SrcMsg
|Node:, Text: ,
|Node:parameter_declaration Text: STCANDATA* DestMsg
|Node:type_identifier Text: STCANDATA
|Node:pointer_declarator Text: * DestMsg
|Node:* Text: *
|Node:identifier Text: DestMsg
|Node:) Text: )
|Node:compound_statement Text: {
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size;

    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0;
    DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;

    UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;

    if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
    DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
    memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size);
}
|Node:{ Text: {
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:= Text: =
|Node:field_expression Text: SrcMsg->frameID
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: frameID
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->size
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:= Text: =
|Node:field_expression Text: SrcMsg->size
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: size
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucEXTENDED
|Node:= Text: =
|Node:conditional_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)? 1 : 0
|Node:parenthesized_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED)
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) == OCI_CAN_MSG_FLAG_EXTENDED
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:) Text: )
|Node:? Text: ?
|Node:number_literal Text: 1
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucRTR
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG;
|Node:assignment_expression Text: DestMsg->m_ucDataType   = ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG
|Node:field_expression Text: DestMsg->m_ucDataType
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_ucDataType
|Node:= Text: =
|Node:conditional_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)? TX_FLAG : RX_FLAG
|Node:parenthesized_expression Text: ((SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION)
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:) Text: )
|Node:? Text: ?
|Node:identifier Text: TX_FLAG
|Node:: Text: :
|Node:identifier Text: RX_FLAG
|Node:; Text: ;
|Node:declaration Text: UINT Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: Channel = DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:identifier Text: Channel
|Node:= Text: =
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:; Text: ;
|Node:if_statement Text: if (Channel > defNO_OF_CHANNELS)
    {
        Channel = 1; // Take appropriate action
    }
|Node:if Text: if
|Node:condition_clause Text: (Channel > defNO_OF_CHANNELS)
|Node:( Text: (
|Node:binary_expression Text: Channel > defNO_OF_CHANNELS
|Node:identifier Text: Channel
|Node:> Text: >
|Node:identifier Text: defNO_OF_CHANNELS
|Node:) Text: )
|Node:compound_statement Text: {
        Channel = 1; // Take appropriate action
    }
|Node:{ Text: {
|Node:expression_statement Text: Channel = 1;
|Node:assignment_expression Text: Channel = 1
|Node:identifier Text: Channel
|Node:= Text: =
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:comment Text: // Take appropriate action
|Node:} Text: }
|Node:expression_statement Text: DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution);
|Node:assignment_expression Text: DestMsg->m_lTickCount.QuadPart = (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:field_expression Text: DestMsg->m_lTickCount.QuadPart
|Node:field_expression Text: DestMsg->m_lTickCount
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:= Text: =
|Node:call_expression Text: (LONGLONG)(SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:parenthesized_expression Text: (LONGLONG)
|Node:( Text: (
|Node:identifier Text: LONGLONG
|Node:) Text: )
|Node:argument_list Text: (SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->timeStamp * sg_asChannel[Channel - 1].m_fResolution
|Node:field_expression Text: SrcMsg->timeStamp
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: timeStamp
|Node:* Text: *
|Node:field_expression Text: sg_asChannel[Channel - 1].m_fResolution
|Node:subscript_expression Text: sg_asChannel[Channel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [Channel - 1]
|Node:[ Text: [
|Node:binary_expression Text: Channel - 1
|Node:identifier Text: Channel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_fResolution
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size);
|Node:call_expression Text: memcpy(DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size)
|Node:identifier Text: memcpy
|Node:argument_list Text: (DestMsg->m_uDataInfo.m_sCANMsg.m_ucData, SrcMsg->data, SrcMsg->size)
|Node:( Text: (
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucData
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucData
|Node:, Text: ,
|Node:field_expression Text: SrcMsg->data
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:, Text: ,
|Node:field_expression Text: SrcMsg->size
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: size
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:comment Text: /**
 * Gets the channel with handle OCI_ControllerHandle
 *
 * @return Returns channel number
 */
|Node:function_definition Text: static UINT nGetChannel(const OCI_ControllerHandle hHandle)
{
    UINT i;
    for (i = 0; i < sg_nNoOfChannels; i++)
    {
        if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
    }
    return (i+1);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: UINT
|Node:function_declarator Text: nGetChannel(const OCI_ControllerHandle hHandle)
|Node:identifier Text: nGetChannel
|Node:parameter_list Text: (const OCI_ControllerHandle hHandle)
|Node:( Text: (
|Node:parameter_declaration Text: const OCI_ControllerHandle hHandle
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: OCI_ControllerHandle
|Node:identifier Text: hHandle
|Node:) Text: )
|Node:compound_statement Text: {
    UINT i;
    for (i = 0; i < sg_nNoOfChannels; i++)
    {
        if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
    }
    return (i+1);
}
|Node:{ Text: {
|Node:declaration Text: UINT i;
|Node:type_identifier Text: UINT
|Node:identifier Text: i
|Node:; Text: ;
|Node:for_statement Text: for (i = 0; i < sg_nNoOfChannels; i++)
    {
        if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:assignment_expression Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (sg_asChannel[i].m_OCI_HwHandle == hHandle)
        {
            break;
        }
|Node:if Text: if
|Node:condition_clause Text: (sg_asChannel[i].m_OCI_HwHandle == hHandle)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[i].m_OCI_HwHandle == hHandle
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:== Text: ==
|Node:identifier Text: hHandle
|Node:) Text: )
|Node:compound_statement Text: {
            break;
        }
|Node:{ Text: {
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return (i+1);
|Node:return Text: return
|Node:parenthesized_expression Text: (i+1)
|Node:( Text: (
|Node:binary_expression Text: i+1
|Node:identifier Text: i
|Node:+ Text: +
|Node:number_literal Text: 1
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Create time mod mapping
 */
|Node:function_definition Text: static void vCreateTimeModeMapping(HANDLE hEvent)
{
    WaitForSingleObject(hEvent, INFINITE);
    GetLocalTime(&sg_CurrSysTime);
    /* Query Tick Count */
    QueryPerformanceCounter(&sg_QueryTickCount);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vCreateTimeModeMapping(HANDLE hEvent)
|Node:identifier Text: vCreateTimeModeMapping
|Node:parameter_list Text: (HANDLE hEvent)
|Node:( Text: (
|Node:parameter_declaration Text: HANDLE hEvent
|Node:type_identifier Text: HANDLE
|Node:identifier Text: hEvent
|Node:) Text: )
|Node:compound_statement Text: {
    WaitForSingleObject(hEvent, INFINITE);
    GetLocalTime(&sg_CurrSysTime);
    /* Query Tick Count */
    QueryPerformanceCounter(&sg_QueryTickCount);
}
|Node:{ Text: {
|Node:expression_statement Text: WaitForSingleObject(hEvent, INFINITE);
|Node:call_expression Text: WaitForSingleObject(hEvent, INFINITE)
|Node:identifier Text: WaitForSingleObject
|Node:argument_list Text: (hEvent, INFINITE)
|Node:( Text: (
|Node:identifier Text: hEvent
|Node:, Text: ,
|Node:identifier Text: INFINITE
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: GetLocalTime(&sg_CurrSysTime);
|Node:call_expression Text: GetLocalTime(&sg_CurrSysTime)
|Node:identifier Text: GetLocalTime
|Node:argument_list Text: (&sg_CurrSysTime)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CurrSysTime
|Node:& Text: &
|Node:identifier Text: sg_CurrSysTime
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Query Tick Count */
|Node:expression_statement Text: QueryPerformanceCounter(&sg_QueryTickCount);
|Node:call_expression Text: QueryPerformanceCounter(&sg_QueryTickCount)
|Node:identifier Text: QueryPerformanceCounter
|Node:argument_list Text: (&sg_QueryTickCount)
|Node:( Text: (
|Node:pointer_expression Text: &sg_QueryTickCount
|Node:& Text: &
|Node:identifier Text: sg_QueryTickCount
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * This function writes the message to the corresponding clients buffer
 */
|Node:function_definition Text: static void vWriteIntoClientsBuffer(STCANDATA& sCanData)
{
    /* Write into the client's buffer and Increment message Count */
    if (sCanData.m_ucDataType == TX_FLAG)
    {
        static SACK_MAP sAckMap;
        UINT ClientId = 0;
        static UINT Index = (UINT)-1;
        sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
        sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;

        if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
    }
    else // provide it to everybody
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vWriteIntoClientsBuffer(STCANDATA& sCanData)
|Node:identifier Text: vWriteIntoClientsBuffer
|Node:parameter_list Text: (STCANDATA& sCanData)
|Node:( Text: (
|Node:parameter_declaration Text: STCANDATA& sCanData
|Node:type_identifier Text: STCANDATA
|Node:reference_declarator Text: & sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:compound_statement Text: {
    /* Write into the client's buffer and Increment message Count */
    if (sCanData.m_ucDataType == TX_FLAG)
    {
        static SACK_MAP sAckMap;
        UINT ClientId = 0;
        static UINT Index = (UINT)-1;
        sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
        sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;

        if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
    }
    else // provide it to everybody
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
}
|Node:{ Text: {
|Node:comment Text: /* Write into the client's buffer and Increment message Count */
|Node:if_statement Text: if (sCanData.m_ucDataType == TX_FLAG)
    {
        static SACK_MAP sAckMap;
        UINT ClientId = 0;
        static UINT Index = (UINT)-1;
        sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
        sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;

        if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
    }
    else // provide it to everybody
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (sCanData.m_ucDataType == TX_FLAG)
|Node:( Text: (
|Node:binary_expression Text: sCanData.m_ucDataType == TX_FLAG
|Node:field_expression Text: sCanData.m_ucDataType
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_ucDataType
|Node:== Text: ==
|Node:identifier Text: TX_FLAG
|Node:) Text: )
|Node:compound_statement Text: {
        static SACK_MAP sAckMap;
        UINT ClientId = 0;
        static UINT Index = (UINT)-1;
        sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
        sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;

        if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
    }
|Node:{ Text: {
|Node:declaration Text: static SACK_MAP sAckMap;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: SACK_MAP
|Node:identifier Text: sAckMap
|Node:; Text: ;
|Node:declaration Text: UINT ClientId = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: ClientId = 0
|Node:identifier Text: ClientId
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: static UINT Index = (UINT)-1;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: UINT
|Node:init_declarator Text: Index = (UINT)-1
|Node:identifier Text: Index
|Node:= Text: =
|Node:binary_expression Text: (UINT)-1
|Node:parenthesized_expression Text: (UINT)
|Node:( Text: (
|Node:identifier Text: UINT
|Node:) Text: )
|Node:- Text: -
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:expression_statement Text: sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
|Node:assignment_expression Text: sAckMap.m_Channel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sAckMap.m_Channel
|Node:identifier Text: sAckMap
|Node:. Text: .
|Node:field_identifier Text: m_Channel
|Node:= Text: =
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:; Text: ;
|Node:expression_statement Text: sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID;
|Node:assignment_expression Text: sAckMap.m_MsgID = sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID
|Node:field_expression Text: sAckMap.m_MsgID
|Node:identifier Text: sAckMap
|Node:. Text: .
|Node:field_identifier Text: m_MsgID
|Node:= Text: =
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_unMsgID
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:; Text: ;
|Node:if_statement Text: if (bRemoveMapEntry(sAckMap, ClientId))
        {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
|Node:if Text: if
|Node:condition_clause Text: (bRemoveMapEntry(sAckMap, ClientId))
|Node:( Text: (
|Node:call_expression Text: bRemoveMapEntry(sAckMap, ClientId)
|Node:identifier Text: bRemoveMapEntry
|Node:argument_list Text: (sAckMap, ClientId)
|Node:( Text: (
|Node:identifier Text: sAckMap
|Node:, Text: ,
|Node:identifier Text: ClientId
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            BOOL bClientExists = bGetClientObj(ClientId, Index);
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
        }
|Node:{ Text: {
|Node:declaration Text: BOOL bClientExists = bGetClientObj(ClientId, Index);
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bClientExists = bGetClientObj(ClientId, Index)
|Node:identifier Text: bClientExists
|Node:= Text: =
|Node:call_expression Text: bGetClientObj(ClientId, Index)
|Node:identifier Text: bGetClientObj
|Node:argument_list Text: (ClientId, Index)
|Node:( Text: (
|Node:identifier Text: ClientId
|Node:, Text: ,
|Node:identifier Text: Index
|Node:) Text: )
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_unClientCnt
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                /* Tx for monitor nodes and sender node */
                if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
            }
|Node:{ Text: {
|Node:comment Text: /* Tx for monitor nodes and sender node */
|Node:if_statement Text: if (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
                {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
                else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
|Node:if Text: if
|Node:condition_clause Text: (/*(i == CAN_MONITOR_NODE_INDEX)  ||*/(bClientExists && (i == Index)))
|Node:( Text: (
|Node:comment Text: /*(i == CAN_MONITOR_NODE_INDEX)  ||*/
|Node:parenthesized_expression Text: (bClientExists && (i == Index))
|Node:( Text: (
|Node:binary_expression Text: bClientExists && (i == Index)
|Node:identifier Text: bClientExists
|Node:&& Text: &&
|Node:parenthesized_expression Text: (i == Index)
|Node:( Text: (
|Node:binary_expression Text: i == Index
|Node:identifier Text: i
|Node:== Text: ==
|Node:identifier Text: Index
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
                }
|Node:{ Text: {
|Node:for_statement Text: for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT j = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: j = 0
|Node:identifier Text: j
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: j < sg_asClientToBufMap[i].m_unBufCount
|Node:identifier Text: j
|Node:< Text: <
|Node:field_expression Text: sg_asClientToBufMap[i].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: j++
|Node:identifier Text: j
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
                    }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
|Node:call_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData)
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer
|Node:subscript_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [j]
|Node:[ Text: [
|Node:identifier Text: j
|Node:] Text: ]
|Node:-> Text: ->
|Node:field_identifier Text: WriteIntoBuffer
|Node:argument_list Text: (&sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
                {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    /* Send the other nodes as Rx. */
                    for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
                }
|Node:{ Text: {
|Node:comment Text: /* Send the other nodes as Rx. */
|Node:for_statement Text: for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
                    {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT j = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: j = 0
|Node:identifier Text: j
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: j < sg_asClientToBufMap[i].m_unBufCount
|Node:identifier Text: j
|Node:< Text: <
|Node:field_expression Text: sg_asClientToBufMap[i].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: j++
|Node:identifier Text: j
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                        static STCANDATA sTempCanData;
                        sTempCanData = sCanData;
                        sTempCanData.m_ucDataType = RX_FLAG;
                        sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
                    }
|Node:{ Text: {
|Node:declaration Text: static STCANDATA sTempCanData;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: STCANDATA
|Node:identifier Text: sTempCanData
|Node:; Text: ;
|Node:expression_statement Text: sTempCanData = sCanData;
|Node:assignment_expression Text: sTempCanData = sCanData
|Node:identifier Text: sTempCanData
|Node:= Text: =
|Node:identifier Text: sCanData
|Node:; Text: ;
|Node:expression_statement Text: sTempCanData.m_ucDataType = RX_FLAG;
|Node:assignment_expression Text: sTempCanData.m_ucDataType = RX_FLAG
|Node:field_expression Text: sTempCanData.m_ucDataType
|Node:identifier Text: sTempCanData
|Node:. Text: .
|Node:field_identifier Text: m_ucDataType
|Node:= Text: =
|Node:identifier Text: RX_FLAG
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData);
|Node:call_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sTempCanData)
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer
|Node:subscript_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [j]
|Node:[ Text: [
|Node:identifier Text: j
|Node:] Text: ]
|Node:-> Text: ->
|Node:field_identifier Text: WriteIntoBuffer
|Node:argument_list Text: (&sTempCanData)
|Node:( Text: (
|Node:pointer_expression Text: &sTempCanData
|Node:& Text: &
|Node:identifier Text: sTempCanData
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else // provide it to everybody
    {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
|Node:else Text: else
|Node:comment Text: // provide it to everybody
|Node:compound_statement Text: {
        for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
    }
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
        {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_unClientCnt
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
            for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
        }
|Node:{ Text: {
|Node:for_statement Text: for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
            {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT j = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: j = 0
|Node:identifier Text: j
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: j < sg_asClientToBufMap[i].m_unBufCount
|Node:identifier Text: j
|Node:< Text: <
|Node:field_expression Text: sg_asClientToBufMap[i].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: j++
|Node:identifier Text: j
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
|Node:call_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData)
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer
|Node:subscript_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [j]
|Node:[ Text: [
|Node:identifier Text: j
|Node:] Text: ]
|Node:-> Text: ->
|Node:field_identifier Text: WriteIntoBuffer
|Node:argument_list Text: (&sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * Processes Rx msg and writes into regiastered clients buffer.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessRxMsg(void* userData, struct OCI_CANMessageEx* msg)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessRxMsg(void* userData, struct OCI_CANMessageEx* msg)
|Node:identifier Text: vProcessRxMsg
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessRxMsg(void* userData, struct OCI_CANMessage* msg)
#endif
{
    /* First calculate timestamp for first message*/
    EnterCriticalSection(&sg_DIL_CriticalSection);

    static STCANDATA sCanData;
    static OCI_ControllerHandle hHandle;

    hHandle = (OCI_ControllerHandle)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel(hHandle);

    if ( msg->type == OCI_CAN_RX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
        vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
    }
#if BOA_VERSION >= BOA_VERSION_2_0
    /* Check if its a CAN FD message */
    else if ( msg->type ==  OCI_CANFDRX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
        vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
    }
#endif

    if (sg_byCurrState == CREATE_MAP_TIMESTAMP)
    {
        // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);
        sg_byCurrState = CALC_TIMESTAMP_READY;


        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;

        /* Time difference should be +ve value */
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
    }

    /* Write the msg into registered client's buffer */
    vWriteIntoClientsBuffer(sCanData);

    LeaveCriticalSection(&sg_DIL_CriticalSection);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessRxMsg(void* userData, struct OCI_CANMessage* msg)
|Node:identifier Text: vProcessRxMsg
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
    /* First calculate timestamp for first message*/
    EnterCriticalSection(&sg_DIL_CriticalSection);

    static STCANDATA sCanData;
    static OCI_ControllerHandle hHandle;

    hHandle = (OCI_ControllerHandle)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel(hHandle);

    if ( msg->type == OCI_CAN_RX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
        vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
    }
#if BOA_VERSION >= BOA_VERSION_2_0
    /* Check if its a CAN FD message */
    else if ( msg->type ==  OCI_CANFDRX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
        vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
    }
#endif

    if (sg_byCurrState == CREATE_MAP_TIMESTAMP)
    {
        // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);
        sg_byCurrState = CALC_TIMESTAMP_READY;


        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;

        /* Time difference should be +ve value */
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
    }

    /* Write the msg into registered client's buffer */
    vWriteIntoClientsBuffer(sCanData);

    LeaveCriticalSection(&sg_DIL_CriticalSection);
}
|Node:{ Text: {
|Node:comment Text: /* First calculate timestamp for first message*/
|Node:expression_statement Text: EnterCriticalSection(&sg_DIL_CriticalSection);
|Node:call_expression Text: EnterCriticalSection(&sg_DIL_CriticalSection)
|Node:identifier Text: EnterCriticalSection
|Node:argument_list Text: (&sg_DIL_CriticalSection)
|Node:( Text: (
|Node:pointer_expression Text: &sg_DIL_CriticalSection
|Node:& Text: &
|Node:identifier Text: sg_DIL_CriticalSection
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: static STCANDATA sCanData;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: STCANDATA
|Node:identifier Text: sCanData
|Node:; Text: ;
|Node:declaration Text: static OCI_ControllerHandle hHandle;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: OCI_ControllerHandle
|Node:identifier Text: hHandle
|Node:; Text: ;
|Node:expression_statement Text: hHandle = (OCI_ControllerHandle)userData;
|Node:assignment_expression Text: hHandle = (OCI_ControllerHandle)userData
|Node:identifier Text: hHandle
|Node:= Text: =
|Node:cast_expression Text: (OCI_ControllerHandle)userData
|Node:( Text: (
|Node:type_descriptor Text: OCI_ControllerHandle
|Node:type_identifier Text: OCI_ControllerHandle
|Node:) Text: )
|Node:identifier Text: userData
|Node:; Text: ;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel(hHandle);
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel(hHandle)
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:= Text: =
|Node:cast_expression Text: (UCHAR)nGetChannel(hHandle)
|Node:( Text: (
|Node:type_descriptor Text: UCHAR
|Node:type_identifier Text: UCHAR
|Node:) Text: )
|Node:call_expression Text: nGetChannel(hHandle)
|Node:identifier Text: nGetChannel
|Node:argument_list Text: (hHandle)
|Node:( Text: (
|Node:identifier Text: hHandle
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if ( msg->type == OCI_CAN_RX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
        vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
    }
|Node:if Text: if
|Node:condition_clause Text: ( msg->type == OCI_CAN_RX_MESSAGE )
|Node:( Text: (
|Node:binary_expression Text: msg->type == OCI_CAN_RX_MESSAGE
|Node:field_expression Text: msg->type
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: type
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_RX_MESSAGE
|Node:) Text: )
|Node:compound_statement Text: {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
        vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
    }
|Node:{ Text: {
|Node:comment Text: // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = false;
|Node:expression_statement Text: vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData);
|Node:call_expression Text: vCopyOCI_CAN_RX_2_DATA(&(msg->data.rxMessage), &sCanData)
|Node:identifier Text: vCopyOCI_CAN_RX_2_DATA
|Node:argument_list Text: (&(msg->data.rxMessage), &sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &(msg->data.rxMessage)
|Node:& Text: &
|Node:parenthesized_expression Text: (msg->data.rxMessage)
|Node:( Text: (
|Node:field_expression Text: msg->data.rxMessage
|Node:field_expression Text: msg->data
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: rxMessage
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false;
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = false
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_bCANFD
|Node:= Text: =
|Node:false Text: false
|Node:; Text: ;
|Node:} Text: }
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
    /* Check if its a CAN FD message */
    else if ( msg->type ==  OCI_CANFDRX_MESSAGE )
    {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
        vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
    }
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:comment Text: /* Check if its a CAN FD message */
|Node:declaration Text: else if ( msg->type ==  OCI_CANFDRX_MESSAGE )
|Node:type_identifier Text: else
|Node:init_declarator Text: if ( msg->type ==  OCI_CANFDRX_MESSAGE )
|Node:identifier Text: if
|Node:argument_list Text: ( msg->type ==  OCI_CANFDRX_MESSAGE )
|Node:( Text: (
|Node:binary_expression Text: msg->type ==  OCI_CANFDRX_MESSAGE
|Node:field_expression Text: msg->type
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: type
|Node:== Text: ==
|Node:identifier Text: OCI_CANFDRX_MESSAGE
|Node:) Text: )
|Node:; Text: 
|Node:compound_statement Text: {
        // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
        vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
        sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
    }
|Node:{ Text: {
|Node:comment Text: // sCanData.m_uDataInfo.m_sCANMsg.m_bCANFDMsg = true;
|Node:expression_statement Text: vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData);
|Node:call_expression Text: vCopyOCI_CAN_FD_RX_2_DATA(&(msg->data.canFDRxMessage), &sCanData)
|Node:identifier Text: vCopyOCI_CAN_FD_RX_2_DATA
|Node:argument_list Text: (&(msg->data.canFDRxMessage), &sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &(msg->data.canFDRxMessage)
|Node:& Text: &
|Node:parenthesized_expression Text: (msg->data.canFDRxMessage)
|Node:( Text: (
|Node:field_expression Text: msg->data.canFDRxMessage
|Node:field_expression Text: msg->data
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: canFDRxMessage
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true;
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD = true
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_bCANFD
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_bCANFD
|Node:= Text: =
|Node:true Text: true
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:if_statement Text: if (sg_byCurrState == CREATE_MAP_TIMESTAMP)
    {
        // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);
        sg_byCurrState = CALC_TIMESTAMP_READY;


        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;

        /* Time difference should be +ve value */
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_byCurrState == CREATE_MAP_TIMESTAMP)
|Node:( Text: (
|Node:binary_expression Text: sg_byCurrState == CREATE_MAP_TIMESTAMP
|Node:identifier Text: sg_byCurrState
|Node:== Text: ==
|Node:identifier Text: CREATE_MAP_TIMESTAMP
|Node:) Text: )
|Node:compound_statement Text: {
        // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);
        sg_byCurrState = CALC_TIMESTAMP_READY;


        LARGE_INTEGER g_QueryTickCount;
        QueryPerformanceCounter(&g_QueryTickCount);
        UINT64 unConnectionTime;
        unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;

        /* Time difference should be +ve value */
        if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
    }
|Node:{ Text: {
|Node:comment Text: // sg_TimeStamp = sCanData.m_lTickCount.QuadPart;
|Node:expression_statement Text: SetEvent(sg_hEvent);
|Node:call_expression Text: SetEvent(sg_hEvent)
|Node:identifier Text: SetEvent
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: vCreateTimeModeMapping(sg_hEvent);
|Node:call_expression Text: vCreateTimeModeMapping(sg_hEvent)
|Node:identifier Text: vCreateTimeModeMapping
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_byCurrState = CALC_TIMESTAMP_READY;
|Node:assignment_expression Text: sg_byCurrState = CALC_TIMESTAMP_READY
|Node:identifier Text: sg_byCurrState
|Node:= Text: =
|Node:identifier Text: CALC_TIMESTAMP_READY
|Node:; Text: ;
|Node:declaration Text: LARGE_INTEGER g_QueryTickCount;
|Node:type_identifier Text: LARGE_INTEGER
|Node:identifier Text: g_QueryTickCount
|Node:; Text: ;
|Node:expression_statement Text: QueryPerformanceCounter(&g_QueryTickCount);
|Node:call_expression Text: QueryPerformanceCounter(&g_QueryTickCount)
|Node:identifier Text: QueryPerformanceCounter
|Node:argument_list Text: (&g_QueryTickCount)
|Node:( Text: (
|Node:pointer_expression Text: &g_QueryTickCount
|Node:& Text: &
|Node:identifier Text: g_QueryTickCount
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: UINT64 unConnectionTime;
|Node:type_identifier Text: UINT64
|Node:identifier Text: unConnectionTime
|Node:; Text: ;
|Node:expression_statement Text: unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp;
|Node:assignment_expression Text: unConnectionTime = ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp
|Node:identifier Text: unConnectionTime
|Node:= Text: =
|Node:binary_expression Text: ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart) - sg_TimeStamp
|Node:parenthesized_expression Text: ((g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart)
|Node:( Text: (
|Node:binary_expression Text: (g_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|Node:parenthesized_expression Text: (g_QueryTickCount.QuadPart * 10000)
|Node:( Text: (
|Node:binary_expression Text: g_QueryTickCount.QuadPart * 10000
|Node:field_expression Text: g_QueryTickCount.QuadPart
|Node:identifier Text: g_QueryTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:* Text: *
|Node:number_literal Text: 10000
|Node:) Text: )
|Node:/ Text: /
|Node:field_expression Text: sg_lnFrequency.QuadPart
|Node:identifier Text: sg_lnFrequency
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:) Text: )
|Node:- Text: -
|Node:identifier Text: sg_TimeStamp
|Node:; Text: ;
|Node:comment Text: /* Time difference should be +ve value */
|Node:if_statement Text: if(sCanData.m_lTickCount.QuadPart >= unConnectionTime)
        {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
        else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|Node:if Text: if
|Node:condition_clause Text: (sCanData.m_lTickCount.QuadPart >= unConnectionTime)
|Node:( Text: (
|Node:binary_expression Text: sCanData.m_lTickCount.QuadPart >= unConnectionTime
|Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|Node:field_expression Text: sCanData.m_lTickCount
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:>= Text: >=
|Node:identifier Text: unConnectionTime
|Node:) Text: )
|Node:compound_statement Text: {
            sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime);
|Node:assignment_expression Text: sg_TimeStamp  = (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime)
|Node:identifier Text: sg_TimeStamp
|Node:= Text: =
|Node:call_expression Text: (LONGLONG)(sCanData.m_lTickCount.QuadPart - unConnectionTime)
|Node:parenthesized_expression Text: (LONGLONG)
|Node:( Text: (
|Node:identifier Text: LONGLONG
|Node:) Text: )
|Node:argument_list Text: (sCanData.m_lTickCount.QuadPart - unConnectionTime)
|Node:( Text: (
|Node:binary_expression Text: sCanData.m_lTickCount.QuadPart - unConnectionTime
|Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|Node:field_expression Text: sCanData.m_lTickCount
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:- Text: -
|Node:identifier Text: unConnectionTime
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|Node:else Text: else
|Node:compound_statement Text: {
            sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart);
|Node:assignment_expression Text: sg_TimeStamp  = (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart)
|Node:identifier Text: sg_TimeStamp
|Node:= Text: =
|Node:call_expression Text: (LONGLONG)(unConnectionTime - sCanData.m_lTickCount.QuadPart)
|Node:parenthesized_expression Text: (LONGLONG)
|Node:( Text: (
|Node:identifier Text: LONGLONG
|Node:) Text: )
|Node:argument_list Text: (unConnectionTime - sCanData.m_lTickCount.QuadPart)
|Node:( Text: (
|Node:binary_expression Text: unConnectionTime - sCanData.m_lTickCount.QuadPart
|Node:identifier Text: unConnectionTime
|Node:- Text: -
|Node:field_expression Text: sCanData.m_lTickCount.QuadPart
|Node:field_expression Text: sCanData.m_lTickCount
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Write the msg into registered client's buffer */
|Node:expression_statement Text: vWriteIntoClientsBuffer(sCanData);
|Node:call_expression Text: vWriteIntoClientsBuffer(sCanData)
|Node:identifier Text: vWriteIntoClientsBuffer
|Node:argument_list Text: (sCanData)
|Node:( Text: (
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: LeaveCriticalSection(&sg_DIL_CriticalSection);
|Node:call_expression Text: LeaveCriticalSection(&sg_DIL_CriticalSection)
|Node:identifier Text: LeaveCriticalSection
|Node:argument_list Text: (&sg_DIL_CriticalSection)
|Node:( Text: (
|Node:pointer_expression Text: &sg_DIL_CriticalSection
|Node:& Text: &
|Node:identifier Text: sg_DIL_CriticalSection
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Processes Tx msg.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessTxMsg(void* /*userData*/, OCI_CANMessageEx* /*msg*/)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessTxMsg(void* /*userData*/, OCI_CANMessageEx* /*msg*/)
|Node:identifier Text: vProcessTxMsg
|Node:parameter_list Text: (void* /*userData*/, OCI_CANMessageEx* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_CANMessageEx*
|Node:type_identifier Text: OCI_CANMessageEx
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessTxMsg(void* /*userData*/, OCI_CANMessage* /*msg*/)
#endif
{
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessTxMsg(void* /*userData*/, OCI_CANMessage* /*msg*/)
|Node:identifier Text: vProcessTxMsg
|Node:parameter_list Text: (void* /*userData*/, OCI_CANMessage* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: OCI_CANMessage*
|Node:type_identifier Text: OCI_CANMessage
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
}
|Node:{ Text: {
|Node:} Text: }
|Node:comment Text: /**
 * Copies OCI_CANErrorFrameMessage struct into STCANDATA.
 */
|Node:function_definition Text: static void vCopyOCI_CAN_ERR_2_DATA(const OCI_CANErrorFrameMessage* SrcMsg, STCANDATA* DestMsg)
{
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_lTickCount.QuadPart = SrcMsg->timeStamp;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0;
    DestMsg->m_ucDataType = ERR_FLAG;
    BOOL bIsTx = (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION;
    if (bIsTx)
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
    }
    else
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
    switch (SrcMsg->type)
    {
        /* stuff error */
        case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;

        /* form error */
        case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;

        /* bit error */
        case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;

        /* other error */
        case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;

        /* crc error */
        case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;

        /* acknowledgement error */
        case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;

        /* other error categories currently just map to ERROR_UNKNOWN */
        case OCI_CAN_ERR_TYPE_OVERLOAD:
        case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
        case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
        default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vCopyOCI_CAN_ERR_2_DATA(const OCI_CANErrorFrameMessage* SrcMsg, STCANDATA* DestMsg)
|Node:identifier Text: vCopyOCI_CAN_ERR_2_DATA
|Node:parameter_list Text: (const OCI_CANErrorFrameMessage* SrcMsg, STCANDATA* DestMsg)
|Node:( Text: (
|Node:parameter_declaration Text: const OCI_CANErrorFrameMessage* SrcMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: OCI_CANErrorFrameMessage
|Node:pointer_declarator Text: * SrcMsg
|Node:* Text: *
|Node:identifier Text: SrcMsg
|Node:, Text: ,
|Node:parameter_declaration Text: STCANDATA* DestMsg
|Node:type_identifier Text: STCANDATA
|Node:pointer_declarator Text: * DestMsg
|Node:* Text: *
|Node:identifier Text: DestMsg
|Node:) Text: )
|Node:compound_statement Text: {
    DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
    DestMsg->m_lTickCount.QuadPart = SrcMsg->timeStamp;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0;
    DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0;
    DestMsg->m_ucDataType = ERR_FLAG;
    BOOL bIsTx = (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION;
    if (bIsTx)
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
    }
    else
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
    switch (SrcMsg->type)
    {
        /* stuff error */
        case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;

        /* form error */
        case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;

        /* bit error */
        case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;

        /* other error */
        case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;

        /* crc error */
        case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;

        /* acknowledgement error */
        case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;

        /* other error categories currently just map to ERROR_UNKNOWN */
        case OCI_CAN_ERR_TYPE_OVERLOAD:
        case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
        case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
        default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
    }
}
|Node:{ Text: {
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID = SrcMsg->frameID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_unMsgID
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:= Text: =
|Node:field_expression Text: SrcMsg->frameID
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: frameID
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen = SrcMsg->dlc
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucDataLen
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:= Text: =
|Node:field_expression Text: SrcMsg->dlc
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: dlc
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_lTickCount.QuadPart = SrcMsg->timeStamp;
|Node:assignment_expression Text: DestMsg->m_lTickCount.QuadPart = SrcMsg->timeStamp
|Node:field_expression Text: DestMsg->m_lTickCount.QuadPart
|Node:field_expression Text: DestMsg->m_lTickCount
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_lTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:= Text: =
|Node:field_expression Text: SrcMsg->timeStamp
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: timeStamp
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucEXTENDED
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucEXTENDED
|Node:= Text: =
|Node:conditional_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED) ? 1 : 0
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_EXTENDED
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:) Text: )
|Node:? Text: ?
|Node:number_literal Text: 1
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR   = (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg.m_ucRTR
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sCANMsg
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucRTR
|Node:= Text: =
|Node:conditional_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME) ? 1 : 0
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:) Text: )
|Node:? Text: ?
|Node:number_literal Text: 1
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg->m_ucDataType = ERR_FLAG;
|Node:assignment_expression Text: DestMsg->m_ucDataType = ERR_FLAG
|Node:field_expression Text: DestMsg->m_ucDataType
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_ucDataType
|Node:= Text: =
|Node:identifier Text: ERR_FLAG
|Node:; Text: ;
|Node:declaration Text: BOOL bIsTx = (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bIsTx = (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:identifier Text: bIsTx
|Node:= Text: =
|Node:binary_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION) == OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:parenthesized_expression Text: (SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg->flags & OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:field_expression Text: SrcMsg->flags
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: flags
|Node:& Text: &
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: OCI_CAN_MSG_FLAG_SELFRECEPTION
|Node:; Text: ;
|Node:if_statement Text: if (bIsTx)
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
    }
    else
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
|Node:if Text: if
|Node:condition_clause Text: (bIsTx)
|Node:( Text: (
|Node:identifier Text: bIsTx
|Node:) Text: )
|Node:compound_statement Text: {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
    }
|Node:{ Text: {
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount += 1
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucTxErrCount
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrCount
|Node:+= Text: +=
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
    {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
|Node:else Text: else
|Node:compound_statement Text: {
        DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
    }
|Node:{ Text: {
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount += 1
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucRxErrCount
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrCount
|Node:+= Text: +=
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:} Text: }
|Node:switch_statement Text: switch (SrcMsg->type)
    {
        /* stuff error */
        case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;

        /* form error */
        case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;

        /* bit error */
        case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;

        /* other error */
        case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;

        /* crc error */
        case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;

        /* acknowledgement error */
        case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;

        /* other error categories currently just map to ERROR_UNKNOWN */
        case OCI_CAN_ERR_TYPE_OVERLOAD:
        case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
        case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
        default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
    }
|Node:switch Text: switch
|Node:condition_clause Text: (SrcMsg->type)
|Node:( Text: (
|Node:field_expression Text: SrcMsg->type
|Node:identifier Text: SrcMsg
|Node:-> Text: ->
|Node:field_identifier Text: type
|Node:) Text: )
|Node:compound_statement Text: {
        /* stuff error */
        case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;

        /* form error */
        case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;

        /* bit error */
        case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;

        /* other error */
        case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;

        /* crc error */
        case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;

        /* acknowledgement error */
        case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;

        /* other error categories currently just map to ERROR_UNKNOWN */
        case OCI_CAN_ERR_TYPE_OVERLOAD:
        case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
        case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
        default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
    }
|Node:{ Text: {
|Node:comment Text: /* stuff error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_BITSTUFF:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_BITSTUFF
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? STUFF_ERROR_TX : STUFF_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: STUFF_ERROR_TX
|Node:: Text: :
|Node:identifier Text: STUFF_ERROR_RX
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:comment Text: /* form error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_FORMAT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_FORMAT
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? FORM_ERROR_TX : FORM_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: FORM_ERROR_TX
|Node:: Text: :
|Node:identifier Text: FORM_ERROR_RX
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:comment Text: /* bit error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_BIT:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? BIT_ERROR_TX : BIT_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: BIT_ERROR_TX
|Node:: Text: :
|Node:identifier Text: BIT_ERROR_RX
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:comment Text: /* other error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_OTHER:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_OTHER
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? OTHER_ERROR_TX : OTHER_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: OTHER_ERROR_TX
|Node:: Text: :
|Node:identifier Text: OTHER_ERROR_RX
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:comment Text: /* crc error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_CRC:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_CRC
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? CRC_ERROR_TX : CRC_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: CRC_ERROR_TX
|Node:: Text: :
|Node:identifier Text: CRC_ERROR_RX
|Node:; Text: ;
|Node:comment Text: /* acknowledgement error */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_ACK:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_ACK
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:conditional_expression Text: bIsTx ? ACK_ERROR_TX : ACK_ERROR_RX
|Node:identifier Text: bIsTx
|Node:? Text: ?
|Node:identifier Text: ACK_ERROR_TX
|Node:: Text: :
|Node:identifier Text: ACK_ERROR_RX
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:comment Text: /* other error categories currently just map to ERROR_UNKNOWN */
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_OVERLOAD:
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_OVERLOAD
|Node:: Text: :
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV:
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
|Node:: Text: :
|Node:case_statement Text: case OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT:
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
|Node:: Text: :
|Node:case_statement Text: default:
            DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
            break;
|Node:default Text: default
|Node:: Text: :
|Node:expression_statement Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN;
|Node:assignment_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType = ERROR_UNKNOWN
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo.m_ucErrType
|Node:field_expression Text: DestMsg->m_uDataInfo.m_sErrInfo
|Node:field_expression Text: DestMsg->m_uDataInfo
|Node:identifier Text: DestMsg
|Node:-> Text: ->
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucErrType
|Node:= Text: =
|Node:identifier Text: ERROR_UNKNOWN
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * Updates Tx and Rx error counter of the nChannel
 */
|Node:function_definition Text: static void vUpdateErrorCounter(UCHAR ucTxError, UCHAR ucRxError, UINT nChannel)
{
    /* Update Tx Error counter and peak Tx Error Counter */
    sg_asChannel[nChannel].m_ucTxErrorCounter = sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError;

    /* Update Peak Value */
    if( ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
    }

    /* Update Rx Error counter and peak Rx Error Counter */
    sg_asChannel[nChannel].m_ucRxErrorCounter = sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError;

    /* Update Peak Value */
    if( ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vUpdateErrorCounter(UCHAR ucTxError, UCHAR ucRxError, UINT nChannel)
|Node:identifier Text: vUpdateErrorCounter
|Node:parameter_list Text: (UCHAR ucTxError, UCHAR ucRxError, UINT nChannel)
|Node:( Text: (
|Node:parameter_declaration Text: UCHAR ucTxError
|Node:type_identifier Text: UCHAR
|Node:identifier Text: ucTxError
|Node:, Text: ,
|Node:parameter_declaration Text: UCHAR ucRxError
|Node:type_identifier Text: UCHAR
|Node:identifier Text: ucRxError
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:) Text: )
|Node:compound_statement Text: {
    /* Update Tx Error counter and peak Tx Error Counter */
    sg_asChannel[nChannel].m_ucTxErrorCounter = sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError;

    /* Update Peak Value */
    if( ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
    }

    /* Update Rx Error counter and peak Rx Error Counter */
    sg_asChannel[nChannel].m_ucRxErrorCounter = sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError;

    /* Update Peak Value */
    if( ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
    }
}
|Node:{ Text: {
|Node:comment Text: /* Update Tx Error counter and peak Tx Error Counter */
|Node:expression_statement Text: sg_asChannel[nChannel].m_ucTxErrorCounter = sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_ucTxErrorCounter = sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrorCounter
|Node:= Text: =
|Node:binary_expression Text: sg_asChannel[nChannel].m_ucTxErrorCounter + ucTxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrorCounter
|Node:+ Text: +
|Node:identifier Text: ucTxError
|Node:; Text: ;
|Node:comment Text: /* Update Peak Value */
|Node:if_statement Text: if( ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
    }
|Node:if Text: if
|Node:condition_clause Text: ( ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter )
|Node:( Text: (
|Node:binary_expression Text: ucTxError > sg_asChannel[nChannel].m_ucPeakTxErrorCounter
|Node:identifier Text: ucTxError
|Node:> Text: >
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakTxErrorCounter
|Node:) Text: )
|Node:compound_statement Text: {
        sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_ucPeakTxErrorCounter = ucTxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakTxErrorCounter
|Node:= Text: =
|Node:identifier Text: ucTxError
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Update Rx Error counter and peak Rx Error Counter */
|Node:expression_statement Text: sg_asChannel[nChannel].m_ucRxErrorCounter = sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_ucRxErrorCounter = sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrorCounter
|Node:= Text: =
|Node:binary_expression Text: sg_asChannel[nChannel].m_ucRxErrorCounter + ucRxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrorCounter
|Node:+ Text: +
|Node:identifier Text: ucRxError
|Node:; Text: ;
|Node:comment Text: /* Update Peak Value */
|Node:if_statement Text: if( ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter )
    {
        sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
    }
|Node:if Text: if
|Node:condition_clause Text: ( ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter )
|Node:( Text: (
|Node:binary_expression Text: ucRxError > sg_asChannel[nChannel].m_ucPeakRxErrorCounter
|Node:identifier Text: ucRxError
|Node:> Text: >
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakRxErrorCounter
|Node:) Text: )
|Node:compound_statement Text: {
        sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError;
|Node:assignment_expression Text: sg_asChannel[nChannel].m_ucPeakRxErrorCounter = ucRxError
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakRxErrorCounter
|Node:= Text: =
|Node:identifier Text: ucRxError
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * Processes error msg and writes into registered clients buffer.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessErrMsg(void* userData, struct OCI_CANMessageEx* msg)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessErrMsg(void* userData, struct OCI_CANMessageEx* msg)
|Node:identifier Text: vProcessErrMsg
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessErrMsg(void* userData, struct OCI_CANMessage* msg)
#endif
{
    static STCANDATA sCanData;
    vCopyOCI_CAN_ERR_2_DATA(&(msg->data.errorFrameMessage), &sCanData);
    // int32* pUserData = (int32*)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = 0;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel((OCI_ControllerHandle)userData);
    sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;

    /*  Update channel error counter */
    vUpdateErrorCounter(sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel);

    /* Write the msg into registered client's buffer */
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessErrMsg(void* userData, struct OCI_CANMessage* msg)
|Node:identifier Text: vProcessErrMsg
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
    static STCANDATA sCanData;
    vCopyOCI_CAN_ERR_2_DATA(&(msg->data.errorFrameMessage), &sCanData);
    // int32* pUserData = (int32*)userData;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = 0;
    sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel((OCI_ControllerHandle)userData);
    sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;

    /*  Update channel error counter */
    vUpdateErrorCounter(sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel);

    /* Write the msg into registered client's buffer */
    for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
    }
}
|Node:{ Text: {
|Node:declaration Text: static STCANDATA sCanData;
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: STCANDATA
|Node:identifier Text: sCanData
|Node:; Text: ;
|Node:expression_statement Text: vCopyOCI_CAN_ERR_2_DATA(&(msg->data.errorFrameMessage), &sCanData);
|Node:call_expression Text: vCopyOCI_CAN_ERR_2_DATA(&(msg->data.errorFrameMessage), &sCanData)
|Node:identifier Text: vCopyOCI_CAN_ERR_2_DATA
|Node:argument_list Text: (&(msg->data.errorFrameMessage), &sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &(msg->data.errorFrameMessage)
|Node:& Text: &
|Node:parenthesized_expression Text: (msg->data.errorFrameMessage)
|Node:( Text: (
|Node:field_expression Text: msg->data.errorFrameMessage
|Node:field_expression Text: msg->data
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: errorFrameMessage
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // int32* pUserData = (int32*)userData;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = 0;
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen = 0
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucDataLen
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel((OCI_ControllerHandle)userData);
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel = (UCHAR)nGetChannel((OCI_ControllerHandle)userData)
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:= Text: =
|Node:cast_expression Text: (UCHAR)nGetChannel((OCI_ControllerHandle)userData)
|Node:( Text: (
|Node:type_descriptor Text: UCHAR
|Node:type_identifier Text: UCHAR
|Node:) Text: )
|Node:call_expression Text: nGetChannel((OCI_ControllerHandle)userData)
|Node:identifier Text: nGetChannel
|Node:argument_list Text: ((OCI_ControllerHandle)userData)
|Node:( Text: (
|Node:cast_expression Text: (OCI_ControllerHandle)userData
|Node:( Text: (
|Node:type_descriptor Text: OCI_ControllerHandle
|Node:type_identifier Text: OCI_ControllerHandle
|Node:) Text: )
|Node:identifier Text: userData
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel;
|Node:assignment_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel = sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:= Text: =
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sCANMsg
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sCANMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:; Text: ;
|Node:comment Text: /*  Update channel error counter */
|Node:expression_statement Text: vUpdateErrorCounter(sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel);
|Node:call_expression Text: vUpdateErrorCounter(sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel)
|Node:identifier Text: vUpdateErrorCounter
|Node:argument_list Text: (sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount,
                        sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel)
|Node:( Text: (
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucTxErrCount
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrCount
|Node:, Text: ,
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucRxErrCount
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrCount
|Node:, Text: ,
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo.m_ucChannel
|Node:field_expression Text: sCanData.m_uDataInfo.m_sErrInfo
|Node:field_expression Text: sCanData.m_uDataInfo
|Node:identifier Text: sCanData
|Node:. Text: .
|Node:field_identifier Text: m_uDataInfo
|Node:. Text: .
|Node:field_identifier Text: m_sErrInfo
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Write the msg into registered client's buffer */
|Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
    {
        for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_unClientCnt
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
    }
|Node:{ Text: {
|Node:for_statement Text: for (UINT j = 0; j < sg_asClientToBufMap[i].m_unBufCount; j++)
        {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT j = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: j = 0
|Node:identifier Text: j
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: j < sg_asClientToBufMap[i].m_unBufCount
|Node:identifier Text: j
|Node:< Text: <
|Node:field_expression Text: sg_asClientToBufMap[i].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: j++
|Node:identifier Text: j
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
            sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData);
|Node:call_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer(&sCanData)
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]->WriteIntoBuffer
|Node:subscript_expression Text: sg_asClientToBufMap[i].m_pClientBuf[j]
|Node:field_expression Text: sg_asClientToBufMap[i].m_pClientBuf
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [j]
|Node:[ Text: [
|Node:identifier Text: j
|Node:] Text: ]
|Node:-> Text: ->
|Node:field_identifier Text: WriteIntoBuffer
|Node:argument_list Text: (&sCanData)
|Node:( Text: (
|Node:pointer_expression Text: &sCanData
|Node:& Text: &
|Node:identifier Text: sCanData
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * Callback function called by the BOA framework
 * when there is presence of msg in the bus.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessageEx* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessCanData)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessCanData
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessCanData
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->type)
    {
        case OCI_CAN_RX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
            vProcessRxMsg(userData, msg);
            break;
        case OCI_CAN_TX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
            vProcessTxMsg(userData, msg);
            break;

    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessCanData)(void* userData, struct OCI_CANMessage* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessCanData)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessCanData
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessCanData
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
    switch (msg->type)
    {
        case OCI_CAN_RX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
            vProcessRxMsg(userData, msg);
            break;
        case OCI_CAN_TX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
            vProcessTxMsg(userData, msg);
            break;

    }
}
|Node:{ Text: {
|Node:switch_statement Text: switch (msg->type)
    {
        case OCI_CAN_RX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
            vProcessRxMsg(userData, msg);
            break;
        case OCI_CAN_TX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
            vProcessTxMsg(userData, msg);
            break;

    }
|Node:switch Text: switch
|Node:condition_clause Text: (msg->type)
|Node:( Text: (
|Node:field_expression Text: msg->type
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: type
|Node:) Text: )
|Node:compound_statement Text: {
        case OCI_CAN_RX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
            vProcessRxMsg(userData, msg);
            break;
        case OCI_CAN_TX_MESSAGE:
#if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
            vProcessTxMsg(userData, msg);
            break;

    }
|Node:{ Text: {
|Node:case_statement Text: case OCI_CAN_RX_MESSAGE:
|Node:case Text: case
|Node:identifier Text: OCI_CAN_RX_MESSAGE
|Node:: Text: :
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDRX_MESSAGE:
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:case_statement Text: case OCI_CANFDRX_MESSAGE:
|Node:case Text: case
|Node:identifier Text: OCI_CANFDRX_MESSAGE
|Node:: Text: :
|Node:#endif Text: #endif
|Node:expression_statement Text: vProcessRxMsg(userData, msg);
|Node:call_expression Text: vProcessRxMsg(userData, msg)
|Node:identifier Text: vProcessRxMsg
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_CAN_TX_MESSAGE:
|Node:case Text: case
|Node:identifier Text: OCI_CAN_TX_MESSAGE
|Node:: Text: :
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        case OCI_CANFDTX_MESSAGE:
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:case_statement Text: case OCI_CANFDTX_MESSAGE:
|Node:case Text: case
|Node:identifier Text: OCI_CANFDTX_MESSAGE
|Node:: Text: :
|Node:#endif Text: #endif
|Node:expression_statement Text: vProcessTxMsg(userData, msg);
|Node:call_expression Text: vProcessTxMsg(userData, msg)
|Node:identifier Text: vProcessTxMsg
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * processes bus event.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessBusEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessBusEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:identifier Text: vProcessBusEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx*
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessBusEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessBusEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:identifier Text: vProcessBusEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage*
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {

}
|Node:{ Text: {
|Node:} Text: }
|Node:comment Text: /**
 * processes internal event.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:identifier Text: vProcessInternalErrEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx*
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessInternalErrEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:identifier Text: vProcessInternalErrEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage*
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {

}
|Node:{ Text: {
|Node:} Text: }
|Node:comment Text: /**
 * process queue event.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:identifier Text: vProcessQueueEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessageEx* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx*
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
#endif
{

}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessQueueEvent(void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:identifier Text: vProcessQueueEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessage* /*msg*/)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage*
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*msg*/
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {

}
|Node:{ Text: {
|Node:} Text: }
|Node:comment Text: /**
 * process tmer event.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessageEx* msg)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessageEx* msg)
|Node:identifier Text: vProcessTimerEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: 
|Node:#else Text: #else
|Node:function_definition Text: static void vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->data.timerEventMessage.eventCode)
    {
        case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
        case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vProcessTimerEvent(void* /*userData*/, struct OCI_CANMessage* msg)
|Node:identifier Text: vProcessTimerEvent
|Node:parameter_list Text: (void* /*userData*/, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:comment Text: /*userData*/
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
    switch (msg->data.timerEventMessage.eventCode)
    {
        case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
        case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
    }
}
|Node:{ Text: {
|Node:switch_statement Text: switch (msg->data.timerEventMessage.eventCode)
    {
        case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
        case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
    }
|Node:switch Text: switch
|Node:condition_clause Text: (msg->data.timerEventMessage.eventCode)
|Node:( Text: (
|Node:field_expression Text: msg->data.timerEventMessage.eventCode
|Node:field_expression Text: msg->data.timerEventMessage
|Node:field_expression Text: msg->data
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: timerEventMessage
|Node:. Text: .
|Node:field_identifier Text: eventCode
|Node:) Text: )
|Node:compound_statement Text: {
        case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
        case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
    }
|Node:{ Text: {
|Node:case_statement Text: case OCI_TIMER_EVENT_SYNC_LOCK:
            SetEvent(sg_hEvent);
            vCreateTimeModeMapping(sg_hEvent);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_TIMER_EVENT_SYNC_LOCK
|Node:: Text: :
|Node:expression_statement Text: SetEvent(sg_hEvent);
|Node:call_expression Text: SetEvent(sg_hEvent)
|Node:identifier Text: SetEvent
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: vCreateTimeModeMapping(sg_hEvent);
|Node:call_expression Text: vCreateTimeModeMapping(sg_hEvent)
|Node:identifier Text: vCreateTimeModeMapping
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_TIMER_EVENT_SYNC_LOSS:
            // Nothing at this moment
            break;
|Node:case Text: case
|Node:identifier Text: OCI_TIMER_EVENT_SYNC_LOSS
|Node:: Text: :
|Node:comment Text: // Nothing at this moment
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /**
 * Callback function called by the BOA framework
 * when there is internal bus event.
 */
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg)
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessageEx* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessEvents)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessEvents
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessEvents
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessageEx* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessageEx* msg
|Node:struct_specifier Text: struct OCI_CANMessageEx
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: 
|Node:preproc_else Text: #else
static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->type)
    {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
{
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_UnloadDriverLibrary(void)
{
    /* Unload OCI library */
    if (sg_hLibOCI != NULL)
    {
        FreeLibrary(sg_hLibOCI);
    }

    /* Unload CSI library */
    if (sg_hLibCSI != NULL)
    {
        FreeLibrary(sg_hLibCSI);
    }

    /* Invalidate all API pointers */
    memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE));
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
{
    HRESULT hResult = S_FALSE;
    if (ClientID != 0)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
{
    HRESULT hResult = S_FALSE;
    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& unCntrlStatus)
{
    unCntrlStatus = defCONTROLLER_ACTIVE; /* Temporary solution. TODO */
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_LoadDriverLibrary(void)
{
    HRESULT hResult = S_FALSE;
    string acPath;

    /* Get BOA installation path from the registery */
    bGetBOAInstallationPath(acPath);

    /* Load cslproxy.dll library */
    string acLIB_CSL = "";
    acLIB_CSL.append(acPath);
    acLIB_CSL.append("\\");
    acLIB_CSL.append(LIB_CSL_NAME);

    /* LoadLibraryEx instead of LoadLibrary seems to be necessary under Windows 7 when the library is not in DLL search path (system32) */
    sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (sg_hLibCSI != NULL)
    {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
    else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformInitOperations(void)
{
    /*
     * Create critical section for ensuring thread
     * safeness of read message function
     */
    InitializeCriticalSection(&sg_DIL_CriticalSection);

    /* Create an event for timestamp calculations */
    sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    /*
     * Initial Channel info with default values.
     * 1. Controller configuration
     * 2. Queue configuration
     * 3. Filter configuration
     */
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }

    /* Register monitor client */
    DWORD dwClient = 0;
    CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE);

    /* Initialize the selected channel items array to -1 */
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return S_OK;
}

/**
 * Copies the controller config values into channel's
 * controller config structure.
 *
 * @return TRUE for success, FALSE for failure
 */
static BOOL bLoadDataFromContr(PSCONTROLLER_DETAILS pControllerDetails)
{
    BOOL bReturn = FALSE;

    /* If successful */
    if (pControllerDetails != NULL)
    {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
    return bReturn;
}

/**
 * Copies from STCAN_MSG structure into OCI_CANTxMessage message structure
 */
static void vCopy_2_OCI_CAN_Data(OCI_CANTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.dlc     = SrcMsg.m_ucDataLen;
    DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
}


#if BOA_VERSION >= BOA_VERSION_2_0
static BOOL vCopy_2_OCI_CANFD_Data(OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.size     = SrcMsg.m_ucDataLen;
    if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
    DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
    return TRUE;
}
#endif

HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformClosureOperations(void)
{
    HRESULT hResult = S_OK;

    CAN_StopHardware();

    /* deselect hw interface */
    hResult = CAN_DeselectHwInterface();

    /* close the existing handle */
    CloseHandle(sg_hEvent);
    sg_hEvent = NULL;

    /* Remove all the existing clients */
    UINT ClientIndex = 0;
    while (sg_unClientCnt > 0)
    {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }

    /* Delete the critical section */
    DeleteCriticalSection(&sg_DIL_CriticalSection);
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
{
    CurrSysTime = sg_CurrSysTime;
    TimeStamp   = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
    return S_OK;
}

/**
 * This function will popup hardware selection dialog and gets the user selection of channels.
 *
 * @return Operation Result. 0 incase of no errors. Failure Error codes otherwise.
 */
static int ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    INT nRet = HwList.DoModal();
    objMainWnd.Detach();

    if ( nRet == IDOK)
    {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
    else
    {
        return -1;
    }
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
{
    // VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_DRIVER_SELECTED, ERR_IMPROPER_STATE);
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;
    OCI_URIName acURI[defNO_OF_CHANNELS];
    INT nFound = 0;

    UINT unDefaultChannelCnt = nCount;

    if (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
    {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SelectHwInterface(const INTERFACE_HW_LIST& asSelHwInterface, INT /*nCount*/)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    /* First select only supported number of HW interfaces */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }

    /* Create the controller instance. */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_DeselectHwInterface(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }

    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
    return hResult;
}

/**
 * Call back function called from ConfigDialogDIL
 *
 * @return TRUE for success, FALSE for failure
 */
static BOOL Callback_DILBOA(BYTE /*Argument*/, PSCONTROLLER_DETAILS pDatStream, INT /*Length*/)
{
    return (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK);
}

/**
 * Displays the configuration dialog for controller
 *
 * @return S_OK for success, S_FALSE for failure
 */
static int DisplayConfigurationDlg(HWND hParent, DILCALLBACK /*ProcDIL*/,
                            PSCONTROLLER_DETAILS pControllerDetails, UINT nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int nResult = WARNING_NOTCONFIRMED;

    SCONTROLLER_DETAILS sController[defNO_OF_CHANNELS];

    for(int i =0 ; i < defNO_OF_CHANNELS; i++)
    {
        sController[i] = pControllerDetails[i];
    }

    CChangeRegisters_CAN_ETAS_BOA ouChangeRegister(NULL, pControllerDetails, nCount);
    ouChangeRegister.DoModal();

    nResult = ouChangeRegister.nGetInitStatus();

    return nResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM);

    USES_CONVERSION;

    INT Result = WARN_INITDAT_NCONFIRM;
    PSCONTROLLER_DETAILS psContrlDets = (PSCONTROLLER_DETAILS)InitData;

    /* First initialize with existing hw description */
    for (INT i = 0; i < min(Length, (INT)sg_nNoOfChannels); i++)
    {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
    if (sg_nNoOfChannels > 0)
    {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }

    return Result;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetConfigData(PSCONTROLLER_DETAILS pInitData, int /*Length*/)
{
    HRESULT hResult = WARNING_NOTCONFIRMED;

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(pInitData, hResult);

    BOA_ResultCode ErrCode = OCI_FAILURE;
    PSCONTROLLER_DETAILS pControllerDetails = (PSCONTROLLER_DETAILS)pInitData;
    bLoadDataFromContr(pControllerDetails);
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_StartHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_StopHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
{
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
    HRESULT hResult = S_FALSE;

    if (bClientIdExist(dwClientID))
    {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetLastErrorString(string& /*acErrorStr*/)
{
    return WARN_DUMMY_API;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
{
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
    return S_OK;
}

HRESULT CDIL_CAN_ETAS_BOA::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|Node:#else Text: #else
|Node:function_definition Text: static void (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg)
#endif
{
    switch (msg->type)
    {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: (OCI_CALLBACK ProcessEvents)(void* userData, struct OCI_CANMessage* msg)
|Node:parenthesized_declarator Text: (OCI_CALLBACK ProcessEvents)
|Node:( Text: (
|Node:qualified_identifier Text: OCI_CALLBACK ProcessEvents
|Node:namespace_identifier Text: OCI_CALLBACK
|Node::: Text: 
|Node:identifier Text: ProcessEvents
|Node:) Text: )
|Node:parameter_list Text: (void* userData, struct OCI_CANMessage* msg)
|Node:( Text: (
|Node:parameter_declaration Text: void* userData
|Node:primitive_type Text: void
|Node:pointer_declarator Text: * userData
|Node:* Text: *
|Node:identifier Text: userData
|Node:, Text: ,
|Node:parameter_declaration Text: struct OCI_CANMessage* msg
|Node:struct_specifier Text: struct OCI_CANMessage
|Node:struct Text: struct
|Node:type_identifier Text: OCI_CANMessage
|Node:pointer_declarator Text: * msg
|Node:* Text: *
|Node:identifier Text: msg
|Node:) Text: )
|Node:ERROR Text: #endif
|Node:#endif Text: #endif
|Node:compound_statement Text: {
    switch (msg->type)
    {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
}
|Node:{ Text: {
|Node:switch_statement Text: switch (msg->type)
    {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
|Node:switch Text: switch
|Node:condition_clause Text: (msg->type)
|Node:( Text: (
|Node:field_expression Text: msg->type
|Node:identifier Text: msg
|Node:-> Text: ->
|Node:field_identifier Text: type
|Node:) Text: )
|Node:compound_statement Text: {
        case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
        case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
        case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
        case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
        case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
    }
|Node:{ Text: {
|Node:case_statement Text: case OCI_CAN_BUS_EVENT:
            vProcessBusEvent(userData, msg);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_BUS_EVENT
|Node:: Text: :
|Node:expression_statement Text: vProcessBusEvent(userData, msg);
|Node:call_expression Text: vProcessBusEvent(userData, msg)
|Node:identifier Text: vProcessBusEvent
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_CAN_INTERNAL_ERROR_EVENT:
            vProcessInternalErrEvent(userData, msg);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_INTERNAL_ERROR_EVENT
|Node:: Text: :
|Node:expression_statement Text: vProcessInternalErrEvent(userData, msg);
|Node:call_expression Text: vProcessInternalErrEvent(userData, msg)
|Node:identifier Text: vProcessInternalErrEvent
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_CAN_QUEUE_EVENT:
            vProcessQueueEvent(userData, msg);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_QUEUE_EVENT
|Node:: Text: :
|Node:expression_statement Text: vProcessQueueEvent(userData, msg);
|Node:call_expression Text: vProcessQueueEvent(userData, msg)
|Node:identifier Text: vProcessQueueEvent
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_CAN_TIMER_EVENT:
            vProcessTimerEvent(userData, msg);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_TIMER_EVENT
|Node:: Text: :
|Node:expression_statement Text: vProcessTimerEvent(userData, msg);
|Node:call_expression Text: vProcessTimerEvent(userData, msg)
|Node:identifier Text: vProcessTimerEvent
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case OCI_CAN_ERROR_FRAME:
            vProcessErrMsg(userData, msg);
            break;
|Node:case Text: case
|Node:identifier Text: OCI_CAN_ERROR_FRAME
|Node:: Text: :
|Node:expression_statement Text: vProcessErrMsg(userData, msg);
|Node:call_expression Text: vProcessErrMsg(userData, msg)
|Node:identifier Text: vProcessErrMsg
|Node:argument_list Text: (userData, msg)
|Node:( Text: (
|Node:identifier Text: userData
|Node:, Text: ,
|Node:identifier Text: msg
|Node:) Text: )
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
{
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;
    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_SetAppParams(HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_SetAppParams
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_SetAppParams
|Node:parameter_list Text: (HWND hWndOwner, Base_WrapperErrorLogger* pILog)
|Node:( Text: (
|Node:parameter_declaration Text: HWND hWndOwner
|Node:type_identifier Text: HWND
|Node:identifier Text: hWndOwner
|Node:, Text: ,
|Node:parameter_declaration Text: Base_WrapperErrorLogger* pILog
|Node:type_identifier Text: Base_WrapperErrorLogger
|Node:pointer_declarator Text: * pILog
|Node:* Text: *
|Node:identifier Text: pILog
|Node:) Text: )
|Node:compound_statement Text: {
    sg_hOwnerWnd = hWndOwner;
    sg_pIlog = pILog;
    return S_OK;
}
|Node:{ Text: {
|Node:expression_statement Text: sg_hOwnerWnd = hWndOwner;
|Node:assignment_expression Text: sg_hOwnerWnd = hWndOwner
|Node:identifier Text: sg_hOwnerWnd
|Node:= Text: =
|Node:identifier Text: hWndOwner
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog = pILog;
|Node:assignment_expression Text: sg_pIlog = pILog
|Node:identifier Text: sg_pIlog
|Node:= Text: =
|Node:identifier Text: pILog
|Node:; Text: ;
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_UnloadDriverLibrary(void)
{
    /* Unload OCI library */
    if (sg_hLibOCI != NULL)
    {
        FreeLibrary(sg_hLibOCI);
    }

    /* Unload CSI library */
    if (sg_hLibCSI != NULL)
    {
        FreeLibrary(sg_hLibCSI);
    }

    /* Invalidate all API pointers */
    memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE));
    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_UnloadDriverLibrary(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_UnloadDriverLibrary
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_UnloadDriverLibrary
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    /* Unload OCI library */
    if (sg_hLibOCI != NULL)
    {
        FreeLibrary(sg_hLibOCI);
    }

    /* Unload CSI library */
    if (sg_hLibCSI != NULL)
    {
        FreeLibrary(sg_hLibCSI);
    }

    /* Invalidate all API pointers */
    memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE));
    return S_OK;
}
|Node:{ Text: {
|Node:comment Text: /* Unload OCI library */
|Node:if_statement Text: if (sg_hLibOCI != NULL)
    {
        FreeLibrary(sg_hLibOCI);
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_hLibOCI != NULL)
|Node:( Text: (
|Node:binary_expression Text: sg_hLibOCI != NULL
|Node:identifier Text: sg_hLibOCI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        FreeLibrary(sg_hLibOCI);
    }
|Node:{ Text: {
|Node:expression_statement Text: FreeLibrary(sg_hLibOCI);
|Node:call_expression Text: FreeLibrary(sg_hLibOCI)
|Node:identifier Text: FreeLibrary
|Node:argument_list Text: (sg_hLibOCI)
|Node:( Text: (
|Node:identifier Text: sg_hLibOCI
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Unload CSI library */
|Node:if_statement Text: if (sg_hLibCSI != NULL)
    {
        FreeLibrary(sg_hLibCSI);
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_hLibCSI != NULL)
|Node:( Text: (
|Node:binary_expression Text: sg_hLibCSI != NULL
|Node:identifier Text: sg_hLibCSI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        FreeLibrary(sg_hLibCSI);
    }
|Node:{ Text: {
|Node:expression_statement Text: FreeLibrary(sg_hLibCSI);
|Node:call_expression Text: FreeLibrary(sg_hLibCSI)
|Node:identifier Text: FreeLibrary
|Node:argument_list Text: (sg_hLibCSI)
|Node:( Text: (
|Node:identifier Text: sg_hLibCSI
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Invalidate all API pointers */
|Node:expression_statement Text: memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE));
|Node:call_expression Text: memset(&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE))
|Node:identifier Text: memset
|Node:argument_list Text: (&sBOA_PTRS, 0, sizeof (SBOA_POINTER_TABLE))
|Node:( Text: (
|Node:pointer_expression Text: &sBOA_PTRS
|Node:& Text: &
|Node:identifier Text: sBOA_PTRS
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:, Text: ,
|Node:sizeof_expression Text: sizeof (SBOA_POINTER_TABLE)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (SBOA_POINTER_TABLE)
|Node:( Text: (
|Node:identifier Text: SBOA_POINTER_TABLE
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
{
    HRESULT hResult = S_FALSE;
    if (ClientID != 0)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_ManageMsgBuf(BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_ManageMsgBuf
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_ManageMsgBuf
|Node:parameter_list Text: (BYTE bAction, DWORD ClientID, CBaseCANBufFSE* pBufObj)
|Node:( Text: (
|Node:parameter_declaration Text: BYTE bAction
|Node:type_identifier Text: BYTE
|Node:identifier Text: bAction
|Node:, Text: ,
|Node:parameter_declaration Text: DWORD ClientID
|Node:type_identifier Text: DWORD
|Node:identifier Text: ClientID
|Node:, Text: ,
|Node:parameter_declaration Text: CBaseCANBufFSE* pBufObj
|Node:type_identifier Text: CBaseCANBufFSE
|Node:pointer_declarator Text: * pBufObj
|Node:* Text: *
|Node:identifier Text: pBufObj
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    if (ClientID != 0)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }

    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:if_statement Text: if (ClientID != 0)
    {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
    else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (ClientID != 0)
|Node:( Text: (
|Node:binary_expression Text: ClientID != 0
|Node:identifier Text: ClientID
|Node:!= Text: !=
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
        UINT unClientIndex;
        if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|Node:{ Text: {
|Node:declaration Text: UINT unClientIndex;
|Node:type_identifier Text: UINT
|Node:identifier Text: unClientIndex
|Node:; Text: ;
|Node:if_statement Text: if (bGetClientObj(ClientID, unClientIndex))
        {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:if Text: if
|Node:condition_clause Text: (bGetClientObj(ClientID, unClientIndex))
|Node:( Text: (
|Node:call_expression Text: bGetClientObj(ClientID, unClientIndex)
|Node:identifier Text: bGetClientObj
|Node:argument_list Text: (ClientID, unClientIndex)
|Node:( Text: (
|Node:identifier Text: ClientID
|Node:, Text: ,
|Node:identifier Text: unClientIndex
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
            if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
        }
|Node:{ Text: {
|Node:declaration Text: SCLIENTBUFMAP& sClientObj = sg_asClientToBufMap[unClientIndex];
|Node:type_identifier Text: SCLIENTBUFMAP
|Node:init_declarator Text: & sClientObj = sg_asClientToBufMap[unClientIndex]
|Node:reference_declarator Text: & sClientObj
|Node:& Text: &
|Node:identifier Text: sClientObj
|Node:= Text: =
|Node:subscript_expression Text: sg_asClientToBufMap[unClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [unClientIndex]
|Node:[ Text: [
|Node:identifier Text: unClientIndex
|Node:] Text: ]
|Node:; Text: ;
|Node:if_statement Text: if (bAction == MSGBUF_ADD)
            {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
            else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
|Node:if Text: if
|Node:condition_clause Text: (bAction == MSGBUF_ADD)
|Node:( Text: (
|Node:binary_expression Text: bAction == MSGBUF_ADD
|Node:identifier Text: bAction
|Node:== Text: ==
|Node:identifier Text: MSGBUF_ADD
|Node:) Text: )
|Node:compound_statement Text: {
                /* Add msg buffer */
                if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
            }
|Node:{ Text: {
|Node:comment Text: /* Add msg buffer */
|Node:if_statement Text: if (pBufObj != NULL)
                {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
|Node:if Text: if
|Node:condition_clause Text: (pBufObj != NULL)
|Node:( Text: (
|Node:binary_expression Text: pBufObj != NULL
|Node:identifier Text: pBufObj
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
                    if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
                }
|Node:{ Text: {
|Node:if_statement Text: if (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
                    {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
|Node:if Text: if
|Node:condition_clause Text: (sClientObj.m_unBufCount < MAX_BUFF_ALLOWED)
|Node:( Text: (
|Node:binary_expression Text: sClientObj.m_unBufCount < MAX_BUFF_ALLOWED
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:< Text: <
|Node:identifier Text: MAX_BUFF_ALLOWED
|Node:) Text: )
|Node:compound_statement Text: {
                        if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
                    }
|Node:{ Text: {
|Node:if_statement Text: if (bIsBufferExists(sClientObj, pBufObj) == FALSE)
                        {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
                        else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|Node:if Text: if
|Node:condition_clause Text: (bIsBufferExists(sClientObj, pBufObj) == FALSE)
|Node:( Text: (
|Node:binary_expression Text: bIsBufferExists(sClientObj, pBufObj) == FALSE
|Node:call_expression Text: bIsBufferExists(sClientObj, pBufObj)
|Node:identifier Text: bIsBufferExists
|Node:argument_list Text: (sClientObj, pBufObj)
|Node:( Text: (
|Node:identifier Text: sClientObj
|Node:, Text: ,
|Node:identifier Text: pBufObj
|Node:) Text: )
|Node:== Text: ==
|Node:false Text: FALSE
|Node:) Text: )
|Node:compound_statement Text: {
                            sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
                            hResult = S_OK;
                        }
|Node:{ Text: {
|Node:expression_statement Text: sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj;
|Node:assignment_expression Text: sClientObj.m_pClientBuf[sClientObj.m_unBufCount++] = pBufObj
|Node:subscript_expression Text: sClientObj.m_pClientBuf[sClientObj.m_unBufCount++]
|Node:field_expression Text: sClientObj.m_pClientBuf
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [sClientObj.m_unBufCount++]
|Node:[ Text: [
|Node:update_expression Text: sClientObj.m_unBufCount++
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:++ Text: ++
|Node:] Text: ]
|Node:= Text: =
|Node:identifier Text: pBufObj
|Node:; Text: ;
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                        {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|Node:else Text: else
|Node:compound_statement Text: {
                            hResult = ERR_BUFFER_EXISTS;
                        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_BUFFER_EXISTS;
|Node:assignment_expression Text: hResult = ERR_BUFFER_EXISTS
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_BUFFER_EXISTS
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
|Node:else Text: else
|Node:if_statement Text: if (bAction == MSGBUF_CLEAR)
            {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
            else
            {
                // ASSERT(FALSE);
            }
|Node:if Text: if
|Node:condition_clause Text: (bAction == MSGBUF_CLEAR)
|Node:( Text: (
|Node:binary_expression Text: bAction == MSGBUF_CLEAR
|Node:identifier Text: bAction
|Node:== Text: ==
|Node:identifier Text: MSGBUF_CLEAR
|Node:) Text: )
|Node:compound_statement Text: {
                /* clear msg buffer */
                if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
                hResult = S_OK;
            }
|Node:{ Text: {
|Node:comment Text: /* clear msg buffer */
|Node:if_statement Text: if (pBufObj != NULL) // Remove only buffer mentioned
                {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
                else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
|Node:if Text: if
|Node:condition_clause Text: (pBufObj != NULL)
|Node:( Text: (
|Node:binary_expression Text: pBufObj != NULL
|Node:identifier Text: pBufObj
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:comment Text: // Remove only buffer mentioned
|Node:compound_statement Text: {
                    bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
                }
|Node:{ Text: {
|Node:expression_statement Text: bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj);
|Node:call_expression Text: bRemoveClientBuffer(sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj)
|Node:identifier Text: bRemoveClientBuffer
|Node:argument_list Text: (sClientObj.m_pClientBuf, sClientObj.m_unBufCount, pBufObj)
|Node:( Text: (
|Node:field_expression Text: sClientObj.m_pClientBuf
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:, Text: ,
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:, Text: ,
|Node:identifier Text: pBufObj
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else // Remove all
                {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
|Node:else Text: else
|Node:comment Text: // Remove all
|Node:compound_statement Text: {
                    for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
                    sClientObj.m_unBufCount = 0;
                }
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < sClientObj.m_unBufCount; i++)
                    {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sClientObj.m_unBufCount
|Node:identifier Text: i
|Node:< Text: <
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                        sClientObj.m_pClientBuf[i] = NULL;
                    }
|Node:{ Text: {
|Node:expression_statement Text: sClientObj.m_pClientBuf[i] = NULL;
|Node:assignment_expression Text: sClientObj.m_pClientBuf[i] = NULL
|Node:subscript_expression Text: sClientObj.m_pClientBuf[i]
|Node:field_expression Text: sClientObj.m_pClientBuf
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_pClientBuf
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sClientObj.m_unBufCount = 0;
|Node:assignment_expression Text: sClientObj.m_unBufCount = 0
|Node:field_expression Text: sClientObj.m_unBufCount
|Node:identifier Text: sClientObj
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
            {
                // ASSERT(FALSE);
            }
|Node:else Text: else
|Node:compound_statement Text: {
                // ASSERT(FALSE);
            }
|Node:{ Text: {
|Node:comment Text: // ASSERT(FALSE);
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_NO_CLIENT_EXIST
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|Node:else Text: else
|Node:compound_statement Text: {
        if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (bAction == MSGBUF_CLEAR)
        {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
|Node:if Text: if
|Node:condition_clause Text: (bAction == MSGBUF_CLEAR)
|Node:( Text: (
|Node:binary_expression Text: bAction == MSGBUF_CLEAR
|Node:identifier Text: bAction
|Node:== Text: ==
|Node:identifier Text: MSGBUF_CLEAR
|Node:) Text: )
|Node:compound_statement Text: {
            /* clear msg buffer */
            for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:comment Text: /* clear msg buffer */
|Node:for_statement Text: for (UINT i = 0; i < sg_unClientCnt; i++)
            {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_unClientCnt
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
            }
|Node:{ Text: {
|Node:expression_statement Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL);
|Node:call_expression Text: CAN_ManageMsgBuf(MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL)
|Node:identifier Text: CAN_ManageMsgBuf
|Node:argument_list Text: (MSGBUF_CLEAR, sg_asClientToBufMap[i].m_dwClientID, NULL)
|Node:( Text: (
|Node:identifier Text: MSGBUF_CLEAR
|Node:, Text: ,
|Node:field_expression Text: sg_asClientToBufMap[i].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[i]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:, Text: ,
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
{
    HRESULT hResult = S_FALSE;
    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_RegisterClient(BOOL bRegister, DWORD& ClientID, char* pacClientName)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_RegisterClient
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_RegisterClient
|Node:parameter_list Text: (BOOL bRegister, DWORD& ClientID, char* pacClientName)
|Node:( Text: (
|Node:parameter_declaration Text: BOOL bRegister
|Node:type_identifier Text: BOOL
|Node:identifier Text: bRegister
|Node:, Text: ,
|Node:parameter_declaration Text: DWORD& ClientID
|Node:type_identifier Text: DWORD
|Node:reference_declarator Text: & ClientID
|Node:& Text: &
|Node:identifier Text: ClientID
|Node:, Text: ,
|Node:parameter_declaration Text: char* pacClientName
|Node:primitive_type Text: char
|Node:pointer_declarator Text: * pacClientName
|Node:* Text: *
|Node:identifier Text: pacClientName
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }

    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:if_statement Text: if (bRegister)
    {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
    else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (bRegister)
|Node:( Text: (
|Node:identifier Text: bRegister
|Node:) Text: )
|Node:compound_statement Text: {
        if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (sg_unClientCnt < MAX_CLIENT_ALLOWED)
        {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
        else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|Node:if Text: if
|Node:condition_clause Text: (sg_unClientCnt < MAX_CLIENT_ALLOWED)
|Node:( Text: (
|Node:binary_expression Text: sg_unClientCnt < MAX_CLIENT_ALLOWED
|Node:identifier Text: sg_unClientCnt
|Node:< Text: <
|Node:identifier Text: MAX_CLIENT_ALLOWED
|Node:) Text: )
|Node:compound_statement Text: {
            INT Index = 0;
            if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
        }
|Node:{ Text: {
|Node:declaration Text: INT Index = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: Index = 0
|Node:identifier Text: Index
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:if_statement Text: if (!bClientExist(pacClientName, Index))
            {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
            else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|Node:if Text: if
|Node:condition_clause Text: (!bClientExist(pacClientName, Index))
|Node:( Text: (
|Node:unary_expression Text: !bClientExist(pacClientName, Index)
|Node:! Text: !
|Node:call_expression Text: bClientExist(pacClientName, Index)
|Node:identifier Text: bClientExist
|Node:argument_list Text: (pacClientName, Index)
|Node:( Text: (
|Node:identifier Text: pacClientName
|Node:, Text: ,
|Node:identifier Text: Index
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                /* Currently store the client information */
                if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
                sg_unClientCnt++;
                hResult = S_OK;
            }
|Node:{ Text: {
|Node:comment Text: /* Currently store the client information */
|Node:if_statement Text: if (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
                {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
                else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
|Node:if Text: if
|Node:condition_clause Text: (strcmp(pacClientName, CAN_MONITOR_NODE) == 0)
|Node:( Text: (
|Node:binary_expression Text: strcmp(pacClientName, CAN_MONITOR_NODE) == 0
|Node:call_expression Text: strcmp(pacClientName, CAN_MONITOR_NODE)
|Node:identifier Text: strcmp
|Node:argument_list Text: (pacClientName, CAN_MONITOR_NODE)
|Node:( Text: (
|Node:identifier Text: pacClientName
|Node:, Text: ,
|Node:identifier Text: CAN_MONITOR_NODE
|Node:) Text: )
|Node:== Text: ==
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
                    /* First slot is reserved to monitor node */
                    ClientID = 1;
                    sg_asClientToBufMap[0].m_acClientName = pacClientName;
                    sg_asClientToBufMap[0].m_dwClientID = ClientID;
                    sg_asClientToBufMap[0].m_unBufCount = 0;
                }
|Node:{ Text: {
|Node:comment Text: /* First slot is reserved to monitor node */
|Node:expression_statement Text: ClientID = 1;
|Node:assignment_expression Text: ClientID = 1
|Node:identifier Text: ClientID
|Node:= Text: =
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[0].m_acClientName = pacClientName;
|Node:assignment_expression Text: sg_asClientToBufMap[0].m_acClientName = pacClientName
|Node:field_expression Text: sg_asClientToBufMap[0].m_acClientName
|Node:subscript_expression Text: sg_asClientToBufMap[0]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [0]
|Node:[ Text: [
|Node:number_literal Text: 0
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acClientName
|Node:= Text: =
|Node:identifier Text: pacClientName
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[0].m_dwClientID = ClientID;
|Node:assignment_expression Text: sg_asClientToBufMap[0].m_dwClientID = ClientID
|Node:field_expression Text: sg_asClientToBufMap[0].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[0]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [0]
|Node:[ Text: [
|Node:number_literal Text: 0
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:= Text: =
|Node:identifier Text: ClientID
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[0].m_unBufCount = 0;
|Node:assignment_expression Text: sg_asClientToBufMap[0].m_unBufCount = 0
|Node:field_expression Text: sg_asClientToBufMap[0].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[0]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [0]
|Node:[ Text: [
|Node:number_literal Text: 0
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
                    ClientID = dwGetAvailableClientSlot();
                    sg_asClientToBufMap[Index].m_acClientName = pacClientName;

                    sg_asClientToBufMap[Index].m_dwClientID = ClientID;
                    sg_asClientToBufMap[Index].m_unBufCount = 0;
                }
|Node:{ Text: {
|Node:if_statement Text: if (!bClientExist(CAN_MONITOR_NODE, Index))
                    {
                        Index = sg_unClientCnt + 1;
                    }
                    else
                    {
                        Index = sg_unClientCnt;
                    }
|Node:if Text: if
|Node:condition_clause Text: (!bClientExist(CAN_MONITOR_NODE, Index))
|Node:( Text: (
|Node:unary_expression Text: !bClientExist(CAN_MONITOR_NODE, Index)
|Node:! Text: !
|Node:call_expression Text: bClientExist(CAN_MONITOR_NODE, Index)
|Node:identifier Text: bClientExist
|Node:argument_list Text: (CAN_MONITOR_NODE, Index)
|Node:( Text: (
|Node:identifier Text: CAN_MONITOR_NODE
|Node:, Text: ,
|Node:identifier Text: Index
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                        Index = sg_unClientCnt + 1;
                    }
|Node:{ Text: {
|Node:expression_statement Text: Index = sg_unClientCnt + 1;
|Node:assignment_expression Text: Index = sg_unClientCnt + 1
|Node:identifier Text: Index
|Node:= Text: =
|Node:binary_expression Text: sg_unClientCnt + 1
|Node:identifier Text: sg_unClientCnt
|Node:+ Text: +
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                    {
                        Index = sg_unClientCnt;
                    }
|Node:else Text: else
|Node:compound_statement Text: {
                        Index = sg_unClientCnt;
                    }
|Node:{ Text: {
|Node:expression_statement Text: Index = sg_unClientCnt;
|Node:assignment_expression Text: Index = sg_unClientCnt
|Node:identifier Text: Index
|Node:= Text: =
|Node:identifier Text: sg_unClientCnt
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: ClientID = dwGetAvailableClientSlot();
|Node:assignment_expression Text: ClientID = dwGetAvailableClientSlot()
|Node:identifier Text: ClientID
|Node:= Text: =
|Node:call_expression Text: dwGetAvailableClientSlot()
|Node:identifier Text: dwGetAvailableClientSlot
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[Index].m_acClientName = pacClientName;
|Node:assignment_expression Text: sg_asClientToBufMap[Index].m_acClientName = pacClientName
|Node:field_expression Text: sg_asClientToBufMap[Index].m_acClientName
|Node:subscript_expression Text: sg_asClientToBufMap[Index]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [Index]
|Node:[ Text: [
|Node:identifier Text: Index
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acClientName
|Node:= Text: =
|Node:identifier Text: pacClientName
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[Index].m_dwClientID = ClientID;
|Node:assignment_expression Text: sg_asClientToBufMap[Index].m_dwClientID = ClientID
|Node:field_expression Text: sg_asClientToBufMap[Index].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[Index]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [Index]
|Node:[ Text: [
|Node:identifier Text: Index
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:= Text: =
|Node:identifier Text: ClientID
|Node:; Text: ;
|Node:expression_statement Text: sg_asClientToBufMap[Index].m_unBufCount = 0;
|Node:assignment_expression Text: sg_asClientToBufMap[Index].m_unBufCount = 0
|Node:field_expression Text: sg_asClientToBufMap[Index].m_unBufCount
|Node:subscript_expression Text: sg_asClientToBufMap[Index]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [Index]
|Node:[ Text: [
|Node:identifier Text: Index
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBufCount
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sg_unClientCnt++;
|Node:update_expression Text: sg_unClientCnt++
|Node:identifier Text: sg_unClientCnt
|Node:++ Text: ++
|Node:; Text: ;
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
            {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|Node:else Text: else
|Node:compound_statement Text: {
                ClientID = sg_asClientToBufMap[Index].m_dwClientID;
                hResult = ERR_CLIENT_EXISTS;
            }
|Node:{ Text: {
|Node:expression_statement Text: ClientID = sg_asClientToBufMap[Index].m_dwClientID;
|Node:assignment_expression Text: ClientID = sg_asClientToBufMap[Index].m_dwClientID
|Node:identifier Text: ClientID
|Node:= Text: =
|Node:field_expression Text: sg_asClientToBufMap[Index].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[Index]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [Index]
|Node:[ Text: [
|Node:identifier Text: Index
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:; Text: ;
|Node:expression_statement Text: hResult = ERR_CLIENT_EXISTS;
|Node:assignment_expression Text: hResult = ERR_CLIENT_EXISTS
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_CLIENT_EXISTS
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_NO_MORE_CLIENT_ALLOWED;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_NO_MORE_CLIENT_ALLOWED;
|Node:assignment_expression Text: hResult = ERR_NO_MORE_CLIENT_ALLOWED
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_NO_MORE_CLIENT_ALLOWED
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|Node:else Text: else
|Node:compound_statement Text: {
        if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (bRemoveClient(ClientID))
        {
            hResult = S_OK;
        }
        else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:if Text: if
|Node:condition_clause Text: (bRemoveClient(ClientID))
|Node:( Text: (
|Node:call_expression Text: bRemoveClient(ClientID)
|Node:identifier Text: bRemoveClient
|Node:argument_list Text: (ClientID)
|Node:( Text: (
|Node:identifier Text: ClientID
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_NO_CLIENT_EXIST;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_NO_CLIENT_EXIST
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& unCntrlStatus)
{
    unCntrlStatus = defCONTROLLER_ACTIVE; /* Temporary solution. TODO */
    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetCntrlStatus(const HANDLE& /*hEvent*/, UINT& unCntrlStatus)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetCntrlStatus
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetCntrlStatus
|Node:parameter_list Text: (const HANDLE& /*hEvent*/, UINT& unCntrlStatus)
|Node:( Text: (
|Node:parameter_declaration Text: const HANDLE&
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: HANDLE
|Node:abstract_reference_declarator Text: &
|Node:& Text: &
|Node:comment Text: /*hEvent*/
|Node:, Text: ,
|Node:parameter_declaration Text: UINT& unCntrlStatus
|Node:type_identifier Text: UINT
|Node:reference_declarator Text: & unCntrlStatus
|Node:& Text: &
|Node:identifier Text: unCntrlStatus
|Node:) Text: )
|Node:compound_statement Text: {
    unCntrlStatus = defCONTROLLER_ACTIVE; /* Temporary solution. TODO */
    return S_OK;
}
|Node:{ Text: {
|Node:expression_statement Text: unCntrlStatus = defCONTROLLER_ACTIVE;
|Node:assignment_expression Text: unCntrlStatus = defCONTROLLER_ACTIVE
|Node:identifier Text: unCntrlStatus
|Node:= Text: =
|Node:identifier Text: defCONTROLLER_ACTIVE
|Node:; Text: ;
|Node:comment Text: /* Temporary solution. TODO */
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_LoadDriverLibrary(void)
{
    HRESULT hResult = S_FALSE;
    string acPath;

    /* Get BOA installation path from the registery */
    bGetBOAInstallationPath(acPath);

    /* Load cslproxy.dll library */
    string acLIB_CSL = "";
    acLIB_CSL.append(acPath);
    acLIB_CSL.append("\\");
    acLIB_CSL.append(LIB_CSL_NAME);

    /* LoadLibraryEx instead of LoadLibrary seems to be necessary under Windows 7 when the library is not in DLL search path (system32) */
    sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (sg_hLibCSI != NULL)
    {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
    else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_LoadDriverLibrary(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_LoadDriverLibrary
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_LoadDriverLibrary
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_FALSE;
    string acPath;

    /* Get BOA installation path from the registery */
    bGetBOAInstallationPath(acPath);

    /* Load cslproxy.dll library */
    string acLIB_CSL = "";
    acLIB_CSL.append(acPath);
    acLIB_CSL.append("\\");
    acLIB_CSL.append(LIB_CSL_NAME);

    /* LoadLibraryEx instead of LoadLibrary seems to be necessary under Windows 7 when the library is not in DLL search path (system32) */
    sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (sg_hLibCSI != NULL)
    {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
    else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:declaration Text: string acPath;
|Node:type_identifier Text: string
|Node:identifier Text: acPath
|Node:; Text: ;
|Node:comment Text: /* Get BOA installation path from the registery */
|Node:expression_statement Text: bGetBOAInstallationPath(acPath);
|Node:call_expression Text: bGetBOAInstallationPath(acPath)
|Node:identifier Text: bGetBOAInstallationPath
|Node:argument_list Text: (acPath)
|Node:( Text: (
|Node:identifier Text: acPath
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Load cslproxy.dll library */
|Node:declaration Text: string acLIB_CSL = "";
|Node:type_identifier Text: string
|Node:init_declarator Text: acLIB_CSL = ""
|Node:identifier Text: acLIB_CSL
|Node:= Text: =
|Node:string_literal Text: ""
|Node:" Text: "
|Node:" Text: "
|Node:; Text: ;
|Node:expression_statement Text: acLIB_CSL.append(acPath);
|Node:call_expression Text: acLIB_CSL.append(acPath)
|Node:field_expression Text: acLIB_CSL.append
|Node:identifier Text: acLIB_CSL
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (acPath)
|Node:( Text: (
|Node:identifier Text: acPath
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acLIB_CSL.append("\\");
|Node:call_expression Text: acLIB_CSL.append("\\")
|Node:field_expression Text: acLIB_CSL.append
|Node:identifier Text: acLIB_CSL
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: ("\\")
|Node:( Text: (
|Node:string_literal Text: "\\"
|Node:" Text: "
|Node:escape_sequence Text: \\
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acLIB_CSL.append(LIB_CSL_NAME);
|Node:call_expression Text: acLIB_CSL.append(LIB_CSL_NAME)
|Node:field_expression Text: acLIB_CSL.append
|Node:identifier Text: acLIB_CSL
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (LIB_CSL_NAME)
|Node:( Text: (
|Node:identifier Text: LIB_CSL_NAME
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* LoadLibraryEx instead of LoadLibrary seems to be necessary under Windows 7 when the library is not in DLL search path (system32) */
|Node:expression_statement Text: sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
|Node:assignment_expression Text: sg_hLibCSI = LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:identifier Text: sg_hLibCSI
|Node:= Text: =
|Node:call_expression Text: LoadLibraryEx(acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:identifier Text: LoadLibraryEx
|Node:argument_list Text: (acLIB_CSL.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:( Text: (
|Node:call_expression Text: acLIB_CSL.c_str()
|Node:field_expression Text: acLIB_CSL.c_str
|Node:identifier Text: acLIB_CSL
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:, Text: ,
|Node:identifier Text: LOAD_WITH_ALTERED_SEARCH_PATH
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (sg_hLibCSI != NULL)
    {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
    else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_hLibCSI != NULL)
|Node:( Text: (
|Node:binary_expression Text: sg_hLibCSI != NULL
|Node:identifier Text: sg_hLibCSI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        hResult = GetCSI_API_Pointers(sg_hLibCSI);

        /* Load the OCI library to use CAN controller */
        if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = GetCSI_API_Pointers(sg_hLibCSI);
|Node:assignment_expression Text: hResult = GetCSI_API_Pointers(sg_hLibCSI)
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: GetCSI_API_Pointers(sg_hLibCSI)
|Node:identifier Text: GetCSI_API_Pointers
|Node:argument_list Text: (sg_hLibCSI)
|Node:( Text: (
|Node:identifier Text: sg_hLibCSI
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Load the OCI library to use CAN controller */
|Node:if_statement Text: if (hResult == S_OK)
        {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
        else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            string acLIB_OCI;
            acLIB_OCI.append(acPath);
            acLIB_OCI.append("\\");
            acLIB_OCI.append(LIB_OCI_NAME);
            sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
        }
|Node:{ Text: {
|Node:declaration Text: string acLIB_OCI;
|Node:type_identifier Text: string
|Node:identifier Text: acLIB_OCI
|Node:; Text: ;
|Node:expression_statement Text: acLIB_OCI.append(acPath);
|Node:call_expression Text: acLIB_OCI.append(acPath)
|Node:field_expression Text: acLIB_OCI.append
|Node:identifier Text: acLIB_OCI
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (acPath)
|Node:( Text: (
|Node:identifier Text: acPath
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acLIB_OCI.append("\\");
|Node:call_expression Text: acLIB_OCI.append("\\")
|Node:field_expression Text: acLIB_OCI.append
|Node:identifier Text: acLIB_OCI
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: ("\\")
|Node:( Text: (
|Node:string_literal Text: "\\"
|Node:" Text: "
|Node:escape_sequence Text: \\
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acLIB_OCI.append(LIB_OCI_NAME);
|Node:call_expression Text: acLIB_OCI.append(LIB_OCI_NAME)
|Node:field_expression Text: acLIB_OCI.append
|Node:identifier Text: acLIB_OCI
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (LIB_OCI_NAME)
|Node:( Text: (
|Node:identifier Text: LIB_OCI_NAME
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
|Node:assignment_expression Text: sg_hLibOCI = LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:identifier Text: sg_hLibOCI
|Node:= Text: =
|Node:call_expression Text: LoadLibraryEx(acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:identifier Text: LoadLibraryEx
|Node:argument_list Text: (acLIB_OCI.c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
|Node:( Text: (
|Node:call_expression Text: acLIB_OCI.c_str()
|Node:field_expression Text: acLIB_OCI.c_str
|Node:identifier Text: acLIB_OCI
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:, Text: ,
|Node:identifier Text: LOAD_WITH_ALTERED_SEARCH_PATH
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (sg_hLibOCI != NULL)
            {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
            else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
|Node:if Text: if
|Node:condition_clause Text: (sg_hLibOCI != NULL)
|Node:( Text: (
|Node:binary_expression Text: sg_hLibOCI != NULL
|Node:identifier Text: sg_hLibOCI
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = GetOCI_API_Pointers(sg_hLibOCI);
                if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = GetOCI_API_Pointers(sg_hLibOCI);
|Node:assignment_expression Text: hResult = GetOCI_API_Pointers(sg_hLibOCI)
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: GetOCI_API_Pointers(sg_hLibOCI)
|Node:identifier Text: GetOCI_API_Pointers
|Node:argument_list Text: (sg_hLibOCI)
|Node:( Text: (
|Node:identifier Text: sg_hLibOCI
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (hResult != S_OK)
                {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
                else
                {
                    sg_bIsDriverRunning = TRUE;
                }
|Node:if Text: if
|Node:condition_clause Text: (hResult != S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult != S_OK
|Node:identifier Text: hResult
|Node:!= Text: !=
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
                }
|Node:{ Text: {
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get OCI function pointers"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not get OCI function pointers"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not get OCI function pointers")
|Node:identifier Text: _
|Node:argument_list Text: ("could not get OCI function pointers")
|Node:( Text: (
|Node:string_literal Text: "could not get OCI function pointers"
|Node:" Text: "
|Node:string_content Text: could not get OCI function pointers
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                {
                    sg_bIsDriverRunning = TRUE;
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    sg_bIsDriverRunning = TRUE;
                }
|Node:{ Text: {
|Node:expression_statement Text: sg_bIsDriverRunning = TRUE;
|Node:assignment_expression Text: sg_bIsDriverRunning = TRUE
|Node:identifier Text: sg_bIsDriverRunning
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
            {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
|Node:else Text: else
|Node:compound_statement Text: {
                hResult = S_FALSE;
                string acErr;
                acErr.append(acLIB_OCI);
                acErr.append(" failed to load");
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:declaration Text: string acErr;
|Node:type_identifier Text: string
|Node:identifier Text: acErr
|Node:; Text: ;
|Node:expression_statement Text: acErr.append(acLIB_OCI);
|Node:call_expression Text: acErr.append(acLIB_OCI)
|Node:field_expression Text: acErr.append
|Node:identifier Text: acErr
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (acLIB_OCI)
|Node:( Text: (
|Node:identifier Text: acLIB_OCI
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acErr.append(" failed to load");
|Node:call_expression Text: acErr.append(" failed to load")
|Node:field_expression Text: acErr.append
|Node:identifier Text: acErr
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (" failed to load")
|Node:( Text: (
|Node:string_literal Text: " failed to load"
|Node:" Text: "
|Node:string_content Text:  failed to load
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr)
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, acErr)
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:identifier Text: acErr
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support")
|Node:identifier Text: _
|Node:argument_list Text: ("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support")
|Node:( Text: (
|Node:string_literal Text: "Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"
|Node:" Text: "
|Node:string_content Text: Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get CSI function pointers"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not get CSI function pointers"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not get CSI function pointers")
|Node:identifier Text: _
|Node:argument_list Text: ("could not get CSI function pointers")
|Node:( Text: (
|Node:string_literal Text: "could not get CSI function pointers"
|Node:" Text: "
|Node:string_content Text: could not get CSI function pointers
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
|Node:else Text: else
|Node:compound_statement Text: {
        string acErr;
        acErr.append(acLIB_CSL);
        acErr.append(_(" failed to load"));
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
    }
|Node:{ Text: {
|Node:declaration Text: string acErr;
|Node:type_identifier Text: string
|Node:identifier Text: acErr
|Node:; Text: ;
|Node:expression_statement Text: acErr.append(acLIB_CSL);
|Node:call_expression Text: acErr.append(acLIB_CSL)
|Node:field_expression Text: acErr.append
|Node:identifier Text: acErr
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (acLIB_CSL)
|Node:( Text: (
|Node:identifier Text: acLIB_CSL
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: acErr.append(_(" failed to load"));
|Node:call_expression Text: acErr.append(_(" failed to load"))
|Node:field_expression Text: acErr.append
|Node:identifier Text: acErr
|Node:. Text: .
|Node:field_identifier Text: append
|Node:argument_list Text: (_(" failed to load"))
|Node:( Text: (
|Node:call_expression Text: _(" failed to load")
|Node:identifier Text: _
|Node:argument_list Text: (" failed to load")
|Node:( Text: (
|Node:string_literal Text: " failed to load"
|Node:" Text: "
|Node:string_content Text:  failed to load
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr);
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, acErr)
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, acErr)
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:identifier Text: acErr
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support")
|Node:identifier Text: _
|Node:argument_list Text: ("Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support")
|Node:( Text: (
|Node:string_literal Text: "Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support"
|Node:" Text: "
|Node:string_content Text: Please have a look at: https://github.com/rbei-etas/busmaster/wiki/Hardware-support
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformInitOperations(void)
{
    /*
     * Create critical section for ensuring thread
     * safeness of read message function
     */
    InitializeCriticalSection(&sg_DIL_CriticalSection);

    /* Create an event for timestamp calculations */
    sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    /*
     * Initial Channel info with default values.
     * 1. Controller configuration
     * 2. Queue configuration
     * 3. Filter configuration
     */
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }

    /* Register monitor client */
    DWORD dwClient = 0;
    CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE);

    /* Initialize the selected channel items array to -1 */
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_PerformInitOperations(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_PerformInitOperations
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_PerformInitOperations
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    /*
     * Create critical section for ensuring thread
     * safeness of read message function
     */
    InitializeCriticalSection(&sg_DIL_CriticalSection);

    /* Create an event for timestamp calculations */
    sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    /*
     * Initial Channel info with default values.
     * 1. Controller configuration
     * 2. Queue configuration
     * 3. Filter configuration
     */
    for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }

    /* Register monitor client */
    DWORD dwClient = 0;
    CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE);

    /* Initialize the selected channel items array to -1 */
    for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }

    return S_OK;
}
|Node:{ Text: {
|Node:comment Text: /*
     * Create critical section for ensuring thread
     * safeness of read message function
     */
|Node:expression_statement Text: InitializeCriticalSection(&sg_DIL_CriticalSection);
|Node:call_expression Text: InitializeCriticalSection(&sg_DIL_CriticalSection)
|Node:identifier Text: InitializeCriticalSection
|Node:argument_list Text: (&sg_DIL_CriticalSection)
|Node:( Text: (
|Node:pointer_expression Text: &sg_DIL_CriticalSection
|Node:& Text: &
|Node:identifier Text: sg_DIL_CriticalSection
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Create an event for timestamp calculations */
|Node:expression_statement Text: sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
|Node:assignment_expression Text: sg_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)
|Node:identifier Text: sg_hEvent
|Node:= Text: =
|Node:call_expression Text: CreateEvent(NULL, FALSE, FALSE, NULL)
|Node:identifier Text: CreateEvent
|Node:argument_list Text: (NULL, FALSE, FALSE, NULL)
|Node:( Text: (
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:, Text: ,
|Node:false Text: FALSE
|Node:, Text: ,
|Node:false Text: FALSE
|Node:, Text: ,
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /*
     * Initial Channel info with default values.
     * 1. Controller configuration
     * 2. Queue configuration
     * 3. Filter configuration
     */
|Node:for_statement Text: for (UINT i = 0; i < defNO_OF_CHANNELS; i++)
    {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < defNO_OF_CHANNELS
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: defNO_OF_CHANNELS
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        /* Controller configuration default values */
        vInitializeControllerConfig(i);

        /* Queue configuration default values */
        vInitializeQueueConfig(i);

        /* Filter configuration default values */
        vInitializeFilterConfig(i);
    }
|Node:{ Text: {
|Node:comment Text: /* Controller configuration default values */
|Node:expression_statement Text: vInitializeControllerConfig(i);
|Node:call_expression Text: vInitializeControllerConfig(i)
|Node:identifier Text: vInitializeControllerConfig
|Node:argument_list Text: (i)
|Node:( Text: (
|Node:identifier Text: i
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Queue configuration default values */
|Node:expression_statement Text: vInitializeQueueConfig(i);
|Node:call_expression Text: vInitializeQueueConfig(i)
|Node:identifier Text: vInitializeQueueConfig
|Node:argument_list Text: (i)
|Node:( Text: (
|Node:identifier Text: i
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Filter configuration default values */
|Node:expression_statement Text: vInitializeFilterConfig(i);
|Node:call_expression Text: vInitializeFilterConfig(i)
|Node:identifier Text: vInitializeFilterConfig
|Node:argument_list Text: (i)
|Node:( Text: (
|Node:identifier Text: i
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Register monitor client */
|Node:declaration Text: DWORD dwClient = 0;
|Node:type_identifier Text: DWORD
|Node:init_declarator Text: dwClient = 0
|Node:identifier Text: dwClient
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE);
|Node:call_expression Text: CAN_RegisterClient(TRUE, dwClient, CAN_MONITOR_NODE)
|Node:identifier Text: CAN_RegisterClient
|Node:argument_list Text: (TRUE, dwClient, CAN_MONITOR_NODE)
|Node:( Text: (
|Node:true Text: TRUE
|Node:, Text: ,
|Node:identifier Text: dwClient
|Node:, Text: ,
|Node:identifier Text: CAN_MONITOR_NODE
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Initialize the selected channel items array to -1 */
|Node:for_statement Text: for ( UINT i = 0; i< CHANNEL_ALLOWED; i++ )
    {
        sg_anSelectedItems[i] = -1;
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i< CHANNEL_ALLOWED
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: CHANNEL_ALLOWED
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        sg_anSelectedItems[i] = -1;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_anSelectedItems[i] = -1;
|Node:assignment_expression Text: sg_anSelectedItems[i] = -1
|Node:subscript_expression Text: sg_anSelectedItems[i]
|Node:identifier Text: sg_anSelectedItems
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:number_literal Text: -1
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Copies the controller config values into channel's
 * controller config structure.
 *
 * @return TRUE for success, FALSE for failure
 */
|Node:function_definition Text: static BOOL bLoadDataFromContr(PSCONTROLLER_DETAILS pControllerDetails)
{
    BOOL bReturn = FALSE;

    /* If successful */
    if (pControllerDetails != NULL)
    {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
    return bReturn;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: bLoadDataFromContr(PSCONTROLLER_DETAILS pControllerDetails)
|Node:identifier Text: bLoadDataFromContr
|Node:parameter_list Text: (PSCONTROLLER_DETAILS pControllerDetails)
|Node:( Text: (
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS pControllerDetails
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: pControllerDetails
|Node:) Text: )
|Node:compound_statement Text: {
    BOOL bReturn = FALSE;

    /* If successful */
    if (pControllerDetails != NULL)
    {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
    return bReturn;
}
|Node:{ Text: {
|Node:declaration Text: BOOL bReturn = FALSE;
|Node:type_identifier Text: BOOL
|Node:init_declarator Text: bReturn = FALSE
|Node:identifier Text: bReturn
|Node:= Text: =
|Node:false Text: FALSE
|Node:; Text: ;
|Node:comment Text: /* If successful */
|Node:if_statement Text: if (pControllerDetails != NULL)
    {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
|Node:if Text: if
|Node:condition_clause Text: (pControllerDetails != NULL)
|Node:( Text: (
|Node:binary_expression Text: pControllerDetails != NULL
|Node:identifier Text: pControllerDetails
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        char* pcStopStr = NULL;
        for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
        bReturn = TRUE;
    }
|Node:{ Text: {
|Node:declaration Text: char* pcStopStr = NULL;
|Node:primitive_type Text: char
|Node:init_declarator Text: * pcStopStr = NULL
|Node:pointer_declarator Text: * pcStopStr
|Node:* Text: *
|Node:identifier Text: pcStopStr
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:for_statement Text: for( INT i = 0; i < defNO_OF_CHANNELS; i++ )
        {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: INT i = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < defNO_OF_CHANNELS
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: defNO_OF_CHANNELS
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
            sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
            sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
            if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
            sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
            sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;

#if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10));
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.baudrate =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10))
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.baudrate
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: baudrate
|Node:= Text: =
|Node:call_expression Text: static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10))
|Node:template_function Text: static_cast <UINT>
|Node:identifier Text: static_cast
|Node:template_argument_list Text: <UINT>
|Node:< Text: <
|Node:type_descriptor Text: UINT
|Node:type_identifier Text: UINT
|Node:> Text: >
|Node:argument_list Text: (_tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10))
|Node:( Text: (
|Node:call_expression Text: _tcstol( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10)
|Node:identifier Text: _tcstol
|Node:argument_list Text: ( pControllerDetails[ i ].m_omStrBaudrate.c_str(),
                                            &pcStopStr, 10)
|Node:( Text: (
|Node:call_expression Text: pControllerDetails[ i ].m_omStrBaudrate.c_str()
|Node:field_expression Text: pControllerDetails[ i ].m_omStrBaudrate.c_str
|Node:field_expression Text: pControllerDetails[ i ].m_omStrBaudrate
|Node:subscript_expression Text: pControllerDetails[ i ]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [ i ]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omStrBaudrate
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &pcStopStr
|Node:& Text: &
|Node:identifier Text: pcStopStr
|Node:, Text: ,
|Node:number_literal Text: 10
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10));
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.samplesPerBit =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10))
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.samplesPerBit
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: samplesPerBit
|Node:= Text: =
|Node:call_expression Text: static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10))
|Node:template_function Text: static_cast <UINT>
|Node:identifier Text: static_cast
|Node:template_argument_list Text: <UINT>
|Node:< Text: <
|Node:type_descriptor Text: UINT
|Node:type_identifier Text: UINT
|Node:> Text: >
|Node:argument_list Text: (_tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10))
|Node:( Text: (
|Node:call_expression Text: _tcstol( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10)
|Node:identifier Text: _tcstol
|Node:argument_list Text: ( pControllerDetails[ i ].m_omStrSampling.c_str(),
                                            &pcStopStr, 10)
|Node:( Text: (
|Node:call_expression Text: pControllerDetails[ i ].m_omStrSampling.c_str()
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSampling.c_str
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSampling
|Node:subscript_expression Text: pControllerDetails[ i ]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [ i ]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omStrSampling
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &pcStopStr
|Node:& Text: &
|Node:identifier Text: pcStopStr
|Node:, Text: ,
|Node:number_literal Text: 10
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10));
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.samplePoint =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10))
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.samplePoint
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: samplePoint
|Node:= Text: =
|Node:call_expression Text: static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10))
|Node:template_function Text: static_cast <UINT>
|Node:identifier Text: static_cast
|Node:template_argument_list Text: <UINT>
|Node:< Text: <
|Node:type_descriptor Text: UINT
|Node:type_identifier Text: UINT
|Node:> Text: >
|Node:argument_list Text: (_tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10))
|Node:( Text: (
|Node:call_expression Text: _tcstol( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10)
|Node:identifier Text: _tcstol
|Node:argument_list Text: ( pControllerDetails[ i ].m_omStrSamplePercentage.c_str(),
                                            &pcStopStr, 10)
|Node:( Text: (
|Node:call_expression Text: pControllerDetails[ i ].m_omStrSamplePercentage.c_str()
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSamplePercentage.c_str
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSamplePercentage
|Node:subscript_expression Text: pControllerDetails[ i ]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [ i ]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omStrSamplePercentage
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &pcStopStr
|Node:& Text: &
|Node:identifier Text: pcStopStr
|Node:, Text: ,
|Node:number_literal Text: 10
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10));
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.SJW =
                static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10))
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.SJW
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: SJW
|Node:= Text: =
|Node:call_expression Text: static_cast <UINT>(_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10))
|Node:template_function Text: static_cast <UINT>
|Node:identifier Text: static_cast
|Node:template_argument_list Text: <UINT>
|Node:< Text: <
|Node:type_descriptor Text: UINT
|Node:type_identifier Text: UINT
|Node:> Text: >
|Node:argument_list Text: (_tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10))
|Node:( Text: (
|Node:call_expression Text: _tcstol( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10)
|Node:identifier Text: _tcstol
|Node:argument_list Text: ( pControllerDetails[ i ].m_omStrSjw.c_str(),
                                            &pcStopStr, 10)
|Node:( Text: (
|Node:call_expression Text: pControllerDetails[ i ].m_omStrSjw.c_str()
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSjw.c_str
|Node:field_expression Text: pControllerDetails[ i ].m_omStrSjw
|Node:subscript_expression Text: pControllerDetails[ i ]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [ i ]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omStrSjw
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &pcStopStr
|Node:& Text: &
|Node:identifier Text: pcStopStr
|Node:, Text: ,
|Node:number_literal Text: 10
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.syncEdge
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: syncEdge
|Node:= Text: =
|Node:identifier Text: OCI_CAN_SINGLE_SYNC_EDGE
|Node:; Text: ;
|Node:if_statement Text: if( FALSE == pControllerDetails [ i ].m_bSelfReception )
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
            else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
|Node:if Text: if
|Node:condition_clause Text: ( FALSE == pControllerDetails [ i ].m_bSelfReception )
|Node:( Text: (
|Node:binary_expression Text: FALSE == pControllerDetails [ i ].m_bSelfReception
|Node:false Text: FALSE
|Node:== Text: ==
|Node:field_expression Text: pControllerDetails [ i ].m_bSelfReception
|Node:subscript_expression Text: pControllerDetails [ i ]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [ i ]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bSelfReception
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_OFF
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: selfReceptionMode
|Node:= Text: =
|Node:identifier Text: OCI_SELF_RECEPTION_OFF
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
            {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
|Node:else Text: else
|Node:compound_statement Text: {
                sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.selfReceptionMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: selfReceptionMode
|Node:= Text: =
|Node:identifier Text: OCI_SELF_RECEPTION_ON
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles = 10
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: BTL_Cycles
|Node:= Text: =
|Node:number_literal Text: 10
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.physicalMedia
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: physicalMedia
|Node:= Text: =
|Node:identifier Text: OCI_CAN_MEDIA_HIGH_SPEED
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles               = pControllerDetails[i].m_unBTL_Cycles
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.BTL_Cycles
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: BTL_Cycles
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unBTL_Cycles
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unBTL_Cycles
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
            /* Set CAN FD parameters */
            sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
            sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
            sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:comment Text: /* Set CAN FD parameters */
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDEnabled = true
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDEnabled
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDEnabled
|Node:= Text: =
|Node:true Text: true
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate                  = pControllerDetails[i].m_unDataBitRate
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBitRate
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataBitRate
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unDataBitRate
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unDataBitRate
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint              = pControllerDetails[i].m_unDataSamplePoint
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSamplePoint
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataSamplePoint
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unDataSamplePoint
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unDataSamplePoint
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles               = pControllerDetails[i].m_unDataBTL_Cycles
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataBTL_Cycles
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataBTL_Cycles
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unDataBTL_Cycles
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unDataBTL_Cycles
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW                      = pControllerDetails[i].m_unDataSJW
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.dataSJW
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: dataSJW
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unDataSJW
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unDataSJW
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl   = (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txDelayCompensationControl
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: txDelayCompensationControl
|Node:= Text: =
|Node:cast_expression Text: (OCI_CANFDTxDelayCompensation)
                    pControllerDetails[i].m_bTxDelayCompensationControl
|Node:( Text: (
|Node:type_descriptor Text: OCI_CANFDTxDelayCompensation
|Node:type_identifier Text: OCI_CANFDTxDelayCompensation
|Node:) Text: )
|Node:field_expression Text: pControllerDetails[i].m_bTxDelayCompensationControl
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bTxDelayCompensationControl
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset = pControllerDetails[i].m_unTxSecondarySamplePointOffset
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.txSecondarySamplePointOffset
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: txSecondarySamplePointOffset
|Node:= Text: =
|Node:field_expression Text: pControllerDetails[i].m_unTxSecondarySamplePointOffset
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_unTxSecondarySamplePointOffset
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode      = (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canRxMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxConfig
|Node:. Text: .
|Node:field_identifier Text: canRxMode
|Node:= Text: =
|Node:cast_expression Text: (OCI_CANRxMode)
                    pControllerDetails[i].m_bytCanRxMode
|Node:( Text: (
|Node:type_descriptor Text: OCI_CANRxMode
|Node:type_identifier Text: OCI_CANRxMode
|Node:) Text: )
|Node:field_expression Text: pControllerDetails[i].m_bytCanRxMode
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bytCanRxMode
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode    = (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig.canFdRxMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdRxConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxConfig
|Node:. Text: .
|Node:field_identifier Text: canFdRxMode
|Node:= Text: =
|Node:cast_expression Text: (OCI_CANFDRxMode)
                    pControllerDetails[i].m_bytCanFdRxMode
|Node:( Text: (
|Node:type_descriptor Text: OCI_CANFDRxMode
|Node:type_identifier Text: OCI_CANFDRxMode
|Node:) Text: )
|Node:field_expression Text: pControllerDetails[i].m_bytCanFdRxMode
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bytCanFdRxMode
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig                = (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig.canFdTxConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.canFDConfig
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: canFDConfig
|Node:. Text: .
|Node:field_identifier Text: canFdTxConfig
|Node:= Text: =
|Node:cast_expression Text: (OCI_CANFDTxConfig)
                    pControllerDetails[i].m_bytCanFdTxConfig
|Node:( Text: (
|Node:type_descriptor Text: OCI_CANFDTxConfig
|Node:type_identifier Text: OCI_CANFDTxConfig
|Node:) Text: )
|Node:field_expression Text: pControllerDetails[i].m_bytCanFdTxConfig
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bytCanFdTxConfig
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CANConfig.busParticipationMode = OCI_BUSMODE_ACTIVE
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig.busParticipationMode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: busParticipationMode
|Node:= Text: =
|Node:identifier Text: OCI_BUSMODE_ACTIVE
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:} Text: }
|Node:expression_statement Text: bReturn = TRUE;
|Node:assignment_expression Text: bReturn = TRUE
|Node:identifier Text: bReturn
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return bReturn;
|Node:return Text: return
|Node:identifier Text: bReturn
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Copies from STCAN_MSG structure into OCI_CANTxMessage message structure
 */
|Node:function_definition Text: static void vCopy_2_OCI_CAN_Data(OCI_CANTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.dlc     = SrcMsg.m_ucDataLen;
    DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: void
|Node:function_declarator Text: vCopy_2_OCI_CAN_Data(OCI_CANTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
|Node:identifier Text: vCopy_2_OCI_CAN_Data
|Node:parameter_list Text: (OCI_CANTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
|Node:( Text: (
|Node:parameter_declaration Text: OCI_CANTxMessage& DestMsg
|Node:type_identifier Text: OCI_CANTxMessage
|Node:reference_declarator Text: & DestMsg
|Node:& Text: &
|Node:identifier Text: DestMsg
|Node:, Text: ,
|Node:parameter_declaration Text: const STCAN_MSG& SrcMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: STCAN_MSG
|Node:reference_declarator Text: & SrcMsg
|Node:& Text: &
|Node:identifier Text: SrcMsg
|Node:) Text: )
|Node:compound_statement Text: {
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.dlc     = SrcMsg.m_ucDataLen;
    DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
}
|Node:{ Text: {
|Node:expression_statement Text: DestMsg.res     = 0;
|Node:assignment_expression Text: DestMsg.res     = 0
|Node:field_expression Text: DestMsg.res
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: res
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.frameID = SrcMsg.m_unMsgID;
|Node:assignment_expression Text: DestMsg.frameID = SrcMsg.m_unMsgID
|Node:field_expression Text: DestMsg.frameID
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: frameID
|Node:= Text: =
|Node:field_expression Text: SrcMsg.m_unMsgID
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.dlc     = SrcMsg.m_ucDataLen;
|Node:assignment_expression Text: DestMsg.dlc     = SrcMsg.m_ucDataLen
|Node:field_expression Text: DestMsg.dlc
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: dlc
|Node:= Text: =
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
|Node:assignment_expression Text: DestMsg.flags   = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0
|Node:field_expression Text: DestMsg.flags
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: flags
|Node:= Text: =
|Node:conditional_expression Text: SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0
|Node:field_expression Text: SrcMsg.m_ucEXTENDED
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucEXTENDED
|Node:? Text: ?
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
|Node:assignment_expression Text: DestMsg.flags   |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0
|Node:field_expression Text: DestMsg.flags
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: flags
|Node:|= Text: |=
|Node:conditional_expression Text: SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0
|Node:field_expression Text: SrcMsg.m_ucRTR
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucRTR
|Node:? Text: ?
|Node:identifier Text: OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
|Node:call_expression Text: memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8)
|Node:identifier Text: memcpy
|Node:argument_list Text: (DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8)
|Node:( Text: (
|Node:field_expression Text: DestMsg.data
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: data
|Node:, Text: ,
|Node:field_expression Text: SrcMsg.m_ucData
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucData
|Node:, Text: ,
|Node:binary_expression Text: sizeof(UCHAR) * 8
|Node:sizeof_expression Text: sizeof(UCHAR)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (UCHAR)
|Node:( Text: (
|Node:identifier Text: UCHAR
|Node:) Text: )
|Node:* Text: *
|Node:number_literal Text: 8
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
static BOOL vCopy_2_OCI_CANFD_Data(OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.size     = SrcMsg.m_ucDataLen;
    if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
    DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
    return TRUE;
}
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:function_definition Text: static BOOL vCopy_2_OCI_CANFD_Data(OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
{
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.size     = SrcMsg.m_ucDataLen;
    if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
    DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
    return TRUE;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: vCopy_2_OCI_CANFD_Data(OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
|Node:identifier Text: vCopy_2_OCI_CANFD_Data
|Node:parameter_list Text: (OCI_CANFDTxMessage& DestMsg, const STCAN_MSG& SrcMsg)
|Node:( Text: (
|Node:parameter_declaration Text: OCI_CANFDTxMessage& DestMsg
|Node:type_identifier Text: OCI_CANFDTxMessage
|Node:reference_declarator Text: & DestMsg
|Node:& Text: &
|Node:identifier Text: DestMsg
|Node:, Text: ,
|Node:parameter_declaration Text: const STCAN_MSG& SrcMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: STCAN_MSG
|Node:reference_declarator Text: & SrcMsg
|Node:& Text: &
|Node:identifier Text: SrcMsg
|Node:) Text: )
|Node:compound_statement Text: {
    DestMsg.res     = 0;
    DestMsg.frameID = SrcMsg.m_unMsgID;
    DestMsg.size     = SrcMsg.m_ucDataLen;
    if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
    DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
    DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
    memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
    return TRUE;
}
|Node:{ Text: {
|Node:expression_statement Text: DestMsg.res     = 0;
|Node:assignment_expression Text: DestMsg.res     = 0
|Node:field_expression Text: DestMsg.res
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: res
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.frameID = SrcMsg.m_unMsgID;
|Node:assignment_expression Text: DestMsg.frameID = SrcMsg.m_unMsgID
|Node:field_expression Text: DestMsg.frameID
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: frameID
|Node:= Text: =
|Node:field_expression Text: SrcMsg.m_unMsgID
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_unMsgID
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.size     = SrcMsg.m_ucDataLen;
|Node:assignment_expression Text: DestMsg.size     = SrcMsg.m_ucDataLen
|Node:field_expression Text: DestMsg.size
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: size
|Node:= Text: =
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:; Text: ;
|Node:if_statement Text: if ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
    {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
|Node:if Text: if
|Node:condition_clause Text: ((SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)))
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg.m_ucDataLen > 8) && (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64))
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen > 8)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen > 8
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:> Text: >
|Node:number_literal Text: 8
|Node:) Text: )
|Node:&& Text: &&
|Node:parenthesized_expression Text: (
        (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64))
|Node:( Text: (
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48) ||
        (SrcMsg.m_ucDataLen != 64)
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32) ||
        (SrcMsg.m_ucDataLen != 48)
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24) ||
        (SrcMsg.m_ucDataLen != 32)
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20) ||
        (SrcMsg.m_ucDataLen != 24)
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16) ||
        (SrcMsg.m_ucDataLen != 20)
|Node:binary_expression Text: (SrcMsg.m_ucDataLen != 12) || 
        (SrcMsg.m_ucDataLen != 16)
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 12)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 12
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 12
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 16)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 16
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 16
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 20)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 20
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 20
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 24)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 24
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 24
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 32)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 32
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 32
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 48)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 48
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 48
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (SrcMsg.m_ucDataLen != 64)
|Node:( Text: (
|Node:binary_expression Text: SrcMsg.m_ucDataLen != 64
|Node:field_expression Text: SrcMsg.m_ucDataLen
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucDataLen
|Node:!= Text: !=
|Node:number_literal Text: 64
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
        return FALSE;
    }
|Node:{ Text: {
|Node:expression_statement Text: AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64");
|Node:call_expression Text: AfxMessageBox("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64")
|Node:identifier Text: AfxMessageBox
|Node:argument_list Text: ("Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64")
|Node:( Text: (
|Node:string_literal Text: "Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64"
|Node:" Text: "
|Node:string_content Text: Unsupported Data Length. It should be 0..8, 12, 16, 20, 24, 32, 48 or 64
|Node:" Text: "
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return FALSE;
|Node:return Text: return
|Node:false Text: FALSE
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0;
|Node:assignment_expression Text: DestMsg.flags = SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0
|Node:field_expression Text: DestMsg.flags
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: flags
|Node:= Text: =
|Node:conditional_expression Text: SrcMsg.m_ucEXTENDED ? OCI_CAN_MSG_FLAG_EXTENDED : 0
|Node:field_expression Text: SrcMsg.m_ucEXTENDED
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucEXTENDED
|Node:? Text: ?
|Node:identifier Text: OCI_CAN_MSG_FLAG_EXTENDED
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0;
|Node:assignment_expression Text: DestMsg.flags |= SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0
|Node:field_expression Text: DestMsg.flags
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: flags
|Node:|= Text: |=
|Node:conditional_expression Text: SrcMsg.m_ucRTR ? OCI_CAN_MSG_FLAG_REMOTE_FRAME : 0
|Node:field_expression Text: SrcMsg.m_ucRTR
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucRTR
|Node:? Text: ?
|Node:identifier Text: OCI_CAN_MSG_FLAG_REMOTE_FRAME
|Node:: Text: :
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8);
|Node:call_expression Text: memcpy(DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8)
|Node:identifier Text: memcpy
|Node:argument_list Text: (DestMsg.data, SrcMsg.m_ucData, sizeof(UCHAR) * 8)
|Node:( Text: (
|Node:field_expression Text: DestMsg.data
|Node:identifier Text: DestMsg
|Node:. Text: .
|Node:field_identifier Text: data
|Node:, Text: ,
|Node:field_expression Text: SrcMsg.m_ucData
|Node:identifier Text: SrcMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucData
|Node:, Text: ,
|Node:binary_expression Text: sizeof(UCHAR) * 8
|Node:sizeof_expression Text: sizeof(UCHAR)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (UCHAR)
|Node:( Text: (
|Node:identifier Text: UCHAR
|Node:) Text: )
|Node:* Text: *
|Node:number_literal Text: 8
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return TRUE;
|Node:return Text: return
|Node:true Text: TRUE
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_PerformClosureOperations(void)
{
    HRESULT hResult = S_OK;

    CAN_StopHardware();

    /* deselect hw interface */
    hResult = CAN_DeselectHwInterface();

    /* close the existing handle */
    CloseHandle(sg_hEvent);
    sg_hEvent = NULL;

    /* Remove all the existing clients */
    UINT ClientIndex = 0;
    while (sg_unClientCnt > 0)
    {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }

    /* Delete the critical section */
    DeleteCriticalSection(&sg_DIL_CriticalSection);
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_PerformClosureOperations(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_PerformClosureOperations
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_PerformClosureOperations
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;

    CAN_StopHardware();

    /* deselect hw interface */
    hResult = CAN_DeselectHwInterface();

    /* close the existing handle */
    CloseHandle(sg_hEvent);
    sg_hEvent = NULL;

    /* Remove all the existing clients */
    UINT ClientIndex = 0;
    while (sg_unClientCnt > 0)
    {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }

    /* Delete the critical section */
    DeleteCriticalSection(&sg_DIL_CriticalSection);
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:expression_statement Text: CAN_StopHardware();
|Node:call_expression Text: CAN_StopHardware()
|Node:identifier Text: CAN_StopHardware
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* deselect hw interface */
|Node:expression_statement Text: hResult = CAN_DeselectHwInterface();
|Node:assignment_expression Text: hResult = CAN_DeselectHwInterface()
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: CAN_DeselectHwInterface()
|Node:identifier Text: CAN_DeselectHwInterface
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* close the existing handle */
|Node:expression_statement Text: CloseHandle(sg_hEvent);
|Node:call_expression Text: CloseHandle(sg_hEvent)
|Node:identifier Text: CloseHandle
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sg_hEvent = NULL;
|Node:assignment_expression Text: sg_hEvent = NULL
|Node:identifier Text: sg_hEvent
|Node:= Text: =
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:; Text: ;
|Node:comment Text: /* Remove all the existing clients */
|Node:declaration Text: UINT ClientIndex = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: ClientIndex = 0
|Node:identifier Text: ClientIndex
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:while_statement Text: while (sg_unClientCnt > 0)
    {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }
|Node:while Text: while
|Node:condition_clause Text: (sg_unClientCnt > 0)
|Node:( Text: (
|Node:binary_expression Text: sg_unClientCnt > 0
|Node:identifier Text: sg_unClientCnt
|Node:> Text: >
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
        bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
    }
|Node:{ Text: {
|Node:expression_statement Text: bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID);
|Node:call_expression Text: bRemoveClient(sg_asClientToBufMap[ClientIndex].m_dwClientID)
|Node:identifier Text: bRemoveClient
|Node:argument_list Text: (sg_asClientToBufMap[ClientIndex].m_dwClientID)
|Node:( Text: (
|Node:field_expression Text: sg_asClientToBufMap[ClientIndex].m_dwClientID
|Node:subscript_expression Text: sg_asClientToBufMap[ClientIndex]
|Node:identifier Text: sg_asClientToBufMap
|Node:subscript_argument_list Text: [ClientIndex]
|Node:[ Text: [
|Node:identifier Text: ClientIndex
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwClientID
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Delete the critical section */
|Node:expression_statement Text: DeleteCriticalSection(&sg_DIL_CriticalSection);
|Node:call_expression Text: DeleteCriticalSection(&sg_DIL_CriticalSection)
|Node:identifier Text: DeleteCriticalSection
|Node:argument_list Text: (&sg_DIL_CriticalSection)
|Node:( Text: (
|Node:pointer_expression Text: &sg_DIL_CriticalSection
|Node:& Text: &
|Node:identifier Text: sg_DIL_CriticalSection
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (hResult == S_OK)
    {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
        sg_bCurrState = STATE_DRIVER_SELECTED;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_bCurrState = STATE_DRIVER_SELECTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_DRIVER_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_DRIVER_SELECTED
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
{
    CurrSysTime = sg_CurrSysTime;
    TimeStamp   = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetTimeModeMapping(SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetTimeModeMapping
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetTimeModeMapping
|Node:parameter_list Text: (SYSTEMTIME& CurrSysTime, UINT64& TimeStamp, LARGE_INTEGER* QueryTickCount)
|Node:( Text: (
|Node:parameter_declaration Text: SYSTEMTIME& CurrSysTime
|Node:type_identifier Text: SYSTEMTIME
|Node:reference_declarator Text: & CurrSysTime
|Node:& Text: &
|Node:identifier Text: CurrSysTime
|Node:, Text: ,
|Node:parameter_declaration Text: UINT64& TimeStamp
|Node:type_identifier Text: UINT64
|Node:reference_declarator Text: & TimeStamp
|Node:& Text: &
|Node:identifier Text: TimeStamp
|Node:, Text: ,
|Node:parameter_declaration Text: LARGE_INTEGER* QueryTickCount
|Node:type_identifier Text: LARGE_INTEGER
|Node:pointer_declarator Text: * QueryTickCount
|Node:* Text: *
|Node:identifier Text: QueryTickCount
|Node:) Text: )
|Node:compound_statement Text: {
    CurrSysTime = sg_CurrSysTime;
    TimeStamp   = sg_TimeStamp;
    if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
    return S_OK;
}
|Node:{ Text: {
|Node:expression_statement Text: CurrSysTime = sg_CurrSysTime;
|Node:assignment_expression Text: CurrSysTime = sg_CurrSysTime
|Node:identifier Text: CurrSysTime
|Node:= Text: =
|Node:identifier Text: sg_CurrSysTime
|Node:; Text: ;
|Node:expression_statement Text: TimeStamp   = sg_TimeStamp;
|Node:assignment_expression Text: TimeStamp   = sg_TimeStamp
|Node:identifier Text: TimeStamp
|Node:= Text: =
|Node:identifier Text: sg_TimeStamp
|Node:; Text: ;
|Node:if_statement Text: if(QueryTickCount != NULL)
    {
        *QueryTickCount = sg_QueryTickCount;
    }
|Node:if Text: if
|Node:condition_clause Text: (QueryTickCount != NULL)
|Node:( Text: (
|Node:binary_expression Text: QueryTickCount != NULL
|Node:identifier Text: QueryTickCount
|Node:!= Text: !=
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:) Text: )
|Node:compound_statement Text: {
        *QueryTickCount = sg_QueryTickCount;
    }
|Node:{ Text: {
|Node:expression_statement Text: *QueryTickCount = sg_QueryTickCount;
|Node:assignment_expression Text: *QueryTickCount = sg_QueryTickCount
|Node:pointer_expression Text: *QueryTickCount
|Node:* Text: *
|Node:identifier Text: QueryTickCount
|Node:= Text: =
|Node:identifier Text: sg_QueryTickCount
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * This function will popup hardware selection dialog and gets the user selection of channels.
 *
 * @return Operation Result. 0 incase of no errors. Failure Error codes otherwise.
 */
|Node:function_definition Text: static int ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    INT nRet = HwList.DoModal();
    objMainWnd.Detach();

    if ( nRet == IDOK)
    {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
    else
    {
        return -1;
    }
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: int
|Node:function_declarator Text: ListHardwareInterfaces(HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
|Node:identifier Text: ListHardwareInterfaces
|Node:parameter_list Text: (HWND hParent, DWORD /*dwDriver*/, INTERFACE_HW* psInterfaces, int* pnSelList, int& nCount)
|Node:( Text: (
|Node:parameter_declaration Text: HWND hParent
|Node:type_identifier Text: HWND
|Node:identifier Text: hParent
|Node:, Text: ,
|Node:parameter_declaration Text: DWORD
|Node:type_identifier Text: DWORD
|Node:comment Text: /*dwDriver*/
|Node:, Text: ,
|Node:parameter_declaration Text: INTERFACE_HW* psInterfaces
|Node:type_identifier Text: INTERFACE_HW
|Node:pointer_declarator Text: * psInterfaces
|Node:* Text: *
|Node:identifier Text: psInterfaces
|Node:, Text: ,
|Node:parameter_declaration Text: int* pnSelList
|Node:primitive_type Text: int
|Node:pointer_declarator Text: * pnSelList
|Node:* Text: *
|Node:identifier Text: pnSelList
|Node:, Text: ,
|Node:parameter_declaration Text: int& nCount
|Node:primitive_type Text: int
|Node:reference_declarator Text: & nCount
|Node:& Text: &
|Node:identifier Text: nCount
|Node:) Text: )
|Node:compound_statement Text: {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd objMainWnd;
    objMainWnd.Attach(hParent);
    CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
    INT nRet = HwList.DoModal();
    objMainWnd.Detach();

    if ( nRet == IDOK)
    {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
    else
    {
        return -1;
    }
}
|Node:{ Text: {
|Node:expression_statement Text: AFX_MANAGE_STATE(AfxGetStaticModuleState());
|Node:call_expression Text: AFX_MANAGE_STATE(AfxGetStaticModuleState())
|Node:identifier Text: AFX_MANAGE_STATE
|Node:argument_list Text: (AfxGetStaticModuleState())
|Node:( Text: (
|Node:call_expression Text: AfxGetStaticModuleState()
|Node:identifier Text: AfxGetStaticModuleState
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: CWnd objMainWnd;
|Node:type_identifier Text: CWnd
|Node:identifier Text: objMainWnd
|Node:; Text: ;
|Node:expression_statement Text: objMainWnd.Attach(hParent);
|Node:call_expression Text: objMainWnd.Attach(hParent)
|Node:field_expression Text: objMainWnd.Attach
|Node:identifier Text: objMainWnd
|Node:. Text: .
|Node:field_identifier Text: Attach
|Node:argument_list Text: (hParent)
|Node:( Text: (
|Node:identifier Text: hParent
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: CHardwareListing HwList(psInterfaces, nCount, pnSelList, &objMainWnd);
|Node:type_identifier Text: CHardwareListing
|Node:init_declarator Text: HwList(psInterfaces, nCount, pnSelList, &objMainWnd)
|Node:identifier Text: HwList
|Node:argument_list Text: (psInterfaces, nCount, pnSelList, &objMainWnd)
|Node:( Text: (
|Node:identifier Text: psInterfaces
|Node:, Text: ,
|Node:identifier Text: nCount
|Node:, Text: ,
|Node:identifier Text: pnSelList
|Node:, Text: ,
|Node:pointer_expression Text: &objMainWnd
|Node:& Text: &
|Node:identifier Text: objMainWnd
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: INT nRet = HwList.DoModal();
|Node:type_identifier Text: INT
|Node:init_declarator Text: nRet = HwList.DoModal()
|Node:identifier Text: nRet
|Node:= Text: =
|Node:call_expression Text: HwList.DoModal()
|Node:field_expression Text: HwList.DoModal
|Node:identifier Text: HwList
|Node:. Text: .
|Node:field_identifier Text: DoModal
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: objMainWnd.Detach();
|Node:call_expression Text: objMainWnd.Detach()
|Node:field_expression Text: objMainWnd.Detach
|Node:identifier Text: objMainWnd
|Node:. Text: .
|Node:field_identifier Text: Detach
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if ( nRet == IDOK)
    {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
    else
    {
        return -1;
    }
|Node:if Text: if
|Node:condition_clause Text: ( nRet == IDOK)
|Node:( Text: (
|Node:binary_expression Text: nRet == IDOK
|Node:identifier Text: nRet
|Node:== Text: ==
|Node:identifier Text: IDOK
|Node:) Text: )
|Node:compound_statement Text: {
        nCount = HwList.nGetSelectedList(pnSelList);
        return 0;
    }
|Node:{ Text: {
|Node:expression_statement Text: nCount = HwList.nGetSelectedList(pnSelList);
|Node:assignment_expression Text: nCount = HwList.nGetSelectedList(pnSelList)
|Node:identifier Text: nCount
|Node:= Text: =
|Node:call_expression Text: HwList.nGetSelectedList(pnSelList)
|Node:field_expression Text: HwList.nGetSelectedList
|Node:identifier Text: HwList
|Node:. Text: .
|Node:field_identifier Text: nGetSelectedList
|Node:argument_list Text: (pnSelList)
|Node:( Text: (
|Node:identifier Text: pnSelList
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return 0;
|Node:return Text: return
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
    {
        return -1;
    }
|Node:else Text: else
|Node:compound_statement Text: {
        return -1;
    }
|Node:{ Text: {
|Node:return_statement Text: return -1;
|Node:return Text: return
|Node:number_literal Text: -1
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
{
    // VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_DRIVER_SELECTED, ERR_IMPROPER_STATE);
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;
    OCI_URIName acURI[defNO_OF_CHANNELS];
    INT nFound = 0;

    UINT unDefaultChannelCnt = nCount;

    if (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
    {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_ListHwInterfaces(INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_ListHwInterfaces
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_ListHwInterfaces
|Node:parameter_list Text: (INTERFACE_HW_LIST& asSelHwInterface, INT& nCount)
|Node:( Text: (
|Node:parameter_declaration Text: INTERFACE_HW_LIST& asSelHwInterface
|Node:type_identifier Text: INTERFACE_HW_LIST
|Node:reference_declarator Text: & asSelHwInterface
|Node:& Text: &
|Node:identifier Text: asSelHwInterface
|Node:, Text: ,
|Node:parameter_declaration Text: INT& nCount
|Node:type_identifier Text: INT
|Node:reference_declarator Text: & nCount
|Node:& Text: &
|Node:identifier Text: nCount
|Node:) Text: )
|Node:compound_statement Text: {
    // VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_DRIVER_SELECTED, ERR_IMPROPER_STATE);
    USES_CONVERSION;
    HRESULT hResult = S_FALSE;
    OCI_URIName acURI[defNO_OF_CHANNELS];
    INT nFound = 0;

    UINT unDefaultChannelCnt = nCount;

    if (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
    {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:comment Text: // VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_DRIVER_SELECTED, ERR_IMPROPER_STATE);
|Node:expression_statement Text: USES_CONVERSION;
|Node:identifier Text: USES_CONVERSION
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:declaration Text: OCI_URIName acURI[defNO_OF_CHANNELS];
|Node:type_identifier Text: OCI_URIName
|Node:array_declarator Text: acURI[defNO_OF_CHANNELS]
|Node:identifier Text: acURI
|Node:[ Text: [
|Node:identifier Text: defNO_OF_CHANNELS
|Node:] Text: ]
|Node:; Text: ;
|Node:declaration Text: INT nFound = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: nFound = 0
|Node:identifier Text: nFound
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: UINT unDefaultChannelCnt = nCount;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: unDefaultChannelCnt = nCount
|Node:identifier Text: unDefaultChannelCnt
|Node:= Text: =
|Node:identifier Text: nCount
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
    {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound))
|Node:( Text: (
|Node:call_expression Text: OCI_FindCANController(acURI, defNO_OF_CHANNELS, &nFound)
|Node:identifier Text: OCI_FindCANController
|Node:argument_list Text: (acURI, defNO_OF_CHANNELS, &nFound)
|Node:( Text: (
|Node:identifier Text: acURI
|Node:, Text: ,
|Node:identifier Text: defNO_OF_CHANNELS
|Node:, Text: ,
|Node:pointer_expression Text: &nFound
|Node:& Text: &
|Node:identifier Text: nFound
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        nCount = nFound;
        qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);

        /* Success only if there exists at least one hw */
        if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
    }
|Node:{ Text: {
|Node:expression_statement Text: nCount = nFound;
|Node:assignment_expression Text: nCount = nFound
|Node:identifier Text: nCount
|Node:= Text: =
|Node:identifier Text: nFound
|Node:; Text: ;
|Node:expression_statement Text: qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn);
|Node:call_expression Text: qsort((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn)
|Node:identifier Text: qsort
|Node:argument_list Text: ((void*)acURI, nCount, sizeof(OCI_URIName), nCallBackStrCompareFn)
|Node:( Text: (
|Node:cast_expression Text: (void*)acURI
|Node:( Text: (
|Node:type_descriptor Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:identifier Text: acURI
|Node:, Text: ,
|Node:identifier Text: nCount
|Node:, Text: ,
|Node:sizeof_expression Text: sizeof(OCI_URIName)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (OCI_URIName)
|Node:( Text: (
|Node:identifier Text: OCI_URIName
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: nCallBackStrCompareFn
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Success only if there exists at least one hw */
|Node:if_statement Text: if (nCount > 0) 
        {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
        else
        {
            hResult = NO_HW_INTERFACE;
        }
|Node:if Text: if
|Node:condition_clause Text: (nCount > 0)
|Node:( Text: (
|Node:binary_expression Text: nCount > 0
|Node:identifier Text: nCount
|Node:> Text: >
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
            INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
            /* set the current number of channels */
            nCount = min(nCount, defNO_OF_CHANNELS);


            for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }

            /* List hw interface if there are more than one hw */
            if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }

            sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
            for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }

            sg_bCurrState = STATE_HW_INTERFACE_LISTED;
            hResult = S_OK;
        }
|Node:{ Text: {
|Node:declaration Text: INTERFACE_HW psHWInterface[defNO_OF_CHANNELS];
|Node:type_identifier Text: INTERFACE_HW
|Node:array_declarator Text: psHWInterface[defNO_OF_CHANNELS]
|Node:identifier Text: psHWInterface
|Node:[ Text: [
|Node:identifier Text: defNO_OF_CHANNELS
|Node:] Text: ]
|Node:; Text: ;
|Node:comment Text: /* set the current number of channels */
|Node:expression_statement Text: nCount = min(nCount, defNO_OF_CHANNELS);
|Node:assignment_expression Text: nCount = min(nCount, defNO_OF_CHANNELS)
|Node:identifier Text: nCount
|Node:= Text: =
|Node:call_expression Text: min(nCount, defNO_OF_CHANNELS)
|Node:identifier Text: min
|Node:argument_list Text: (nCount, defNO_OF_CHANNELS)
|Node:( Text: (
|Node:identifier Text: nCount
|Node:, Text: ,
|Node:identifier Text: defNO_OF_CHANNELS
|Node:) Text: )
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < nCount; i++)
            {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < nCount
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: nCount
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                psHWInterface[i].m_dwIdInterface = 0;
                psHWInterface[i].m_dwVendor = 0;
                psHWInterface[i].m_acDeviceName = "";
                psHWInterface[i].m_acNameInterface = acURI[i];
                psHWInterface[i].m_acDescription = acURI[i];
            }
|Node:{ Text: {
|Node:expression_statement Text: psHWInterface[i].m_dwIdInterface = 0;
|Node:assignment_expression Text: psHWInterface[i].m_dwIdInterface = 0
|Node:field_expression Text: psHWInterface[i].m_dwIdInterface
|Node:subscript_expression Text: psHWInterface[i]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwIdInterface
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: psHWInterface[i].m_dwVendor = 0;
|Node:assignment_expression Text: psHWInterface[i].m_dwVendor = 0
|Node:field_expression Text: psHWInterface[i].m_dwVendor
|Node:subscript_expression Text: psHWInterface[i]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwVendor
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: psHWInterface[i].m_acDeviceName = "";
|Node:assignment_expression Text: psHWInterface[i].m_acDeviceName = ""
|Node:field_expression Text: psHWInterface[i].m_acDeviceName
|Node:subscript_expression Text: psHWInterface[i]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acDeviceName
|Node:= Text: =
|Node:string_literal Text: ""
|Node:" Text: "
|Node:" Text: "
|Node:; Text: ;
|Node:expression_statement Text: psHWInterface[i].m_acNameInterface = acURI[i];
|Node:assignment_expression Text: psHWInterface[i].m_acNameInterface = acURI[i]
|Node:field_expression Text: psHWInterface[i].m_acNameInterface
|Node:subscript_expression Text: psHWInterface[i]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acNameInterface
|Node:= Text: =
|Node:subscript_expression Text: acURI[i]
|Node:identifier Text: acURI
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:; Text: ;
|Node:expression_statement Text: psHWInterface[i].m_acDescription = acURI[i];
|Node:assignment_expression Text: psHWInterface[i].m_acDescription = acURI[i]
|Node:field_expression Text: psHWInterface[i].m_acDescription
|Node:subscript_expression Text: psHWInterface[i]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acDescription
|Node:= Text: =
|Node:subscript_expression Text: acURI[i]
|Node:identifier Text: acURI
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* List hw interface if there are more than one hw */
|Node:if_statement Text: if (nCount > 1)
            {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }
|Node:if Text: if
|Node:condition_clause Text: (nCount > 1)
|Node:( Text: (
|Node:binary_expression Text: nCount > 1
|Node:identifier Text: nCount
|Node:> Text: >
|Node:number_literal Text: 1
|Node:) Text: )
|Node:compound_statement Text: {
                /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
                if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
            }
|Node:{ Text: {
|Node:comment Text: /* If the default channel count parameter is set, prevent displaying the hardware selection dialog */
|Node:if_statement Text: if ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
                {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
                else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
|Node:if Text: if
|Node:condition_clause Text: ( unDefaultChannelCnt && nCount >= unDefaultChannelCnt )
|Node:( Text: (
|Node:binary_expression Text: unDefaultChannelCnt && nCount >= unDefaultChannelCnt
|Node:identifier Text: unDefaultChannelCnt
|Node:&& Text: &&
|Node:binary_expression Text: nCount >= unDefaultChannelCnt
|Node:identifier Text: nCount
|Node:>= Text: >=
|Node:identifier Text: unDefaultChannelCnt
|Node:) Text: )
|Node:compound_statement Text: {
                    for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
                    nCount  = unDefaultChannelCnt;
                }
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < unDefaultChannelCnt; i++)
                    {
                        sg_anSelectedItems[i] = i;
                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < unDefaultChannelCnt
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: unDefaultChannelCnt
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                        sg_anSelectedItems[i] = i;
                    }
|Node:{ Text: {
|Node:expression_statement Text: sg_anSelectedItems[i] = i;
|Node:assignment_expression Text: sg_anSelectedItems[i] = i
|Node:subscript_expression Text: sg_anSelectedItems[i]
|Node:identifier Text: sg_anSelectedItems
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:identifier Text: i
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: nCount  = unDefaultChannelCnt;
|Node:assignment_expression Text: nCount  = unDefaultChannelCnt
|Node:identifier Text: nCount
|Node:= Text: =
|Node:identifier Text: unDefaultChannelCnt
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
|Node:else Text: else
|Node:if_statement Text: if ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
                {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
|Node:if Text: if
|Node:condition_clause Text: ( ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0 )
|Node:( Text: (
|Node:binary_expression Text: ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount) != 0
|Node:call_expression Text: ListHardwareInterfaces(NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount)
|Node:identifier Text: ListHardwareInterfaces
|Node:argument_list Text: (NULL, DRIVER_CAN_ETAS_BOA, psHWInterface, sg_anSelectedItems, nCount)
|Node:( Text: (
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:, Text: ,
|Node:identifier Text: DRIVER_CAN_ETAS_BOA
|Node:, Text: ,
|Node:identifier Text: psHWInterface
|Node:, Text: ,
|Node:identifier Text: sg_anSelectedItems
|Node:, Text: ,
|Node:identifier Text: nCount
|Node:) Text: )
|Node:!= Text: !=
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
                    /* return if user cancels hardware selection */
                    return HW_INTERFACE_NO_SEL;
                }
|Node:{ Text: {
|Node:comment Text: /* return if user cancels hardware selection */
|Node:return_statement Text: return HW_INTERFACE_NO_SEL;
|Node:return Text: return
|Node:identifier Text: HW_INTERFACE_NO_SEL
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:expression_statement Text: sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS);
|Node:assignment_expression Text: sg_nNoOfChannels = min(nCount, defNO_OF_CHANNELS)
|Node:identifier Text: sg_nNoOfChannels
|Node:= Text: =
|Node:call_expression Text: min(nCount, defNO_OF_CHANNELS)
|Node:identifier Text: min
|Node:argument_list Text: (nCount, defNO_OF_CHANNELS)
|Node:( Text: (
|Node:identifier Text: nCount
|Node:, Text: ,
|Node:identifier Text: defNO_OF_CHANNELS
|Node:) Text: )
|Node:; Text: ;
|Node:for_statement Text: for (UINT nList = 0; nList < sg_nNoOfChannels; nList++)
            {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT nList = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: nList = 0
|Node:identifier Text: nList
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: nList < sg_nNoOfChannels
|Node:identifier Text: nList
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: nList++
|Node:identifier Text: nList
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
                asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
                asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
                asSelHwInterface[nList].m_dwIdInterface = 100 + nList; // Give a dummy number
            }
|Node:{ Text: {
|Node:expression_statement Text: asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface;
|Node:assignment_expression Text: asSelHwInterface[nList].m_acNameInterface = psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface
|Node:field_expression Text: asSelHwInterface[nList].m_acNameInterface
|Node:subscript_expression Text: asSelHwInterface[nList]
|Node:identifier Text: asSelHwInterface
|Node:subscript_argument_list Text: [nList]
|Node:[ Text: [
|Node:identifier Text: nList
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acNameInterface
|Node:= Text: =
|Node:field_expression Text: psHWInterface[sg_anSelectedItems[nList]].m_acNameInterface
|Node:subscript_expression Text: psHWInterface[sg_anSelectedItems[nList]]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [sg_anSelectedItems[nList]]
|Node:[ Text: [
|Node:subscript_expression Text: sg_anSelectedItems[nList]
|Node:identifier Text: sg_anSelectedItems
|Node:subscript_argument_list Text: [nList]
|Node:[ Text: [
|Node:identifier Text: nList
|Node:] Text: ]
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acNameInterface
|Node:; Text: ;
|Node:expression_statement Text: asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription;
|Node:assignment_expression Text: asSelHwInterface[nList].m_acDescription = psHWInterface[sg_anSelectedItems[nList]].m_acDescription
|Node:field_expression Text: asSelHwInterface[nList].m_acDescription
|Node:subscript_expression Text: asSelHwInterface[nList]
|Node:identifier Text: asSelHwInterface
|Node:subscript_argument_list Text: [nList]
|Node:[ Text: [
|Node:identifier Text: nList
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acDescription
|Node:= Text: =
|Node:field_expression Text: psHWInterface[sg_anSelectedItems[nList]].m_acDescription
|Node:subscript_expression Text: psHWInterface[sg_anSelectedItems[nList]]
|Node:identifier Text: psHWInterface
|Node:subscript_argument_list Text: [sg_anSelectedItems[nList]]
|Node:[ Text: [
|Node:subscript_expression Text: sg_anSelectedItems[nList]
|Node:identifier Text: sg_anSelectedItems
|Node:subscript_argument_list Text: [nList]
|Node:[ Text: [
|Node:identifier Text: nList
|Node:] Text: ]
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acDescription
|Node:; Text: ;
|Node:expression_statement Text: asSelHwInterface[nList].m_dwIdInterface = 100 + nList;
|Node:assignment_expression Text: asSelHwInterface[nList].m_dwIdInterface = 100 + nList
|Node:field_expression Text: asSelHwInterface[nList].m_dwIdInterface
|Node:subscript_expression Text: asSelHwInterface[nList]
|Node:identifier Text: asSelHwInterface
|Node:subscript_argument_list Text: [nList]
|Node:[ Text: [
|Node:identifier Text: nList
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_dwIdInterface
|Node:= Text: =
|Node:binary_expression Text: 100 + nList
|Node:number_literal Text: 100
|Node:+ Text: +
|Node:identifier Text: nList
|Node:; Text: ;
|Node:comment Text: // Give a dummy number
|Node:} Text: }
|Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_HW_INTERFACE_LISTED
|Node:; Text: ;
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = NO_HW_INTERFACE;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = NO_HW_INTERFACE;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = NO_HW_INTERFACE;
|Node:assignment_expression Text: hResult = NO_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: NO_HW_INTERFACE
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_SelectHwInterface(const INTERFACE_HW_LIST& asSelHwInterface, INT /*nCount*/)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    /* First select only supported number of HW interfaces */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }

    /* Create the controller instance. */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_SelectHwInterface(const INTERFACE_HW_LIST& asSelHwInterface, INT /*nCount*/)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_SelectHwInterface
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_SelectHwInterface
|Node:parameter_list Text: (const INTERFACE_HW_LIST& asSelHwInterface, INT /*nCount*/)
|Node:( Text: (
|Node:parameter_declaration Text: const INTERFACE_HW_LIST& asSelHwInterface
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: INTERFACE_HW_LIST
|Node:reference_declarator Text: & asSelHwInterface
|Node:& Text: &
|Node:identifier Text: asSelHwInterface
|Node:, Text: ,
|Node:parameter_declaration Text: INT
|Node:type_identifier Text: INT
|Node:comment Text: /*nCount*/
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);

    USES_CONVERSION;
    HRESULT hResult = S_OK;

    /* First select only supported number of HW interfaces */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }

    /* Create the controller instance. */
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
    return hResult;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_LISTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_HW_INTERFACE_LISTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: USES_CONVERSION;
|Node:identifier Text: USES_CONVERSION
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:comment Text: /* First select only supported number of HW interfaces */
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
    }
|Node:{ Text: {
|Node:expression_statement Text: strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str());
|Node:call_expression Text: strcpy_s(sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str())
|Node:identifier Text: strcpy_s
|Node:argument_list Text: (sg_asChannel[i].m_acURI, asSelHwInterface[i].m_acNameInterface.c_str())
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:, Text: ,
|Node:call_expression Text: asSelHwInterface[i].m_acNameInterface.c_str()
|Node:field_expression Text: asSelHwInterface[i].m_acNameInterface.c_str
|Node:field_expression Text: asSelHwInterface[i].m_acNameInterface
|Node:subscript_expression Text: asSelHwInterface[i]
|Node:identifier Text: asSelHwInterface
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acNameInterface
|Node:. Text: .
|Node:field_identifier Text: c_str
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /* Create the controller instance. */
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        BOA_ResultCode err=0;
        // bool bSUpportCAN_FD = false;
#if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
        if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
    }
|Node:{ Text: {
|Node:declaration Text: BOA_ResultCode err=0;
|Node:type_identifier Text: BOA_ResultCode
|Node:init_declarator Text: err=0
|Node:identifier Text: err
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:comment Text: // bool bSUpportCAN_FD = false;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        BOA_Version                     version = {1, 3, 0, 0};

        BOA_Version                     version1 = {1, 1, 0, 0};

        err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));

        if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }


#else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: BOA_Version                     version = {1, 3, 0, 0};
|Node:type_identifier Text: BOA_Version
|Node:init_declarator Text: version = {1, 3, 0, 0}
|Node:identifier Text: version
|Node:= Text: =
|Node:initializer_list Text: {1, 3, 0, 0}
|Node:{ Text: {
|Node:number_literal Text: 1
|Node:, Text: ,
|Node:number_literal Text: 3
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:} Text: }
|Node:; Text: ;
|Node:declaration Text: BOA_Version                     version1 = {1, 1, 0, 0};
|Node:type_identifier Text: BOA_Version
|Node:init_declarator Text: version1 = {1, 1, 0, 0}
|Node:identifier Text: version1
|Node:= Text: =
|Node:initializer_list Text: {1, 1, 0, 0}
|Node:{ Text: {
|Node:number_literal Text: 1
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:} Text: }
|Node:; Text: ;
|Node:expression_statement Text: err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle));
|Node:assignment_expression Text: err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:identifier Text: err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.createCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.createCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.createCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.createCANController
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: createCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_acURI,&version,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:, Text: ,
|Node:pointer_expression Text: &version
|Node:& Text: &
|Node:identifier Text: version
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_HwHandle)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if(BOA_FAILED(err)  )
        {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
        else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_FAILED(err)  )
|Node:( Text: (
|Node:call_expression Text: BOA_FAILED(err)
|Node:identifier Text: BOA_FAILED
|Node:argument_list Text: (err)
|Node:( Text: (
|Node:identifier Text: err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            // m_bSupportCANFD
            sg_asChannel[i].m_bSupportCANFD = false;

            err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));

        }
|Node:{ Text: {
|Node:comment Text: // m_bSupportCANFD
|Node:expression_statement Text: sg_asChannel[i].m_bSupportCANFD = false;
|Node:assignment_expression Text: sg_asChannel[i].m_bSupportCANFD = false
|Node:field_expression Text: sg_asChannel[i].m_bSupportCANFD
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bSupportCANFD
|Node:= Text: =
|Node:false Text: false
|Node:; Text: ;
|Node:expression_statement Text: err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle));
|Node:assignment_expression Text: err =  (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle))
|Node:identifier Text: err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.createCANController))(sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.createCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.createCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.createCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.createCANController
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: createCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_acURI,&version1,
                    &(sg_asChannel[i].m_OCI_HwHandle))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:, Text: ,
|Node:pointer_expression Text: &version1
|Node:& Text: &
|Node:identifier Text: version1
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_HwHandle)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            sg_asChannel[i].m_bSupportCANFD = true;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            sg_asChannel[i].m_bSupportCANFD = true;
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_bSupportCANFD = true;
|Node:assignment_expression Text: sg_asChannel[i].m_bSupportCANFD = true
|Node:field_expression Text: sg_asChannel[i].m_bSupportCANFD
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bSupportCANFD
|Node:= Text: =
|Node:true Text: true
|Node:; Text: ;
|Node:} Text: }
|Node:preproc_else Text: #else

        err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
|Node:#else Text: #else
|Node:expression_statement Text: err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle));
|Node:assignment_expression Text: err =  (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:identifier Text: err
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.createCANController))(sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.createCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.createCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.createCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.createCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: createCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_acURI,
                &(sg_asChannel[i].m_OCI_HwHandle))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_HwHandle)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:if_statement Text: if (BOA_SUCCEEDED(err))
        {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
        else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(err))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(err)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (err)
|Node:( Text: (
|Node:identifier Text: err
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
            sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
            BOA_ResultCode ErrorCode = OCI_FAILURE;

            /* configure the controller first */
            ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
            if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
        }
|Node:{ Text: {
|Node:comment Text: /*
             * Assign to userdata of QueueCfg. This will be useful to differentiate
             * between the controller
             */
|Node:expression_statement Text: sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData = (void*)sg_asChannel[i].m_OCI_HwHandle
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onFrame.userData
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onFrame
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onFrame
|Node:. Text: .
|Node:field_identifier Text: userData
|Node:= Text: =
|Node:cast_expression Text: (void*)sg_asChannel[i].m_OCI_HwHandle
|Node:( Text: (
|Node:type_descriptor Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:; Text: ;
|Node:expression_statement Text: sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData = (void*)sg_asChannel[i].m_OCI_HwHandle
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onEvent.userData
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg.onEvent
|Node:field_expression Text: sg_asChannel[i].m_OCI_RxQueueCfg
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_RxQueueCfg
|Node:. Text: .
|Node:field_identifier Text: onEvent
|Node:. Text: .
|Node:field_identifier Text: userData
|Node:= Text: =
|Node:cast_expression Text: (void*)sg_asChannel[i].m_OCI_HwHandle
|Node:( Text: (
|Node:type_descriptor Text: void*
|Node:primitive_type Text: void
|Node:abstract_pointer_declarator Text: *
|Node:* Text: *
|Node:) Text: )
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:; Text: ;
|Node:declaration Text: BOA_ResultCode ErrorCode = OCI_FAILURE;
|Node:type_identifier Text: BOA_ResultCode
|Node:init_declarator Text: ErrorCode = OCI_FAILURE
|Node:identifier Text: ErrorCode
|Node:= Text: =
|Node:identifier Text: OCI_FAILURE
|Node:; Text: ;
|Node:comment Text: /* configure the controller first */
|Node:expression_statement Text: ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp));
|Node:assignment_expression Text: ErrorCode = (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:identifier Text: ErrorCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.openCANController))(sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.openCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.openCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.openCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.openCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: openCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                        &(sg_asChannel[i].m_OCI_CANConfig),
                        &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CANConfig)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CANConfig)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(ErrorCode))
            {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
            else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(ErrorCode))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(ErrorCode)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (ErrorCode)
|Node:( Text: (
|Node:identifier Text: ErrorCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }

            }
|Node:{ Text: {
|Node:if_statement Text: if (ManageQueue(QUEUE_ADD, i) == S_OK)
                {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
                else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }
|Node:if Text: if
|Node:condition_clause Text: (ManageQueue(QUEUE_ADD, i) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: ManageQueue(QUEUE_ADD, i) == S_OK
|Node:call_expression Text: ManageQueue(QUEUE_ADD, i)
|Node:identifier Text: ManageQueue
|Node:argument_list Text: (QUEUE_ADD, i)
|Node:( Text: (
|Node:identifier Text: QUEUE_ADD
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                    if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
                }
|Node:{ Text: {
|Node:if_statement Text: if (ManageFilters(FILTER_ADD, i) == S_OK)
                    {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
                    else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
|Node:if Text: if
|Node:condition_clause Text: (ManageFilters(FILTER_ADD, i) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: ManageFilters(FILTER_ADD, i) == S_OK
|Node:call_expression Text: ManageFilters(FILTER_ADD, i)
|Node:identifier Text: ManageFilters
|Node:argument_list Text: (FILTER_ADD, i)
|Node:( Text: (
|Node:identifier Text: FILTER_ADD
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                        hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
                        if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
                    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities));
|Node:assignment_expression Text: hResult = (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities))
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable.getTimerCapabilities
|Node:field_expression Text: sBOA_PTRS.m_sOCI.timeVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: timeVTable
|Node:. Text: .
|Node:field_identifier Text: getTimerCapabilities
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_TimerCapabilities))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_TimerCapabilities)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_TimerCapabilities)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_TimerCapabilities
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TimerCapabilities
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (hResult == S_OK)
                        {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
                        else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                            sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
                        }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency);
|Node:assignment_expression Text: sg_asChannel[i].m_fResolution = (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency)
|Node:field_expression Text: sg_asChannel[i].m_fResolution
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_fResolution
|Node:= Text: =
|Node:binary_expression Text: (float)10000 /
                                                            (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency)
|Node:cast_expression Text: (float)10000
|Node:( Text: (
|Node:type_descriptor Text: float
|Node:primitive_type Text: float
|Node:) Text: )
|Node:number_literal Text: 10000
|Node:/ Text: /
|Node:cast_expression Text: (float)(sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency)
|Node:( Text: (
|Node:type_descriptor Text: float
|Node:primitive_type Text: float
|Node:) Text: )
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_TimerCapabilities.tickFrequency
|Node:field_expression Text: sg_asChannel[i].m_OCI_TimerCapabilities
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TimerCapabilities
|Node:. Text: .
|Node:field_identifier Text: tickFrequency
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                        {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
|Node:else Text: else
|Node:compound_statement Text: {
                            hResult = ERR_LOAD_HW_INTERFACE;
                            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
                        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_LOAD_HW_INTERFACE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get timer resolution"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not get timer resolution"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not get timer resolution")
|Node:identifier Text: _
|Node:argument_list Text: ("could not get timer resolution")
|Node:( Text: (
|Node:string_literal Text: "could not get timer resolution"
|Node:" Text: "
|Node:string_content Text: could not get timer resolution
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
                    {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
|Node:else Text: else
|Node:compound_statement Text: {
                        hResult = ERR_LOAD_HW_INTERFACE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
                    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_LOAD_HW_INTERFACE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not add filters"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not add filters"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not add filters")
|Node:identifier Text: _
|Node:argument_list Text: ("could not add filters")
|Node:( Text: (
|Node:string_literal Text: "could not add filters"
|Node:" Text: "
|Node:string_content Text: could not add filters
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
                {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    hResult = ERR_LOAD_HW_INTERFACE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_LOAD_HW_INTERFACE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could create Rx Queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could create Rx Queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could create Rx Queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could create Rx Queue")
|Node:( Text: (
|Node:string_literal Text: "could create Rx Queue"
|Node:" Text: "
|Node:string_content Text: could create Rx Queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
            {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
|Node:else Text: else
|Node:compound_statement Text: {
                hResult = ERR_LOAD_HW_INTERFACE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_LOAD_HW_INTERFACE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not open controller"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not open controller"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not open controller")
|Node:identifier Text: _
|Node:argument_list Text: ("could not open controller")
|Node:( Text: (
|Node:string_literal Text: "could not open controller"
|Node:" Text: "
|Node:string_content Text: could not open controller
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_LOAD_HW_INTERFACE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_LOAD_HW_INTERFACE;
|Node:assignment_expression Text: hResult = ERR_LOAD_HW_INTERFACE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_LOAD_HW_INTERFACE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not create controller"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not create controller"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not create controller")
|Node:identifier Text: _
|Node:argument_list Text: ("could not create controller")
|Node:( Text: (
|Node:string_literal Text: "could not create controller"
|Node:" Text: "
|Node:string_content Text: could not create controller
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Check for the success */
|Node:if_statement Text: if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_DeselectHwInterface(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }

    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_DeselectHwInterface(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_DeselectHwInterface
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_DeselectHwInterface
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }

    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
    return hResult;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
        {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
|Node:if Text: if
|Node:condition_clause Text: ((hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: (hResult = ManageFilters(FILTER_REMOVE, i)) == S_OK
|Node:parenthesized_expression Text: (hResult = ManageFilters(FILTER_REMOVE, i))
|Node:( Text: (
|Node:assignment_expression Text: hResult = ManageFilters(FILTER_REMOVE, i)
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: ManageFilters(FILTER_REMOVE, i)
|Node:identifier Text: ManageFilters
|Node:argument_list Text: (FILTER_REMOVE, i)
|Node:( Text: (
|Node:identifier Text: FILTER_REMOVE
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
            if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
        }
|Node:{ Text: {
|Node:if_statement Text: if ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
            {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
            else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
|Node:if Text: if
|Node:condition_clause Text: ((hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: (hResult = ManageQueue(QUEUE_DESTROY, i)) == S_OK
|Node:parenthesized_expression Text: (hResult = ManageQueue(QUEUE_DESTROY, i))
|Node:( Text: (
|Node:assignment_expression Text: hResult = ManageQueue(QUEUE_DESTROY, i)
|Node:identifier Text: hResult
|Node:= Text: =
|Node:call_expression Text: ManageQueue(QUEUE_DESTROY, i)
|Node:identifier Text: ManageQueue
|Node:argument_list Text: (QUEUE_DESTROY, i)
|Node:( Text: (
|Node:identifier Text: QUEUE_DESTROY
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
            }
|Node:{ Text: {
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.closeCANController))(sg_asChannel[i].m_OCI_HwHandle)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.closeCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.closeCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.closeCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.closeCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: closeCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                    if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
                }
|Node:{ Text: {
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
                    {
                        hResult |= S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.destroyCANController))(sg_asChannel[i].m_OCI_HwHandle)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.destroyCANController))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.destroyCANController)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.destroyCANController)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.destroyCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: destroyCANController
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                        hResult |= S_OK;
                    }
|Node:{ Text: {
|Node:expression_statement Text: hResult |= S_OK;
|Node:assignment_expression Text: hResult |= S_OK
|Node:identifier Text: hResult
|Node:|= Text: |=
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                    {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
|Node:else Text: else
|Node:compound_statement Text: {
                        hResult = S_FALSE;
                        sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
                    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy controller"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not destroy controller"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not destroy controller")
|Node:identifier Text: _
|Node:argument_list Text: ("could not destroy controller")
|Node:( Text: (
|Node:string_literal Text: "could not destroy controller"
|Node:" Text: "
|Node:string_content Text: could not destroy controller
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not close controller"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not close controller"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not close controller")
|Node:identifier Text: _
|Node:argument_list Text: ("could not close controller")
|Node:( Text: (
|Node:string_literal Text: "could not close controller"
|Node:" Text: "
|Node:string_content Text: could not close controller
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
            {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
|Node:else Text: else
|Node:compound_statement Text: {
                hResult = S_FALSE;
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not destroy the queue"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not destroy the queue"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not destroy the queue")
|Node:identifier Text: _
|Node:argument_list Text: ("could not destroy the queue")
|Node:( Text: (
|Node:string_literal Text: "could not destroy the queue"
|Node:" Text: "
|Node:string_content Text: could not destroy the queue
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not remove the filter"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not remove the filter"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not remove the filter")
|Node:identifier Text: _
|Node:argument_list Text: ("could not remove the filter")
|Node:( Text: (
|Node:string_literal Text: "could not remove the filter"
|Node:" Text: "
|Node:string_content Text: could not remove the filter
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:if_statement Text: if (hResult == S_OK)
    {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
        sg_bCurrState = STATE_HW_INTERFACE_LISTED;
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_LISTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_HW_INTERFACE_LISTED
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Call back function called from ConfigDialogDIL
 *
 * @return TRUE for success, FALSE for failure
 */
|Node:function_definition Text: static BOOL Callback_DILBOA(BYTE /*Argument*/, PSCONTROLLER_DETAILS pDatStream, INT /*Length*/)
{
    return (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK);
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:type_identifier Text: BOOL
|Node:function_declarator Text: Callback_DILBOA(BYTE /*Argument*/, PSCONTROLLER_DETAILS pDatStream, INT /*Length*/)
|Node:identifier Text: Callback_DILBOA
|Node:parameter_list Text: (BYTE /*Argument*/, PSCONTROLLER_DETAILS pDatStream, INT /*Length*/)
|Node:( Text: (
|Node:parameter_declaration Text: BYTE
|Node:type_identifier Text: BYTE
|Node:comment Text: /*Argument*/
|Node:, Text: ,
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS pDatStream
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: pDatStream
|Node:, Text: ,
|Node:parameter_declaration Text: INT
|Node:type_identifier Text: INT
|Node:comment Text: /*Length*/
|Node:) Text: )
|Node:compound_statement Text: {
    return (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK);
}
|Node:{ Text: {
|Node:return_statement Text: return (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK);
|Node:return Text: return
|Node:parenthesized_expression Text: (sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0) == S_OK
|Node:call_expression Text: sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData( pDatStream, 0)
|Node:field_expression Text: sg_pouDIL_CAN_ETAS_BOA->CAN_SetConfigData
|Node:identifier Text: sg_pouDIL_CAN_ETAS_BOA
|Node:-> Text: ->
|Node:field_identifier Text: CAN_SetConfigData
|Node:argument_list Text: ( pDatStream, 0)
|Node:( Text: (
|Node:identifier Text: pDatStream
|Node:, Text: ,
|Node:number_literal Text: 0
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:comment Text: /**
 * Displays the configuration dialog for controller
 *
 * @return S_OK for success, S_FALSE for failure
 */
|Node:function_definition Text: static int DisplayConfigurationDlg(HWND hParent, DILCALLBACK /*ProcDIL*/,
                            PSCONTROLLER_DETAILS pControllerDetails, UINT nCount)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int nResult = WARNING_NOTCONFIRMED;

    SCONTROLLER_DETAILS sController[defNO_OF_CHANNELS];

    for(int i =0 ; i < defNO_OF_CHANNELS; i++)
    {
        sController[i] = pControllerDetails[i];
    }

    CChangeRegisters_CAN_ETAS_BOA ouChangeRegister(NULL, pControllerDetails, nCount);
    ouChangeRegister.DoModal();

    nResult = ouChangeRegister.nGetInitStatus();

    return nResult;
}
|Node:storage_class_specifier Text: static
|Node:static Text: static
|Node:primitive_type Text: int
|Node:function_declarator Text: DisplayConfigurationDlg(HWND hParent, DILCALLBACK /*ProcDIL*/,
                            PSCONTROLLER_DETAILS pControllerDetails, UINT nCount)
|Node:identifier Text: DisplayConfigurationDlg
|Node:parameter_list Text: (HWND hParent, DILCALLBACK /*ProcDIL*/,
                            PSCONTROLLER_DETAILS pControllerDetails, UINT nCount)
|Node:( Text: (
|Node:parameter_declaration Text: HWND hParent
|Node:type_identifier Text: HWND
|Node:identifier Text: hParent
|Node:, Text: ,
|Node:parameter_declaration Text: DILCALLBACK
|Node:type_identifier Text: DILCALLBACK
|Node:comment Text: /*ProcDIL*/
|Node:, Text: ,
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS pControllerDetails
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: pControllerDetails
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nCount
|Node:type_identifier Text: UINT
|Node:identifier Text: nCount
|Node:) Text: )
|Node:compound_statement Text: {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int nResult = WARNING_NOTCONFIRMED;

    SCONTROLLER_DETAILS sController[defNO_OF_CHANNELS];

    for(int i =0 ; i < defNO_OF_CHANNELS; i++)
    {
        sController[i] = pControllerDetails[i];
    }

    CChangeRegisters_CAN_ETAS_BOA ouChangeRegister(NULL, pControllerDetails, nCount);
    ouChangeRegister.DoModal();

    nResult = ouChangeRegister.nGetInitStatus();

    return nResult;
}
|Node:{ Text: {
|Node:expression_statement Text: AFX_MANAGE_STATE(AfxGetStaticModuleState());
|Node:call_expression Text: AFX_MANAGE_STATE(AfxGetStaticModuleState())
|Node:identifier Text: AFX_MANAGE_STATE
|Node:argument_list Text: (AfxGetStaticModuleState())
|Node:( Text: (
|Node:call_expression Text: AfxGetStaticModuleState()
|Node:identifier Text: AfxGetStaticModuleState
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: int nResult = WARNING_NOTCONFIRMED;
|Node:primitive_type Text: int
|Node:init_declarator Text: nResult = WARNING_NOTCONFIRMED
|Node:identifier Text: nResult
|Node:= Text: =
|Node:identifier Text: WARNING_NOTCONFIRMED
|Node:; Text: ;
|Node:declaration Text: SCONTROLLER_DETAILS sController[defNO_OF_CHANNELS];
|Node:type_identifier Text: SCONTROLLER_DETAILS
|Node:array_declarator Text: sController[defNO_OF_CHANNELS]
|Node:identifier Text: sController
|Node:[ Text: [
|Node:identifier Text: defNO_OF_CHANNELS
|Node:] Text: ]
|Node:; Text: ;
|Node:for_statement Text: for(int i =0 ; i < defNO_OF_CHANNELS; i++)
    {
        sController[i] = pControllerDetails[i];
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: int i =0 ;
|Node:primitive_type Text: int
|Node:init_declarator Text: i =0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < defNO_OF_CHANNELS
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: defNO_OF_CHANNELS
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        sController[i] = pControllerDetails[i];
    }
|Node:{ Text: {
|Node:expression_statement Text: sController[i] = pControllerDetails[i];
|Node:assignment_expression Text: sController[i] = pControllerDetails[i]
|Node:subscript_expression Text: sController[i]
|Node:identifier Text: sController
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:= Text: =
|Node:subscript_expression Text: pControllerDetails[i]
|Node:identifier Text: pControllerDetails
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:; Text: ;
|Node:} Text: }
|Node:declaration Text: CChangeRegisters_CAN_ETAS_BOA ouChangeRegister(NULL, pControllerDetails, nCount);
|Node:type_identifier Text: CChangeRegisters_CAN_ETAS_BOA
|Node:init_declarator Text: ouChangeRegister(NULL, pControllerDetails, nCount)
|Node:identifier Text: ouChangeRegister
|Node:argument_list Text: (NULL, pControllerDetails, nCount)
|Node:( Text: (
|Node:null Text: NULL
|Node:NULL Text: NULL
|Node:, Text: ,
|Node:identifier Text: pControllerDetails
|Node:, Text: ,
|Node:identifier Text: nCount
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: ouChangeRegister.DoModal();
|Node:call_expression Text: ouChangeRegister.DoModal()
|Node:field_expression Text: ouChangeRegister.DoModal
|Node:identifier Text: ouChangeRegister
|Node:. Text: .
|Node:field_identifier Text: DoModal
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: nResult = ouChangeRegister.nGetInitStatus();
|Node:assignment_expression Text: nResult = ouChangeRegister.nGetInitStatus()
|Node:identifier Text: nResult
|Node:= Text: =
|Node:call_expression Text: ouChangeRegister.nGetInitStatus()
|Node:field_expression Text: ouChangeRegister.nGetInitStatus
|Node:identifier Text: ouChangeRegister
|Node:. Text: .
|Node:field_identifier Text: nGetInitStatus
|Node:argument_list Text: ()
|Node:( Text: (
|Node:) Text: )
|Node:; Text: ;
|Node:return_statement Text: return nResult;
|Node:return Text: return
|Node:identifier Text: nResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM);

    USES_CONVERSION;

    INT Result = WARN_INITDAT_NCONFIRM;
    PSCONTROLLER_DETAILS psContrlDets = (PSCONTROLLER_DETAILS)InitData;

    /* First initialize with existing hw description */
    for (INT i = 0; i < min(Length, (INT)sg_nNoOfChannels); i++)
    {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
    if (sg_nNoOfChannels > 0)
    {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }

    return Result;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_DisplayConfigDlg(PSCONTROLLER_DETAILS InitData, int& Length)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_DisplayConfigDlg
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_DisplayConfigDlg
|Node:parameter_list Text: (PSCONTROLLER_DETAILS InitData, int& Length)
|Node:( Text: (
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS InitData
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: InitData
|Node:, Text: ,
|Node:parameter_declaration Text: int& Length
|Node:primitive_type Text: int
|Node:reference_declarator Text: & Length
|Node:& Text: &
|Node:identifier Text: Length
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM);

    USES_CONVERSION;

    INT Result = WARN_INITDAT_NCONFIRM;
    PSCONTROLLER_DETAILS psContrlDets = (PSCONTROLLER_DETAILS)InitData;

    /* First initialize with existing hw description */
    for (INT i = 0; i < min(Length, (INT)sg_nNoOfChannels); i++)
    {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
    if (sg_nNoOfChannels > 0)
    {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }

    return Result;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM);
|Node:call_expression Text: VALIDATE_POINTER_RETURN_VAL(InitData, WARN_INITDAT_NCONFIRM)
|Node:identifier Text: VALIDATE_POINTER_RETURN_VAL
|Node:argument_list Text: (InitData, WARN_INITDAT_NCONFIRM)
|Node:( Text: (
|Node:identifier Text: InitData
|Node:, Text: ,
|Node:identifier Text: WARN_INITDAT_NCONFIRM
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: USES_CONVERSION;
|Node:identifier Text: USES_CONVERSION
|Node:; Text: ;
|Node:declaration Text: INT Result = WARN_INITDAT_NCONFIRM;
|Node:type_identifier Text: INT
|Node:init_declarator Text: Result = WARN_INITDAT_NCONFIRM
|Node:identifier Text: Result
|Node:= Text: =
|Node:identifier Text: WARN_INITDAT_NCONFIRM
|Node:; Text: ;
|Node:declaration Text: PSCONTROLLER_DETAILS psContrlDets = (PSCONTROLLER_DETAILS)InitData;
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:init_declarator Text: psContrlDets = (PSCONTROLLER_DETAILS)InitData
|Node:identifier Text: psContrlDets
|Node:= Text: =
|Node:cast_expression Text: (PSCONTROLLER_DETAILS)InitData
|Node:( Text: (
|Node:type_descriptor Text: PSCONTROLLER_DETAILS
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:) Text: )
|Node:identifier Text: InitData
|Node:; Text: ;
|Node:comment Text: /* First initialize with existing hw description */
|Node:for_statement Text: for (INT i = 0; i < min(Length, (INT)sg_nNoOfChannels); i++)
    {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: INT i = 0;
|Node:type_identifier Text: INT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < min(Length, (INT)sg_nNoOfChannels)
|Node:identifier Text: i
|Node:< Text: <
|Node:call_expression Text: min(Length, (INT)sg_nNoOfChannels)
|Node:identifier Text: min
|Node:argument_list Text: (Length, (INT)sg_nNoOfChannels)
|Node:( Text: (
|Node:identifier Text: Length
|Node:, Text: ,
|Node:cast_expression Text: (INT)sg_nNoOfChannels
|Node:( Text: (
|Node:type_descriptor Text: INT
|Node:type_identifier Text: INT
|Node:) Text: )
|Node:identifier Text: sg_nNoOfChannels
|Node:) Text: )
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
    }
|Node:{ Text: {
|Node:expression_statement Text: psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI;
|Node:assignment_expression Text: psContrlDets[i].m_omHardwareDesc = sg_asChannel[i].m_acURI
|Node:field_expression Text: psContrlDets[i].m_omHardwareDesc
|Node:subscript_expression Text: psContrlDets[i]
|Node:identifier Text: psContrlDets
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omHardwareDesc
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:; Text: ;
|Node:} Text: }
|Node:if_statement Text: if (sg_nNoOfChannels > 0)
    {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (sg_nNoOfChannels > 0)
|Node:( Text: (
|Node:binary_expression Text: sg_nNoOfChannels > 0
|Node:identifier Text: sg_nNoOfChannels
|Node:> Text: >
|Node:number_literal Text: 0
|Node:) Text: )
|Node:compound_statement Text: {
        Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
        switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
    }
|Node:{ Text: {
|Node:expression_statement Text: Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels);
|Node:assignment_expression Text: Result = DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels)
|Node:identifier Text: Result
|Node:= Text: =
|Node:call_expression Text: DisplayConfigurationDlg(sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels)
|Node:identifier Text: DisplayConfigurationDlg
|Node:argument_list Text: (sg_hOwnerWnd, Callback_DILBOA,
                                         psContrlDets, sg_nNoOfChannels)
|Node:( Text: (
|Node:identifier Text: sg_hOwnerWnd
|Node:, Text: ,
|Node:identifier Text: Callback_DILBOA
|Node:, Text: ,
|Node:identifier Text: psContrlDets
|Node:, Text: ,
|Node:identifier Text: sg_nNoOfChannels
|Node:) Text: )
|Node:; Text: ;
|Node:switch_statement Text: switch (Result)
        {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
|Node:switch Text: switch
|Node:condition_clause Text: (Result)
|Node:( Text: (
|Node:identifier Text: Result
|Node:) Text: )
|Node:compound_statement Text: {
            case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;

            case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;

            case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;

            case ERR_CONFIRMED_CONFIGURED: // Not to be addressed at present
            case INFO_CONFIRMED_CONFIGURED: // Not to be addressed at present
            default:
                /* Do nothing... default return value is S_FALSE. */
                break;
        }
|Node:{ Text: {
|Node:case_statement Text: case WARNING_NOTCONFIRMED:
                Result = WARN_INITDAT_NCONFIRM;
            break;
|Node:case Text: case
|Node:identifier Text: WARNING_NOTCONFIRMED
|Node:: Text: :
|Node:expression_statement Text: Result = WARN_INITDAT_NCONFIRM;
|Node:assignment_expression Text: Result = WARN_INITDAT_NCONFIRM
|Node:identifier Text: Result
|Node:= Text: =
|Node:identifier Text: WARN_INITDAT_NCONFIRM
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case INFO_INIT_DATA_CONFIRMED:
                Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
                Result = CAN_SetConfigData(psContrlDets, Length);
                if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
            break;
|Node:case Text: case
|Node:identifier Text: INFO_INIT_DATA_CONFIRMED
|Node:: Text: :
|Node:expression_statement Text: Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS;
|Node:assignment_expression Text: Length = sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS
|Node:identifier Text: Length
|Node:= Text: =
|Node:binary_expression Text: sizeof(SCONTROLLER_DETAILS) * defNO_OF_CHANNELS
|Node:sizeof_expression Text: sizeof(SCONTROLLER_DETAILS)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (SCONTROLLER_DETAILS)
|Node:( Text: (
|Node:identifier Text: SCONTROLLER_DETAILS
|Node:) Text: )
|Node:* Text: *
|Node:identifier Text: defNO_OF_CHANNELS
|Node:; Text: ;
|Node:expression_statement Text: Result = CAN_SetConfigData(psContrlDets, Length);
|Node:assignment_expression Text: Result = CAN_SetConfigData(psContrlDets, Length)
|Node:identifier Text: Result
|Node:= Text: =
|Node:call_expression Text: CAN_SetConfigData(psContrlDets, Length)
|Node:identifier Text: CAN_SetConfigData
|Node:argument_list Text: (psContrlDets, Length)
|Node:( Text: (
|Node:identifier Text: psContrlDets
|Node:, Text: ,
|Node:identifier Text: Length
|Node:) Text: )
|Node:; Text: ;
|Node:if_statement Text: if (Result == S_OK)
                {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
|Node:if Text: if
|Node:condition_clause Text: (Result == S_OK)
|Node:( Text: (
|Node:binary_expression Text: Result == S_OK
|Node:identifier Text: Result
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                    Result = INFO_INITDAT_CONFIRM_CONFIG;
                }
|Node:{ Text: {
|Node:expression_statement Text: Result = INFO_INITDAT_CONFIRM_CONFIG;
|Node:assignment_expression Text: Result = INFO_INITDAT_CONFIRM_CONFIG
|Node:identifier Text: Result
|Node:= Text: =
|Node:identifier Text: INFO_INITDAT_CONFIRM_CONFIG
|Node:; Text: ;
|Node:} Text: }
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case INFO_RETAINED_CONFDATA:
                Result = INFO_INITDAT_RETAINED;
            break;
|Node:case Text: case
|Node:identifier Text: INFO_RETAINED_CONFDATA
|Node:: Text: :
|Node:expression_statement Text: Result = INFO_INITDAT_RETAINED;
|Node:assignment_expression Text: Result = INFO_INITDAT_RETAINED
|Node:identifier Text: Result
|Node:= Text: =
|Node:identifier Text: INFO_INITDAT_RETAINED
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case ERR_CONFIRMED_CONFIGURED:
|Node:case Text: case
|Node:identifier Text: ERR_CONFIRMED_CONFIGURED
|Node:: Text: :
|Node:comment Text: // Not to be addressed at present
|Node:case_statement Text: case INFO_CONFIRMED_CONFIGURED:
|Node:case Text: case
|Node:identifier Text: INFO_CONFIRMED_CONFIGURED
|Node:: Text: :
|Node:comment Text: // Not to be addressed at present
|Node:case_statement Text: default:
                /* Do nothing... default return value is S_FALSE. */
                break;
|Node:default Text: default
|Node:: Text: :
|Node:comment Text: /* Do nothing... default return value is S_FALSE. */
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return Result;
|Node:return Text: return
|Node:identifier Text: Result
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_SetConfigData(PSCONTROLLER_DETAILS pInitData, int /*Length*/)
{
    HRESULT hResult = WARNING_NOTCONFIRMED;

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(pInitData, hResult);

    BOA_ResultCode ErrCode = OCI_FAILURE;
    PSCONTROLLER_DETAILS pControllerDetails = (PSCONTROLLER_DETAILS)pInitData;
    bLoadDataFromContr(pControllerDetails);
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_SetConfigData(PSCONTROLLER_DETAILS pInitData, int /*Length*/)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_SetConfigData
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_SetConfigData
|Node:parameter_list Text: (PSCONTROLLER_DETAILS pInitData, int /*Length*/)
|Node:( Text: (
|Node:parameter_declaration Text: PSCONTROLLER_DETAILS pInitData
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:identifier Text: pInitData
|Node:, Text: ,
|Node:parameter_declaration Text: int
|Node:primitive_type Text: int
|Node:comment Text: /*Length*/
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = WARNING_NOTCONFIRMED;

    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
    VALIDATE_POINTER_RETURN_VAL(pInitData, hResult);

    BOA_ResultCode ErrCode = OCI_FAILURE;
    PSCONTROLLER_DETAILS pControllerDetails = (PSCONTROLLER_DETAILS)pInitData;
    bLoadDataFromContr(pControllerDetails);
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = WARNING_NOTCONFIRMED;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = WARNING_NOTCONFIRMED
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: WARNING_NOTCONFIRMED
|Node:; Text: ;
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: VALIDATE_POINTER_RETURN_VAL(pInitData, hResult);
|Node:call_expression Text: VALIDATE_POINTER_RETURN_VAL(pInitData, hResult)
|Node:identifier Text: VALIDATE_POINTER_RETURN_VAL
|Node:argument_list Text: (pInitData, hResult)
|Node:( Text: (
|Node:identifier Text: pInitData
|Node:, Text: ,
|Node:identifier Text: hResult
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: BOA_ResultCode ErrCode = OCI_FAILURE;
|Node:type_identifier Text: BOA_ResultCode
|Node:init_declarator Text: ErrCode = OCI_FAILURE
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:identifier Text: OCI_FAILURE
|Node:; Text: ;
|Node:declaration Text: PSCONTROLLER_DETAILS pControllerDetails = (PSCONTROLLER_DETAILS)pInitData;
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:init_declarator Text: pControllerDetails = (PSCONTROLLER_DETAILS)pInitData
|Node:identifier Text: pControllerDetails
|Node:= Text: =
|Node:cast_expression Text: (PSCONTROLLER_DETAILS)pInitData
|Node:( Text: (
|Node:type_descriptor Text: PSCONTROLLER_DETAILS
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:) Text: )
|Node:identifier Text: pInitData
|Node:; Text: ;
|Node:expression_statement Text: bLoadDataFromContr(pControllerDetails);
|Node:call_expression Text: bLoadDataFromContr(pControllerDetails)
|Node:identifier Text: bLoadDataFromContr
|Node:argument_list Text: (pControllerDetails)
|Node:( Text: (
|Node:identifier Text: pControllerDetails
|Node:) Text: )
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        /* First remove all the filters */
        ManageFilters(FILTER_REMOVE, i);

        /* First remove all the Rx Tx queues */
        ManageQueue(QUEUE_DESTROY, i);

        /* if controller is open, close the controller. Do not bother about return value */
        ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);

        /* Now load the controller config and open the controller */
        ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));

        /* Fill the hardware description details */
        ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;

        if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
    }
|Node:{ Text: {
|Node:comment Text: /* First remove all the filters */
|Node:expression_statement Text: ManageFilters(FILTER_REMOVE, i);
|Node:call_expression Text: ManageFilters(FILTER_REMOVE, i)
|Node:identifier Text: ManageFilters
|Node:argument_list Text: (FILTER_REMOVE, i)
|Node:( Text: (
|Node:identifier Text: FILTER_REMOVE
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* First remove all the Rx Tx queues */
|Node:expression_statement Text: ManageQueue(QUEUE_DESTROY, i);
|Node:call_expression Text: ManageQueue(QUEUE_DESTROY, i)
|Node:identifier Text: ManageQueue
|Node:argument_list Text: (QUEUE_DESTROY, i)
|Node:( Text: (
|Node:identifier Text: QUEUE_DESTROY
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* if controller is open, close the controller. Do not bother about return value */
|Node:expression_statement Text: ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle);
|Node:assignment_expression Text: ErrCode = (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*sBOA_PTRS.m_sOCI.closeCANController)(sg_asChannel[i].m_OCI_HwHandle)
|Node:parenthesized_expression Text: (*sBOA_PTRS.m_sOCI.closeCANController)
|Node:( Text: (
|Node:pointer_expression Text: *sBOA_PTRS.m_sOCI.closeCANController
|Node:* Text: *
|Node:field_expression Text: sBOA_PTRS.m_sOCI.closeCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: closeCANController
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Now load the controller config and open the controller */
|Node:expression_statement Text: ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp));
|Node:assignment_expression Text: ErrCode = (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*sBOA_PTRS.m_sOCI.openCANController)(sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*sBOA_PTRS.m_sOCI.openCANController)
|Node:( Text: (
|Node:pointer_expression Text: *sBOA_PTRS.m_sOCI.openCANController
|Node:* Text: *
|Node:field_expression Text: sBOA_PTRS.m_sOCI.openCANController
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: openCANController
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                  &(sg_asChannel[i].m_OCI_CANConfig),
                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CANConfig)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CANConfig)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Fill the hardware description details */
|Node:expression_statement Text: ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI;
|Node:assignment_expression Text: ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc =
            sg_asChannel[i].m_acURI
|Node:field_expression Text: ((PSCONTROLLER_DETAILS)pInitData)[i].m_omHardwareDesc
|Node:subscript_expression Text: ((PSCONTROLLER_DETAILS)pInitData)[i]
|Node:parenthesized_expression Text: ((PSCONTROLLER_DETAILS)pInitData)
|Node:( Text: (
|Node:cast_expression Text: (PSCONTROLLER_DETAILS)pInitData
|Node:( Text: (
|Node:type_descriptor Text: PSCONTROLLER_DETAILS
|Node:type_identifier Text: PSCONTROLLER_DETAILS
|Node:) Text: )
|Node:identifier Text: pInitData
|Node:) Text: )
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_omHardwareDesc
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[i].m_acURI
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_acURI
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED(ErrCode))
        {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(ErrCode)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            /* Rx Tx queue */
            if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
        }
|Node:{ Text: {
|Node:comment Text: /* Rx Tx queue */
|Node:if_statement Text: if (ManageQueue(QUEUE_ADD, i) == S_OK)
            {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
|Node:if Text: if
|Node:condition_clause Text: (ManageQueue(QUEUE_ADD, i) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: ManageQueue(QUEUE_ADD, i) == S_OK
|Node:call_expression Text: ManageQueue(QUEUE_ADD, i)
|Node:identifier Text: ManageQueue
|Node:argument_list Text: (QUEUE_ADD, i)
|Node:( Text: (
|Node:identifier Text: QUEUE_ADD
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
            }
|Node:{ Text: {
|Node:if_statement Text: if (ManageFilters(FILTER_ADD, i) == S_OK)
                {
                    hResult |= S_OK;
                }
|Node:if Text: if
|Node:condition_clause Text: (ManageFilters(FILTER_ADD, i) == S_OK)
|Node:( Text: (
|Node:binary_expression Text: ManageFilters(FILTER_ADD, i) == S_OK
|Node:call_expression Text: ManageFilters(FILTER_ADD, i)
|Node:identifier Text: ManageFilters
|Node:argument_list Text: (FILTER_ADD, i)
|Node:( Text: (
|Node:identifier Text: FILTER_ADD
|Node:, Text: ,
|Node:identifier Text: i
|Node:) Text: )
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
                    hResult |= S_OK;
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult |= S_OK;
|Node:assignment_expression Text: hResult |= S_OK
|Node:identifier Text: hResult
|Node:|= Text: |=
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not configure the controller"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not configure the controller"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not configure the controller")
|Node:identifier Text: _
|Node:argument_list Text: ("could not configure the controller")
|Node:( Text: (
|Node:string_literal Text: "could not configure the controller"
|Node:" Text: "
|Node:string_content Text: could not configure the controller
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_StartHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }

    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_StartHardware(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_StartHardware
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_StartHardware
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }

    return hResult;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_HW_INTERFACE_SELECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        OCI_CANControllerCapabilities capabilities;
#if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }
|Node:{ Text: {
|Node:declaration Text: OCI_CANControllerCapabilities capabilities;
|Node:type_identifier Text: OCI_CANControllerCapabilities
|Node:identifier Text: capabilities
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
        capabilities.canFDSupport = 0;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:expression_statement Text: capabilities.canFDSupport = 0;
|Node:assignment_expression Text: capabilities.canFDSupport = 0
|Node:field_expression Text: capabilities.canFDSupport
|Node:identifier Text: capabilities
|Node:. Text: .
|Node:field_identifier Text: canFDSupport
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))(sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.getCANControllerCapabilities
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: getCANControllerCapabilities
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                          &capabilities)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &capabilities
|Node:& Text: &
|Node:identifier Text: capabilities
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
#if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
        }
|Node:{ Text: {
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
            if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:if_statement Text: if( capabilities.canFDSupport & OCI_CANFDSUPPORT)
            {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
|Node:if Text: if
|Node:condition_clause Text: ( capabilities.canFDSupport & OCI_CANFDSUPPORT)
|Node:( Text: (
|Node:binary_expression Text: capabilities.canFDSupport & OCI_CANFDSUPPORT
|Node:field_expression Text: capabilities.canFDSupport
|Node:identifier Text: capabilities
|Node:. Text: .
|Node:field_identifier Text: canFDSupport
|Node:& Text: &
|Node:identifier Text: OCI_CANFDSUPPORT
|Node:) Text: )
|Node:compound_statement Text: {
                /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
                int i =0;
            }
|Node:{ Text: {
|Node:comment Text: /*
                 * The OCI_CAN implementation for the CAN port supports CAN-FD. Latch the URI of the CAN port
                 * in our results.
                 */
|Node:declaration Text: int i =0;
|Node:primitive_type Text: int
|Node:init_declarator Text: i =0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:} Text: }
|Node:#endif Text: #endif
|Node:} Text: }
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.getCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.getCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.getCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.getCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: getCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
        }
|Node:{ Text: {
|Node:if_statement Text: if ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
|Node:if Text: if
|Node:condition_clause Text: ((sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING))
|Node:( Text: (
|Node:binary_expression Text: (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
                    || (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:== Text: ==
|Node:identifier Text: OCI_CONTROLLER_MODE_SUSPENDED
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:== Text: ==
|Node:identifier Text: OCI_CONTROLLER_MODE_RUNNING
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_RUNNING
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:= Text: =
|Node:identifier Text: OCI_CONTROLLER_MODE_RUNNING
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: setCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                    hResult |= S_OK;
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult |= S_OK;
|Node:assignment_expression Text: hResult |= S_OK
|Node:identifier Text: hResult
|Node:|= Text: |=
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not start the controller in running mode"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not start the controller in running mode"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not start the controller in running mode")
|Node:identifier Text: _
|Node:argument_list Text: ("could not start the controller in running mode")
|Node:( Text: (
|Node:string_literal Text: "could not start the controller in running mode"
|Node:" Text: "
|Node:string_content Text: could not start the controller in running mode
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not get controller mode"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not get controller mode")
|Node:identifier Text: _
|Node:argument_list Text: ("could not get controller mode")
|Node:( Text: (
|Node:string_literal Text: "could not get controller mode"
|Node:" Text: "
|Node:string_content Text: could not get controller mode
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Check for the success */
|Node:if_statement Text: if (hResult == S_OK)
    {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
        sg_bCurrState = STATE_CONNECTED;
        SetEvent(sg_hEvent);
        vCreateTimeModeMapping(sg_hEvent);

        InitializeCriticalSection(&sg_CritSectForAckBuf);

        QueryPerformanceCounter(&sg_QueryTickCount);

        /* Get frequency of the performance counter */
        QueryPerformanceFrequency(&sg_lnFrequency);

        /* Convert it to time stamp with the granularity of hundreds of microsecond */
        if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_bCurrState = STATE_CONNECTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_CONNECTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_CONNECTED
|Node:; Text: ;
|Node:expression_statement Text: SetEvent(sg_hEvent);
|Node:call_expression Text: SetEvent(sg_hEvent)
|Node:identifier Text: SetEvent
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: vCreateTimeModeMapping(sg_hEvent);
|Node:call_expression Text: vCreateTimeModeMapping(sg_hEvent)
|Node:identifier Text: vCreateTimeModeMapping
|Node:argument_list Text: (sg_hEvent)
|Node:( Text: (
|Node:identifier Text: sg_hEvent
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: InitializeCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: InitializeCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: InitializeCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: QueryPerformanceCounter(&sg_QueryTickCount);
|Node:call_expression Text: QueryPerformanceCounter(&sg_QueryTickCount)
|Node:identifier Text: QueryPerformanceCounter
|Node:argument_list Text: (&sg_QueryTickCount)
|Node:( Text: (
|Node:pointer_expression Text: &sg_QueryTickCount
|Node:& Text: &
|Node:identifier Text: sg_QueryTickCount
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Get frequency of the performance counter */
|Node:expression_statement Text: QueryPerformanceFrequency(&sg_lnFrequency);
|Node:call_expression Text: QueryPerformanceFrequency(&sg_lnFrequency)
|Node:identifier Text: QueryPerformanceFrequency
|Node:argument_list Text: (&sg_lnFrequency)
|Node:( Text: (
|Node:pointer_expression Text: &sg_lnFrequency
|Node:& Text: &
|Node:identifier Text: sg_lnFrequency
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: /* Convert it to time stamp with the granularity of hundreds of microsecond */
|Node:if_statement Text: if ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
        else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
|Node:if Text: if
|Node:condition_clause Text: ((sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart)
|Node:( Text: (
|Node:binary_expression Text: (sg_QueryTickCount.QuadPart * 10000) > sg_lnFrequency.QuadPart
|Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart * 10000)
|Node:( Text: (
|Node:binary_expression Text: sg_QueryTickCount.QuadPart * 10000
|Node:field_expression Text: sg_QueryTickCount.QuadPart
|Node:identifier Text: sg_QueryTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:* Text: *
|Node:number_literal Text: 10000
|Node:) Text: )
|Node:> Text: >
|Node:field_expression Text: sg_lnFrequency.QuadPart
|Node:identifier Text: sg_lnFrequency
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:) Text: )
|Node:compound_statement Text: {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart;
|Node:assignment_expression Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|Node:identifier Text: sg_TimeStamp
|Node:= Text: =
|Node:binary_expression Text: (sg_QueryTickCount.QuadPart * 10000) / sg_lnFrequency.QuadPart
|Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart * 10000)
|Node:( Text: (
|Node:binary_expression Text: sg_QueryTickCount.QuadPart * 10000
|Node:field_expression Text: sg_QueryTickCount.QuadPart
|Node:identifier Text: sg_QueryTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:* Text: *
|Node:number_literal Text: 10000
|Node:) Text: )
|Node:/ Text: /
|Node:field_expression Text: sg_lnFrequency.QuadPart
|Node:identifier Text: sg_lnFrequency
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
        {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
        }
|Node:{ Text: {
|Node:expression_statement Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000;
|Node:assignment_expression Text: sg_TimeStamp = (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000
|Node:identifier Text: sg_TimeStamp
|Node:= Text: =
|Node:binary_expression Text: (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart) * 10000
|Node:parenthesized_expression Text: (sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart)
|Node:( Text: (
|Node:binary_expression Text: sg_QueryTickCount.QuadPart / sg_lnFrequency.QuadPart
|Node:field_expression Text: sg_QueryTickCount.QuadPart
|Node:identifier Text: sg_QueryTickCount
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:/ Text: /
|Node:field_expression Text: sg_lnFrequency.QuadPart
|Node:identifier Text: sg_lnFrequency
|Node:. Text: .
|Node:field_identifier Text: QuadPart
|Node:) Text: )
|Node:* Text: *
|Node:number_literal Text: 10000
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_StopHardware(void)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }

    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_StopHardware(void)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_StopHardware
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_StopHardware
|Node:parameter_list Text: (void)
|Node:( Text: (
|Node:parameter_declaration Text: void
|Node:primitive_type Text: void
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);

    HRESULT hResult = S_OK;
    for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }

    /* Check for the success */
    if (hResult == S_OK)
    {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }

    return hResult;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_CONNECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels; i++)
    {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:) Text: )
|Node:compound_statement Text: {
        if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
        {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
        else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.getCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.getCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.getCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.getCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.getCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: getCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                          &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
            if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
        }
|Node:{ Text: {
|Node:if_statement Text: if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
            {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
            else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
|Node:if Text: if
|Node:condition_clause Text: (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_RUNNING
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:== Text: ==
|Node:identifier Text: OCI_CONTROLLER_MODE_RUNNING
|Node:) Text: )
|Node:compound_statement Text: {
                sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
                if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED;
|Node:assignment_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode = OCI_CONTROLLER_MODE_SUSPENDED
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:= Text: =
|Node:identifier Text: OCI_CONTROLLER_MODE_SUSPENDED
|Node:; Text: ;
|Node:if_statement Text: if (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
                {
                    hResult |= S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: ((*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp)))
|Node:( Text: (
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: setCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                                  &(sg_asChannel[i].m_OCI_CntrlProp))
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &(sg_asChannel[i].m_OCI_CntrlProp)
|Node:& Text: &
|Node:parenthesized_expression Text: (sg_asChannel[i].m_OCI_CntrlProp)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                    hResult |= S_OK;
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult |= S_OK;
|Node:assignment_expression Text: hResult |= S_OK
|Node:identifier Text: hResult
|Node:|= Text: |=
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
                {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
|Node:else Text: else
|Node:compound_statement Text: {
                    hResult = S_FALSE;
                    sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
                }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not stop the controller in suspended mode"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not stop the controller in suspended mode")
|Node:identifier Text: _
|Node:argument_list Text: ("could not stop the controller in suspended mode")
|Node:( Text: (
|Node:string_literal Text: "could not stop the controller in suspended mode"
|Node:" Text: "
|Node:string_content Text: could not stop the controller in suspended mode
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
|Node:else Text: else
|Node:if_statement Text: if (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
            {
                hResult |= S_OK;
            }
|Node:if Text: if
|Node:condition_clause Text: (sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode == OCI_CONTROLLER_MODE_SUSPENDED
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp.mode
|Node:field_expression Text: sg_asChannel[i].m_OCI_CntrlProp
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CntrlProp
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:== Text: ==
|Node:identifier Text: OCI_CONTROLLER_MODE_SUSPENDED
|Node:) Text: )
|Node:compound_statement Text: {
                hResult |= S_OK;
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult |= S_OK;
|Node:assignment_expression Text: hResult |= S_OK
|Node:identifier Text: hResult
|Node:|= Text: |=
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = S_FALSE;
            sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not get controller mode"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not get controller mode"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not get controller mode")
|Node:identifier Text: _
|Node:argument_list Text: ("could not get controller mode")
|Node:( Text: (
|Node:string_literal Text: "could not get controller mode"
|Node:" Text: "
|Node:string_content Text: could not get controller mode
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:comment Text: /* Check for the success */
|Node:if_statement Text: if (hResult == S_OK)
    {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }
|Node:if Text: if
|Node:condition_clause Text: (hResult == S_OK)
|Node:( Text: (
|Node:binary_expression Text: hResult == S_OK
|Node:identifier Text: hResult
|Node:== Text: ==
|Node:identifier Text: S_OK
|Node:) Text: )
|Node:compound_statement Text: {
        sg_byCurrState = CREATE_MAP_TIMESTAMP;
        sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
        DeleteCriticalSection(&sg_CritSectForAckBuf);
    }
|Node:{ Text: {
|Node:expression_statement Text: sg_byCurrState = CREATE_MAP_TIMESTAMP;
|Node:assignment_expression Text: sg_byCurrState = CREATE_MAP_TIMESTAMP
|Node:identifier Text: sg_byCurrState
|Node:= Text: =
|Node:identifier Text: CREATE_MAP_TIMESTAMP
|Node:; Text: ;
|Node:expression_statement Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED;
|Node:assignment_expression Text: sg_bCurrState = STATE_HW_INTERFACE_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:= Text: =
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:; Text: ;
|Node:expression_statement Text: DeleteCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: DeleteCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: DeleteCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
{
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetCurrStatus(s_STATUSMSG& StatusData)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetCurrStatus
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetCurrStatus
|Node:parameter_list Text: (s_STATUSMSG& StatusData)
|Node:( Text: (
|Node:parameter_declaration Text: s_STATUSMSG& StatusData
|Node:type_identifier Text: s_STATUSMSG
|Node:reference_declarator Text: & StatusData
|Node:& Text: &
|Node:identifier Text: StatusData
|Node:) Text: )
|Node:compound_statement Text: {
    StatusData.wControllerStatus = NORMAL_ACTIVE;

    return S_OK;
}
|Node:{ Text: {
|Node:expression_statement Text: StatusData.wControllerStatus = NORMAL_ACTIVE;
|Node:assignment_expression Text: StatusData.wControllerStatus = NORMAL_ACTIVE
|Node:field_expression Text: StatusData.wControllerStatus
|Node:identifier Text: StatusData
|Node:. Text: .
|Node:field_identifier Text: wControllerStatus
|Node:= Text: =
|Node:identifier Text: NORMAL_ACTIVE
|Node:; Text: ;
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
{
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
    HRESULT hResult = S_FALSE;

    if (bClientIdExist(dwClientID))
    {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_SendMsg(DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_SendMsg
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_SendMsg
|Node:parameter_list Text: (DWORD dwClientID, const STCAN_MSG& sCanTxMsg)
|Node:( Text: (
|Node:parameter_declaration Text: DWORD dwClientID
|Node:type_identifier Text: DWORD
|Node:identifier Text: dwClientID
|Node:, Text: ,
|Node:parameter_declaration Text: const STCAN_MSG& sCanTxMsg
|Node:type_qualifier Text: const
|Node:const Text: const
|Node:type_identifier Text: STCAN_MSG
|Node:reference_declarator Text: & sCanTxMsg
|Node:& Text: &
|Node:identifier Text: sCanTxMsg
|Node:) Text: )
|Node:compound_statement Text: {
    VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
    HRESULT hResult = S_FALSE;

    if (bClientIdExist(dwClientID))
    {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }

    return hResult;
}
|Node:{ Text: {
|Node:expression_statement Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE);
|Node:call_expression Text: VALIDATE_VALUE_RETURN_VAL(sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|Node:identifier Text: VALIDATE_VALUE_RETURN_VAL
|Node:argument_list Text: (sg_bCurrState, STATE_CONNECTED, ERR_IMPROPER_STATE)
|Node:( Text: (
|Node:identifier Text: sg_bCurrState
|Node:, Text: ,
|Node:identifier Text: STATE_CONNECTED
|Node:, Text: ,
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: HRESULT hResult = S_FALSE;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:if_statement Text: if (bClientIdExist(dwClientID))
    {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|Node:if Text: if
|Node:condition_clause Text: (bClientIdExist(dwClientID))
|Node:( Text: (
|Node:call_expression Text: bClientIdExist(dwClientID)
|Node:identifier Text: bClientIdExist
|Node:argument_list Text: (dwClientID)
|Node:( Text: (
|Node:identifier Text: dwClientID
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
        {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:if Text: if
|Node:condition_clause Text: (sCanTxMsg.m_ucChannel <= sg_nNoOfChannels)
|Node:( Text: (
|Node:binary_expression Text: sCanTxMsg.m_ucChannel <= sg_nNoOfChannels
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:<= Text: <=
|Node:identifier Text: sg_nNoOfChannels
|Node:) Text: )
|Node:compound_statement Text: {
#if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
            OCI_CANMessage sOciCanMsg;

            OCI_CANTxMessage sOciTxCanMsg;
            SACK_MAP sAckMap;
            vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
            sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
            sOciCanMsg.reserved = 0;
            uint32 nRemaining = 0;
            memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
            sAckMap.m_ClientID = dwClientID;
            sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
            sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
            EnterCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
            LeaveCriticalSection(&sg_CritSectForAckBuf); // Lock the buffer
            BOA_ResultCode ErrCode;
#if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
            if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
        }
|Node:{ Text: {
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
            OCI_CANMessageEx sOciCanMsgEx; // Currently both type of messages are created in BOA 2.0;
            OCI_CANFDTxMessage     sOciTxCanFDMsg;
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:declaration Text: OCI_CANMessageEx sOciCanMsgEx;
|Node:type_identifier Text: OCI_CANMessageEx
|Node:identifier Text: sOciCanMsgEx
|Node:; Text: ;
|Node:comment Text: // Currently both type of messages are created in BOA 2.0;
|Node:declaration Text: OCI_CANFDTxMessage     sOciTxCanFDMsg;
|Node:type_identifier Text: OCI_CANFDTxMessage
|Node:identifier Text: sOciTxCanFDMsg
|Node:; Text: ;
|Node:#endif Text: #endif
|Node:declaration Text: OCI_CANMessage sOciCanMsg;
|Node:type_identifier Text: OCI_CANMessage
|Node:identifier Text: sOciCanMsg
|Node:; Text: ;
|Node:declaration Text: OCI_CANTxMessage sOciTxCanMsg;
|Node:type_identifier Text: OCI_CANTxMessage
|Node:identifier Text: sOciTxCanMsg
|Node:; Text: ;
|Node:declaration Text: SACK_MAP sAckMap;
|Node:type_identifier Text: SACK_MAP
|Node:identifier Text: sAckMap
|Node:; Text: ;
|Node:expression_statement Text: vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg);
|Node:call_expression Text: vCopy_2_OCI_CAN_Data(sOciTxCanMsg, sCanTxMsg)
|Node:identifier Text: vCopy_2_OCI_CAN_Data
|Node:argument_list Text: (sOciTxCanMsg, sCanTxMsg)
|Node:( Text: (
|Node:identifier Text: sOciTxCanMsg
|Node:, Text: ,
|Node:identifier Text: sCanTxMsg
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sOciCanMsg.type = OCI_CAN_TX_MESSAGE;
|Node:assignment_expression Text: sOciCanMsg.type = OCI_CAN_TX_MESSAGE
|Node:field_expression Text: sOciCanMsg.type
|Node:identifier Text: sOciCanMsg
|Node:. Text: .
|Node:field_identifier Text: type
|Node:= Text: =
|Node:identifier Text: OCI_CAN_TX_MESSAGE
|Node:; Text: ;
|Node:expression_statement Text: sOciCanMsg.reserved = 0;
|Node:assignment_expression Text: sOciCanMsg.reserved = 0
|Node:field_expression Text: sOciCanMsg.reserved
|Node:identifier Text: sOciCanMsg
|Node:. Text: .
|Node:field_identifier Text: reserved
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:declaration Text: uint32 nRemaining = 0;
|Node:type_identifier Text: uint32
|Node:init_declarator Text: nRemaining = 0
|Node:identifier Text: nRemaining
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:expression_statement Text: memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage));
|Node:call_expression Text: memcpy(&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage))
|Node:identifier Text: memcpy
|Node:argument_list Text: (&(sOciCanMsg.data.txMessage), &(sOciTxCanMsg), sizeof(OCI_CANTxMessage))
|Node:( Text: (
|Node:pointer_expression Text: &(sOciCanMsg.data.txMessage)
|Node:& Text: &
|Node:parenthesized_expression Text: (sOciCanMsg.data.txMessage)
|Node:( Text: (
|Node:field_expression Text: sOciCanMsg.data.txMessage
|Node:field_expression Text: sOciCanMsg.data
|Node:identifier Text: sOciCanMsg
|Node:. Text: .
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: txMessage
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sOciTxCanMsg)
|Node:& Text: &
|Node:parenthesized_expression Text: (sOciTxCanMsg)
|Node:( Text: (
|Node:identifier Text: sOciTxCanMsg
|Node:) Text: )
|Node:, Text: ,
|Node:sizeof_expression Text: sizeof(OCI_CANTxMessage)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (OCI_CANTxMessage)
|Node:( Text: (
|Node:identifier Text: OCI_CANTxMessage
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: sAckMap.m_ClientID = dwClientID;
|Node:assignment_expression Text: sAckMap.m_ClientID = dwClientID
|Node:field_expression Text: sAckMap.m_ClientID
|Node:identifier Text: sAckMap
|Node:. Text: .
|Node:field_identifier Text: m_ClientID
|Node:= Text: =
|Node:identifier Text: dwClientID
|Node:; Text: ;
|Node:expression_statement Text: sAckMap.m_Channel  = sCanTxMsg.m_ucChannel;
|Node:assignment_expression Text: sAckMap.m_Channel  = sCanTxMsg.m_ucChannel
|Node:field_expression Text: sAckMap.m_Channel
|Node:identifier Text: sAckMap
|Node:. Text: .
|Node:field_identifier Text: m_Channel
|Node:= Text: =
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:; Text: ;
|Node:expression_statement Text: sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID;
|Node:assignment_expression Text: sAckMap.m_MsgID    = sOciCanMsg.data.txMessage.frameID
|Node:field_expression Text: sAckMap.m_MsgID
|Node:identifier Text: sAckMap
|Node:. Text: .
|Node:field_identifier Text: m_MsgID
|Node:= Text: =
|Node:field_expression Text: sOciCanMsg.data.txMessage.frameID
|Node:field_expression Text: sOciCanMsg.data.txMessage
|Node:field_expression Text: sOciCanMsg.data
|Node:identifier Text: sOciCanMsg
|Node:. Text: .
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: txMessage
|Node:. Text: .
|Node:field_identifier Text: frameID
|Node:; Text: ;
|Node:expression_statement Text: EnterCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: EnterCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: EnterCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Lock the buffer
|Node:if_statement Text: if ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
            {
                vMarkEntryIntoMap(sAckMap);
            }
|Node:if Text: if
|Node:condition_clause Text: ( sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON )
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode == OCI_SELF_RECEPTION_ON
|Node:field_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig.selfReceptionMode
|Node:field_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_CANConfig
|Node:subscript_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [sCanTxMsg.m_ucChannel - 1]
|Node:[ Text: [
|Node:binary_expression Text: sCanTxMsg.m_ucChannel - 1
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_CANConfig
|Node:. Text: .
|Node:field_identifier Text: selfReceptionMode
|Node:== Text: ==
|Node:identifier Text: OCI_SELF_RECEPTION_ON
|Node:) Text: )
|Node:compound_statement Text: {
                vMarkEntryIntoMap(sAckMap);
            }
|Node:{ Text: {
|Node:expression_statement Text: vMarkEntryIntoMap(sAckMap);
|Node:call_expression Text: vMarkEntryIntoMap(sAckMap)
|Node:identifier Text: vMarkEntryIntoMap
|Node:argument_list Text: (sAckMap)
|Node:( Text: (
|Node:identifier Text: sAckMap
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: LeaveCriticalSection(&sg_CritSectForAckBuf);
|Node:call_expression Text: LeaveCriticalSection(&sg_CritSectForAckBuf)
|Node:identifier Text: LeaveCriticalSection
|Node:argument_list Text: (&sg_CritSectForAckBuf)
|Node:( Text: (
|Node:pointer_expression Text: &sg_CritSectForAckBuf
|Node:& Text: &
|Node:identifier Text: sg_CritSectForAckBuf
|Node:) Text: )
|Node:; Text: ;
|Node:comment Text: // Lock the buffer
|Node:declaration Text: BOA_ResultCode ErrCode;
|Node:type_identifier Text: BOA_ResultCode
|Node:identifier Text: ErrCode
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0
            if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
#endif
|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:if_statement Text: if(sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
            {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
            else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
|Node:if Text: if
|Node:condition_clause Text: (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true)
|Node:( Text: (
|Node:binary_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD == true
|Node:field_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_bSupportCANFD
|Node:subscript_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [sCanTxMsg.m_ucChannel - 1]
|Node:[ Text: [
|Node:binary_expression Text: sCanTxMsg.m_ucChannel - 1
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_bSupportCANFD
|Node:== Text: ==
|Node:true Text: true
|Node:) Text: )
|Node:compound_statement Text: {
                /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
                if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
                sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
                memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
                OCI_CANMessageEx* ociMsgArr[1];

                ociMsgArr[0] = &sOciCanMsgEx;
                sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;

                ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);


            }
|Node:{ Text: {
|Node:comment Text: /* Currently if Device supports CAN FD, switch to CAN_FD mode by default.But in future based on user input switch to CAN_FD or CAN mode */
|Node:if_statement Text: if(vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
                {
                    return ERR_WRITE_INVALID_SIZE;
                }
|Node:if Text: if
|Node:condition_clause Text: (vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE)
|Node:( Text: (
|Node:binary_expression Text: vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg) == FALSE
|Node:call_expression Text: vCopy_2_OCI_CANFD_Data(sOciTxCanFDMsg,sCanTxMsg)
|Node:identifier Text: vCopy_2_OCI_CANFD_Data
|Node:argument_list Text: (sOciTxCanFDMsg,sCanTxMsg)
|Node:( Text: (
|Node:identifier Text: sOciTxCanFDMsg
|Node:, Text: ,
|Node:identifier Text: sCanTxMsg
|Node:) Text: )
|Node:== Text: ==
|Node:false Text: FALSE
|Node:) Text: )
|Node:compound_statement Text: {
                    return ERR_WRITE_INVALID_SIZE;
                }
|Node:{ Text: {
|Node:return_statement Text: return ERR_WRITE_INVALID_SIZE;
|Node:return Text: return
|Node:identifier Text: ERR_WRITE_INVALID_SIZE
|Node:; Text: ;
|Node:} Text: }
|Node:expression_statement Text: sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE;
|Node:assignment_expression Text: sOciCanMsgEx.type = OCI_CANFDTX_MESSAGE
|Node:field_expression Text: sOciCanMsgEx.type
|Node:identifier Text: sOciCanMsgEx
|Node:. Text: .
|Node:field_identifier Text: type
|Node:= Text: =
|Node:identifier Text: OCI_CANFDTX_MESSAGE
|Node:; Text: ;
|Node:expression_statement Text: memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage));
|Node:call_expression Text: memcpy(&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage))
|Node:identifier Text: memcpy
|Node:argument_list Text: (&(sOciCanMsgEx.data.canFDTxMessage), &(sOciTxCanFDMsg), sizeof(OCI_CANFDTxMessage))
|Node:( Text: (
|Node:pointer_expression Text: &(sOciCanMsgEx.data.canFDTxMessage)
|Node:& Text: &
|Node:parenthesized_expression Text: (sOciCanMsgEx.data.canFDTxMessage)
|Node:( Text: (
|Node:field_expression Text: sOciCanMsgEx.data.canFDTxMessage
|Node:field_expression Text: sOciCanMsgEx.data
|Node:identifier Text: sOciCanMsgEx
|Node:. Text: .
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: canFDTxMessage
|Node:) Text: )
|Node:, Text: ,
|Node:pointer_expression Text: &(sOciTxCanFDMsg)
|Node:& Text: &
|Node:parenthesized_expression Text: (sOciTxCanFDMsg)
|Node:( Text: (
|Node:identifier Text: sOciTxCanFDMsg
|Node:) Text: )
|Node:, Text: ,
|Node:sizeof_expression Text: sizeof(OCI_CANFDTxMessage)
|Node:sizeof Text: sizeof
|Node:parenthesized_expression Text: (OCI_CANFDTxMessage)
|Node:( Text: (
|Node:identifier Text: OCI_CANFDTxMessage
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:declaration Text: OCI_CANMessageEx* ociMsgArr[1];
|Node:type_identifier Text: OCI_CANMessageEx
|Node:pointer_declarator Text: * ociMsgArr[1]
|Node:* Text: *
|Node:array_declarator Text: ociMsgArr[1]
|Node:identifier Text: ociMsgArr
|Node:[ Text: [
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:; Text: ;
|Node:expression_statement Text: ociMsgArr[0] = &sOciCanMsgEx;
|Node:assignment_expression Text: ociMsgArr[0] = &sOciCanMsgEx
|Node:subscript_expression Text: ociMsgArr[0]
|Node:identifier Text: ociMsgArr
|Node:subscript_argument_list Text: [0]
|Node:[ Text: [
|Node:number_literal Text: 0
|Node:] Text: ]
|Node:= Text: =
|Node:pointer_expression Text: &sOciCanMsgEx
|Node:& Text: &
|Node:identifier Text: sOciCanMsgEx
|Node:; Text: ;
|Node:expression_statement Text: sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;
|Node:assignment_expression Text: sOciCanMsgEx.data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE
|Node:field_expression Text: sOciCanMsgEx.data.canFDTxMessage.flags
|Node:field_expression Text: sOciCanMsgEx.data.canFDTxMessage
|Node:field_expression Text: sOciCanMsgEx.data
|Node:identifier Text: sOciCanMsgEx
|Node:. Text: .
|Node:field_identifier Text: data
|Node:. Text: .
|Node:field_identifier Text: canFDTxMessage
|Node:. Text: .
|Node:field_identifier Text: flags
|Node:= Text: =
|Node:binary_expression Text: OCI_CAN_MSG_FLAG_FD_DATA | OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE
|Node:identifier Text: OCI_CAN_MSG_FLAG_FD_DATA
|Node:| Text: |
|Node:identifier Text: OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE
|Node:; Text: ;
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.writeCANDataEx))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.writeCANDataEx)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.writeCANDataEx)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.writeCANDataEx
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: writeCANDataEx
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, ociMsgArr, 1, &nRemaining)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle
|Node:subscript_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [sCanTxMsg.m_ucChannel - 1]
|Node:[ Text: [
|Node:binary_expression Text: sCanTxMsg.m_ucChannel - 1
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueHandle
|Node:, Text: ,
|Node:identifier Text: OCI_NO_TIME
|Node:, Text: ,
|Node:identifier Text: ociMsgArr
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:, Text: ,
|Node:pointer_expression Text: &nRemaining
|Node:& Text: &
|Node:identifier Text: nRemaining
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
            {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
|Node:else Text: else
|Node:compound_statement Text: {

#endif
                ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
#if BOA_VERSION >= BOA_VERSION_2_0
            }
|Node:{ Text: {
|Node:preproc_call Text: #endif

|Node:preproc_directive Text: #endif
|Node:expression_statement Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining);
|Node:assignment_expression Text: ErrCode = (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining)
|Node:identifier Text: ErrCode
|Node:= Text: =
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
                          (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.canioVTable.writeCANData))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.canioVTable.writeCANData)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.canioVTable.writeCANData)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable.writeCANData
|Node:field_expression Text: sBOA_PTRS.m_sOCI.canioVTable
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: canioVTable
|Node:. Text: .
|Node:field_identifier Text: writeCANData
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle, OCI_NO_TIME, &sOciCanMsg, 1, &nRemaining)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1].m_OCI_TxQueueHandle
|Node:subscript_expression Text: sg_asChannel[sCanTxMsg.m_ucChannel - 1]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [sCanTxMsg.m_ucChannel - 1]
|Node:[ Text: [
|Node:binary_expression Text: sCanTxMsg.m_ucChannel - 1
|Node:field_expression Text: sCanTxMsg.m_ucChannel
|Node:identifier Text: sCanTxMsg
|Node:. Text: .
|Node:field_identifier Text: m_ucChannel
|Node:- Text: -
|Node:number_literal Text: 1
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_TxQueueHandle
|Node:, Text: ,
|Node:identifier Text: OCI_NO_TIME
|Node:, Text: ,
|Node:pointer_expression Text: &sOciCanMsg
|Node:& Text: &
|Node:identifier Text: sOciCanMsg
|Node:, Text: ,
|Node:number_literal Text: 1
|Node:, Text: ,
|Node:pointer_expression Text: &nRemaining
|Node:& Text: &
|Node:identifier Text: nRemaining
|Node:) Text: )
|Node:; Text: ;
|Node:preproc_if Text: #if BOA_VERSION >= BOA_VERSION_2_0

|Node:#if Text: #if
|Node:binary_expression Text: BOA_VERSION >= BOA_VERSION_2_0
|Node:identifier Text: BOA_VERSION
|Node:>= Text: >=
|Node:identifier Text: BOA_VERSION_2_0
|Node:
 Text: 

|Node:#endif Text: 
|Node:} Text: }
|Node:#endif Text: #endif
|Node:if_statement Text: if (BOA_SUCCEEDED(ErrCode))
            {
                hResult = S_OK;
            }
            else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
|Node:if Text: if
|Node:condition_clause Text: (BOA_SUCCEEDED(ErrCode))
|Node:( Text: (
|Node:call_expression Text: BOA_SUCCEEDED(ErrCode)
|Node:identifier Text: BOA_SUCCEEDED
|Node:argument_list Text: (ErrCode)
|Node:( Text: (
|Node:identifier Text: ErrCode
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
                hResult = S_OK;
            }
|Node:{ Text: {
|Node:expression_statement Text: hResult = S_OK;
|Node:assignment_expression Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else
            {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
|Node:else Text: else
|Node:compound_statement Text: {
                sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
            }
|Node:{ Text: {
|Node:expression_statement Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"));
|Node:call_expression Text: sg_pIlog->vLogAMessage(A2T(__FILE__), __LINE__, _("could not write can data into bus"))
|Node:field_expression Text: sg_pIlog->vLogAMessage
|Node:identifier Text: sg_pIlog
|Node:-> Text: ->
|Node:field_identifier Text: vLogAMessage
|Node:argument_list Text: (A2T(__FILE__), __LINE__, _("could not write can data into bus"))
|Node:( Text: (
|Node:call_expression Text: A2T(__FILE__)
|Node:identifier Text: A2T
|Node:argument_list Text: (__FILE__)
|Node:( Text: (
|Node:identifier Text: __FILE__
|Node:) Text: )
|Node:, Text: ,
|Node:identifier Text: __LINE__
|Node:, Text: ,
|Node:call_expression Text: _("could not write can data into bus")
|Node:identifier Text: _
|Node:argument_list Text: ("could not write can data into bus")
|Node:( Text: (
|Node:string_literal Text: "could not write can data into bus"
|Node:" Text: "
|Node:string_content Text: could not write can data into bus
|Node:" Text: "
|Node:) Text: )
|Node:) Text: )
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_INVALID_CHANNEL;
|Node:assignment_expression Text: hResult = ERR_INVALID_CHANNEL
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_INVALID_CHANNEL
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|Node:else Text: else
|Node:compound_statement Text: {
        hResult = ERR_NO_CLIENT_EXIST;
    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_NO_CLIENT_EXIST;
|Node:assignment_expression Text: hResult = ERR_NO_CLIENT_EXIST
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_NO_CLIENT_EXIST
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetLastErrorString(string& /*acErrorStr*/)
{
    return WARN_DUMMY_API;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetLastErrorString(string& /*acErrorStr*/)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetLastErrorString
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetLastErrorString
|Node:parameter_list Text: (string& /*acErrorStr*/)
|Node:( Text: (
|Node:parameter_declaration Text: string&
|Node:type_identifier Text: string
|Node:abstract_reference_declarator Text: &
|Node:& Text: &
|Node:comment Text: /*acErrorStr*/
|Node:) Text: )
|Node:compound_statement Text: {
    return WARN_DUMMY_API;
}
|Node:{ Text: {
|Node:return_statement Text: return WARN_DUMMY_API;
|Node:return Text: return
|Node:identifier Text: WARN_DUMMY_API
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetControllerParams(LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetControllerParams
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetControllerParams
|Node:parameter_list Text: (LONG& lParam, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:( Text: (
|Node:parameter_declaration Text: LONG& lParam
|Node:type_identifier Text: LONG
|Node:reference_declarator Text: & lParam
|Node:& Text: &
|Node:identifier Text: lParam
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrParam
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:if_statement Text: if ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
    {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:if Text: if
|Node:condition_clause Text: ((sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED))
|Node:( Text: (
|Node:binary_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED) || (sg_bCurrState == STATE_CONNECTED)
|Node:parenthesized_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|Node:( Text: (
|Node:binary_expression Text: sg_bCurrState == STATE_HW_INTERFACE_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:== Text: ==
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (sg_bCurrState == STATE_CONNECTED)
|Node:( Text: (
|Node:binary_expression Text: sg_bCurrState == STATE_CONNECTED
|Node:identifier Text: sg_bCurrState
|Node:== Text: ==
|Node:identifier Text: STATE_CONNECTED
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
    }
|Node:{ Text: {
|Node:switch_statement Text: switch (eContrParam)
        {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
|Node:switch Text: switch
|Node:condition_clause Text: (eContrParam)
|Node:( Text: (
|Node:identifier Text: eContrParam
|Node:) Text: )
|Node:compound_statement Text: {
            case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;

            case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;

            case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;

            case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;

            case CON_TEST:
                lParam = TRUE;
                break;

            default:
                hResult = S_FALSE;
                break;
        }
|Node:{ Text: {
|Node:case_statement Text: case NUMBER_HW:
                lParam = sg_nNoOfChannels;
                break;
|Node:case Text: case
|Node:identifier Text: NUMBER_HW
|Node:: Text: :
|Node:expression_statement Text: lParam = sg_nNoOfChannels;
|Node:assignment_expression Text: lParam = sg_nNoOfChannels
|Node:identifier Text: lParam
|Node:= Text: =
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case NUMBER_CONNECTED_HW:
                lParam = sg_nNoOfChannels;
                break;
|Node:case Text: case
|Node:identifier Text: NUMBER_CONNECTED_HW
|Node:: Text: :
|Node:expression_statement Text: lParam = sg_nNoOfChannels;
|Node:assignment_expression Text: lParam = sg_nNoOfChannels
|Node:identifier Text: lParam
|Node:= Text: =
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case DRIVER_STATUS:
                lParam = sg_bIsDriverRunning;
                break;
|Node:case Text: case
|Node:identifier Text: DRIVER_STATUS
|Node:: Text: :
|Node:expression_statement Text: lParam = sg_bIsDriverRunning;
|Node:assignment_expression Text: lParam = sg_bIsDriverRunning
|Node:identifier Text: lParam
|Node:= Text: =
|Node:identifier Text: sg_bIsDriverRunning
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case HW_MODE:
                lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
                break;
|Node:case Text: case
|Node:identifier Text: HW_MODE
|Node:: Text: :
|Node:expression_statement Text: lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1;
|Node:assignment_expression Text: lParam = (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1
|Node:identifier Text: lParam
|Node:= Text: =
|Node:conditional_expression Text: (nChannel < sg_nNoOfChannels) ? defMODE_ACTIVE : defCONTROLLER_BUSOFF + 1
|Node:parenthesized_expression Text: (nChannel < sg_nNoOfChannels)
|Node:( Text: (
|Node:binary_expression Text: nChannel < sg_nNoOfChannels
|Node:identifier Text: nChannel
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:) Text: )
|Node:? Text: ?
|Node:identifier Text: defMODE_ACTIVE
|Node:: Text: :
|Node:binary_expression Text: defCONTROLLER_BUSOFF + 1
|Node:identifier Text: defCONTROLLER_BUSOFF
|Node:+ Text: +
|Node:number_literal Text: 1
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case CON_TEST:
                lParam = TRUE;
                break;
|Node:case Text: case
|Node:identifier Text: CON_TEST
|Node:: Text: :
|Node:expression_statement Text: lParam = TRUE;
|Node:assignment_expression Text: lParam = TRUE
|Node:identifier Text: lParam
|Node:= Text: =
|Node:true Text: TRUE
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: default:
                hResult = S_FALSE;
                break;
|Node:default Text: default
|Node:: Text: :
|Node:expression_statement Text: hResult = S_FALSE;
|Node:assignment_expression Text: hResult = S_FALSE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_FALSE
|Node:; Text: ;
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:else Text: else
|Node:compound_statement Text: {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_IMPROPER_STATE;
|Node:assignment_expression Text: hResult = ERR_IMPROPER_STATE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
{
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
    return S_OK;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_SetControllerParams(int nValue, ECONTR_PARAM eContrparam)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_SetControllerParams
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_SetControllerParams
|Node:parameter_list Text: (int nValue, ECONTR_PARAM eContrparam)
|Node:( Text: (
|Node:parameter_declaration Text: int nValue
|Node:primitive_type Text: int
|Node:identifier Text: nValue
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrparam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrparam
|Node:) Text: )
|Node:compound_statement Text: {
    switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
    return S_OK;
}
|Node:{ Text: {
|Node:switch_statement Text: switch(eContrparam)
    {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
|Node:switch Text: switch
|Node:condition_clause Text: (eContrparam)
|Node:( Text: (
|Node:identifier Text: eContrparam
|Node:) Text: )
|Node:compound_statement Text: {
        case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
    }
|Node:{ Text: {
|Node:case_statement Text: case HW_MODE:
        {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
|Node:case Text: case
|Node:identifier Text: HW_MODE
|Node:: Text: :
|Node:compound_statement Text: {
            switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
        }
|Node:{ Text: {
|Node:switch_statement Text: switch(nValue)
            {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
|Node:switch Text: switch
|Node:condition_clause Text: (nValue)
|Node:( Text: (
|Node:identifier Text: nValue
|Node:) Text: )
|Node:compound_statement Text: {
                case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
                case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
            }
|Node:{ Text: {
|Node:case_statement Text: case defMODE_ACTIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
|Node:case Text: case
|Node:identifier Text: defMODE_ACTIVE
|Node:: Text: :
|Node:compound_statement Text: {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:) Text: )
|Node:compound_statement Text: {
                        OCI_CANControllerProperties val;
                        val.mode = OCI_CONTROLLER_MODE_RUNNING;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
|Node:{ Text: {
|Node:declaration Text: OCI_CANControllerProperties val;
|Node:type_identifier Text: OCI_CANControllerProperties
|Node:identifier Text: val
|Node:; Text: ;
|Node:expression_statement Text: val.mode = OCI_CONTROLLER_MODE_RUNNING;
|Node:assignment_expression Text: val.mode = OCI_CONTROLLER_MODE_RUNNING
|Node:field_expression Text: val.mode
|Node:identifier Text: val
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:= Text: =
|Node:identifier Text: OCI_CONTROLLER_MODE_RUNNING
|Node:; Text: ;
|Node:expression_statement Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: setCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                                &val)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &val
|Node:& Text: &
|Node:identifier Text: val
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: i++;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:case_statement Text: case defMODE_PASSIVE:
                {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
                break;
|Node:case Text: case
|Node:identifier Text: defMODE_PASSIVE
|Node:: Text: :
|Node:compound_statement Text: {
                    for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
                }
|Node:{ Text: {
|Node:for_statement Text: for (UINT i = 0; i < sg_nNoOfChannels;)
                    {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
|Node:for Text: for
|Node:( Text: (
|Node:declaration Text: UINT i = 0;
|Node:type_identifier Text: UINT
|Node:init_declarator Text: i = 0
|Node:identifier Text: i
|Node:= Text: =
|Node:number_literal Text: 0
|Node:; Text: ;
|Node:binary_expression Text: i < sg_nNoOfChannels
|Node:identifier Text: i
|Node:< Text: <
|Node:identifier Text: sg_nNoOfChannels
|Node:; Text: ;
|Node:) Text: )
|Node:compound_statement Text: {
                        OCI_CANControllerProperties val;
                        val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
                        (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
                        i++;

                    }
|Node:{ Text: {
|Node:declaration Text: OCI_CANControllerProperties val;
|Node:type_identifier Text: OCI_CANControllerProperties
|Node:identifier Text: val
|Node:; Text: ;
|Node:expression_statement Text: val.mode  = OCI_CONTROLLER_MODE_SUSPENDED;
|Node:assignment_expression Text: val.mode  = OCI_CONTROLLER_MODE_SUSPENDED
|Node:field_expression Text: val.mode
|Node:identifier Text: val
|Node:. Text: .
|Node:field_identifier Text: mode
|Node:= Text: =
|Node:identifier Text: OCI_CONTROLLER_MODE_SUSPENDED
|Node:; Text: ;
|Node:expression_statement Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val);
|Node:call_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))(sg_asChannel[i].m_OCI_HwHandle,
                                &val)
|Node:parenthesized_expression Text: (*(sBOA_PTRS.m_sOCI.setCANControllerProperties))
|Node:( Text: (
|Node:pointer_expression Text: *(sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:* Text: *
|Node:parenthesized_expression Text: (sBOA_PTRS.m_sOCI.setCANControllerProperties)
|Node:( Text: (
|Node:field_expression Text: sBOA_PTRS.m_sOCI.setCANControllerProperties
|Node:field_expression Text: sBOA_PTRS.m_sOCI
|Node:identifier Text: sBOA_PTRS
|Node:. Text: .
|Node:field_identifier Text: m_sOCI
|Node:. Text: .
|Node:field_identifier Text: setCANControllerProperties
|Node:) Text: )
|Node:) Text: )
|Node:argument_list Text: (sg_asChannel[i].m_OCI_HwHandle,
                                &val)
|Node:( Text: (
|Node:field_expression Text: sg_asChannel[i].m_OCI_HwHandle
|Node:subscript_expression Text: sg_asChannel[i]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [i]
|Node:[ Text: [
|Node:identifier Text: i
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_OCI_HwHandle
|Node:, Text: ,
|Node:pointer_expression Text: &val
|Node:& Text: &
|Node:identifier Text: val
|Node:) Text: )
|Node:; Text: ;
|Node:expression_statement Text: i++;
|Node:update_expression Text: i++
|Node:identifier Text: i
|Node:++ Text: ++
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:break_statement Text: break;
|Node:break Text: break
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:} Text: }
|Node:return_statement Text: return S_OK;
|Node:return Text: return
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:} Text: }
|Node:function_definition Text: HRESULT CDIL_CAN_ETAS_BOA::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
{
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|Node:type_identifier Text: HRESULT
|Node:function_declarator Text: CDIL_CAN_ETAS_BOA::CAN_GetErrorCount(SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:qualified_identifier Text: CDIL_CAN_ETAS_BOA::CAN_GetErrorCount
|Node:namespace_identifier Text: CDIL_CAN_ETAS_BOA
|Node::: Text: ::
|Node:identifier Text: CAN_GetErrorCount
|Node:parameter_list Text: (SERROR_CNT& sErrorCnt, UINT nChannel, ECONTR_PARAM eContrParam)
|Node:( Text: (
|Node:parameter_declaration Text: SERROR_CNT& sErrorCnt
|Node:type_identifier Text: SERROR_CNT
|Node:reference_declarator Text: & sErrorCnt
|Node:& Text: &
|Node:identifier Text: sErrorCnt
|Node:, Text: ,
|Node:parameter_declaration Text: UINT nChannel
|Node:type_identifier Text: UINT
|Node:identifier Text: nChannel
|Node:, Text: ,
|Node:parameter_declaration Text: ECONTR_PARAM eContrParam
|Node:type_identifier Text: ECONTR_PARAM
|Node:identifier Text: eContrParam
|Node:) Text: )
|Node:compound_statement Text: {
    HRESULT hResult = S_OK;
    if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
    return hResult;
}
|Node:{ Text: {
|Node:declaration Text: HRESULT hResult = S_OK;
|Node:type_identifier Text: HRESULT
|Node:init_declarator Text: hResult = S_OK
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: S_OK
|Node:; Text: ;
|Node:if_statement Text: if ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
    {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
    else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:if Text: if
|Node:condition_clause Text: ((sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED))
|Node:( Text: (
|Node:binary_expression Text: (sg_bCurrState == STATE_CONNECTED) || (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|Node:parenthesized_expression Text: (sg_bCurrState == STATE_CONNECTED)
|Node:( Text: (
|Node:binary_expression Text: sg_bCurrState == STATE_CONNECTED
|Node:identifier Text: sg_bCurrState
|Node:== Text: ==
|Node:identifier Text: STATE_CONNECTED
|Node:) Text: )
|Node:|| Text: ||
|Node:parenthesized_expression Text: (sg_bCurrState == STATE_HW_INTERFACE_SELECTED)
|Node:( Text: (
|Node:binary_expression Text: sg_bCurrState == STATE_HW_INTERFACE_SELECTED
|Node:identifier Text: sg_bCurrState
|Node:== Text: ==
|Node:identifier Text: STATE_HW_INTERFACE_SELECTED
|Node:) Text: )
|Node:) Text: )
|Node:compound_statement Text: {
        if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
    }
|Node:{ Text: {
|Node:if_statement Text: if (nChannel <= sg_nNoOfChannels)
        {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
        else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:if Text: if
|Node:condition_clause Text: (nChannel <= sg_nNoOfChannels)
|Node:( Text: (
|Node:binary_expression Text: nChannel <= sg_nNoOfChannels
|Node:identifier Text: nChannel
|Node:<= Text: <=
|Node:identifier Text: sg_nNoOfChannels
|Node:) Text: )
|Node:compound_statement Text: {
            if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
        }
|Node:{ Text: {
|Node:if_statement Text: if (eContrParam == ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
            else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
|Node:if Text: if
|Node:condition_clause Text: (eContrParam == ERR_CNT)
|Node:( Text: (
|Node:binary_expression Text: eContrParam == ERR_CNT
|Node:identifier Text: eContrParam
|Node:== Text: ==
|Node:identifier Text: ERR_CNT
|Node:) Text: )
|Node:compound_statement Text: {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
            }
|Node:{ Text: {
|Node:expression_statement Text: sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter;
|Node:assignment_expression Text: sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucTxErrorCounter
|Node:field_expression Text: sErrorCnt.m_ucTxErrCount
|Node:identifier Text: sErrorCnt
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrCount
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[nChannel].m_ucTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrorCounter
|Node:; Text: ;
|Node:expression_statement Text: sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter;
|Node:assignment_expression Text: sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucRxErrorCounter
|Node:field_expression Text: sErrorCnt.m_ucRxErrCount
|Node:identifier Text: sErrorCnt
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrCount
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[nChannel].m_ucRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrorCounter
|Node:; Text: ;
|Node:} Text: }
|Node:else_clause Text: else if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
|Node:else Text: else
|Node:if_statement Text: if (eContrParam == PEAK_ERR_CNT)
            {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
|Node:if Text: if
|Node:condition_clause Text: (eContrParam == PEAK_ERR_CNT)
|Node:( Text: (
|Node:binary_expression Text: eContrParam == PEAK_ERR_CNT
|Node:identifier Text: eContrParam
|Node:== Text: ==
|Node:identifier Text: PEAK_ERR_CNT
|Node:) Text: )
|Node:compound_statement Text: {
                sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
                sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
            }
|Node:{ Text: {
|Node:expression_statement Text: sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter;
|Node:assignment_expression Text: sErrorCnt.m_ucTxErrCount = sg_asChannel[nChannel].m_ucPeakTxErrorCounter
|Node:field_expression Text: sErrorCnt.m_ucTxErrCount
|Node:identifier Text: sErrorCnt
|Node:. Text: .
|Node:field_identifier Text: m_ucTxErrCount
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakTxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakTxErrorCounter
|Node:; Text: ;
|Node:expression_statement Text: sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter;
|Node:assignment_expression Text: sErrorCnt.m_ucRxErrCount = sg_asChannel[nChannel].m_ucPeakRxErrorCounter
|Node:field_expression Text: sErrorCnt.m_ucRxErrCount
|Node:identifier Text: sErrorCnt
|Node:. Text: .
|Node:field_identifier Text: m_ucRxErrCount
|Node:= Text: =
|Node:field_expression Text: sg_asChannel[nChannel].m_ucPeakRxErrorCounter
|Node:subscript_expression Text: sg_asChannel[nChannel]
|Node:identifier Text: sg_asChannel
|Node:subscript_argument_list Text: [nChannel]
|Node:[ Text: [
|Node:identifier Text: nChannel
|Node:] Text: ]
|Node:. Text: .
|Node:field_identifier Text: m_ucPeakRxErrorCounter
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
        {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:else Text: else
|Node:compound_statement Text: {
            hResult = ERR_INVALID_CHANNEL;
        }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_INVALID_CHANNEL;
|Node:assignment_expression Text: hResult = ERR_INVALID_CHANNEL
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_INVALID_CHANNEL
|Node:; Text: ;
|Node:} Text: }
|Node:} Text: }
|Node:else_clause Text: else
    {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:else Text: else
|Node:compound_statement Text: {
        hResult = ERR_IMPROPER_STATE;
    }
|Node:{ Text: {
|Node:expression_statement Text: hResult = ERR_IMPROPER_STATE;
|Node:assignment_expression Text: hResult = ERR_IMPROPER_STATE
|Node:identifier Text: hResult
|Node:= Text: =
|Node:identifier Text: ERR_IMPROPER_STATE
|Node:; Text: ;
|Node:} Text: }
|Node:return_statement Text: return hResult;
|Node:return Text: return
|Node:identifier Text: hResult
|Node:; Text: ;
|Node:} Text: }
