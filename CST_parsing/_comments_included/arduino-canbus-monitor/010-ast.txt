arduino-canbus-monitor-can-232.cpp

|Node:translation_unit
|—Node:comment Text: /*****************************************************************************************
* This is implementation of CAN BUS ASCII protocol based on LAWICEL v1.3 serial protocol
*  of CAN232/CANUSB device (http://www.can232.com/docs/can232_v3.pdf)
*
* Made for Arduino with Seeduino/ElecFreaks CAN BUS Shield based on MCP2515
*
* Copyright (C) 2015 Anton Viktorov <latonita@yandex.ru>
*                                    https://github.com/latonita/can-ascii
*
* This library is free software. You may use/redistribute it under The MIT License terms. 
*
*****************************************************************************************/
|—Node:preproc_include Text: #include <SPI.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <SPI.h>
|—Node:preproc_include Text: #include "mcp_can.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "mcp_can.h"
|———Node:" Text: "
|———Node:string_content Text: mcp_can.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "can-232.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "can-232.h"
|———Node:" Text: "
|———Node:string_content Text: can-232.h
|———Node:" Text: "
|—Node:preproc_def Text: #define LOGGING_ENABLED

|——Node:#define Text: #define
|——Node:identifier Text: LOGGING_ENABLED
|—Node:preproc_ifdef Text: #ifdef LOGGING_ENABLED
#define dbg_begin(x) debug.begin(x)
#define dbg0(x)   debug.print(x)
#define dbg1(x)   debug.println(x)
#define dbg2(x,y) debug.print(x); debug.println(y)
#define dbgH(x)   debug.print(x,HEX)
#define DEBUG_RX_PIN 8
#define DEBUG_TX_PIN 9
#else
#define dbg_begin(x)
#define dbg0(x) 
#define dbg1(x) 
#define dbg2(x,y)
#define dbgH(x)
#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: LOGGING_ENABLED
|——Node:preproc_function_def Text: #define dbg_begin(x) debug.begin(x)

|———Node:#define Text: #define
|———Node:identifier Text: dbg_begin
|———Node:preproc_params Text: (x)
|————Node:( Text: (
|————Node:identifier Text: x
|————Node:) Text: )
|———Node:preproc_arg Text: debug.begin(x)
|——Node:preproc_function_def Text: #define dbg0(x)   debug.print(x)

|———Node:#define Text: #define
|———Node:identifier Text: dbg0
|———Node:preproc_params Text: (x)
|————Node:( Text: (
|————Node:identifier Text: x
|————Node:) Text: )
|———Node:preproc_arg Text: debug.print(x)
|——Node:preproc_function_def Text: #define dbg1(x)   debug.println(x)

|———Node:#define Text: #define
|———Node:identifier Text: dbg1
|———Node:preproc_params Text: (x)
|————Node:( Text: (
|————Node:identifier Text: x
|————Node:) Text: )
|———Node:preproc_arg Text: debug.println(x)
|——Node:preproc_function_def Text: #define dbg2(x,y) debug.print(x); debug.println(y)

|———Node:#define Text: #define
|———Node:identifier Text: dbg2
|———Node:preproc_params Text: (x,y)
|————Node:( Text: (
|————Node:identifier Text: x
|————Node:, Text: ,
|————Node:identifier Text: y
|————Node:) Text: )
|———Node:preproc_arg Text: debug.print(x); debug.println(y)
|——Node:preproc_function_def Text: #define dbgH(x)   debug.print(x,HEX)

|———Node:#define Text: #define
|———Node:identifier Text: dbgH
|———Node:preproc_params Text: (x)
|————Node:( Text: (
|————Node:identifier Text: x
|————Node:) Text: )
|———Node:preproc_arg Text: debug.print(x,HEX)
|——Node:preproc_def Text: #define DEBUG_RX_PIN 8

|———Node:#define Text: #define
|———Node:identifier Text: DEBUG_RX_PIN
|———Node:preproc_arg Text: 8
|——Node:preproc_def Text: #define DEBUG_TX_PIN 9

|———Node:#define Text: #define
|———Node:identifier Text: DEBUG_TX_PIN
|———Node:preproc_arg Text: 9
|——Node:preproc_else Text: #else
#define dbg_begin(x)
#define dbg0(x) 
#define dbg1(x) 
#define dbg2(x,y)
#define dbgH(x)

|———Node:#else Text: #else
|———Node:preproc_function_def Text: #define dbg_begin(x)

|————Node:#define Text: #define
|————Node:identifier Text: dbg_begin
|————Node:preproc_params Text: (x)
|—————Node:( Text: (
|—————Node:identifier Text: x
|—————Node:) Text: )
|———Node:preproc_function_def Text: #define dbg0(x) 
#define dbg1(x) 

|————Node:#define Text: #define
|————Node:identifier Text: dbg0
|————Node:preproc_params Text: (x)
|—————Node:( Text: (
|—————Node:identifier Text: x
|—————Node:) Text: )
|————Node:preproc_arg Text: #define dbg1(x) 
|———Node:preproc_function_def Text: #define dbg2(x,y)

|————Node:#define Text: #define
|————Node:identifier Text: dbg2
|————Node:preproc_params Text: (x,y)
|—————Node:( Text: (
|—————Node:identifier Text: x
|—————Node:, Text: ,
|—————Node:identifier Text: y
|—————Node:) Text: )
|———Node:preproc_function_def Text: #define dbgH(x)

|————Node:#define Text: #define
|————Node:identifier Text: dbgH
|————Node:preproc_params Text: (x)
|—————Node:( Text: (
|—————Node:identifier Text: x
|—————Node:) Text: )
|——Node:#endif Text: #endif
|—Node:preproc_ifdef Text: #ifdef LOGGING_ENABLED
    // software serial #2: TX = digital pin 8, RX = digital pin 9
    // on the Mega, use other pins instead, since 8 and 9 don't work on the Mega
  
      SoftwareSerial debug(DEBUG_RX_PIN, DEBUG_TX_PIN);
  //#define debug Serial
#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: LOGGING_ENABLED
|——Node:comment Text: // software serial #2: TX = digital pin 8, RX = digital pin 9
|——Node:comment Text: // on the Mega, use other pins instead, since 8 and 9 don't work on the Mega
|——Node:declaration Text: SoftwareSerial debug(DEBUG_RX_PIN, DEBUG_TX_PIN);
|———Node:type_identifier Text: SoftwareSerial
|———Node:function_declarator Text: debug(DEBUG_RX_PIN, DEBUG_TX_PIN)
|————Node:identifier Text: debug
|————Node:parameter_list Text: (DEBUG_RX_PIN, DEBUG_TX_PIN)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: DEBUG_RX_PIN
|——————Node:type_identifier Text: DEBUG_RX_PIN
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: DEBUG_TX_PIN
|——————Node:type_identifier Text: DEBUG_TX_PIN
|—————Node:) Text: )
|———Node:; Text: ;
|——Node:comment Text: //#define debug Serial
|——Node:#endif Text: #endif
|—Node:declaration Text: Can232* Can232::_instance = 0;
|——Node:type_identifier Text: Can232
|——Node:init_declarator Text: * Can232::_instance = 0
|———Node:pointer_declarator Text: * Can232::_instance
|————Node:* Text: *
|————Node:qualified_identifier Text: Can232::_instance
|—————Node:namespace_identifier Text: Can232
|—————Node::: Text: ::
|—————Node:identifier Text: _instance
|———Node:= Text: =
|———Node:number_literal Text: 0
|——Node:; Text: ;
|—Node:function_definition Text: Can232* Can232::instance() {
    if (_instance == 0)
        _instance = new Can232();
    return _instance;
}
|——Node:type_identifier Text: Can232
|——Node:pointer_declarator Text: * Can232::instance()
|———Node:* Text: *
|———Node:function_declarator Text: Can232::instance()
|————Node:qualified_identifier Text: Can232::instance
|—————Node:namespace_identifier Text: Can232
|—————Node::: Text: ::
|—————Node:identifier Text: instance
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|——Node:compound_statement Text: {
    if (_instance == 0)
        _instance = new Can232();
    return _instance;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_instance == 0)
        _instance = new Can232();
|————Node:if Text: if
|————Node:condition_clause Text: (_instance == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: _instance == 0
|——————Node:identifier Text: _instance
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: _instance = new Can232();
|—————Node:assignment_expression Text: _instance = new Can232()
|——————Node:identifier Text: _instance
|——————Node:= Text: =
|——————Node:new_expression Text: new Can232()
|———————Node:new Text: new
|———————Node:type_identifier Text: Can232
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:; Text: ;
|———Node:return_statement Text: return _instance;
|————Node:return Text: return
|————Node:identifier Text: _instance
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::init(INT8U defaultCanSpeed, const INT8U clock) {
    dbg_begin(LW232_DEFAULT_BAUD_RATE); // logging through software serial 
    dbg1("CAN ASCII. Welcome to debug");

    instance()->lw232CanSpeedSelection = defaultCanSpeed;
    instance()->lw232McpModuleClock = clock;
    instance()->initFunc();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::init(INT8U defaultCanSpeed, const INT8U clock)
|———Node:qualified_identifier Text: Can232::init
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: init
|———Node:parameter_list Text: (INT8U defaultCanSpeed, const INT8U clock)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U defaultCanSpeed
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: defaultCanSpeed
|————Node:, Text: ,
|————Node:parameter_declaration Text: const INT8U clock
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: clock
|————Node:) Text: )
|——Node:compound_statement Text: {
    dbg_begin(LW232_DEFAULT_BAUD_RATE); // logging through software serial 
    dbg1("CAN ASCII. Welcome to debug");

    instance()->lw232CanSpeedSelection = defaultCanSpeed;
    instance()->lw232McpModuleClock = clock;
    instance()->initFunc();
}
|———Node:{ Text: {
|———Node:expression_statement Text: dbg_begin(LW232_DEFAULT_BAUD_RATE);
|————Node:call_expression Text: dbg_begin(LW232_DEFAULT_BAUD_RATE)
|—————Node:identifier Text: dbg_begin
|—————Node:argument_list Text: (LW232_DEFAULT_BAUD_RATE)
|——————Node:( Text: (
|——————Node:identifier Text: LW232_DEFAULT_BAUD_RATE
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // logging through software serial 
|———Node:expression_statement Text: dbg1("CAN ASCII. Welcome to debug");
|————Node:call_expression Text: dbg1("CAN ASCII. Welcome to debug")
|—————Node:identifier Text: dbg1
|—————Node:argument_list Text: ("CAN ASCII. Welcome to debug")
|——————Node:( Text: (
|——————Node:string_literal Text: "CAN ASCII. Welcome to debug"
|———————Node:" Text: "
|———————Node:string_content Text: CAN ASCII. Welcome to debug
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: instance()->lw232CanSpeedSelection = defaultCanSpeed;
|————Node:assignment_expression Text: instance()->lw232CanSpeedSelection = defaultCanSpeed
|—————Node:field_expression Text: instance()->lw232CanSpeedSelection
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: lw232CanSpeedSelection
|—————Node:= Text: =
|—————Node:identifier Text: defaultCanSpeed
|————Node:; Text: ;
|———Node:expression_statement Text: instance()->lw232McpModuleClock = clock;
|————Node:assignment_expression Text: instance()->lw232McpModuleClock = clock
|—————Node:field_expression Text: instance()->lw232McpModuleClock
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: lw232McpModuleClock
|—————Node:= Text: =
|—————Node:identifier Text: clock
|————Node:; Text: ;
|———Node:expression_statement Text: instance()->initFunc();
|————Node:call_expression Text: instance()->initFunc()
|—————Node:field_expression Text: instance()->initFunc
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: initFunc
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::setFilter(INT8U (*userFunc)(INT32U)) {
    instance()->setFilterFunc(userFunc);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::setFilter(INT8U (*userFunc)(INT32U))
|———Node:qualified_identifier Text: Can232::setFilter
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: setFilter
|———Node:parameter_list Text: (INT8U (*userFunc)(INT32U))
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U (*userFunc)(INT32U)
|—————Node:type_identifier Text: INT8U
|—————Node:function_declarator Text: (*userFunc)(INT32U)
|——————Node:parenthesized_declarator Text: (*userFunc)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *userFunc
|————————Node:* Text: *
|————————Node:identifier Text: userFunc
|———————Node:) Text: )
|——————Node:parameter_list Text: (INT32U)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: INT32U
|————————Node:type_identifier Text: INT32U
|———————Node:) Text: )
|————Node:) Text: )
|——Node:compound_statement Text: {
    instance()->setFilterFunc(userFunc);
}
|———Node:{ Text: {
|———Node:expression_statement Text: instance()->setFilterFunc(userFunc);
|————Node:call_expression Text: instance()->setFilterFunc(userFunc)
|—————Node:field_expression Text: instance()->setFilterFunc
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: setFilterFunc
|—————Node:argument_list Text: (userFunc)
|——————Node:( Text: (
|——————Node:identifier Text: userFunc
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::loop() {
    instance()->loopFunc();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::loop()
|———Node:qualified_identifier Text: Can232::loop
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: loop
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    instance()->loopFunc();
}
|———Node:{ Text: {
|———Node:expression_statement Text: instance()->loopFunc();
|————Node:call_expression Text: instance()->loopFunc()
|—————Node:field_expression Text: instance()->loopFunc
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: loopFunc
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::serialEvent() {
    instance()->serialEventFunc();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::serialEvent()
|———Node:qualified_identifier Text: Can232::serialEvent
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: serialEvent
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    instance()->serialEventFunc();
}
|———Node:{ Text: {
|———Node:expression_statement Text: instance()->serialEventFunc();
|————Node:call_expression Text: instance()->serialEventFunc()
|—————Node:field_expression Text: instance()->serialEventFunc
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: serialEventFunc
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::initFunc() {
    inputString.reserve(200);
    // lw232AutoStart = true; //todo: read from eeprom
    // lw232AutoPoll = false; //todo: read from eeprom
    //  lw232TimeStamp = //read from eeprom
    //    lw232Message[0] = 'Z';    lw232Message[1] = '1'; exec();
    //if (lw232AutoStart) {
        inputString = "O\0x0D";
        stringComplete = true;
        loopFunc();
    //}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::initFunc()
|———Node:qualified_identifier Text: Can232::initFunc
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: initFunc
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    inputString.reserve(200);
    // lw232AutoStart = true; //todo: read from eeprom
    // lw232AutoPoll = false; //todo: read from eeprom
    //  lw232TimeStamp = //read from eeprom
    //    lw232Message[0] = 'Z';    lw232Message[1] = '1'; exec();
    //if (lw232AutoStart) {
        inputString = "O\0x0D";
        stringComplete = true;
        loopFunc();
    //}
}
|———Node:{ Text: {
|———Node:expression_statement Text: inputString.reserve(200);
|————Node:call_expression Text: inputString.reserve(200)
|—————Node:field_expression Text: inputString.reserve
|——————Node:identifier Text: inputString
|——————Node:. Text: .
|——————Node:field_identifier Text: reserve
|—————Node:argument_list Text: (200)
|——————Node:( Text: (
|——————Node:number_literal Text: 200
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // lw232AutoStart = true; //todo: read from eeprom
|———Node:comment Text: // lw232AutoPoll = false; //todo: read from eeprom
|———Node:comment Text: //  lw232TimeStamp = //read from eeprom
|———Node:comment Text: //    lw232Message[0] = 'Z';    lw232Message[1] = '1'; exec();
|———Node:comment Text: //if (lw232AutoStart) {
|———Node:expression_statement Text: inputString = "O\0x0D";
|————Node:assignment_expression Text: inputString = "O\0x0D"
|—————Node:identifier Text: inputString
|—————Node:= Text: =
|—————Node:string_literal Text: "O\0x0D"
|——————Node:" Text: "
|——————Node:string_content Text: O
|——————Node:escape_sequence Text: \0
|——————Node:string_content Text: x0D
|——————Node:" Text: "
|————Node:; Text: ;
|———Node:expression_statement Text: stringComplete = true;
|————Node:assignment_expression Text: stringComplete = true
|—————Node:identifier Text: stringComplete
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: loopFunc();
|————Node:call_expression Text: loopFunc()
|—————Node:identifier Text: loopFunc
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //}
|———Node:} Text: }
|—Node:function_definition Text: void Can232::setFilterFunc(INT8U (*userFunc)(INT32U)) {
    instance()->userAddressFilterFunc = userFunc;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::setFilterFunc(INT8U (*userFunc)(INT32U))
|———Node:qualified_identifier Text: Can232::setFilterFunc
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: setFilterFunc
|———Node:parameter_list Text: (INT8U (*userFunc)(INT32U))
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U (*userFunc)(INT32U)
|—————Node:type_identifier Text: INT8U
|—————Node:function_declarator Text: (*userFunc)(INT32U)
|——————Node:parenthesized_declarator Text: (*userFunc)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *userFunc
|————————Node:* Text: *
|————————Node:identifier Text: userFunc
|———————Node:) Text: )
|——————Node:parameter_list Text: (INT32U)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: INT32U
|————————Node:type_identifier Text: INT32U
|———————Node:) Text: )
|————Node:) Text: )
|——Node:compound_statement Text: {
    instance()->userAddressFilterFunc = userFunc;
}
|———Node:{ Text: {
|———Node:expression_statement Text: instance()->userAddressFilterFunc = userFunc;
|————Node:assignment_expression Text: instance()->userAddressFilterFunc = userFunc
|—————Node:field_expression Text: instance()->userAddressFilterFunc
|——————Node:call_expression Text: instance()
|———————Node:identifier Text: instance
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:-> Text: ->
|——————Node:field_identifier Text: userAddressFilterFunc
|—————Node:= Text: =
|—————Node:identifier Text: userFunc
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::loopFunc() {
    if (stringComplete) {
        int len = inputString.length();
        if (len > 0 && len < 29) {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
        // clear the string:
        inputString = "";
        stringComplete = false;
    }
    if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
        int recv = 0;
        while (CAN_MSGAVAIL == checkReceive() && recv++<5) {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
        Serial.flush();
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::loopFunc()
|———Node:qualified_identifier Text: Can232::loopFunc
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: loopFunc
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (stringComplete) {
        int len = inputString.length();
        if (len > 0 && len < 29) {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
        // clear the string:
        inputString = "";
        stringComplete = false;
    }
    if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
        int recv = 0;
        while (CAN_MSGAVAIL == checkReceive() && recv++<5) {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
        Serial.flush();
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (stringComplete) {
        int len = inputString.length();
        if (len > 0 && len < 29) {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
        // clear the string:
        inputString = "";
        stringComplete = false;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (stringComplete)
|—————Node:( Text: (
|—————Node:identifier Text: stringComplete
|—————Node:) Text: )
|————Node:compound_statement Text: {
        int len = inputString.length();
        if (len > 0 && len < 29) {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
        // clear the string:
        inputString = "";
        stringComplete = false;
    }
|—————Node:{ Text: {
|—————Node:declaration Text: int len = inputString.length();
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: len = inputString.length()
|———————Node:identifier Text: len
|———————Node:= Text: =
|———————Node:call_expression Text: inputString.length()
|————————Node:field_expression Text: inputString.length
|—————————Node:identifier Text: inputString
|—————————Node:. Text: .
|—————————Node:field_identifier Text: length
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (len > 0 && len < 29) {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (len > 0 && len < 29)
|———————Node:( Text: (
|———————Node:binary_expression Text: len > 0 && len < 29
|————————Node:binary_expression Text: len > 0
|—————————Node:identifier Text: len
|—————————Node:> Text: >
|—————————Node:number_literal Text: 0
|————————Node:&& Text: &&
|————————Node:binary_expression Text: len < 29
|—————————Node:identifier Text: len
|—————————Node:< Text: <
|—————————Node:number_literal Text: 29
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            strcpy((char*)lw232Message, inputString.c_str());
            exec();
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: strcpy((char*)lw232Message, inputString.c_str());
|————————Node:call_expression Text: strcpy((char*)lw232Message, inputString.c_str())
|—————————Node:identifier Text: strcpy
|—————————Node:argument_list Text: ((char*)lw232Message, inputString.c_str())
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (char*)lw232Message
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: char*
|————————————Node:primitive_type Text: char
|————————————Node:abstract_pointer_declarator Text: *
|—————————————Node:* Text: *
|———————————Node:) Text: )
|———————————Node:identifier Text: lw232Message
|——————————Node:, Text: ,
|——————————Node:call_expression Text: inputString.c_str()
|———————————Node:field_expression Text: inputString.c_str
|————————————Node:identifier Text: inputString
|————————————Node:. Text: .
|————————————Node:field_identifier Text: c_str
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: exec();
|————————Node:call_expression Text: exec()
|—————————Node:identifier Text: exec
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment Text: // clear the string:
|—————Node:expression_statement Text: inputString = "";
|——————Node:assignment_expression Text: inputString = ""
|———————Node:identifier Text: inputString
|———————Node:= Text: =
|———————Node:string_literal Text: ""
|————————Node:" Text: "
|————————Node:" Text: "
|——————Node:; Text: ;
|—————Node:expression_statement Text: stringComplete = false;
|——————Node:assignment_expression Text: stringComplete = false
|———————Node:identifier Text: stringComplete
|———————Node:= Text: =
|———————Node:false Text: false
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
        int recv = 0;
        while (CAN_MSGAVAIL == checkReceive() && recv++<5) {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
        Serial.flush();
    }
|————Node:if Text: if
|————Node:condition_clause Text: (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED)
|—————Node:( Text: (
|—————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED
|——————Node:identifier Text: lw232CanChannelMode
|——————Node:!= Text: !=
|——————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|—————Node:) Text: )
|————Node:compound_statement Text: {
        int recv = 0;
        while (CAN_MSGAVAIL == checkReceive() && recv++<5) {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
        Serial.flush();
    }
|—————Node:{ Text: {
|—————Node:declaration Text: int recv = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: recv = 0
|———————Node:identifier Text: recv
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:while_statement Text: while (CAN_MSGAVAIL == checkReceive() && recv++<5) {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
|——————Node:while Text: while
|——————Node:condition_clause Text: (CAN_MSGAVAIL == checkReceive() && recv++<5)
|———————Node:( Text: (
|———————Node:binary_expression Text: CAN_MSGAVAIL == checkReceive() && recv++<5
|————————Node:binary_expression Text: CAN_MSGAVAIL == checkReceive()
|—————————Node:identifier Text: CAN_MSGAVAIL
|—————————Node:== Text: ==
|—————————Node:call_expression Text: checkReceive()
|——————————Node:identifier Text: checkReceive
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:binary_expression Text: recv++<5
|—————————Node:update_expression Text: recv++
|——————————Node:identifier Text: recv
|——————————Node:++ Text: ++
|—————————Node:< Text: <
|—————————Node:number_literal Text: 5
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            dbg0('+');
            if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: dbg0('+');
|————————Node:call_expression Text: dbg0('+')
|—————————Node:identifier Text: dbg0
|—————————Node:argument_list Text: ('+')
|——————————Node:( Text: (
|——————————Node:char_literal Text: '+'
|———————————Node:' Text: '
|———————————Node:character Text: +
|———————————Node:' Text: '
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (CAN_OK == receiveSingleFrame()) {
                Serial.write(LW232_CR);
            }
|————————Node:if Text: if
|————————Node:condition_clause Text: (CAN_OK == receiveSingleFrame())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: CAN_OK == receiveSingleFrame()
|——————————Node:identifier Text: CAN_OK
|——————————Node:== Text: ==
|——————————Node:call_expression Text: receiveSingleFrame()
|———————————Node:identifier Text: receiveSingleFrame
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                Serial.write(LW232_CR);
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: Serial.write(LW232_CR);
|——————————Node:call_expression Text: Serial.write(LW232_CR)
|———————————Node:field_expression Text: Serial.write
|————————————Node:identifier Text: Serial
|————————————Node:. Text: .
|————————————Node:field_identifier Text: write
|———————————Node:argument_list Text: (LW232_CR)
|————————————Node:( Text: (
|————————————Node:identifier Text: LW232_CR
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: Serial.flush();
|——————Node:call_expression Text: Serial.flush()
|———————Node:field_expression Text: Serial.flush
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: flush
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void Can232::serialEventFunc() {
    while (Serial.available()) {
        char inChar = (char)Serial.read();
        inputString += inChar;
        if (inChar == LW232_CR) {
            stringComplete = true;
        }
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::serialEventFunc()
|———Node:qualified_identifier Text: Can232::serialEventFunc
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: serialEventFunc
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    while (Serial.available()) {
        char inChar = (char)Serial.read();
        inputString += inChar;
        if (inChar == LW232_CR) {
            stringComplete = true;
        }
    }
}
|———Node:{ Text: {
|———Node:while_statement Text: while (Serial.available()) {
        char inChar = (char)Serial.read();
        inputString += inChar;
        if (inChar == LW232_CR) {
            stringComplete = true;
        }
    }
|————Node:while Text: while
|————Node:condition_clause Text: (Serial.available())
|—————Node:( Text: (
|—————Node:call_expression Text: Serial.available()
|——————Node:field_expression Text: Serial.available
|———————Node:identifier Text: Serial
|———————Node:. Text: .
|———————Node:field_identifier Text: available
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        char inChar = (char)Serial.read();
        inputString += inChar;
        if (inChar == LW232_CR) {
            stringComplete = true;
        }
    }
|—————Node:{ Text: {
|—————Node:declaration Text: char inChar = (char)Serial.read();
|——————Node:primitive_type Text: char
|——————Node:init_declarator Text: inChar = (char)Serial.read()
|———————Node:identifier Text: inChar
|———————Node:= Text: =
|———————Node:cast_expression Text: (char)Serial.read()
|————————Node:( Text: (
|————————Node:type_descriptor Text: char
|—————————Node:primitive_type Text: char
|————————Node:) Text: )
|————————Node:call_expression Text: Serial.read()
|—————————Node:field_expression Text: Serial.read
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: inputString += inChar;
|——————Node:assignment_expression Text: inputString += inChar
|———————Node:identifier Text: inputString
|———————Node:+= Text: +=
|———————Node:identifier Text: inChar
|——————Node:; Text: ;
|—————Node:if_statement Text: if (inChar == LW232_CR) {
            stringComplete = true;
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (inChar == LW232_CR)
|———————Node:( Text: (
|———————Node:binary_expression Text: inChar == LW232_CR
|————————Node:identifier Text: inChar
|————————Node:== Text: ==
|————————Node:identifier Text: LW232_CR
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            stringComplete = true;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: stringComplete = true;
|————————Node:assignment_expression Text: stringComplete = true
|—————————Node:identifier Text: stringComplete
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::exec() {
    dbg2("Command received:", inputString);
    lw232LastErr = parseAndRunCommand();
    switch (lw232LastErr) {
    case LW232_OK:
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_SMALL:
        Serial.write(LW232_RET_ASCII_OK_SMALL);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_BIG:
        Serial.write(LW232_RET_ASCII_OK_BIG);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_ERR_NOT_IMPLEMENTED:
        // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
        Serial.write(LW232_RET_ASCII_ERROR);
        //Serial.write(LW232_RET_ASCII_OK); 
        break;
    default:
        Serial.write(LW232_RET_ASCII_ERROR);
    }
    return 0;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::exec()
|———Node:qualified_identifier Text: Can232::exec
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: exec
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    dbg2("Command received:", inputString);
    lw232LastErr = parseAndRunCommand();
    switch (lw232LastErr) {
    case LW232_OK:
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_SMALL:
        Serial.write(LW232_RET_ASCII_OK_SMALL);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_BIG:
        Serial.write(LW232_RET_ASCII_OK_BIG);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_ERR_NOT_IMPLEMENTED:
        // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
        Serial.write(LW232_RET_ASCII_ERROR);
        //Serial.write(LW232_RET_ASCII_OK); 
        break;
    default:
        Serial.write(LW232_RET_ASCII_ERROR);
    }
    return 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: dbg2("Command received:", inputString);
|————Node:call_expression Text: dbg2("Command received:", inputString)
|—————Node:identifier Text: dbg2
|—————Node:argument_list Text: ("Command received:", inputString)
|——————Node:( Text: (
|——————Node:string_literal Text: "Command received:"
|———————Node:" Text: "
|———————Node:string_content Text: Command received:
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:identifier Text: inputString
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: lw232LastErr = parseAndRunCommand();
|————Node:assignment_expression Text: lw232LastErr = parseAndRunCommand()
|—————Node:identifier Text: lw232LastErr
|—————Node:= Text: =
|—————Node:call_expression Text: parseAndRunCommand()
|——————Node:identifier Text: parseAndRunCommand
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:switch_statement Text: switch (lw232LastErr) {
    case LW232_OK:
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_SMALL:
        Serial.write(LW232_RET_ASCII_OK_SMALL);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_BIG:
        Serial.write(LW232_RET_ASCII_OK_BIG);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_ERR_NOT_IMPLEMENTED:
        // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
        Serial.write(LW232_RET_ASCII_ERROR);
        //Serial.write(LW232_RET_ASCII_OK); 
        break;
    default:
        Serial.write(LW232_RET_ASCII_ERROR);
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (lw232LastErr)
|—————Node:( Text: (
|—————Node:identifier Text: lw232LastErr
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case LW232_OK:
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_SMALL:
        Serial.write(LW232_RET_ASCII_OK_SMALL);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_OK_BIG:
        Serial.write(LW232_RET_ASCII_OK_BIG);
        Serial.write(LW232_RET_ASCII_OK);
        break;
    case LW232_ERR_NOT_IMPLEMENTED:
        // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
        Serial.write(LW232_RET_ASCII_ERROR);
        //Serial.write(LW232_RET_ASCII_OK); 
        break;
    default:
        Serial.write(LW232_RET_ASCII_ERROR);
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case LW232_OK:
        Serial.write(LW232_RET_ASCII_OK);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_OK
|——————Node:: Text: :
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_OK);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_OK)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_OK)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_OK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_OK_SMALL:
        Serial.write(LW232_RET_ASCII_OK_SMALL);
        Serial.write(LW232_RET_ASCII_OK);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_OK_SMALL
|——————Node:: Text: :
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_OK_SMALL);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_OK_SMALL)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_OK_SMALL)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_OK_SMALL
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_OK);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_OK)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_OK)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_OK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_OK_BIG:
        Serial.write(LW232_RET_ASCII_OK_BIG);
        Serial.write(LW232_RET_ASCII_OK);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_OK_BIG
|——————Node:: Text: :
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_OK_BIG);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_OK_BIG)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_OK_BIG)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_OK_BIG
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_OK);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_OK)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_OK)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_OK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_ERR_NOT_IMPLEMENTED:
        // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
        Serial.write(LW232_RET_ASCII_ERROR);
        //Serial.write(LW232_RET_ASCII_OK); 
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_ERR_NOT_IMPLEMENTED
|——————Node:: Text: :
|——————Node:comment Text: // Choose behavior: will it fail or not when not implemented command comes in. Some can monitors might be affected by this selection.
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_ERROR);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_ERROR)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_ERROR)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_ERROR
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: //Serial.write(LW232_RET_ASCII_OK); 
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
        Serial.write(LW232_RET_ASCII_ERROR);
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: Serial.write(LW232_RET_ASCII_ERROR);
|———————Node:call_expression Text: Serial.write(LW232_RET_ASCII_ERROR)
|————————Node:field_expression Text: Serial.write
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: write
|————————Node:argument_list Text: (LW232_RET_ASCII_ERROR)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_RET_ASCII_ERROR
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::parseAndRunCommand() {
    INT8U ret = LW232_OK;
    INT8U idx = 0;
    INT8U err = 0;

    lw232LastErr = LW232_OK;

    switch (lw232Message[0]) {
        case LW232_CMD_SETUP:
        // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_SETUP_BTR:
        // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
        ret = LW232_ERR; break;
        case LW232_CMD_OPEN:
        // O[CR] Open the CAN channel in normal mode (sending & receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_LISTEN:
        // L[CR] Open the CAN channel in listen only mode (receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_CLOSE:
        // C[CR] Close the CAN channel.
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX11:
        // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX29:
        // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
        break;
    case LW232_CMD_RTR11:
        // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_RTR29:
        // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_ONE:
        // P[CR] Poll incomming FIFO for CAN frames (single poll)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_MANY:
        // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FLAGS:
        // F[CR] Read Status Flags.
        // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
        Serial.print(LW232_FLAG);
        if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
        HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
        break;
    case LW232_CMD_AUTOPOLL:
        // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FILTER:
        // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_CODE:
        // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_MASK:
        // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_UART:
        // Un[CR] Setup UART with a new baud rate where n is 0-6.
        idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
        Serial.begin(lw232SerialBaudRates[idx]);
        break;
    case LW232_CMD_VERSION1:
    case LW232_CMD_VERSION2:
        // V[CR] Get Version number of both CAN232 hardware and software
        Serial.print(LW232_LAWICEL_VERSION_STR);
        break;
    case LW232_CMD_SERIAL:
        // N[CR] Get Serial number of the CAN232.
        Serial.print(LW232_LAWICEL_SERIAL_NUM);
        break;
    case LW232_CMD_TIMESTAMP:
        // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_AUTOSTART:
        // Qn[CR] Auto Startup feature (from power on).
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
        break;
    default:
        ret = LW232_ERR_UNKNOWN_CMD;
    }

    return ret;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::parseAndRunCommand()
|———Node:qualified_identifier Text: Can232::parseAndRunCommand
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: parseAndRunCommand
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret = LW232_OK;
    INT8U idx = 0;
    INT8U err = 0;

    lw232LastErr = LW232_OK;

    switch (lw232Message[0]) {
        case LW232_CMD_SETUP:
        // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_SETUP_BTR:
        // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
        ret = LW232_ERR; break;
        case LW232_CMD_OPEN:
        // O[CR] Open the CAN channel in normal mode (sending & receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_LISTEN:
        // L[CR] Open the CAN channel in listen only mode (receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_CLOSE:
        // C[CR] Close the CAN channel.
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX11:
        // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX29:
        // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
        break;
    case LW232_CMD_RTR11:
        // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_RTR29:
        // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_ONE:
        // P[CR] Poll incomming FIFO for CAN frames (single poll)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_MANY:
        // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FLAGS:
        // F[CR] Read Status Flags.
        // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
        Serial.print(LW232_FLAG);
        if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
        HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
        break;
    case LW232_CMD_AUTOPOLL:
        // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FILTER:
        // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_CODE:
        // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_MASK:
        // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_UART:
        // Un[CR] Setup UART with a new baud rate where n is 0-6.
        idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
        Serial.begin(lw232SerialBaudRates[idx]);
        break;
    case LW232_CMD_VERSION1:
    case LW232_CMD_VERSION2:
        // V[CR] Get Version number of both CAN232 hardware and software
        Serial.print(LW232_LAWICEL_VERSION_STR);
        break;
    case LW232_CMD_SERIAL:
        // N[CR] Get Serial number of the CAN232.
        Serial.print(LW232_LAWICEL_SERIAL_NUM);
        break;
    case LW232_CMD_TIMESTAMP:
        // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_AUTOSTART:
        // Qn[CR] Auto Startup feature (from power on).
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
        break;
    default:
        ret = LW232_ERR_UNKNOWN_CMD;
    }

    return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret = LW232_OK;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ret = LW232_OK
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:identifier Text: LW232_OK
|————Node:; Text: ;
|———Node:declaration Text: INT8U idx = 0;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: idx = 0
|—————Node:identifier Text: idx
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: INT8U err = 0;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: err = 0
|—————Node:identifier Text: err
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: lw232LastErr = LW232_OK;
|————Node:assignment_expression Text: lw232LastErr = LW232_OK
|—————Node:identifier Text: lw232LastErr
|—————Node:= Text: =
|—————Node:identifier Text: LW232_OK
|————Node:; Text: ;
|———Node:switch_statement Text: switch (lw232Message[0]) {
        case LW232_CMD_SETUP:
        // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_SETUP_BTR:
        // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
        ret = LW232_ERR; break;
        case LW232_CMD_OPEN:
        // O[CR] Open the CAN channel in normal mode (sending & receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_LISTEN:
        // L[CR] Open the CAN channel in listen only mode (receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_CLOSE:
        // C[CR] Close the CAN channel.
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX11:
        // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX29:
        // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
        break;
    case LW232_CMD_RTR11:
        // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_RTR29:
        // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_ONE:
        // P[CR] Poll incomming FIFO for CAN frames (single poll)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_MANY:
        // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FLAGS:
        // F[CR] Read Status Flags.
        // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
        Serial.print(LW232_FLAG);
        if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
        HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
        break;
    case LW232_CMD_AUTOPOLL:
        // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FILTER:
        // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_CODE:
        // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_MASK:
        // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_UART:
        // Un[CR] Setup UART with a new baud rate where n is 0-6.
        idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
        Serial.begin(lw232SerialBaudRates[idx]);
        break;
    case LW232_CMD_VERSION1:
    case LW232_CMD_VERSION2:
        // V[CR] Get Version number of both CAN232 hardware and software
        Serial.print(LW232_LAWICEL_VERSION_STR);
        break;
    case LW232_CMD_SERIAL:
        // N[CR] Get Serial number of the CAN232.
        Serial.print(LW232_LAWICEL_SERIAL_NUM);
        break;
    case LW232_CMD_TIMESTAMP:
        // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_AUTOSTART:
        // Qn[CR] Auto Startup feature (from power on).
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
        break;
    default:
        ret = LW232_ERR_UNKNOWN_CMD;
    }
|————Node:switch Text: switch
|————Node:condition_clause Text: (lw232Message[0])
|—————Node:( Text: (
|—————Node:subscript_expression Text: lw232Message[0]
|——————Node:identifier Text: lw232Message
|——————Node:subscript_argument_list Text: [0]
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case LW232_CMD_SETUP:
        // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_SETUP_BTR:
        // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
        ret = LW232_ERR; break;
        case LW232_CMD_OPEN:
        // O[CR] Open the CAN channel in normal mode (sending & receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_LISTEN:
        // L[CR] Open the CAN channel in listen only mode (receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
        case LW232_CMD_CLOSE:
        // C[CR] Close the CAN channel.
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX11:
        // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_TX29:
        // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
        break;
    case LW232_CMD_RTR11:
        // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_RTR29:
        // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_ONE:
        // P[CR] Poll incomming FIFO for CAN frames (single poll)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_POLL_MANY:
        // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FLAGS:
        // F[CR] Read Status Flags.
        // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
        Serial.print(LW232_FLAG);
        if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
        HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
        break;
    case LW232_CMD_AUTOPOLL:
        // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_FILTER:
        // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_CODE:
        // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_ACC_MASK:
        // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
    case LW232_CMD_UART:
        // Un[CR] Setup UART with a new baud rate where n is 0-6.
        idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
        Serial.begin(lw232SerialBaudRates[idx]);
        break;
    case LW232_CMD_VERSION1:
    case LW232_CMD_VERSION2:
        // V[CR] Get Version number of both CAN232 hardware and software
        Serial.print(LW232_LAWICEL_VERSION_STR);
        break;
    case LW232_CMD_SERIAL:
        // N[CR] Get Serial number of the CAN232.
        Serial.print(LW232_LAWICEL_SERIAL_NUM);
        break;
    case LW232_CMD_TIMESTAMP:
        // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
    case LW232_CMD_AUTOSTART:
        // Qn[CR] Auto Startup feature (from power on).
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
        break;
    default:
        ret = LW232_ERR_UNKNOWN_CMD;
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case LW232_CMD_SETUP:
        // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_SETUP
|——————Node:: Text: :
|——————Node:comment Text: // Sn[CR] Setup with standard CAN bit-rates where n is 0-9.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
			      lw232CanSpeedSelection = lw232CanBaudRates[idx];
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM);
|—————————Node:assignment_expression Text: idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM)
|——————————Node:identifier Text: idx
|——————————Node:= Text: =
|——————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_CAN_BAUD_NUM)
|———————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: parseNibbleWithLimit
|———————————Node:argument_list Text: (lw232Message[1], LW232_CAN_BAUD_NUM)
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: lw232Message[1]
|—————————————Node:identifier Text: lw232Message
|—————————————Node:subscript_argument_list Text: [1]
|——————————————Node:[ Text: [
|——————————————Node:number_literal Text: 1
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:identifier Text: LW232_CAN_BAUD_NUM
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: lw232CanSpeedSelection = lw232CanBaudRates[idx];
|—————————Node:assignment_expression Text: lw232CanSpeedSelection = lw232CanBaudRates[idx]
|——————————Node:identifier Text: lw232CanSpeedSelection
|——————————Node:= Text: =
|——————————Node:subscript_expression Text: lw232CanBaudRates[idx]
|———————————Node:identifier Text: lw232CanBaudRates
|———————————Node:subscript_argument_list Text: [idx]
|————————————Node:[ Text: [
|————————————Node:identifier Text: idx
|————————————Node:] Text: ]
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_SETUP_BTR:
        // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
        ret = LW232_ERR; break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_SETUP_BTR
|——————Node:: Text: :
|——————Node:comment Text: // sxxyy[CR] Setup with BTR0/BTR1 CAN bit-rates where xx and yy is a hex value.
|——————Node:expression_statement Text: ret = LW232_ERR;
|———————Node:assignment_expression Text: ret = LW232_ERR
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_OPEN:
        // O[CR] Open the CAN channel in normal mode (sending & receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_OPEN
|——————Node:: Text: :
|——————Node:comment Text: // O[CR] Open the CAN channel in normal mode (sending & receiving).
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: ret = openCanBus();
|—————————Node:assignment_expression Text: ret = openCanBus()
|——————————Node:identifier Text: ret
|——————————Node:= Text: =
|——————————Node:call_expression Text: openCanBus()
|———————————Node:identifier Text: openCanBus
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (ret == LW232_OK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ret == LW232_OK
|———————————Node:identifier Text: ret
|———————————Node:== Text: ==
|———————————Node:identifier Text: LW232_OK
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL;
|———————————Node:assignment_expression Text: lw232CanChannelMode = LW232_STATUS_CAN_OPEN_NORMAL
|————————————Node:identifier Text: lw232CanChannelMode
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_STATUS_CAN_OPEN_NORMAL
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_LISTEN:
        // L[CR] Open the CAN channel in listen only mode (receiving).
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_LISTEN
|——————Node:: Text: :
|——————Node:comment Text: // L[CR] Open the CAN channel in listen only mode (receiving).
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            ret = openCanBus();
            if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: ret = openCanBus();
|—————————Node:assignment_expression Text: ret = openCanBus()
|——————————Node:identifier Text: ret
|——————————Node:= Text: =
|——————————Node:call_expression Text: openCanBus()
|———————————Node:identifier Text: openCanBus
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (ret == LW232_OK) {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (ret == LW232_OK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ret == LW232_OK
|———————————Node:identifier Text: ret
|———————————Node:== Text: ==
|———————————Node:identifier Text: LW232_OK
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
              lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN;
|———————————Node:assignment_expression Text: lw232CanChannelMode = LW232_STATUS_CAN_OPEN_LISTEN
|————————————Node:identifier Text: lw232CanChannelMode
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_STATUS_CAN_OPEN_LISTEN
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_CLOSE:
        // C[CR] Close the CAN channel.
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_CLOSE
|——————Node:: Text: :
|——————Node:comment Text: // C[CR] Close the CAN channel.
|——————Node:if_statement Text: if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:!= Text: !=
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: lw232CanChannelMode = LW232_STATUS_CAN_CLOSED;
|—————————Node:assignment_expression Text: lw232CanChannelMode = LW232_STATUS_CAN_CLOSED
|——————————Node:identifier Text: lw232CanChannelMode
|——————————Node:= Text: =
|——————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_TX11:
        // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_TX11
|——————Node:: Text: :
|——————Node:comment Text: // tiiildd...[CR] Transmit a standard (11bit) CAN frame.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_OPEN_NORMAL
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
            INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
            if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            } 
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: parseCanStdId();
|—————————Node:call_expression Text: parseCanStdId()
|——————————Node:identifier Text: parseCanStdId
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
|—————————Node:assignment_expression Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|——————————Node:identifier Text: lw232PacketLen
|——————————Node:= Text: =
|——————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|———————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: parseNibbleWithLimit
|———————————Node:argument_list Text: (lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_STD_PKT_LEN]
|—————————————Node:identifier Text: lw232Message
|—————————————Node:subscript_argument_list Text: [LW232_OFFSET_STD_PKT_LEN]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: LW232_OFFSET_STD_PKT_LEN
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: LW232_FRAME_MAX_LENGTH + 1
|—————————————Node:identifier Text: LW232_FRAME_MAX_LENGTH
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:for_statement Text: for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
|—————————Node:for Text: for
|—————————Node:( Text: (
|—————————Node:; Text: ;
|—————————Node:binary_expression Text: idx < lw232PacketLen
|——————————Node:identifier Text: idx
|——————————Node:< Text: <
|——————————Node:identifier Text: lw232PacketLen
|—————————Node:; Text: ;
|—————————Node:update_expression Text: idx++
|——————————Node:identifier Text: idx
|——————————Node:++ Text: ++
|—————————Node:) Text: )
|—————————Node:compound_statement Text: {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]);
|———————————Node:assignment_expression Text: lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1])
|————————————Node:subscript_expression Text: lw232Buffer[idx]
|—————————————Node:identifier Text: lw232Buffer
|—————————————Node:subscript_argument_list Text: [idx]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: idx
|——————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:call_expression Text: HexHelper::parseFullByte(lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1])
|—————————————Node:qualified_identifier Text: HexHelper::parseFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: parseFullByte
|—————————————Node:argument_list Text: (lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1])
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2]
|———————————————Node:identifier Text: lw232Message
|———————————————Node:subscript_argument_list Text: [LW232_OFFSET_STD_PKT_DATA + idx * 2]
|————————————————Node:[ Text: [
|————————————————Node:binary_expression Text: LW232_OFFSET_STD_PKT_DATA + idx * 2
|—————————————————Node:identifier Text: LW232_OFFSET_STD_PKT_DATA
|—————————————————Node:+ Text: +
|—————————————————Node:binary_expression Text: idx * 2
|——————————————————Node:identifier Text: idx
|——————————————————Node:* Text: *
|——————————————————Node:number_literal Text: 2
|————————————————Node:] Text: ]
|——————————————Node:, Text: ,
|——————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]
|———————————————Node:identifier Text: lw232Message
|———————————————Node:subscript_argument_list Text: [LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1]
|————————————————Node:[ Text: [
|————————————————Node:binary_expression Text: LW232_OFFSET_STD_PKT_DATA + idx * 2 + 1
|—————————————————Node:binary_expression Text: LW232_OFFSET_STD_PKT_DATA + idx * 2
|——————————————————Node:identifier Text: LW232_OFFSET_STD_PKT_DATA
|——————————————————Node:+ Text: +
|——————————————————Node:binary_expression Text: idx * 2
|———————————————————Node:identifier Text: idx
|———————————————————Node:* Text: *
|———————————————————Node:number_literal Text: 2
|—————————————————Node:+ Text: +
|—————————————————Node:number_literal Text: 1
|————————————————Node:] Text: ]
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:declaration Text: INT8U mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer);
|—————————Node:type_identifier Text: INT8U
|—————————Node:init_declarator Text: mcpErr = sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer)
|——————————Node:identifier Text: mcpErr
|——————————Node:= Text: =
|——————————Node:call_expression Text: sendMsgBuf(lw232CanId, 0, 0, lw232PacketLen, lw232Buffer)
|———————————Node:identifier Text: sendMsgBuf
|———————————Node:argument_list Text: (lw232CanId, 0, 0, lw232PacketLen, lw232Buffer)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232CanId
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:, Text: ,
|————————————Node:identifier Text: lw232PacketLen
|————————————Node:, Text: ,
|————————————Node:identifier Text: lw232Buffer
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (mcpErr != CAN_OK) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (mcpErr != CAN_OK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: mcpErr != CAN_OK
|———————————Node:identifier Text: mcpErr
|———————————Node:!= Text: !=
|———————————Node:identifier Text: CAN_OK
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = LW232_ERR;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = LW232_ERR;
|———————————Node:assignment_expression Text: ret = LW232_ERR
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_ERR
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232AutoPoll)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232AutoPoll
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                ret = LW232_OK_SMALL;
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: ret = LW232_OK_SMALL;
|—————————————Node:assignment_expression Text: ret = LW232_OK_SMALL
|——————————————Node:identifier Text: ret
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_OK_SMALL
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_TX29:
        // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_TX29
|——————Node:: Text: :
|——————Node:comment Text: // Tiiiiiiiildd...[CR] Transmit an extended (29bit) CAN frame
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_OPEN_NORMAL
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: parseCanExtId();
|—————————Node:call_expression Text: parseCanExtId()
|——————————Node:identifier Text: parseCanExtId
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
|—————————Node:assignment_expression Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|——————————Node:identifier Text: lw232PacketLen
|——————————Node:= Text: =
|——————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|———————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: parseNibbleWithLimit
|———————————Node:argument_list Text: (lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_EXT_PKT_LEN]
|—————————————Node:identifier Text: lw232Message
|—————————————Node:subscript_argument_list Text: [LW232_OFFSET_EXT_PKT_LEN]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: LW232_OFFSET_EXT_PKT_LEN
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: LW232_FRAME_MAX_LENGTH + 1
|—————————————Node:identifier Text: LW232_FRAME_MAX_LENGTH
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:for_statement Text: for (; idx < lw232PacketLen; idx++) {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
|—————————Node:for Text: for
|—————————Node:( Text: (
|—————————Node:; Text: ;
|—————————Node:binary_expression Text: idx < lw232PacketLen
|——————————Node:identifier Text: idx
|——————————Node:< Text: <
|——————————Node:identifier Text: lw232PacketLen
|—————————Node:; Text: ;
|—————————Node:update_expression Text: idx++
|——————————Node:identifier Text: idx
|——————————Node:++ Text: ++
|—————————Node:) Text: )
|—————————Node:compound_statement Text: {
                lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]);
|———————————Node:assignment_expression Text: lw232Buffer[idx] = HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1])
|————————————Node:subscript_expression Text: lw232Buffer[idx]
|—————————————Node:identifier Text: lw232Buffer
|—————————————Node:subscript_argument_list Text: [idx]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: idx
|——————————————Node:] Text: ]
|————————————Node:= Text: =
|————————————Node:call_expression Text: HexHelper::parseFullByte(lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1])
|—————————————Node:qualified_identifier Text: HexHelper::parseFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: parseFullByte
|—————————————Node:argument_list Text: (lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2], lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1])
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2]
|———————————————Node:identifier Text: lw232Message
|———————————————Node:subscript_argument_list Text: [LW232_OFFSET_EXT_PKT_DATA + idx * 2]
|————————————————Node:[ Text: [
|————————————————Node:binary_expression Text: LW232_OFFSET_EXT_PKT_DATA + idx * 2
|—————————————————Node:identifier Text: LW232_OFFSET_EXT_PKT_DATA
|—————————————————Node:+ Text: +
|—————————————————Node:binary_expression Text: idx * 2
|——————————————————Node:identifier Text: idx
|——————————————————Node:* Text: *
|——————————————————Node:number_literal Text: 2
|————————————————Node:] Text: ]
|——————————————Node:, Text: ,
|——————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]
|———————————————Node:identifier Text: lw232Message
|———————————————Node:subscript_argument_list Text: [LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1]
|————————————————Node:[ Text: [
|————————————————Node:binary_expression Text: LW232_OFFSET_EXT_PKT_DATA + idx * 2 + 1
|—————————————————Node:binary_expression Text: LW232_OFFSET_EXT_PKT_DATA + idx * 2
|——————————————————Node:identifier Text: LW232_OFFSET_EXT_PKT_DATA
|——————————————————Node:+ Text: +
|——————————————————Node:binary_expression Text: idx * 2
|———————————————————Node:identifier Text: idx
|———————————————————Node:* Text: *
|———————————————————Node:number_literal Text: 2
|—————————————————Node:+ Text: +
|—————————————————Node:number_literal Text: 1
|————————————————Node:] Text: ]
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:if_statement Text: if (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            } else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: CAN_OK != sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)
|———————————Node:identifier Text: CAN_OK
|———————————Node:!= Text: !=
|———————————Node:call_expression Text: sendMsgBuf(lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)
|————————————Node:identifier Text: sendMsgBuf
|————————————Node:argument_list Text: (lw232CanId, 1, 0, lw232PacketLen, lw232Buffer)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: lw232CanId
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 1
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 0
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232PacketLen
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232Buffer
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = LW232_ERR;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = LW232_ERR;
|———————————Node:assignment_expression Text: ret = LW232_ERR
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_ERR
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232AutoPoll) {
                ret = LW232_OK_BIG;
            } else {
              ret = LW232_OK;
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232AutoPoll)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232AutoPoll
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                ret = LW232_OK_BIG;
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: ret = LW232_OK_BIG;
|—————————————Node:assignment_expression Text: ret = LW232_OK_BIG
|——————————————Node:identifier Text: ret
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_OK_BIG
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
              ret = LW232_OK;
            }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
              ret = LW232_OK;
            }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: ret = LW232_OK;
|——————————————Node:assignment_expression Text: ret = LW232_OK
|———————————————Node:identifier Text: ret
|———————————————Node:= Text: =
|———————————————Node:identifier Text: LW232_OK
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_RTR11:
        // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_RTR11
|——————Node:: Text: :
|——————Node:comment Text: // riiil[CR] Transmit an standard RTR (11bit) CAN frame.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_OPEN_NORMAL
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            parseCanStdId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: parseCanStdId();
|—————————Node:call_expression Text: parseCanStdId()
|——————————Node:identifier Text: parseCanStdId
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
|—————————Node:assignment_expression Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|——————————Node:identifier Text: lw232PacketLen
|——————————Node:= Text: =
|——————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|———————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: parseNibbleWithLimit
|———————————Node:argument_list Text: (lw232Message[LW232_OFFSET_STD_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_STD_PKT_LEN]
|—————————————Node:identifier Text: lw232Message
|—————————————Node:subscript_argument_list Text: [LW232_OFFSET_STD_PKT_LEN]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: LW232_OFFSET_STD_PKT_LEN
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: LW232_FRAME_MAX_LENGTH + 1
|—————————————Node:identifier Text: LW232_FRAME_MAX_LENGTH
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: CAN_OK != sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)
|———————————Node:identifier Text: CAN_OK
|———————————Node:!= Text: !=
|———————————Node:call_expression Text: sendMsgBuf(lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)
|————————————Node:identifier Text: sendMsgBuf
|————————————Node:argument_list Text: (lw232CanId, 0, 1, lw232PacketLen, lw232Buffer)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: lw232CanId
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 0
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 1
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232PacketLen
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232Buffer
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = LW232_ERR;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = LW232_ERR;
|———————————Node:assignment_expression Text: ret = LW232_ERR
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_ERR
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232AutoPoll) {
                ret = LW232_OK_SMALL;
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232AutoPoll)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232AutoPoll
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                ret = LW232_OK_SMALL;
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: ret = LW232_OK_SMALL;
|—————————————Node:assignment_expression Text: ret = LW232_OK_SMALL
|——————————————Node:identifier Text: ret
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_OK_SMALL
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_RTR29:
        // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
        if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_RTR29
|——————Node:: Text: :
|——————Node:comment Text: // Riiiiiiiil[CR] Transmit an extended RTR (29bit) CAN frame.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL) {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        } else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_OPEN_NORMAL
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_OPEN_NORMAL
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            parseCanExtId();
            lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
            if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: parseCanExtId();
|—————————Node:call_expression Text: parseCanExtId()
|——————————Node:identifier Text: parseCanExtId
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1);
|—————————Node:assignment_expression Text: lw232PacketLen = HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|——————————Node:identifier Text: lw232PacketLen
|——————————Node:= Text: =
|——————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|———————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: parseNibbleWithLimit
|———————————Node:argument_list Text: (lw232Message[LW232_OFFSET_EXT_PKT_LEN], LW232_FRAME_MAX_LENGTH + 1)
|————————————Node:( Text: (
|————————————Node:subscript_expression Text: lw232Message[LW232_OFFSET_EXT_PKT_LEN]
|—————————————Node:identifier Text: lw232Message
|—————————————Node:subscript_argument_list Text: [LW232_OFFSET_EXT_PKT_LEN]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: LW232_OFFSET_EXT_PKT_LEN
|——————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: LW232_FRAME_MAX_LENGTH + 1
|—————————————Node:identifier Text: LW232_FRAME_MAX_LENGTH
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)) {
                ret = LW232_ERR;
            }
            else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: CAN_OK != sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)
|———————————Node:identifier Text: CAN_OK
|———————————Node:!= Text: !=
|———————————Node:call_expression Text: sendMsgBuf(lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)
|————————————Node:identifier Text: sendMsgBuf
|————————————Node:argument_list Text: (lw232CanId, 1, 1, lw232PacketLen, lw232Buffer)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: lw232CanId
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 1
|—————————————Node:, Text: ,
|—————————————Node:number_literal Text: 1
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232PacketLen
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: lw232Buffer
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = LW232_ERR;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = LW232_ERR;
|———————————Node:assignment_expression Text: ret = LW232_ERR
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_ERR
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232AutoPoll) {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232AutoPoll)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232AutoPoll
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                ret = LW232_OK_SMALL; // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: ret = LW232_OK_SMALL;
|—————————————Node:assignment_expression Text: ret = LW232_OK_SMALL
|——————————————Node:identifier Text: ret
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_OK_SMALL
|—————————————Node:; Text: ;
|————————————Node:comment Text: // not a typo. strangely can232_v3.pdf tells to return "z[CR]", not "Z[CR]" as in 29bit. todo: check if it is error in pdf???
|————————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_POLL_ONE:
        // P[CR] Poll incomming FIFO for CAN frames (single poll)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_POLL_ONE
|——————Node:: Text: :
|——————Node:comment Text: // P[CR] Poll incomming FIFO for CAN frames (single poll)
|——————Node:if_statement Text: if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        } else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF
|—————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED
|——————————Node:identifier Text: lw232CanChannelMode
|——————————Node:!= Text: !=
|——————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: lw232AutoPoll == LW232_AUTOPOLL_OFF
|——————————Node:identifier Text: lw232AutoPoll
|——————————Node:== Text: ==
|——————————Node:identifier Text: LW232_AUTOPOLL_OFF
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
        }
|————————Node:{ Text: {
|————————Node:if_statement Text: if (CAN_MSGAVAIL == checkReceive()) {
                ret = receiveSingleFrame();
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (CAN_MSGAVAIL == checkReceive())
|——————————Node:( Text: (
|——————————Node:binary_expression Text: CAN_MSGAVAIL == checkReceive()
|———————————Node:identifier Text: CAN_MSGAVAIL
|———————————Node:== Text: ==
|———————————Node:call_expression Text: checkReceive()
|————————————Node:identifier Text: checkReceive
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = receiveSingleFrame();
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = receiveSingleFrame();
|———————————Node:assignment_expression Text: ret = receiveSingleFrame()
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:call_expression Text: receiveSingleFrame()
|—————————————Node:identifier Text: receiveSingleFrame
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_POLL_MANY:
        // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_POLL_MANY
|——————Node:: Text: :
|——————Node:comment Text: // A[CR] Polls incomming FIFO for CAN frames (all pending frames)
|——————Node:if_statement Text: if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF) {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        } else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED && lw232AutoPoll == LW232_AUTOPOLL_OFF
|—————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED
|——————————Node:identifier Text: lw232CanChannelMode
|——————————Node:!= Text: !=
|——————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: lw232AutoPoll == LW232_AUTOPOLL_OFF
|——————————Node:identifier Text: lw232AutoPoll
|——————————Node:== Text: ==
|——————————Node:identifier Text: LW232_AUTOPOLL_OFF
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
            if (ret == CAN_OK)
                Serial.print(LW232_ALL);
        }
|————————Node:{ Text: {
|————————Node:while_statement Text: while (CAN_MSGAVAIL == checkReceive()) {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
|—————————Node:while Text: while
|—————————Node:condition_clause Text: (CAN_MSGAVAIL == checkReceive())
|——————————Node:( Text: (
|——————————Node:binary_expression Text: CAN_MSGAVAIL == checkReceive()
|———————————Node:identifier Text: CAN_MSGAVAIL
|———————————Node:== Text: ==
|———————————Node:call_expression Text: checkReceive()
|————————————Node:identifier Text: checkReceive
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                ret = ret ^ receiveSingleFrame();
                if (ret != CAN_OK)
                    break;
                Serial.write(LW232_CR);
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: ret = ret ^ receiveSingleFrame();
|———————————Node:assignment_expression Text: ret = ret ^ receiveSingleFrame()
|————————————Node:identifier Text: ret
|————————————Node:= Text: =
|————————————Node:binary_expression Text: ret ^ receiveSingleFrame()
|—————————————Node:identifier Text: ret
|—————————————Node:^ Text: ^
|—————————————Node:call_expression Text: receiveSingleFrame()
|——————————————Node:identifier Text: receiveSingleFrame
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:if_statement Text: if (ret != CAN_OK)
                    break;
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (ret != CAN_OK)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ret != CAN_OK
|—————————————Node:identifier Text: ret
|—————————————Node:!= Text: !=
|—————————————Node:identifier Text: CAN_OK
|————————————Node:) Text: )
|———————————Node:break_statement Text: break;
|————————————Node:break Text: break
|————————————Node:; Text: ;
|——————————Node:expression_statement Text: Serial.write(LW232_CR);
|———————————Node:call_expression Text: Serial.write(LW232_CR)
|————————————Node:field_expression Text: Serial.write
|—————————————Node:identifier Text: Serial
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: write
|————————————Node:argument_list Text: (LW232_CR)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: LW232_CR
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:if_statement Text: if (ret == CAN_OK)
                Serial.print(LW232_ALL);
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (ret == CAN_OK)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ret == CAN_OK
|———————————Node:identifier Text: ret
|———————————Node:== Text: ==
|———————————Node:identifier Text: CAN_OK
|——————————Node:) Text: )
|—————————Node:expression_statement Text: Serial.print(LW232_ALL);
|——————————Node:call_expression Text: Serial.print(LW232_ALL)
|———————————Node:field_expression Text: Serial.print
|————————————Node:identifier Text: Serial
|————————————Node:. Text: .
|————————————Node:field_identifier Text: print
|———————————Node:argument_list Text: (LW232_ALL)
|————————————Node:( Text: (
|————————————Node:identifier Text: LW232_ALL
|————————————Node:) Text: )
|——————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_FLAGS:
        // F[CR] Read Status Flags.
        // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
        Serial.print(LW232_FLAG);
        if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
        HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_FLAGS
|——————Node:: Text: :
|——————Node:comment Text: // F[CR] Read Status Flags.
|——————Node:comment Text: // LAWICEL CAN232 and CANUSB have some specific errors which differ from MCP2515/MCP2551 errors. We just return MCP2515 error.
|——————Node:expression_statement Text: Serial.print(LW232_FLAG);
|———————Node:call_expression Text: Serial.print(LW232_FLAG)
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: (LW232_FLAG)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_FLAG
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (lw232CAN.checkError(&err) == CAN_OK) 
            err = 0;
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CAN.checkError(&err) == CAN_OK)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CAN.checkError(&err) == CAN_OK
|—————————Node:call_expression Text: lw232CAN.checkError(&err)
|——————————Node:field_expression Text: lw232CAN.checkError
|———————————Node:identifier Text: lw232CAN
|———————————Node:. Text: .
|———————————Node:field_identifier Text: checkError
|——————————Node:argument_list Text: (&err)
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &err
|————————————Node:& Text: &
|————————————Node:identifier Text: err
|———————————Node:) Text: )
|—————————Node:== Text: ==
|—————————Node:identifier Text: CAN_OK
|————————Node:) Text: )
|———————Node:expression_statement Text: err = 0;
|————————Node:assignment_expression Text: err = 0
|—————————Node:identifier Text: err
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|——————Node:expression_statement Text: HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK);
|———————Node:call_expression Text: HexHelper::printFullByte(err & MCP_EFLG_ERRORMASK)
|————————Node:qualified_identifier Text: HexHelper::printFullByte
|—————————Node:namespace_identifier Text: HexHelper
|—————————Node::: Text: ::
|—————————Node:identifier Text: printFullByte
|————————Node:argument_list Text: (err & MCP_EFLG_ERRORMASK)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: err & MCP_EFLG_ERRORMASK
|——————————Node:identifier Text: err
|——————————Node:& Text: &
|——————————Node:identifier Text: MCP_EFLG_ERRORMASK
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_AUTOPOLL:
        // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_AUTOPOLL
|——————Node:: Text: :
|——————Node:comment Text: // Xn[CR] Sets Auto Poll/Send ON/OFF for received frames.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        } else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
            //todo: save to eeprom
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF;
|—————————Node:assignment_expression Text: lw232AutoPoll = (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF
|——————————Node:identifier Text: lw232AutoPoll
|——————————Node:= Text: =
|——————————Node:conditional_expression Text: (lw232Message[1] == LW232_ON_ONE) ? LW232_AUTOPOLL_ON : LW232_AUTOPOLL_OFF
|———————————Node:parenthesized_expression Text: (lw232Message[1] == LW232_ON_ONE)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: lw232Message[1] == LW232_ON_ONE
|—————————————Node:subscript_expression Text: lw232Message[1]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [1]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|—————————————Node:== Text: ==
|—————————————Node:identifier Text: LW232_ON_ONE
|————————————Node:) Text: )
|———————————Node:? Text: ?
|———————————Node:identifier Text: LW232_AUTOPOLL_ON
|———————————Node:: Text: :
|———————————Node:identifier Text: LW232_AUTOPOLL_OFF
|—————————Node:; Text: ;
|————————Node:comment Text: //todo: save to eeprom
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_FILTER:
        // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_FILTER
|——————Node:: Text: :
|——————Node:comment Text: // Wn[CR] Filter mode setting. By default CAN232 works in dual filter mode (0) and is backwards compatible with previous CAN232 versions.
|——————Node:expression_statement Text: ret = LW232_ERR_NOT_IMPLEMENTED;
|———————Node:assignment_expression Text: ret = LW232_ERR_NOT_IMPLEMENTED
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR_NOT_IMPLEMENTED
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_ACC_CODE:
        // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_ACC_CODE
|——————Node:: Text: :
|——————Node:comment Text: // Mxxxxxxxx[CR] Sets Acceptance Code Register (ACn Register of SJA1000). // we use MCP2515,
|——————Node:expression_statement Text: ret = LW232_ERR_NOT_IMPLEMENTED;
|———————Node:assignment_expression Text: ret = LW232_ERR_NOT_IMPLEMENTED
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR_NOT_IMPLEMENTED
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_ACC_MASK:
        // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
        ret = LW232_ERR_NOT_IMPLEMENTED; break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_ACC_MASK
|——————Node:: Text: :
|——————Node:comment Text: // mxxxxxxxx[CR] Sets Acceptance Mask Register (AMn Register of SJA1000).
|——————Node:expression_statement Text: ret = LW232_ERR_NOT_IMPLEMENTED;
|———————Node:assignment_expression Text: ret = LW232_ERR_NOT_IMPLEMENTED
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR_NOT_IMPLEMENTED
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_UART:
        // Un[CR] Setup UART with a new baud rate where n is 0-6.
        idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
        Serial.begin(lw232SerialBaudRates[idx]);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_UART
|——————Node:: Text: :
|——————Node:comment Text: // Un[CR] Setup UART with a new baud rate where n is 0-6.
|——————Node:expression_statement Text: idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM);
|———————Node:assignment_expression Text: idx = HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM)
|————————Node:identifier Text: idx
|————————Node:= Text: =
|————————Node:call_expression Text: HexHelper::parseNibbleWithLimit(lw232Message[1], LW232_UART_BAUD_NUM)
|—————————Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|——————————Node:namespace_identifier Text: HexHelper
|——————————Node::: Text: ::
|——————————Node:identifier Text: parseNibbleWithLimit
|—————————Node:argument_list Text: (lw232Message[1], LW232_UART_BAUD_NUM)
|——————————Node:( Text: (
|——————————Node:subscript_expression Text: lw232Message[1]
|———————————Node:identifier Text: lw232Message
|———————————Node:subscript_argument_list Text: [1]
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 1
|————————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:identifier Text: LW232_UART_BAUD_NUM
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: Serial.begin(lw232SerialBaudRates[idx]);
|———————Node:call_expression Text: Serial.begin(lw232SerialBaudRates[idx])
|————————Node:field_expression Text: Serial.begin
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: begin
|————————Node:argument_list Text: (lw232SerialBaudRates[idx])
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: lw232SerialBaudRates[idx]
|——————————Node:identifier Text: lw232SerialBaudRates
|——————————Node:subscript_argument_list Text: [idx]
|———————————Node:[ Text: [
|———————————Node:identifier Text: idx
|———————————Node:] Text: ]
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_VERSION1:
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_VERSION1
|——————Node:: Text: :
|—————Node:case_statement Text: case LW232_CMD_VERSION2:
        // V[CR] Get Version number of both CAN232 hardware and software
        Serial.print(LW232_LAWICEL_VERSION_STR);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_VERSION2
|——————Node:: Text: :
|——————Node:comment Text: // V[CR] Get Version number of both CAN232 hardware and software
|——————Node:expression_statement Text: Serial.print(LW232_LAWICEL_VERSION_STR);
|———————Node:call_expression Text: Serial.print(LW232_LAWICEL_VERSION_STR)
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: (LW232_LAWICEL_VERSION_STR)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_LAWICEL_VERSION_STR
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_SERIAL:
        // N[CR] Get Serial number of the CAN232.
        Serial.print(LW232_LAWICEL_SERIAL_NUM);
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_SERIAL
|——————Node:: Text: :
|——————Node:comment Text: // N[CR] Get Serial number of the CAN232.
|——————Node:expression_statement Text: Serial.print(LW232_LAWICEL_SERIAL_NUM);
|———————Node:call_expression Text: Serial.print(LW232_LAWICEL_SERIAL_NUM)
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: (LW232_LAWICEL_SERIAL_NUM)
|—————————Node:( Text: (
|—————————Node:identifier Text: LW232_LAWICEL_SERIAL_NUM
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_TIMESTAMP:
        // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
        if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_TIMESTAMP
|——————Node:: Text: :
|——————Node:comment Text: // Zn[CR] Sets Time Stamp ON/OFF for received frames only. Z0 - OFF, Z1 - Lawicel's timestamp 2 bytes, Z2 - arduino timestamp 4 bytes.
|——————Node:if_statement Text: if (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED) {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode == LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode == LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:== Text: ==
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
        }
|————————Node:{ Text: {
|————————Node:comment Text: // lw232TimeStamp = (lw232Message[1] == LW232_ON_ONE); 
|————————Node:if_statement Text: if (lw232Message[1] == LW232_ON_ONE) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (lw232Message[1] == LW232_ON_ONE)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: lw232Message[1] == LW232_ON_ONE
|———————————Node:subscript_expression Text: lw232Message[1]
|————————————Node:identifier Text: lw232Message
|————————————Node:subscript_argument_list Text: [1]
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|———————————Node:== Text: ==
|———————————Node:identifier Text: LW232_ON_ONE
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL;
|———————————Node:assignment_expression Text: lw232TimeStamp = LW232_TIMESTAMP_ON_NORMAL
|————————————Node:identifier Text: lw232TimeStamp
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_TIMESTAMP_ON_NORMAL
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232Message[1] == LW232_ON_TWO) {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
            else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232Message[1] == LW232_ON_TWO)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: lw232Message[1] == LW232_ON_TWO
|—————————————Node:subscript_expression Text: lw232Message[1]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [1]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|—————————————Node:== Text: ==
|—————————————Node:identifier Text: LW232_ON_TWO
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED;
|—————————————Node:assignment_expression Text: lw232TimeStamp = LW232_TIMESTAMP_ON_EXTENDED
|——————————————Node:identifier Text: lw232TimeStamp
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_TIMESTAMP_ON_EXTENDED
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
                lw232TimeStamp = LW232_TIMESTAMP_OFF;
            }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: lw232TimeStamp = LW232_TIMESTAMP_OFF;
|——————————————Node:assignment_expression Text: lw232TimeStamp = LW232_TIMESTAMP_OFF
|———————————————Node:identifier Text: lw232TimeStamp
|———————————————Node:= Text: =
|———————————————Node:identifier Text: LW232_TIMESTAMP_OFF
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case LW232_CMD_AUTOSTART:
        // Qn[CR] Auto Startup feature (from power on).
        if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
        break;
|——————Node:case Text: case
|——————Node:identifier Text: LW232_CMD_AUTOSTART
|——————Node:: Text: :
|——————Node:comment Text: // Qn[CR] Auto Startup feature (from power on).
|——————Node:if_statement Text: if (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED) {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
        else {
            ret = LW232_ERR;
        }
|———————Node:if Text: if
|———————Node:condition_clause Text: (lw232CanChannelMode != LW232_STATUS_CAN_CLOSED)
|————————Node:( Text: (
|————————Node:binary_expression Text: lw232CanChannelMode != LW232_STATUS_CAN_CLOSED
|—————————Node:identifier Text: lw232CanChannelMode
|—————————Node:!= Text: !=
|—————————Node:identifier Text: LW232_STATUS_CAN_CLOSED
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
            //todo: save to eeprom
        }
|————————Node:{ Text: {
|————————Node:if_statement Text: if (lw232Message[1] == LW232_ON_ONE) {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
            else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (lw232Message[1] == LW232_ON_ONE)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: lw232Message[1] == LW232_ON_ONE
|———————————Node:subscript_expression Text: lw232Message[1]
|————————————Node:identifier Text: lw232Message
|————————————Node:subscript_argument_list Text: [1]
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|———————————Node:== Text: ==
|———————————Node:identifier Text: LW232_ON_ONE
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: lw232AutoStart = LW232_AUTOSTART_ON_NORMAL;
|———————————Node:assignment_expression Text: lw232AutoStart = LW232_AUTOSTART_ON_NORMAL
|————————————Node:identifier Text: lw232AutoStart
|————————————Node:= Text: =
|————————————Node:identifier Text: LW232_AUTOSTART_ON_NORMAL
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
|——————————Node:else Text: else
|——————————Node:if_statement Text: if (lw232Message[1] == LW232_ON_TWO) {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
            else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (lw232Message[1] == LW232_ON_TWO)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: lw232Message[1] == LW232_ON_TWO
|—————————————Node:subscript_expression Text: lw232Message[1]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [1]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|—————————————Node:== Text: ==
|—————————————Node:identifier Text: LW232_ON_TWO
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: lw232AutoStart = LW232_AUTOSTART_ON_LISTEN;
|—————————————Node:assignment_expression Text: lw232AutoStart = LW232_AUTOSTART_ON_LISTEN
|——————————————Node:identifier Text: lw232AutoStart
|——————————————Node:= Text: =
|——————————————Node:identifier Text: LW232_AUTOSTART_ON_LISTEN
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
                lw232AutoStart = LW232_AUTOSTART_OFF;
            }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: lw232AutoStart = LW232_AUTOSTART_OFF;
|——————————————Node:assignment_expression Text: lw232AutoStart = LW232_AUTOSTART_OFF
|———————————————Node:identifier Text: lw232AutoStart
|———————————————Node:= Text: =
|———————————————Node:identifier Text: LW232_AUTOSTART_OFF
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————Node:comment Text: //todo: save to eeprom
|————————Node:} Text: }
|———————Node:else_clause Text: else {
            ret = LW232_ERR;
        }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
            ret = LW232_ERR;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = LW232_ERR;
|——————————Node:assignment_expression Text: ret = LW232_ERR
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:identifier Text: LW232_ERR
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
        ret = LW232_ERR_UNKNOWN_CMD;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: ret = LW232_ERR_UNKNOWN_CMD;
|———————Node:assignment_expression Text: ret = LW232_ERR_UNKNOWN_CMD
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR_UNKNOWN_CMD
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::checkReceive() {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.checkReceive();
#else
    return CAN_MSGAVAIL;
#endif
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::checkReceive()
|———Node:qualified_identifier Text: Can232::checkReceive
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: checkReceive
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.checkReceive();
#else
    return CAN_MSGAVAIL;
#endif
}
|———Node:{ Text: {
|———Node:preproc_ifdef Text: #ifndef _MCP_FAKE_MODE_
    return lw232CAN.checkReceive();
#else
    return CAN_MSGAVAIL;
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: _MCP_FAKE_MODE_
|————Node:return_statement Text: return lw232CAN.checkReceive();
|—————Node:return Text: return
|—————Node:call_expression Text: lw232CAN.checkReceive()
|——————Node:field_expression Text: lw232CAN.checkReceive
|———————Node:identifier Text: lw232CAN
|———————Node:. Text: .
|———————Node:field_identifier Text: checkReceive
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    return CAN_MSGAVAIL;
|—————Node:#else Text: #else
|—————Node:return_statement Text: return CAN_MSGAVAIL;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_MSGAVAIL
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::readMsgBufID(INT32U *ID, INT8U *len, INT8U buf[]) {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.readMsgBufID(ID, len, buf);
#else
    *ID = random(0x100, 0x110);
    *len = 4;
    buf[0] = random(0x01, 0x10);
    buf[1] = random(0xa1, 0xf0);
    buf[2] = 0x00;
    buf[3] = 0x00;
    return CAN_OK;
#endif
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::readMsgBufID(INT32U *ID, INT8U *len, INT8U buf[])
|———Node:qualified_identifier Text: Can232::readMsgBufID
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: readMsgBufID
|———Node:parameter_list Text: (INT32U *ID, INT8U *len, INT8U buf[])
|————Node:( Text: (
|————Node:parameter_declaration Text: INT32U *ID
|—————Node:type_identifier Text: INT32U
|—————Node:pointer_declarator Text: *ID
|——————Node:* Text: *
|——————Node:identifier Text: ID
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U *len
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *len
|——————Node:* Text: *
|——————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U buf[]
|—————Node:type_identifier Text: INT8U
|—————Node:array_declarator Text: buf[]
|——————Node:identifier Text: buf
|——————Node:[ Text: [
|——————Node:] Text: ]
|————Node:) Text: )
|——Node:compound_statement Text: {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.readMsgBufID(ID, len, buf);
#else
    *ID = random(0x100, 0x110);
    *len = 4;
    buf[0] = random(0x01, 0x10);
    buf[1] = random(0xa1, 0xf0);
    buf[2] = 0x00;
    buf[3] = 0x00;
    return CAN_OK;
#endif
}
|———Node:{ Text: {
|———Node:preproc_ifdef Text: #ifndef _MCP_FAKE_MODE_
    return lw232CAN.readMsgBufID(ID, len, buf);
#else
    *ID = random(0x100, 0x110);
    *len = 4;
    buf[0] = random(0x01, 0x10);
    buf[1] = random(0xa1, 0xf0);
    buf[2] = 0x00;
    buf[3] = 0x00;
    return CAN_OK;
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: _MCP_FAKE_MODE_
|————Node:return_statement Text: return lw232CAN.readMsgBufID(ID, len, buf);
|—————Node:return Text: return
|—————Node:call_expression Text: lw232CAN.readMsgBufID(ID, len, buf)
|——————Node:field_expression Text: lw232CAN.readMsgBufID
|———————Node:identifier Text: lw232CAN
|———————Node:. Text: .
|———————Node:field_identifier Text: readMsgBufID
|——————Node:argument_list Text: (ID, len, buf)
|———————Node:( Text: (
|———————Node:identifier Text: ID
|———————Node:, Text: ,
|———————Node:identifier Text: len
|———————Node:, Text: ,
|———————Node:identifier Text: buf
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    *ID = random(0x100, 0x110);
    *len = 4;
    buf[0] = random(0x01, 0x10);
    buf[1] = random(0xa1, 0xf0);
    buf[2] = 0x00;
    buf[3] = 0x00;
    return CAN_OK;
|—————Node:#else Text: #else
|—————Node:expression_statement Text: *ID = random(0x100, 0x110);
|——————Node:assignment_expression Text: *ID = random(0x100, 0x110)
|———————Node:pointer_expression Text: *ID
|————————Node:* Text: *
|————————Node:identifier Text: ID
|———————Node:= Text: =
|———————Node:call_expression Text: random(0x100, 0x110)
|————————Node:identifier Text: random
|————————Node:argument_list Text: (0x100, 0x110)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0x100
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x110
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: *len = 4;
|——————Node:assignment_expression Text: *len = 4
|———————Node:pointer_expression Text: *len
|————————Node:* Text: *
|————————Node:identifier Text: len
|———————Node:= Text: =
|———————Node:number_literal Text: 4
|——————Node:; Text: ;
|—————Node:expression_statement Text: buf[0] = random(0x01, 0x10);
|——————Node:assignment_expression Text: buf[0] = random(0x01, 0x10)
|———————Node:subscript_expression Text: buf[0]
|————————Node:identifier Text: buf
|————————Node:subscript_argument_list Text: [0]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: random(0x01, 0x10)
|————————Node:identifier Text: random
|————————Node:argument_list Text: (0x01, 0x10)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x10
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: buf[1] = random(0xa1, 0xf0);
|——————Node:assignment_expression Text: buf[1] = random(0xa1, 0xf0)
|———————Node:subscript_expression Text: buf[1]
|————————Node:identifier Text: buf
|————————Node:subscript_argument_list Text: [1]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:call_expression Text: random(0xa1, 0xf0)
|————————Node:identifier Text: random
|————————Node:argument_list Text: (0xa1, 0xf0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0xa1
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xf0
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: buf[2] = 0x00;
|——————Node:assignment_expression Text: buf[2] = 0x00
|———————Node:subscript_expression Text: buf[2]
|————————Node:identifier Text: buf
|————————Node:subscript_argument_list Text: [2]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 2
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:number_literal Text: 0x00
|——————Node:; Text: ;
|—————Node:expression_statement Text: buf[3] = 0x00;
|——————Node:assignment_expression Text: buf[3] = 0x00
|———————Node:subscript_expression Text: buf[3]
|————————Node:identifier Text: buf
|————————Node:subscript_argument_list Text: [3]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 3
|—————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:number_literal Text: 0x00
|——————Node:; Text: ;
|—————Node:return_statement Text: return CAN_OK;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_OK
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::receiveSingleFrame() {
    INT8U ret = LW232_OK;
    INT8U idx = 0;
    if (CAN_OK == readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer)) {
        if (lw232CanId > 0x1FFFFFFF) {
            ret = LW232_ERR; // address if totally wrong
        }
        else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
    }
    else {
        ret = LW232_ERR;
    }
    return ret;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::receiveSingleFrame()
|———Node:qualified_identifier Text: Can232::receiveSingleFrame
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: receiveSingleFrame
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret = LW232_OK;
    INT8U idx = 0;
    if (CAN_OK == readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer)) {
        if (lw232CanId > 0x1FFFFFFF) {
            ret = LW232_ERR; // address if totally wrong
        }
        else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
    }
    else {
        ret = LW232_ERR;
    }
    return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret = LW232_OK;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ret = LW232_OK
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:identifier Text: LW232_OK
|————Node:; Text: ;
|———Node:declaration Text: INT8U idx = 0;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: idx = 0
|—————Node:identifier Text: idx
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (CAN_OK == readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer)) {
        if (lw232CanId > 0x1FFFFFFF) {
            ret = LW232_ERR; // address if totally wrong
        }
        else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
    }
    else {
        ret = LW232_ERR;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (CAN_OK == readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer))
|—————Node:( Text: (
|—————Node:binary_expression Text: CAN_OK == readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer)
|——————Node:identifier Text: CAN_OK
|——————Node:== Text: ==
|——————Node:call_expression Text: readMsgBufID(&lw232CanId, &lw232PacketLen, lw232Buffer)
|———————Node:identifier Text: readMsgBufID
|———————Node:argument_list Text: (&lw232CanId, &lw232PacketLen, lw232Buffer)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &lw232CanId
|—————————Node:& Text: &
|—————————Node:identifier Text: lw232CanId
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &lw232PacketLen
|—————————Node:& Text: &
|—————————Node:identifier Text: lw232PacketLen
|————————Node:, Text: ,
|————————Node:identifier Text: lw232Buffer
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (lw232CanId > 0x1FFFFFFF) {
            ret = LW232_ERR; // address if totally wrong
        }
        else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (lw232CanId > 0x1FFFFFFF) {
            ret = LW232_ERR; // address if totally wrong
        }
        else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
|——————Node:if Text: if
|——————Node:condition_clause Text: (lw232CanId > 0x1FFFFFFF)
|———————Node:( Text: (
|———————Node:binary_expression Text: lw232CanId > 0x1FFFFFFF
|————————Node:identifier Text: lw232CanId
|————————Node:> Text: >
|————————Node:number_literal Text: 0x1FFFFFFF
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            ret = LW232_ERR; // address if totally wrong
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: ret = LW232_ERR;
|————————Node:assignment_expression Text: ret = LW232_ERR
|—————————Node:identifier Text: ret
|—————————Node:= Text: =
|—————————Node:identifier Text: LW232_ERR
|————————Node:; Text: ;
|———————Node:comment Text: // address if totally wrong
|———————Node:} Text: }
|——————Node:else_clause Text: else if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
|———————Node:else Text: else
|———————Node:if_statement Text: if (checkPassFilter(lw232CanId)) {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
|————————Node:if Text: if
|————————Node:condition_clause Text: (checkPassFilter(lw232CanId))
|—————————Node:( Text: (
|—————————Node:call_expression Text: checkPassFilter(lw232CanId)
|——————————Node:identifier Text: checkPassFilter
|——————————Node:argument_list Text: (lw232CanId)
|———————————Node:( Text: (
|———————————Node:identifier Text: lw232CanId
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {// do we want to skip some addresses?
            if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            //write data len
            HexHelper::printNibble(lw232PacketLen);
            //write data
            for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
            //write timestamp if needed
            if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // do we want to skip some addresses?
|—————————Node:if_statement Text: if (isExtendedFrame()) {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
            else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (isExtendedFrame())
|———————————Node:( Text: (
|———————————Node:call_expression Text: isExtendedFrame()
|————————————Node:identifier Text: isExtendedFrame
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                Serial.print(LW232_TR29);
                HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: Serial.print(LW232_TR29);
|————————————Node:call_expression Text: Serial.print(LW232_TR29)
|—————————————Node:field_expression Text: Serial.print
|——————————————Node:identifier Text: Serial
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: print
|—————————————Node:argument_list Text: (LW232_TR29)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: LW232_TR29
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)));
|————————————Node:call_expression Text: HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(lw232CanId)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (HIGH_BYTE(HIGH_WORD(lw232CanId)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: HIGH_BYTE(HIGH_WORD(lw232CanId))
|———————————————Node:identifier Text: HIGH_BYTE
|———————————————Node:argument_list Text: (HIGH_WORD(lw232CanId))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: HIGH_WORD(lw232CanId)
|—————————————————Node:identifier Text: HIGH_WORD
|—————————————————Node:argument_list Text: (lw232CanId)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: lw232CanId
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)));
|————————————Node:call_expression Text: HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(lw232CanId)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (LOW_BYTE(HIGH_WORD(lw232CanId)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: LOW_BYTE(HIGH_WORD(lw232CanId))
|———————————————Node:identifier Text: LOW_BYTE
|———————————————Node:argument_list Text: (HIGH_WORD(lw232CanId))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: HIGH_WORD(lw232CanId)
|—————————————————Node:identifier Text: HIGH_WORD
|—————————————————Node:argument_list Text: (lw232CanId)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: lw232CanId
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)));
|————————————Node:call_expression Text: HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(lw232CanId)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (HIGH_BYTE(LOW_WORD(lw232CanId)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: HIGH_BYTE(LOW_WORD(lw232CanId))
|———————————————Node:identifier Text: HIGH_BYTE
|———————————————Node:argument_list Text: (LOW_WORD(lw232CanId))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: LOW_WORD(lw232CanId)
|—————————————————Node:identifier Text: LOW_WORD
|—————————————————Node:argument_list Text: (lw232CanId)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: lw232CanId
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
|————————————Node:call_expression Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (LOW_BYTE(LOW_WORD(lw232CanId)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: LOW_BYTE(LOW_WORD(lw232CanId))
|———————————————Node:identifier Text: LOW_BYTE
|———————————————Node:argument_list Text: (LOW_WORD(lw232CanId))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: LOW_WORD(lw232CanId)
|—————————————————Node:identifier Text: LOW_WORD
|—————————————————Node:argument_list Text: (lw232CanId)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: lw232CanId
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
                Serial.print(LW232_TR11);
                HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
            }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: Serial.print(LW232_TR11);
|—————————————Node:call_expression Text: Serial.print(LW232_TR11)
|——————————————Node:field_expression Text: Serial.print
|———————————————Node:identifier Text: Serial
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: print
|——————————————Node:argument_list Text: (LW232_TR11)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: LW232_TR11
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)));
|—————————————Node:call_expression Text: HexHelper::printNibble(HIGH_BYTE(LOW_WORD(lw232CanId)))
|——————————————Node:qualified_identifier Text: HexHelper::printNibble
|———————————————Node:namespace_identifier Text: HexHelper
|———————————————Node::: Text: ::
|———————————————Node:identifier Text: printNibble
|——————————————Node:argument_list Text: (HIGH_BYTE(LOW_WORD(lw232CanId)))
|———————————————Node:( Text: (
|———————————————Node:call_expression Text: HIGH_BYTE(LOW_WORD(lw232CanId))
|————————————————Node:identifier Text: HIGH_BYTE
|————————————————Node:argument_list Text: (LOW_WORD(lw232CanId))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: LOW_WORD(lw232CanId)
|——————————————————Node:identifier Text: LOW_WORD
|——————————————————Node:argument_list Text: (lw232CanId)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: lw232CanId
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)));
|—————————————Node:call_expression Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(lw232CanId)))
|——————————————Node:qualified_identifier Text: HexHelper::printFullByte
|———————————————Node:namespace_identifier Text: HexHelper
|———————————————Node::: Text: ::
|———————————————Node:identifier Text: printFullByte
|——————————————Node:argument_list Text: (LOW_BYTE(LOW_WORD(lw232CanId)))
|———————————————Node:( Text: (
|———————————————Node:call_expression Text: LOW_BYTE(LOW_WORD(lw232CanId))
|————————————————Node:identifier Text: LOW_BYTE
|————————————————Node:argument_list Text: (LOW_WORD(lw232CanId))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: LOW_WORD(lw232CanId)
|——————————————————Node:identifier Text: LOW_WORD
|——————————————————Node:argument_list Text: (lw232CanId)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: lw232CanId
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:comment Text: //write data len
|—————————Node:expression_statement Text: HexHelper::printNibble(lw232PacketLen);
|——————————Node:call_expression Text: HexHelper::printNibble(lw232PacketLen)
|———————————Node:qualified_identifier Text: HexHelper::printNibble
|————————————Node:namespace_identifier Text: HexHelper
|————————————Node::: Text: ::
|————————————Node:identifier Text: printNibble
|———————————Node:argument_list Text: (lw232PacketLen)
|————————————Node:( Text: (
|————————————Node:identifier Text: lw232PacketLen
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:comment Text: //write data
|—————————Node:for_statement Text: for (idx = 0; idx < lw232PacketLen; idx++) {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:assignment_expression Text: idx = 0
|———————————Node:identifier Text: idx
|———————————Node:= Text: =
|———————————Node:number_literal Text: 0
|——————————Node:; Text: ;
|——————————Node:binary_expression Text: idx < lw232PacketLen
|———————————Node:identifier Text: idx
|———————————Node:< Text: <
|———————————Node:identifier Text: lw232PacketLen
|——————————Node:; Text: ;
|——————————Node:update_expression Text: idx++
|———————————Node:identifier Text: idx
|———————————Node:++ Text: ++
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
                HexHelper::printFullByte(lw232Buffer[idx]);
            }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: HexHelper::printFullByte(lw232Buffer[idx]);
|————————————Node:call_expression Text: HexHelper::printFullByte(lw232Buffer[idx])
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (lw232Buffer[idx])
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: lw232Buffer[idx]
|———————————————Node:identifier Text: lw232Buffer
|———————————————Node:subscript_argument_list Text: [idx]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: idx
|————————————————Node:] Text: ]
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:comment Text: //write timestamp if needed
|—————————Node:if_statement Text: if (lw232TimeStamp != LW232_TIMESTAMP_OFF) {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (lw232TimeStamp != LW232_TIMESTAMP_OFF)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: lw232TimeStamp != LW232_TIMESTAMP_OFF
|————————————Node:identifier Text: lw232TimeStamp
|————————————Node:!= Text: !=
|————————————Node:identifier Text: LW232_TIMESTAMP_OFF
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                INT32U time = millis();
                if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
                HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
                HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
            }
|———————————Node:{ Text: {
|———————————Node:declaration Text: INT32U time = millis();
|————————————Node:type_identifier Text: INT32U
|————————————Node:init_declarator Text: time = millis()
|—————————————Node:identifier Text: time
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: millis()
|——————————————Node:identifier Text: millis
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL) { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                } else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: lw232TimeStamp == LW232_TIMESTAMP_ON_NORMAL
|——————————————Node:identifier Text: lw232TimeStamp
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: LW232_TIMESTAMP_ON_NORMAL
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: { 
                    // standard LAWICEL protocol. two bytes.
                    time %= 60000;  
                }
|—————————————Node:{ Text: {
|—————————————Node:comment Text: // standard LAWICEL protocol. two bytes.
|—————————————Node:expression_statement Text: time %= 60000;
|——————————————Node:assignment_expression Text: time %= 60000
|———————————————Node:identifier Text: time
|———————————————Node:%= Text: %=
|———————————————Node:number_literal Text: 60000
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|————————————Node:else_clause Text: else {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
|—————————————Node:else Text: else
|—————————————Node:compound_statement Text: {
                    // non standard protocol - 4 bytes timestamp
                    HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
                    HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
                }
|——————————————Node:{ Text: {
|——————————————Node:comment Text: // non standard protocol - 4 bytes timestamp
|——————————————Node:expression_statement Text: HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)));
|———————————————Node:call_expression Text: HexHelper::printFullByte(HIGH_BYTE(HIGH_WORD(time)))
|————————————————Node:qualified_identifier Text: HexHelper::printFullByte
|—————————————————Node:namespace_identifier Text: HexHelper
|—————————————————Node::: Text: ::
|—————————————————Node:identifier Text: printFullByte
|————————————————Node:argument_list Text: (HIGH_BYTE(HIGH_WORD(time)))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: HIGH_BYTE(HIGH_WORD(time))
|——————————————————Node:identifier Text: HIGH_BYTE
|——————————————————Node:argument_list Text: (HIGH_WORD(time))
|———————————————————Node:( Text: (
|———————————————————Node:call_expression Text: HIGH_WORD(time)
|————————————————————Node:identifier Text: HIGH_WORD
|————————————————————Node:argument_list Text: (time)
|—————————————————————Node:( Text: (
|—————————————————————Node:identifier Text: time
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:expression_statement Text: HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)));
|———————————————Node:call_expression Text: HexHelper::printFullByte(LOW_BYTE(HIGH_WORD(time)))
|————————————————Node:qualified_identifier Text: HexHelper::printFullByte
|—————————————————Node:namespace_identifier Text: HexHelper
|—————————————————Node::: Text: ::
|—————————————————Node:identifier Text: printFullByte
|————————————————Node:argument_list Text: (LOW_BYTE(HIGH_WORD(time)))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: LOW_BYTE(HIGH_WORD(time))
|——————————————————Node:identifier Text: LOW_BYTE
|——————————————————Node:argument_list Text: (HIGH_WORD(time))
|———————————————————Node:( Text: (
|———————————————————Node:call_expression Text: HIGH_WORD(time)
|————————————————————Node:identifier Text: HIGH_WORD
|————————————————————Node:argument_list Text: (time)
|—————————————————————Node:( Text: (
|—————————————————————Node:identifier Text: time
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:; Text: ;
|——————————————Node:} Text: }
|———————————Node:expression_statement Text: HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)));
|————————————Node:call_expression Text: HexHelper::printFullByte(HIGH_BYTE(LOW_WORD(time)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (HIGH_BYTE(LOW_WORD(time)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: HIGH_BYTE(LOW_WORD(time))
|———————————————Node:identifier Text: HIGH_BYTE
|———————————————Node:argument_list Text: (LOW_WORD(time))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: LOW_WORD(time)
|—————————————————Node:identifier Text: LOW_WORD
|—————————————————Node:argument_list Text: (time)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: time
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)));
|————————————Node:call_expression Text: HexHelper::printFullByte(LOW_BYTE(LOW_WORD(time)))
|—————————————Node:qualified_identifier Text: HexHelper::printFullByte
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: printFullByte
|—————————————Node:argument_list Text: (LOW_BYTE(LOW_WORD(time)))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: LOW_BYTE(LOW_WORD(time))
|———————————————Node:identifier Text: LOW_BYTE
|———————————————Node:argument_list Text: (LOW_WORD(time))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: LOW_WORD(time)
|—————————————————Node:identifier Text: LOW_WORD
|—————————————————Node:argument_list Text: (time)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: time
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else {
        ret = LW232_ERR;
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        ret = LW232_ERR;
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: ret = LW232_ERR;
|———————Node:assignment_expression Text: ret = LW232_ERR
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:identifier Text: LW232_ERR
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::isExtendedFrame() {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.isExtendedFrame();
#else
    return lw232CanId > 0x7FF ? 1 : 0; //simple hack for fake mode
#endif
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::isExtendedFrame()
|———Node:qualified_identifier Text: Can232::isExtendedFrame
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: isExtendedFrame
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.isExtendedFrame();
#else
    return lw232CanId > 0x7FF ? 1 : 0; //simple hack for fake mode
#endif
}
|———Node:{ Text: {
|———Node:preproc_ifdef Text: #ifndef _MCP_FAKE_MODE_
    return lw232CAN.isExtendedFrame();
#else
    return lw232CanId > 0x7FF ? 1 : 0; //simple hack for fake mode
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: _MCP_FAKE_MODE_
|————Node:return_statement Text: return lw232CAN.isExtendedFrame();
|—————Node:return Text: return
|—————Node:call_expression Text: lw232CAN.isExtendedFrame()
|——————Node:field_expression Text: lw232CAN.isExtendedFrame
|———————Node:identifier Text: lw232CAN
|———————Node:. Text: .
|———————Node:field_identifier Text: isExtendedFrame
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    return lw232CanId > 0x7FF ? 1 : 0;
|—————Node:#else Text: #else
|—————Node:return_statement Text: return lw232CanId > 0x7FF ? 1 : 0;
|——————Node:return Text: return
|——————Node:conditional_expression Text: lw232CanId > 0x7FF ? 1 : 0
|———————Node:binary_expression Text: lw232CanId > 0x7FF
|————————Node:identifier Text: lw232CanId
|————————Node:> Text: >
|————————Node:number_literal Text: 0x7FF
|———————Node:? Text: ?
|———————Node:number_literal Text: 1
|———————Node:: Text: :
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|————Node:comment Text: //simple hack for fake mode
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::checkPassFilter(INT32U addr) {
	if (userAddressFilterFunc == 0) 
		return LW232_FILTER_PROCESS;
	
	return (*userAddressFilterFunc)(addr);
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::checkPassFilter(INT32U addr)
|———Node:qualified_identifier Text: Can232::checkPassFilter
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: checkPassFilter
|———Node:parameter_list Text: (INT32U addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT32U addr
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: addr
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (userAddressFilterFunc == 0) 
		return LW232_FILTER_PROCESS;
	
	return (*userAddressFilterFunc)(addr);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (userAddressFilterFunc == 0) 
		return LW232_FILTER_PROCESS;
|————Node:if Text: if
|————Node:condition_clause Text: (userAddressFilterFunc == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: userAddressFilterFunc == 0
|——————Node:identifier Text: userAddressFilterFunc
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:return_statement Text: return LW232_FILTER_PROCESS;
|—————Node:return Text: return
|—————Node:identifier Text: LW232_FILTER_PROCESS
|—————Node:; Text: ;
|———Node:return_statement Text: return (*userAddressFilterFunc)(addr);
|————Node:return Text: return
|————Node:call_expression Text: (*userAddressFilterFunc)(addr)
|—————Node:parenthesized_expression Text: (*userAddressFilterFunc)
|——————Node:( Text: (
|——————Node:pointer_expression Text: *userAddressFilterFunc
|———————Node:* Text: *
|———————Node:identifier Text: userAddressFilterFunc
|——————Node:) Text: )
|—————Node:argument_list Text: (addr)
|——————Node:( Text: (
|——————Node:identifier Text: addr
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::openCanBus() {
    INT8U ret = LW232_OK;
#ifndef _MCP_FAKE_MODE_
    if (CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock))
        ret = LW232_ERR;
#endif
    return ret;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::openCanBus()
|———Node:qualified_identifier Text: Can232::openCanBus
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: openCanBus
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret = LW232_OK;
#ifndef _MCP_FAKE_MODE_
    if (CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock))
        ret = LW232_ERR;
#endif
    return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret = LW232_OK;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ret = LW232_OK
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:identifier Text: LW232_OK
|————Node:; Text: ;
|———Node:preproc_ifdef Text: #ifndef _MCP_FAKE_MODE_
    if (CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock))
        ret = LW232_ERR;
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: _MCP_FAKE_MODE_
|————Node:if_statement Text: if (CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock))
        ret = LW232_ERR;
|—————Node:if Text: if
|—————Node:condition_clause Text: (CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock))
|——————Node:( Text: (
|——————Node:binary_expression Text: CAN_OK != lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock)
|———————Node:identifier Text: CAN_OK
|———————Node:!= Text: !=
|———————Node:call_expression Text: lw232CAN.begin(lw232CanSpeedSelection, lw232McpModuleClock)
|————————Node:field_expression Text: lw232CAN.begin
|—————————Node:identifier Text: lw232CAN
|—————————Node:. Text: .
|—————————Node:field_identifier Text: begin
|————————Node:argument_list Text: (lw232CanSpeedSelection, lw232McpModuleClock)
|—————————Node:( Text: (
|—————————Node:identifier Text: lw232CanSpeedSelection
|—————————Node:, Text: ,
|—————————Node:identifier Text: lw232McpModuleClock
|—————————Node:) Text: )
|——————Node:) Text: )
|—————Node:expression_statement Text: ret = LW232_ERR;
|——————Node:assignment_expression Text: ret = LW232_ERR
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:identifier Text: LW232_ERR
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U Can232::sendMsgBuf(INT32U id, INT8U ext, INT8U rtr, INT8U len, INT8U *buf) {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.sendMsgBuf(id, ext, rtr, len, buf);
#else
    Serial.print("<sending:");
    Serial.print(id, HEX);
    Serial.print(',');
    if (ext) Serial.print('+');
    else Serial.print('-');
    if (rtr) Serial.print('+');
    else Serial.print('-');
    Serial.print(',');
    Serial.print(len, DEC);
    Serial.print(',');
    int i;
    for (i = 0; i < len; i++) printFullByte(buf[i]);
    return CAN_OK;
#endif
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: Can232::sendMsgBuf(INT32U id, INT8U ext, INT8U rtr, INT8U len, INT8U *buf)
|———Node:qualified_identifier Text: Can232::sendMsgBuf
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: sendMsgBuf
|———Node:parameter_list Text: (INT32U id, INT8U ext, INT8U rtr, INT8U len, INT8U *buf)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT32U id
|—————Node:type_identifier Text: INT32U
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U ext
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: ext
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U rtr
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: rtr
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U len
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: len
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U *buf
|—————Node:type_identifier Text: INT8U
|—————Node:pointer_declarator Text: *buf
|——————Node:* Text: *
|——————Node:identifier Text: buf
|————Node:) Text: )
|——Node:compound_statement Text: {
#ifndef _MCP_FAKE_MODE_
    return lw232CAN.sendMsgBuf(id, ext, rtr, len, buf);
#else
    Serial.print("<sending:");
    Serial.print(id, HEX);
    Serial.print(',');
    if (ext) Serial.print('+');
    else Serial.print('-');
    if (rtr) Serial.print('+');
    else Serial.print('-');
    Serial.print(',');
    Serial.print(len, DEC);
    Serial.print(',');
    int i;
    for (i = 0; i < len; i++) printFullByte(buf[i]);
    return CAN_OK;
#endif
}
|———Node:{ Text: {
|———Node:preproc_ifdef Text: #ifndef _MCP_FAKE_MODE_
    return lw232CAN.sendMsgBuf(id, ext, rtr, len, buf);
#else
    Serial.print("<sending:");
    Serial.print(id, HEX);
    Serial.print(',');
    if (ext) Serial.print('+');
    else Serial.print('-');
    if (rtr) Serial.print('+');
    else Serial.print('-');
    Serial.print(',');
    Serial.print(len, DEC);
    Serial.print(',');
    int i;
    for (i = 0; i < len; i++) printFullByte(buf[i]);
    return CAN_OK;
#endif
|————Node:#ifndef Text: #ifndef
|————Node:identifier Text: _MCP_FAKE_MODE_
|————Node:return_statement Text: return lw232CAN.sendMsgBuf(id, ext, rtr, len, buf);
|—————Node:return Text: return
|—————Node:call_expression Text: lw232CAN.sendMsgBuf(id, ext, rtr, len, buf)
|——————Node:field_expression Text: lw232CAN.sendMsgBuf
|———————Node:identifier Text: lw232CAN
|———————Node:. Text: .
|———————Node:field_identifier Text: sendMsgBuf
|——————Node:argument_list Text: (id, ext, rtr, len, buf)
|———————Node:( Text: (
|———————Node:identifier Text: id
|———————Node:, Text: ,
|———————Node:identifier Text: ext
|———————Node:, Text: ,
|———————Node:identifier Text: rtr
|———————Node:, Text: ,
|———————Node:identifier Text: len
|———————Node:, Text: ,
|———————Node:identifier Text: buf
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    Serial.print("<sending:");
    Serial.print(id, HEX);
    Serial.print(',');
    if (ext) Serial.print('+');
    else Serial.print('-');
    if (rtr) Serial.print('+');
    else Serial.print('-');
    Serial.print(',');
    Serial.print(len, DEC);
    Serial.print(',');
    int i;
    for (i = 0; i < len; i++) printFullByte(buf[i]);
    return CAN_OK;
|—————Node:#else Text: #else
|—————Node:expression_statement Text: Serial.print("<sending:");
|——————Node:call_expression Text: Serial.print("<sending:")
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ("<sending:")
|————————Node:( Text: (
|————————Node:string_literal Text: "<sending:"
|—————————Node:" Text: "
|—————————Node:string_content Text: <sending:
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: Serial.print(id, HEX);
|——————Node:call_expression Text: Serial.print(id, HEX)
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (id, HEX)
|————————Node:( Text: (
|————————Node:identifier Text: id
|————————Node:, Text: ,
|————————Node:identifier Text: HEX
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: Serial.print(',');
|——————Node:call_expression Text: Serial.print(',')
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (',')
|————————Node:( Text: (
|————————Node:char_literal Text: ','
|—————————Node:' Text: '
|—————————Node:character Text: ,
|—————————Node:' Text: '
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (ext) Serial.print('+');
    else Serial.print('-');
|——————Node:if Text: if
|——————Node:condition_clause Text: (ext)
|———————Node:( Text: (
|———————Node:identifier Text: ext
|———————Node:) Text: )
|——————Node:expression_statement Text: Serial.print('+');
|———————Node:call_expression Text: Serial.print('+')
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ('+')
|—————————Node:( Text: (
|—————————Node:char_literal Text: '+'
|——————————Node:' Text: '
|——————————Node:character Text: +
|——————————Node:' Text: '
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:else_clause Text: else Serial.print('-');
|———————Node:else Text: else
|———————Node:expression_statement Text: Serial.print('-');
|————————Node:call_expression Text: Serial.print('-')
|—————————Node:field_expression Text: Serial.print
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: print
|—————————Node:argument_list Text: ('-')
|——————————Node:( Text: (
|——————————Node:char_literal Text: '-'
|———————————Node:' Text: '
|———————————Node:character Text: -
|———————————Node:' Text: '
|——————————Node:) Text: )
|————————Node:; Text: ;
|—————Node:if_statement Text: if (rtr) Serial.print('+');
    else Serial.print('-');
|——————Node:if Text: if
|——————Node:condition_clause Text: (rtr)
|———————Node:( Text: (
|———————Node:identifier Text: rtr
|———————Node:) Text: )
|——————Node:expression_statement Text: Serial.print('+');
|———————Node:call_expression Text: Serial.print('+')
|————————Node:field_expression Text: Serial.print
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ('+')
|—————————Node:( Text: (
|—————————Node:char_literal Text: '+'
|——————————Node:' Text: '
|——————————Node:character Text: +
|——————————Node:' Text: '
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:else_clause Text: else Serial.print('-');
|———————Node:else Text: else
|———————Node:expression_statement Text: Serial.print('-');
|————————Node:call_expression Text: Serial.print('-')
|—————————Node:field_expression Text: Serial.print
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: print
|—————————Node:argument_list Text: ('-')
|——————————Node:( Text: (
|——————————Node:char_literal Text: '-'
|———————————Node:' Text: '
|———————————Node:character Text: -
|———————————Node:' Text: '
|——————————Node:) Text: )
|————————Node:; Text: ;
|—————Node:expression_statement Text: Serial.print(',');
|——————Node:call_expression Text: Serial.print(',')
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (',')
|————————Node:( Text: (
|————————Node:char_literal Text: ','
|—————————Node:' Text: '
|—————————Node:character Text: ,
|—————————Node:' Text: '
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: Serial.print(len, DEC);
|——————Node:call_expression Text: Serial.print(len, DEC)
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (len, DEC)
|————————Node:( Text: (
|————————Node:identifier Text: len
|————————Node:, Text: ,
|————————Node:identifier Text: DEC
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: Serial.print(',');
|——————Node:call_expression Text: Serial.print(',')
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: (',')
|————————Node:( Text: (
|————————Node:char_literal Text: ','
|—————————Node:' Text: '
|—————————Node:character Text: ,
|—————————Node:' Text: '
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: int i;
|——————Node:primitive_type Text: int
|——————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:for_statement Text: for (i = 0; i < len; i++) printFullByte(buf[i]);
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: i < len
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: len
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:expression_statement Text: printFullByte(buf[i]);
|———————Node:call_expression Text: printFullByte(buf[i])
|————————Node:identifier Text: printFullByte
|————————Node:argument_list Text: (buf[i])
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: buf[i]
|——————————Node:identifier Text: buf
|——————————Node:subscript_argument_list Text: [i]
|———————————Node:[ Text: [
|———————————Node:identifier Text: i
|———————————Node:] Text: ]
|—————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:return_statement Text: return CAN_OK;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_OK
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: void Can232::parseCanStdId() {
    lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])));
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::parseCanStdId()
|———Node:qualified_identifier Text: Can232::parseCanStdId
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: parseCanStdId
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])));
}
|———Node:{ Text: {
|———Node:expression_statement Text: lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])));
|————Node:assignment_expression Text: lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])))
|—————Node:identifier Text: lw232CanId
|—————Node:= Text: =
|—————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])))
|——————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
|———————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8)
|————————Node:( Text: (
|————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[1])) << 8
|—————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[1]))
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[1])
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: INT32U
|————————————Node:type_identifier Text: INT32U
|———————————Node:) Text: )
|———————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[1])
|————————————Node:qualified_identifier Text: HexHelper::parseNibble
|—————————————Node:namespace_identifier Text: HexHelper
|—————————————Node::: Text: ::
|—————————————Node:identifier Text: parseNibble
|————————————Node:argument_list Text: (lw232Message[1])
|—————————————Node:( Text: (
|—————————————Node:subscript_expression Text: lw232Message[1]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [1]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 1
|———————————————Node:] Text: ]
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:number_literal Text: 8
|————————Node:) Text: )
|———————Node:+ Text: +
|———————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4)
|————————Node:( Text: (
|————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[2])) << 4
|—————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[2]))
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[2])
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: INT32U
|————————————Node:type_identifier Text: INT32U
|———————————Node:) Text: )
|———————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[2])
|————————————Node:qualified_identifier Text: HexHelper::parseNibble
|—————————————Node:namespace_identifier Text: HexHelper
|—————————————Node::: Text: ::
|—————————————Node:identifier Text: parseNibble
|————————————Node:argument_list Text: (lw232Message[2])
|—————————————Node:( Text: (
|—————————————Node:subscript_expression Text: lw232Message[2]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [2]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 2
|———————————————Node:] Text: ]
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:number_literal Text: 4
|————————Node:) Text: )
|——————Node:+ Text: +
|——————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[3])))
|———————Node:( Text: (
|———————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[3]))
|————————Node:( Text: (
|————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[3])
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: INT32U
|——————————Node:type_identifier Text: INT32U
|—————————Node:) Text: )
|—————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[3])
|——————————Node:qualified_identifier Text: HexHelper::parseNibble
|———————————Node:namespace_identifier Text: HexHelper
|———————————Node::: Text: ::
|———————————Node:identifier Text: parseNibble
|——————————Node:argument_list Text: (lw232Message[3])
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: lw232Message[3]
|————————————Node:identifier Text: lw232Message
|————————————Node:subscript_argument_list Text: [3]
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 3
|—————————————Node:] Text: ]
|———————————Node:) Text: )
|————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void Can232::parseCanExtId() {
    lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[6])));
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: Can232::parseCanExtId()
|———Node:qualified_identifier Text: Can232::parseCanExtId
|————Node:namespace_identifier Text: Can232
|————Node::: Text: ::
|————Node:identifier Text: parseCanExtId
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[6])));
}
|———Node:{ Text: {
|———Node:expression_statement Text: lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[6])));
|————Node:assignment_expression Text: lw232CanId = (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[6])))
|—————Node:identifier Text: lw232CanId
|—————Node:= Text: =
|—————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
        + (((INT32U)HexHelper::parseNibble(lw232Message[6])))
|——————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
        + (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
|———————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
        + (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
|————————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
        + (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
|—————————Node:binary_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
        + (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
|——————————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[1])) << 20
|————————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[1]))
|—————————————Node:( Text: (
|—————————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[1])
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: INT32U
|———————————————Node:type_identifier Text: INT32U
|——————————————Node:) Text: )
|——————————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[1])
|———————————————Node:qualified_identifier Text: HexHelper::parseNibble
|————————————————Node:namespace_identifier Text: HexHelper
|————————————————Node::: Text: ::
|————————————————Node:identifier Text: parseNibble
|———————————————Node:argument_list Text: (lw232Message[1])
|————————————————Node:( Text: (
|————————————————Node:subscript_expression Text: lw232Message[1]
|—————————————————Node:identifier Text: lw232Message
|—————————————————Node:subscript_argument_list Text: [1]
|——————————————————Node:[ Text: [
|——————————————————Node:number_literal Text: 1
|——————————————————Node:] Text: ]
|————————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:<< Text: <<
|————————————Node:number_literal Text: 20
|———————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[2])) << 16
|————————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[2]))
|—————————————Node:( Text: (
|—————————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[2])
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: INT32U
|———————————————Node:type_identifier Text: INT32U
|——————————————Node:) Text: )
|——————————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[2])
|———————————————Node:qualified_identifier Text: HexHelper::parseNibble
|————————————————Node:namespace_identifier Text: HexHelper
|————————————————Node::: Text: ::
|————————————————Node:identifier Text: parseNibble
|———————————————Node:argument_list Text: (lw232Message[2])
|————————————————Node:( Text: (
|————————————————Node:subscript_expression Text: lw232Message[2]
|—————————————————Node:identifier Text: lw232Message
|—————————————————Node:subscript_argument_list Text: [2]
|——————————————————Node:[ Text: [
|——————————————————Node:number_literal Text: 2
|——————————————————Node:] Text: ]
|————————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:<< Text: <<
|————————————Node:number_literal Text: 16
|———————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[3])) << 12
|———————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[3]))
|————————————Node:( Text: (
|————————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[3])
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: INT32U
|——————————————Node:type_identifier Text: INT32U
|—————————————Node:) Text: )
|—————————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[3])
|——————————————Node:qualified_identifier Text: HexHelper::parseNibble
|———————————————Node:namespace_identifier Text: HexHelper
|———————————————Node::: Text: ::
|———————————————Node:identifier Text: parseNibble
|——————————————Node:argument_list Text: (lw232Message[3])
|———————————————Node:( Text: (
|———————————————Node:subscript_expression Text: lw232Message[3]
|————————————————Node:identifier Text: lw232Message
|————————————————Node:subscript_argument_list Text: [3]
|—————————————————Node:[ Text: [
|—————————————————Node:number_literal Text: 3
|—————————————————Node:] Text: ]
|———————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 12
|——————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[4])) << 8
|——————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[4]))
|———————————Node:( Text: (
|———————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[4])
|————————————Node:( Text: (
|————————————Node:type_descriptor Text: INT32U
|—————————————Node:type_identifier Text: INT32U
|————————————Node:) Text: )
|————————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[4])
|—————————————Node:qualified_identifier Text: HexHelper::parseNibble
|——————————————Node:namespace_identifier Text: HexHelper
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: parseNibble
|—————————————Node:argument_list Text: (lw232Message[4])
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: lw232Message[4]
|———————————————Node:identifier Text: lw232Message
|———————————————Node:subscript_argument_list Text: [4]
|————————————————Node:[ Text: [
|————————————————Node:number_literal Text: 4
|————————————————Node:] Text: ]
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 8
|—————————Node:) Text: )
|———————Node:+ Text: +
|———————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4)
|————————Node:( Text: (
|————————Node:binary_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[5])) << 4
|—————————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[5]))
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[5])
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: INT32U
|————————————Node:type_identifier Text: INT32U
|———————————Node:) Text: )
|———————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[5])
|————————————Node:qualified_identifier Text: HexHelper::parseNibble
|—————————————Node:namespace_identifier Text: HexHelper
|—————————————Node::: Text: ::
|—————————————Node:identifier Text: parseNibble
|————————————Node:argument_list Text: (lw232Message[5])
|—————————————Node:( Text: (
|—————————————Node:subscript_expression Text: lw232Message[5]
|——————————————Node:identifier Text: lw232Message
|——————————————Node:subscript_argument_list Text: [5]
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 5
|———————————————Node:] Text: ]
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:number_literal Text: 4
|————————Node:) Text: )
|——————Node:+ Text: +
|——————Node:parenthesized_expression Text: (((INT32U)HexHelper::parseNibble(lw232Message[6])))
|———————Node:( Text: (
|———————Node:parenthesized_expression Text: ((INT32U)HexHelper::parseNibble(lw232Message[6]))
|————————Node:( Text: (
|————————Node:cast_expression Text: (INT32U)HexHelper::parseNibble(lw232Message[6])
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: INT32U
|——————————Node:type_identifier Text: INT32U
|—————————Node:) Text: )
|—————————Node:call_expression Text: HexHelper::parseNibble(lw232Message[6])
|——————————Node:qualified_identifier Text: HexHelper::parseNibble
|———————————Node:namespace_identifier Text: HexHelper
|———————————Node::: Text: ::
|———————————Node:identifier Text: parseNibble
|——————————Node:argument_list Text: (lw232Message[6])
|———————————Node:( Text: (
|———————————Node:subscript_expression Text: lw232Message[6]
|————————————Node:identifier Text: lw232Message
|————————————Node:subscript_argument_list Text: [6]
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 6
|—————————————Node:] Text: ]
|———————————Node:) Text: )
|————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void HexHelper::printFullByte(INT8U b) {
    if (b < 0x10) {
        Serial.print('0');
       // dbg0('0');
    }
    Serial.print(b, HEX);
    //dbgH(b);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: HexHelper::printFullByte(INT8U b)
|———Node:qualified_identifier Text: HexHelper::printFullByte
|————Node:namespace_identifier Text: HexHelper
|————Node::: Text: ::
|————Node:identifier Text: printFullByte
|———Node:parameter_list Text: (INT8U b)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U b
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: b
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (b < 0x10) {
        Serial.print('0');
       // dbg0('0');
    }
    Serial.print(b, HEX);
    //dbgH(b);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (b < 0x10) {
        Serial.print('0');
       // dbg0('0');
    }
|————Node:if Text: if
|————Node:condition_clause Text: (b < 0x10)
|—————Node:( Text: (
|—————Node:binary_expression Text: b < 0x10
|——————Node:identifier Text: b
|——————Node:< Text: <
|——————Node:number_literal Text: 0x10
|—————Node:) Text: )
|————Node:compound_statement Text: {
        Serial.print('0');
       // dbg0('0');
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: Serial.print('0');
|——————Node:call_expression Text: Serial.print('0')
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ('0')
|————————Node:( Text: (
|————————Node:char_literal Text: '0'
|—————————Node:' Text: '
|—————————Node:character Text: 0
|—————————Node:' Text: '
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: // dbg0('0');
|—————Node:} Text: }
|———Node:expression_statement Text: Serial.print(b, HEX);
|————Node:call_expression Text: Serial.print(b, HEX)
|—————Node:field_expression Text: Serial.print
|——————Node:identifier Text: Serial
|——————Node:. Text: .
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: (b, HEX)
|——————Node:( Text: (
|——————Node:identifier Text: b
|——————Node:, Text: ,
|——————Node:identifier Text: HEX
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //dbgH(b);
|———Node:} Text: }
|—Node:function_definition Text: void HexHelper::printNibble(INT8U b) {
    Serial.print(b & 0x0F, HEX);
    //dbgH(b & 0x0F);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: HexHelper::printNibble(INT8U b)
|———Node:qualified_identifier Text: HexHelper::printNibble
|————Node:namespace_identifier Text: HexHelper
|————Node::: Text: ::
|————Node:identifier Text: printNibble
|———Node:parameter_list Text: (INT8U b)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U b
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: b
|————Node:) Text: )
|——Node:compound_statement Text: {
    Serial.print(b & 0x0F, HEX);
    //dbgH(b & 0x0F);
}
|———Node:{ Text: {
|———Node:expression_statement Text: Serial.print(b & 0x0F, HEX);
|————Node:call_expression Text: Serial.print(b & 0x0F, HEX)
|—————Node:field_expression Text: Serial.print
|——————Node:identifier Text: Serial
|——————Node:. Text: .
|——————Node:field_identifier Text: print
|—————Node:argument_list Text: (b & 0x0F, HEX)
|——————Node:( Text: (
|——————Node:binary_expression Text: b & 0x0F
|———————Node:identifier Text: b
|———————Node:& Text: &
|———————Node:number_literal Text: 0x0F
|——————Node:, Text: ,
|——————Node:identifier Text: HEX
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //dbgH(b & 0x0F);
|———Node:} Text: }
|—Node:function_definition Text: INT8U HexHelper::parseNibble(INT8U hex) {
    INT8U ret = 0;
    if (hex >= '0' && hex <= '9') {
        ret = hex - '0';
    } else if (hex >= 'a' && hex <= 'f') {
        ret = hex - 'a' + 10;
    } else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    } // else error, return 0
    return ret;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: HexHelper::parseNibble(INT8U hex)
|———Node:qualified_identifier Text: HexHelper::parseNibble
|————Node:namespace_identifier Text: HexHelper
|————Node::: Text: ::
|————Node:identifier Text: parseNibble
|———Node:parameter_list Text: (INT8U hex)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U hex
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: hex
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret = 0;
    if (hex >= '0' && hex <= '9') {
        ret = hex - '0';
    } else if (hex >= 'a' && hex <= 'f') {
        ret = hex - 'a' + 10;
    } else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    } // else error, return 0
    return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret = 0;
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ret = 0
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (hex >= '0' && hex <= '9') {
        ret = hex - '0';
    } else if (hex >= 'a' && hex <= 'f') {
        ret = hex - 'a' + 10;
    } else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (hex >= '0' && hex <= '9')
|—————Node:( Text: (
|—————Node:binary_expression Text: hex >= '0' && hex <= '9'
|——————Node:binary_expression Text: hex >= '0'
|———————Node:identifier Text: hex
|———————Node:>= Text: >=
|———————Node:char_literal Text: '0'
|————————Node:' Text: '
|————————Node:character Text: 0
|————————Node:' Text: '
|——————Node:&& Text: &&
|——————Node:binary_expression Text: hex <= '9'
|———————Node:identifier Text: hex
|———————Node:<= Text: <=
|———————Node:char_literal Text: '9'
|————————Node:' Text: '
|————————Node:character Text: 9
|————————Node:' Text: '
|—————Node:) Text: )
|————Node:compound_statement Text: {
        ret = hex - '0';
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ret = hex - '0';
|——————Node:assignment_expression Text: ret = hex - '0'
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:binary_expression Text: hex - '0'
|————————Node:identifier Text: hex
|————————Node:- Text: -
|————————Node:char_literal Text: '0'
|—————————Node:' Text: '
|—————————Node:character Text: 0
|—————————Node:' Text: '
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (hex >= 'a' && hex <= 'f') {
        ret = hex - 'a' + 10;
    } else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (hex >= 'a' && hex <= 'f') {
        ret = hex - 'a' + 10;
    } else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (hex >= 'a' && hex <= 'f')
|———————Node:( Text: (
|———————Node:binary_expression Text: hex >= 'a' && hex <= 'f'
|————————Node:binary_expression Text: hex >= 'a'
|—————————Node:identifier Text: hex
|—————————Node:>= Text: >=
|—————————Node:char_literal Text: 'a'
|——————————Node:' Text: '
|——————————Node:character Text: a
|——————————Node:' Text: '
|————————Node:&& Text: &&
|————————Node:binary_expression Text: hex <= 'f'
|—————————Node:identifier Text: hex
|—————————Node:<= Text: <=
|—————————Node:char_literal Text: 'f'
|——————————Node:' Text: '
|——————————Node:character Text: f
|——————————Node:' Text: '
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        ret = hex - 'a' + 10;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: ret = hex - 'a' + 10;
|————————Node:assignment_expression Text: ret = hex - 'a' + 10
|—————————Node:identifier Text: ret
|—————————Node:= Text: =
|—————————Node:binary_expression Text: hex - 'a' + 10
|——————————Node:binary_expression Text: hex - 'a'
|———————————Node:identifier Text: hex
|———————————Node:- Text: -
|———————————Node:char_literal Text: 'a'
|————————————Node:' Text: '
|————————————Node:character Text: a
|————————————Node:' Text: '
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 10
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    }
|———————Node:else Text: else
|———————Node:if_statement Text: if (hex >= 'A' && hex <= 'F') {
        ret = hex - 'A' + 10;
    }
|————————Node:if Text: if
|————————Node:condition_clause Text: (hex >= 'A' && hex <= 'F')
|—————————Node:( Text: (
|—————————Node:binary_expression Text: hex >= 'A' && hex <= 'F'
|——————————Node:binary_expression Text: hex >= 'A'
|———————————Node:identifier Text: hex
|———————————Node:>= Text: >=
|———————————Node:char_literal Text: 'A'
|————————————Node:' Text: '
|————————————Node:character Text: A
|————————————Node:' Text: '
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: hex <= 'F'
|———————————Node:identifier Text: hex
|———————————Node:<= Text: <=
|———————————Node:char_literal Text: 'F'
|————————————Node:' Text: '
|————————————Node:character Text: F
|————————————Node:' Text: '
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        ret = hex - 'A' + 10;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ret = hex - 'A' + 10;
|——————————Node:assignment_expression Text: ret = hex - 'A' + 10
|———————————Node:identifier Text: ret
|———————————Node:= Text: =
|———————————Node:binary_expression Text: hex - 'A' + 10
|————————————Node:binary_expression Text: hex - 'A'
|—————————————Node:identifier Text: hex
|—————————————Node:- Text: -
|—————————————Node:char_literal Text: 'A'
|——————————————Node:' Text: '
|——————————————Node:character Text: A
|——————————————Node:' Text: '
|————————————Node:+ Text: +
|————————————Node:number_literal Text: 10
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———Node:comment Text: // else error, return 0
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U HexHelper::parseFullByte(INT8U H, INT8U L) {
    return (parseNibble(H) << 4) + parseNibble(L);
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: HexHelper::parseFullByte(INT8U H, INT8U L)
|———Node:qualified_identifier Text: HexHelper::parseFullByte
|————Node:namespace_identifier Text: HexHelper
|————Node::: Text: ::
|————Node:identifier Text: parseFullByte
|———Node:parameter_list Text: (INT8U H, INT8U L)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U H
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: H
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U L
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: L
|————Node:) Text: )
|——Node:compound_statement Text: {
    return (parseNibble(H) << 4) + parseNibble(L);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (parseNibble(H) << 4) + parseNibble(L);
|————Node:return Text: return
|————Node:binary_expression Text: (parseNibble(H) << 4) + parseNibble(L)
|—————Node:parenthesized_expression Text: (parseNibble(H) << 4)
|——————Node:( Text: (
|——————Node:binary_expression Text: parseNibble(H) << 4
|———————Node:call_expression Text: parseNibble(H)
|————————Node:identifier Text: parseNibble
|————————Node:argument_list Text: (H)
|—————————Node:( Text: (
|—————————Node:identifier Text: H
|—————————Node:) Text: )
|———————Node:<< Text: <<
|———————Node:number_literal Text: 4
|——————Node:) Text: )
|—————Node:+ Text: +
|—————Node:call_expression Text: parseNibble(L)
|——————Node:identifier Text: parseNibble
|——————Node:argument_list Text: (L)
|———————Node:( Text: (
|———————Node:identifier Text: L
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: INT8U HexHelper::parseNibbleWithLimit(INT8U hex, INT8U limit) {
    INT8U ret = parseNibble(hex);
    if (ret < limit)
        return ret;
    else
        return 0;
}
|——Node:type_identifier Text: INT8U
|——Node:function_declarator Text: HexHelper::parseNibbleWithLimit(INT8U hex, INT8U limit)
|———Node:qualified_identifier Text: HexHelper::parseNibbleWithLimit
|————Node:namespace_identifier Text: HexHelper
|————Node::: Text: ::
|————Node:identifier Text: parseNibbleWithLimit
|———Node:parameter_list Text: (INT8U hex, INT8U limit)
|————Node:( Text: (
|————Node:parameter_declaration Text: INT8U hex
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: hex
|————Node:, Text: ,
|————Node:parameter_declaration Text: INT8U limit
|—————Node:type_identifier Text: INT8U
|—————Node:identifier Text: limit
|————Node:) Text: )
|——Node:compound_statement Text: {
    INT8U ret = parseNibble(hex);
    if (ret < limit)
        return ret;
    else
        return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: INT8U ret = parseNibble(hex);
|————Node:type_identifier Text: INT8U
|————Node:init_declarator Text: ret = parseNibble(hex)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: parseNibble(hex)
|——————Node:identifier Text: parseNibble
|——————Node:argument_list Text: (hex)
|———————Node:( Text: (
|———————Node:identifier Text: hex
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ret < limit)
        return ret;
    else
        return 0;
|————Node:if Text: if
|————Node:condition_clause Text: (ret < limit)
|—————Node:( Text: (
|—————Node:binary_expression Text: ret < limit
|——————Node:identifier Text: ret
|——————Node:< Text: <
|——————Node:identifier Text: limit
|—————Node:) Text: )
|————Node:return_statement Text: return ret;
|—————Node:return Text: return
|—————Node:identifier Text: ret
|—————Node:; Text: ;
|————Node:else_clause Text: else
        return 0;
|—————Node:else Text: else
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|———Node:} Text: }
