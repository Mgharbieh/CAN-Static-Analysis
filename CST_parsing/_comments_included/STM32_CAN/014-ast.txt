STM32_CAN-STM32_CAN.cpp

|Node:translation_unit
|—Node:comment Text: /* -------------------------------------------------------------------------------------------
 simpel CAN driver for stm32 devices using HAL

 Before you can use this driver you need to enable the CAN module in the HAL configuration file,
 for a stm32f103 blue board you have to find the stm32f1xx_hal_conf.h 
 file and uncomment #define HAL_CAN_MODULE_ENABLED
 
 This can be used in a C++ projects by replacing the
 #include <Arduino.h> with the include for the used HAL for example;  
 #include <stm32f1xx_hal.h>
 
 Inspired by the following giving me the input needed to make this work:
 https://github.com/jiauka/stm32Can
 https://gist.github.com/Arman92/154e2540847b32c44c29
 https://github.com/collin80
 st's CAN examples and documentation
 
---------------------------------------------------------------------------------------------*/
|—Node:preproc_include Text: #include "STM32_CAN.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "STM32_CAN.h"
|———Node:" Text: "
|———Node:string_content Text: STM32_CAN.h
|———Node:" Text: "
|—Node:declaration Text: stm32Can *pointerToClass;
|——Node:type_identifier Text: stm32Can
|——Node:pointer_declarator Text: *pointerToClass
|———Node:* Text: *
|———Node:identifier Text: pointerToClass
|——Node:; Text: ;
|—Node:comment Text: // declare a pointer to stm32Can class
|—Node:comment Text: /* Constructor */
|—Node:function_definition Text: stm32Can::stm32Can( CAN_HandleTypeDef* pCanHandle, int portNumber ) {

  if (_canIsActive) { return; }

  n_pCanHandle = pCanHandle;
  
  sizeRxBuffer=SIZE_RX_BUFFER; //default value, use setRxBufferSize to change it before begin
  sizeTxBuffer=SIZE_TX_BUFFER; //default value, use setTxBufferSize to change it before begin

  _portNumber = portNumber;
}
|——Node:function_declarator Text: stm32Can::stm32Can( CAN_HandleTypeDef* pCanHandle, int portNumber )
|———Node:qualified_identifier Text: stm32Can::stm32Can
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: stm32Can
|———Node:parameter_list Text: ( CAN_HandleTypeDef* pCanHandle, int portNumber )
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_HandleTypeDef* pCanHandle
|—————Node:type_identifier Text: CAN_HandleTypeDef
|—————Node:pointer_declarator Text: * pCanHandle
|——————Node:* Text: *
|——————Node:identifier Text: pCanHandle
|————Node:, Text: ,
|————Node:parameter_declaration Text: int portNumber
|—————Node:primitive_type Text: int
|—————Node:identifier Text: portNumber
|————Node:) Text: )
|——Node:compound_statement Text: {

  if (_canIsActive) { return; }

  n_pCanHandle = pCanHandle;
  
  sizeRxBuffer=SIZE_RX_BUFFER; //default value, use setRxBufferSize to change it before begin
  sizeTxBuffer=SIZE_TX_BUFFER; //default value, use setTxBufferSize to change it before begin

  _portNumber = portNumber;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (_canIsActive) { return; }
|————Node:if Text: if
|————Node:condition_clause Text: (_canIsActive)
|—————Node:( Text: (
|—————Node:identifier Text: _canIsActive
|—————Node:) Text: )
|————Node:compound_statement Text: { return; }
|—————Node:{ Text: {
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: n_pCanHandle = pCanHandle;
|————Node:assignment_expression Text: n_pCanHandle = pCanHandle
|—————Node:identifier Text: n_pCanHandle
|—————Node:= Text: =
|—————Node:identifier Text: pCanHandle
|————Node:; Text: ;
|———Node:expression_statement Text: sizeRxBuffer=SIZE_RX_BUFFER;
|————Node:assignment_expression Text: sizeRxBuffer=SIZE_RX_BUFFER
|—————Node:identifier Text: sizeRxBuffer
|—————Node:= Text: =
|—————Node:identifier Text: SIZE_RX_BUFFER
|————Node:; Text: ;
|———Node:comment Text: //default value, use setRxBufferSize to change it before begin
|———Node:expression_statement Text: sizeTxBuffer=SIZE_TX_BUFFER;
|————Node:assignment_expression Text: sizeTxBuffer=SIZE_TX_BUFFER
|—————Node:identifier Text: sizeTxBuffer
|—————Node:= Text: =
|—————Node:identifier Text: SIZE_TX_BUFFER
|————Node:; Text: ;
|———Node:comment Text: //default value, use setTxBufferSize to change it before begin
|———Node:expression_statement Text: _portNumber = portNumber;
|————Node:assignment_expression Text: _portNumber = portNumber
|—————Node:identifier Text: _portNumber
|—————Node:= Text: =
|—————Node:identifier Text: portNumber
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* Init and start CAN */
|—Node:function_definition Text: void stm32Can::begin( bool UseAltPins ) {
	pointerToClass = this; // assign current instance to pointer
    init( n_pCanHandle, UseAltPins );
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::begin( bool UseAltPins )
|———Node:qualified_identifier Text: stm32Can::begin
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: begin
|———Node:parameter_list Text: ( bool UseAltPins )
|————Node:( Text: (
|————Node:parameter_declaration Text: bool UseAltPins
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: UseAltPins
|————Node:) Text: )
|——Node:compound_statement Text: {
	pointerToClass = this; // assign current instance to pointer
    init( n_pCanHandle, UseAltPins );
}
|———Node:{ Text: {
|———Node:expression_statement Text: pointerToClass = this;
|————Node:assignment_expression Text: pointerToClass = this
|—————Node:identifier Text: pointerToClass
|—————Node:= Text: =
|—————Node:this Text: this
|————Node:; Text: ;
|———Node:comment Text: // assign current instance to pointer
|———Node:expression_statement Text: init( n_pCanHandle, UseAltPins );
|————Node:call_expression Text: init( n_pCanHandle, UseAltPins )
|—————Node:identifier Text: init
|—————Node:argument_list Text: ( n_pCanHandle, UseAltPins )
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: UseAltPins
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* Init and start CAN */
|—Node:function_definition Text: void stm32Can::init( CAN_HandleTypeDef* CanHandle, bool UseAltPins ) {

  /* exit if CAN already is active */
  if ( _canIsActive ) return;
  
  _canIsActive = true;
  
  GPIO_InitTypeDef GPIO_InitStruct;
  
  DEBUG(Serial.begin(115200));
  DEBUG(Serial.println("stm32Can:Begin"));
  if ( _portNumber == 1 ) {
  DEBUG(Serial.println("CAN1"));
  }
  
  initializeBuffers();
  
  /* Configure CAN **************************************************/
  /* Struct init*/
  if ( _portNumber == 1 )
  {
    __HAL_RCC_CAN1_CLK_ENABLE();
  
    /* Enable GPIO clock */
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    if(UseAltPins) {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN1 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn );
	/* NVIC configuration for CAN1 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 );
    HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    
    CanHandle->Instance = CAN1;
  }
#ifdef CAN2  
  else
  {
     /* USER CODE END CAN2_MspInit 0 */
    /* CAN2 clock enable */
	#if defined(STM32F1xx)
    __HAL_RCC_CAN2_CLK_ENABLE();

    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
    #endif
    if(UseAltPins) {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN2 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN2_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_RX0_IRQn );
	/* NVIC configuration for CAN2 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN2_TX_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    
    CanHandle->Instance = CAN2;
  }
#endif

  CanHandle->Init.TimeTriggeredMode = DISABLE;
  CanHandle->Init.AutoBusOff = DISABLE;
  CanHandle->Init.AutoWakeUp = DISABLE;
  CanHandle->Init.AutoRetransmission  = DISABLE;
  CanHandle->Init.ReceiveFifoLocked  = DISABLE;
  CanHandle->Init.TransmitFifoPriority = ENABLE;
  CanHandle->Init.Mode = CAN_MODE_NORMAL;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::init( CAN_HandleTypeDef* CanHandle, bool UseAltPins )
|———Node:qualified_identifier Text: stm32Can::init
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: init
|———Node:parameter_list Text: ( CAN_HandleTypeDef* CanHandle, bool UseAltPins )
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_HandleTypeDef* CanHandle
|—————Node:type_identifier Text: CAN_HandleTypeDef
|—————Node:pointer_declarator Text: * CanHandle
|——————Node:* Text: *
|——————Node:identifier Text: CanHandle
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool UseAltPins
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: UseAltPins
|————Node:) Text: )
|——Node:compound_statement Text: {

  /* exit if CAN already is active */
  if ( _canIsActive ) return;
  
  _canIsActive = true;
  
  GPIO_InitTypeDef GPIO_InitStruct;
  
  DEBUG(Serial.begin(115200));
  DEBUG(Serial.println("stm32Can:Begin"));
  if ( _portNumber == 1 ) {
  DEBUG(Serial.println("CAN1"));
  }
  
  initializeBuffers();
  
  /* Configure CAN **************************************************/
  /* Struct init*/
  if ( _portNumber == 1 )
  {
    __HAL_RCC_CAN1_CLK_ENABLE();
  
    /* Enable GPIO clock */
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    if(UseAltPins) {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN1 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn );
	/* NVIC configuration for CAN1 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 );
    HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    
    CanHandle->Instance = CAN1;
  }
#ifdef CAN2  
  else
  {
     /* USER CODE END CAN2_MspInit 0 */
    /* CAN2 clock enable */
	#if defined(STM32F1xx)
    __HAL_RCC_CAN2_CLK_ENABLE();

    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
    #endif
    if(UseAltPins) {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN2 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN2_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_RX0_IRQn );
	/* NVIC configuration for CAN2 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN2_TX_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    
    CanHandle->Instance = CAN2;
  }
#endif

  CanHandle->Init.TimeTriggeredMode = DISABLE;
  CanHandle->Init.AutoBusOff = DISABLE;
  CanHandle->Init.AutoWakeUp = DISABLE;
  CanHandle->Init.AutoRetransmission  = DISABLE;
  CanHandle->Init.ReceiveFifoLocked  = DISABLE;
  CanHandle->Init.TransmitFifoPriority = ENABLE;
  CanHandle->Init.Mode = CAN_MODE_NORMAL;
}
|———Node:{ Text: {
|———Node:comment Text: /* exit if CAN already is active */
|———Node:if_statement Text: if ( _canIsActive ) return;
|————Node:if Text: if
|————Node:condition_clause Text: ( _canIsActive )
|—————Node:( Text: (
|—————Node:identifier Text: _canIsActive
|—————Node:) Text: )
|————Node:return_statement Text: return;
|—————Node:return Text: return
|—————Node:; Text: ;
|———Node:expression_statement Text: _canIsActive = true;
|————Node:assignment_expression Text: _canIsActive = true
|—————Node:identifier Text: _canIsActive
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:declaration Text: GPIO_InitTypeDef GPIO_InitStruct;
|————Node:type_identifier Text: GPIO_InitTypeDef
|————Node:identifier Text: GPIO_InitStruct
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.begin(115200));
|————Node:call_expression Text: DEBUG(Serial.begin(115200))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.begin(115200))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.begin(115200)
|———————Node:field_expression Text: Serial.begin
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: begin
|———————Node:argument_list Text: (115200)
|————————Node:( Text: (
|————————Node:number_literal Text: 115200
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println("stm32Can:Begin"));
|————Node:call_expression Text: DEBUG(Serial.println("stm32Can:Begin"))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println("stm32Can:Begin"))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println("stm32Can:Begin")
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ("stm32Can:Begin")
|————————Node:( Text: (
|————————Node:string_literal Text: "stm32Can:Begin"
|—————————Node:" Text: "
|—————————Node:string_content Text: stm32Can:Begin
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( _portNumber == 1 ) {
  DEBUG(Serial.println("CAN1"));
  }
|————Node:if Text: if
|————Node:condition_clause Text: ( _portNumber == 1 )
|—————Node:( Text: (
|—————Node:binary_expression Text: _portNumber == 1
|——————Node:identifier Text: _portNumber
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
  DEBUG(Serial.println("CAN1"));
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: DEBUG(Serial.println("CAN1"));
|——————Node:call_expression Text: DEBUG(Serial.println("CAN1"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("CAN1"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("CAN1")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("CAN1")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN1"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN1
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: initializeBuffers();
|————Node:call_expression Text: initializeBuffers()
|—————Node:identifier Text: initializeBuffers
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Configure CAN **************************************************/
|———Node:comment Text: /* Struct init*/
|———Node:if_statement Text: if ( _portNumber == 1 )
  {
    __HAL_RCC_CAN1_CLK_ENABLE();
  
    /* Enable GPIO clock */
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    if(UseAltPins) {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN1 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn );
	/* NVIC configuration for CAN1 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 );
    HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    
    CanHandle->Instance = CAN1;
  }
|————Node:if Text: if
|————Node:condition_clause Text: ( _portNumber == 1 )
|—————Node:( Text: (
|—————Node:binary_expression Text: _portNumber == 1
|——————Node:identifier Text: _portNumber
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
    __HAL_RCC_CAN1_CLK_ENABLE();
  
    /* Enable GPIO clock */
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    if(UseAltPins) {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN1 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn );
	/* NVIC configuration for CAN1 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 );
    HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    
    CanHandle->Instance = CAN1;
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: __HAL_RCC_CAN1_CLK_ENABLE();
|——————Node:call_expression Text: __HAL_RCC_CAN1_CLK_ENABLE()
|———————Node:identifier Text: __HAL_RCC_CAN1_CLK_ENABLE
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* Enable GPIO clock */
|—————Node:expression_statement Text: __HAL_RCC_GPIOB_CLK_ENABLE();
|——————Node:call_expression Text: __HAL_RCC_GPIOB_CLK_ENABLE()
|———————Node:identifier Text: __HAL_RCC_GPIOB_CLK_ENABLE
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if(UseAltPins) {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (UseAltPins)
|———————Node:( Text: (
|———————Node:identifier Text: UseAltPins
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_8;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }
|———————Node:{ Text: {
|———————Node:comment Text: /* Enable AFIO clock and remap CAN PINs to PB_8 and PB_9*/
|———————Node:preproc_if Text: #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
      __HAL_AFIO_REMAP_CAN1_2();
      #endif
|————————Node:#if Text: #if
|————————Node:preproc_defined Text: defined(STM32F1xx)
|—————————Node:defined Text: defined
|—————————Node:( Text: (
|—————————Node:identifier Text: STM32F1xx
|—————————Node:) Text: )
|————————Node:
 Text: 

|————————Node:expression_statement Text: __HAL_RCC_AFIO_CLK_ENABLE();
|—————————Node:call_expression Text: __HAL_RCC_AFIO_CLK_ENABLE()
|——————————Node:identifier Text: __HAL_RCC_AFIO_CLK_ENABLE
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: __HAL_AFIO_REMAP_CAN1_2();
|—————————Node:call_expression Text: __HAL_AFIO_REMAP_CAN1_2()
|——————————Node:identifier Text: __HAL_AFIO_REMAP_CAN1_2
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:comment Text: /* CAN1 RX GPIO pin configuration */
|———————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_8;
|————————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_8
|—————————Node:field_expression Text: GPIO_InitStruct.Pin
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Pin
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_PIN_8
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
|————————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_INPUT
|—————————Node:field_expression Text: GPIO_InitStruct.Mode
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Mode
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_MODE_INPUT
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Pull = GPIO_NOPULL;
|————————Node:assignment_expression Text: GPIO_InitStruct.Pull = GPIO_NOPULL
|—————————Node:field_expression Text: GPIO_InitStruct.Pull
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Pull
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_NOPULL
|————————Node:; Text: ;
|———————Node:expression_statement Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
|————————Node:call_expression Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct)
|—————————Node:identifier Text: HAL_GPIO_Init
|—————————Node:argument_list Text: (GPIOB, &GPIO_InitStruct)
|——————————Node:( Text: (
|——————————Node:identifier Text: GPIOB
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &GPIO_InitStruct
|———————————Node:& Text: &
|———————————Node:identifier Text: GPIO_InitStruct
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_9;
|————————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_9
|—————————Node:field_expression Text: GPIO_InitStruct.Pin
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Pin
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_PIN_9
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
|————————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP
|—————————Node:field_expression Text: GPIO_InitStruct.Mode
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Mode
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_MODE_AF_PP
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
|————————Node:assignment_expression Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH
|—————————Node:field_expression Text: GPIO_InitStruct.Speed
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Speed
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_SPEED_FREQ_HIGH
|————————Node:; Text: ;
|———————Node:expression_statement Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
|————————Node:call_expression Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct)
|—————————Node:identifier Text: HAL_GPIO_Init
|—————————Node:argument_list Text: (GPIOB, &GPIO_InitStruct)
|——————————Node:( Text: (
|——————————Node:identifier Text: GPIOB
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &GPIO_InitStruct
|———————————Node:& Text: &
|———————————Node:identifier Text: GPIO_InitStruct
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
	  #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
      /* CAN1 RX GPIO pin configuration */
      GPIO_InitStruct.Pin = GPIO_PIN_11;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      GPIO_InitStruct.Pin = GPIO_PIN_12;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }
|————————Node:{ Text: {
|————————Node:preproc_if Text: #if defined(STM32F1xx)
      __HAL_RCC_AFIO_CLK_ENABLE();
	  #endif
|—————————Node:#if Text: #if
|—————————Node:preproc_defined Text: defined(STM32F1xx)
|——————————Node:defined Text: defined
|——————————Node:( Text: (
|——————————Node:identifier Text: STM32F1xx
|——————————Node:) Text: )
|—————————Node:
 Text: 

|—————————Node:expression_statement Text: __HAL_RCC_AFIO_CLK_ENABLE();
|——————————Node:call_expression Text: __HAL_RCC_AFIO_CLK_ENABLE()
|———————————Node:identifier Text: __HAL_RCC_AFIO_CLK_ENABLE
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:#endif Text: #endif
|————————Node:comment Text: /* CAN1 RX GPIO pin configuration */
|————————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_11;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_11
|——————————Node:field_expression Text: GPIO_InitStruct.Pin
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Pin
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_PIN_11
|—————————Node:; Text: ;
|————————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_INPUT
|——————————Node:field_expression Text: GPIO_InitStruct.Mode
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Mode
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_MODE_INPUT
|—————————Node:; Text: ;
|————————Node:expression_statement Text: GPIO_InitStruct.Pull = GPIO_NOPULL;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Pull = GPIO_NOPULL
|——————————Node:field_expression Text: GPIO_InitStruct.Pull
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Pull
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_NOPULL
|—————————Node:; Text: ;
|————————Node:expression_statement Text: HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
|—————————Node:call_expression Text: HAL_GPIO_Init(GPIOA, &GPIO_InitStruct)
|——————————Node:identifier Text: HAL_GPIO_Init
|——————————Node:argument_list Text: (GPIOA, &GPIO_InitStruct)
|———————————Node:( Text: (
|———————————Node:identifier Text: GPIOA
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &GPIO_InitStruct
|————————————Node:& Text: &
|————————————Node:identifier Text: GPIO_InitStruct
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_12;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_12
|——————————Node:field_expression Text: GPIO_InitStruct.Pin
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Pin
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_PIN_12
|—————————Node:; Text: ;
|————————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP
|——————————Node:field_expression Text: GPIO_InitStruct.Mode
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Mode
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_MODE_AF_PP
|—————————Node:; Text: ;
|————————Node:expression_statement Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
|—————————Node:assignment_expression Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH
|——————————Node:field_expression Text: GPIO_InitStruct.Speed
|———————————Node:identifier Text: GPIO_InitStruct
|———————————Node:. Text: .
|———————————Node:field_identifier Text: Speed
|——————————Node:= Text: =
|——————————Node:identifier Text: GPIO_SPEED_FREQ_HIGH
|—————————Node:; Text: ;
|————————Node:expression_statement Text: HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
|—————————Node:call_expression Text: HAL_GPIO_Init(GPIOA, &GPIO_InitStruct)
|——————————Node:identifier Text: HAL_GPIO_Init
|——————————Node:argument_list Text: (GPIOA, &GPIO_InitStruct)
|———————————Node:( Text: (
|———————————Node:identifier Text: GPIOA
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &GPIO_InitStruct
|————————————Node:& Text: &
|————————————Node:identifier Text: GPIO_InitStruct
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:comment Text: /*##-3- Configure the NVIC #################################################*/
|—————Node:comment Text: /* NVIC configuration for CAN1 Reception complete interrupt */
|—————Node:expression_statement Text: HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 );
|——————Node:call_expression Text: HAL_NVIC_SetPriority( CAN1_RX0_IRQn, 4, 0 )
|———————Node:identifier Text: HAL_NVIC_SetPriority
|———————Node:argument_list Text: ( CAN1_RX0_IRQn, 4, 0 )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_RX0_IRQn
|————————Node:, Text: ,
|————————Node:number_literal Text: 4
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn );
|——————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN1_RX0_IRQn )
|———————Node:identifier Text: HAL_NVIC_EnableIRQ
|———————Node:argument_list Text: ( CAN1_RX0_IRQn )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_RX0_IRQn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* NVIC configuration for CAN1 Transmission complete interrupt */
|—————Node:expression_statement Text: HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 );
|——————Node:call_expression Text: HAL_NVIC_SetPriority( CAN1_TX_IRQn, 3, 0 )
|———————Node:identifier Text: HAL_NVIC_SetPriority
|———————Node:argument_list Text: ( CAN1_TX_IRQn, 3, 0 )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_TX_IRQn
|————————Node:, Text: ,
|————————Node:number_literal Text: 3
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
|——————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN1_TX_IRQn )
|———————Node:identifier Text: HAL_NVIC_EnableIRQ
|———————Node:argument_list Text: ( CAN1_TX_IRQn )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_TX_IRQn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: CanHandle->Instance = CAN1;
|——————Node:assignment_expression Text: CanHandle->Instance = CAN1
|———————Node:field_expression Text: CanHandle->Instance
|————————Node:identifier Text: CanHandle
|————————Node:-> Text: ->
|————————Node:field_identifier Text: Instance
|———————Node:= Text: =
|———————Node:identifier Text: CAN1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_ifdef Text: #ifdef CAN2  
  else
  {
     /* USER CODE END CAN2_MspInit 0 */
    /* CAN2 clock enable */
	#if defined(STM32F1xx)
    __HAL_RCC_CAN2_CLK_ENABLE();

    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
    #endif
    if(UseAltPins) {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }

    /*##-3- Configure the NVIC #################################################*/
    /* NVIC configuration for CAN2 Reception complete interrupt */
    HAL_NVIC_SetPriority( CAN2_RX0_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_RX0_IRQn );
	/* NVIC configuration for CAN2 Transmission complete interrupt */
    HAL_NVIC_SetPriority( CAN2_TX_IRQn, 4, 0 );
    HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    
    CanHandle->Instance = CAN2;
  }
#endif
|————Node:#ifdef Text: #ifdef
|————Node:identifier Text: CAN2
|————Node:ERROR Text: else
  {
|—————Node:type_identifier Text: else
|—————Node:{ Text: {
|————Node:comment Text: /* USER CODE END CAN2_MspInit 0 */
|————Node:comment Text: /* CAN2 clock enable */
|————Node:preproc_if Text: #if defined(STM32F1xx)
    __HAL_RCC_CAN2_CLK_ENABLE();

    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
    #endif
|—————Node:#if Text: #if
|—————Node:preproc_defined Text: defined(STM32F1xx)
|——————Node:defined Text: defined
|——————Node:( Text: (
|——————Node:identifier Text: STM32F1xx
|——————Node:) Text: )
|—————Node:
 Text: 

|—————Node:expression_statement Text: __HAL_RCC_CAN2_CLK_ENABLE();
|——————Node:call_expression Text: __HAL_RCC_CAN2_CLK_ENABLE()
|———————Node:identifier Text: __HAL_RCC_CAN2_CLK_ENABLE
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: HAL_RCC_CAN1_CLK_ENABLED++;
|——————Node:update_expression Text: HAL_RCC_CAN1_CLK_ENABLED++
|———————Node:identifier Text: HAL_RCC_CAN1_CLK_ENABLED
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:if_statement Text: if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (HAL_RCC_CAN1_CLK_ENABLED==1)
|———————Node:( Text: (
|———————Node:binary_expression Text: HAL_RCC_CAN1_CLK_ENABLED==1
|————————Node:identifier Text: HAL_RCC_CAN1_CLK_ENABLED
|————————Node:== Text: ==
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      __HAL_RCC_CAN1_CLK_ENABLE();
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: __HAL_RCC_CAN1_CLK_ENABLE();
|————————Node:call_expression Text: __HAL_RCC_CAN1_CLK_ENABLE()
|—————————Node:identifier Text: __HAL_RCC_CAN1_CLK_ENABLE
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:#endif Text: #endif
|————Node:if_statement Text: if(UseAltPins) {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    } 
    else {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }
|—————Node:if Text: if
|—————Node:condition_clause Text: (UseAltPins)
|——————Node:( Text: (
|——————Node:identifier Text: UseAltPins
|——————Node:) Text: )
|—————Node:compound_statement Text: {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: __HAL_RCC_GPIOB_CLK_ENABLE();
|———————Node:call_expression Text: __HAL_RCC_GPIOB_CLK_ENABLE()
|————————Node:identifier Text: __HAL_RCC_GPIOB_CLK_ENABLE
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: /**CAN2 GPIO Configuration    
      PB5     ------> CAN2_RX
      PB6     ------> CAN2_TX 
      */
|——————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
|———————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6
|————————Node:field_expression Text: GPIO_InitStruct.Pin
|—————————Node:identifier Text: GPIO_InitStruct
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Pin
|————————Node:= Text: =
|————————Node:binary_expression Text: GPIO_PIN_5|GPIO_PIN_6
|—————————Node:identifier Text: GPIO_PIN_5
|—————————Node:| Text: |
|—————————Node:identifier Text: GPIO_PIN_6
|———————Node:; Text: ;
|——————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
|———————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP
|————————Node:field_expression Text: GPIO_InitStruct.Mode
|—————————Node:identifier Text: GPIO_InitStruct
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Mode
|————————Node:= Text: =
|————————Node:identifier Text: GPIO_MODE_AF_PP
|———————Node:; Text: ;
|——————Node:expression_statement Text: GPIO_InitStruct.Pull = GPIO_NOPULL;
|———————Node:assignment_expression Text: GPIO_InitStruct.Pull = GPIO_NOPULL
|————————Node:field_expression Text: GPIO_InitStruct.Pull
|—————————Node:identifier Text: GPIO_InitStruct
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Pull
|————————Node:= Text: =
|————————Node:identifier Text: GPIO_NOPULL
|———————Node:; Text: ;
|——————Node:expression_statement Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
|———————Node:assignment_expression Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH
|————————Node:field_expression Text: GPIO_InitStruct.Speed
|—————————Node:identifier Text: GPIO_InitStruct
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Speed
|————————Node:= Text: =
|————————Node:identifier Text: GPIO_SPEED_FREQ_VERY_HIGH
|———————Node:; Text: ;
|——————Node:expression_statement Text: GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
|———————Node:assignment_expression Text: GPIO_InitStruct.Alternate = GPIO_AF9_CAN2
|————————Node:field_expression Text: GPIO_InitStruct.Alternate
|—————————Node:identifier Text: GPIO_InitStruct
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Alternate
|————————Node:= Text: =
|————————Node:identifier Text: GPIO_AF9_CAN2
|———————Node:; Text: ;
|——————Node:expression_statement Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
|———————Node:call_expression Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct)
|————————Node:identifier Text: HAL_GPIO_Init
|————————Node:argument_list Text: (GPIOB, &GPIO_InitStruct)
|—————————Node:( Text: (
|—————————Node:identifier Text: GPIOB
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &GPIO_InitStruct
|——————————Node:& Text: &
|——————————Node:identifier Text: GPIO_InitStruct
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
      __HAL_RCC_GPIOB_CLK_ENABLE();
      /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
      GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: __HAL_RCC_GPIOB_CLK_ENABLE();
|————————Node:call_expression Text: __HAL_RCC_GPIOB_CLK_ENABLE()
|—————————Node:identifier Text: __HAL_RCC_GPIOB_CLK_ENABLE
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: /**CAN2 GPIO Configuration    
      PB12     ------> CAN2_RX
      PB13     ------> CAN2_TX 
      */
|———————Node:expression_statement Text: GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
|————————Node:assignment_expression Text: GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13
|—————————Node:field_expression Text: GPIO_InitStruct.Pin
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Pin
|—————————Node:= Text: =
|—————————Node:binary_expression Text: GPIO_PIN_12|GPIO_PIN_13
|——————————Node:identifier Text: GPIO_PIN_12
|——————————Node:| Text: |
|——————————Node:identifier Text: GPIO_PIN_13
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
|————————Node:assignment_expression Text: GPIO_InitStruct.Mode = GPIO_MODE_AF_PP
|—————————Node:field_expression Text: GPIO_InitStruct.Mode
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Mode
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_MODE_AF_PP
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Pull = GPIO_NOPULL;
|————————Node:assignment_expression Text: GPIO_InitStruct.Pull = GPIO_NOPULL
|—————————Node:field_expression Text: GPIO_InitStruct.Pull
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Pull
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_NOPULL
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
|————————Node:assignment_expression Text: GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH
|—————————Node:field_expression Text: GPIO_InitStruct.Speed
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Speed
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_SPEED_FREQ_VERY_HIGH
|————————Node:; Text: ;
|———————Node:expression_statement Text: GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
|————————Node:assignment_expression Text: GPIO_InitStruct.Alternate = GPIO_AF9_CAN2
|—————————Node:field_expression Text: GPIO_InitStruct.Alternate
|——————————Node:identifier Text: GPIO_InitStruct
|——————————Node:. Text: .
|——————————Node:field_identifier Text: Alternate
|—————————Node:= Text: =
|—————————Node:identifier Text: GPIO_AF9_CAN2
|————————Node:; Text: ;
|———————Node:expression_statement Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
|————————Node:call_expression Text: HAL_GPIO_Init(GPIOB, &GPIO_InitStruct)
|—————————Node:identifier Text: HAL_GPIO_Init
|—————————Node:argument_list Text: (GPIOB, &GPIO_InitStruct)
|——————————Node:( Text: (
|——————————Node:identifier Text: GPIOB
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &GPIO_InitStruct
|———————————Node:& Text: &
|———————————Node:identifier Text: GPIO_InitStruct
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|————Node:comment Text: /*##-3- Configure the NVIC #################################################*/
|————Node:comment Text: /* NVIC configuration for CAN2 Reception complete interrupt */
|————Node:expression_statement Text: HAL_NVIC_SetPriority( CAN2_RX0_IRQn, 4, 0 );
|—————Node:call_expression Text: HAL_NVIC_SetPriority( CAN2_RX0_IRQn, 4, 0 )
|——————Node:identifier Text: HAL_NVIC_SetPriority
|——————Node:argument_list Text: ( CAN2_RX0_IRQn, 4, 0 )
|———————Node:( Text: (
|———————Node:identifier Text: CAN2_RX0_IRQn
|———————Node:, Text: ,
|———————Node:number_literal Text: 4
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: HAL_NVIC_EnableIRQ( CAN2_RX0_IRQn );
|—————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN2_RX0_IRQn )
|——————Node:identifier Text: HAL_NVIC_EnableIRQ
|——————Node:argument_list Text: ( CAN2_RX0_IRQn )
|———————Node:( Text: (
|———————Node:identifier Text: CAN2_RX0_IRQn
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:comment Text: /* NVIC configuration for CAN2 Transmission complete interrupt */
|————Node:expression_statement Text: HAL_NVIC_SetPriority( CAN2_TX_IRQn, 4, 0 );
|—————Node:call_expression Text: HAL_NVIC_SetPriority( CAN2_TX_IRQn, 4, 0 )
|——————Node:identifier Text: HAL_NVIC_SetPriority
|——————Node:argument_list Text: ( CAN2_TX_IRQn, 4, 0 )
|———————Node:( Text: (
|———————Node:identifier Text: CAN2_TX_IRQn
|———————Node:, Text: ,
|———————Node:number_literal Text: 4
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
|—————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN2_TX_IRQn )
|——————Node:identifier Text: HAL_NVIC_EnableIRQ
|——————Node:argument_list Text: ( CAN2_TX_IRQn )
|———————Node:( Text: (
|———————Node:identifier Text: CAN2_TX_IRQn
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: CanHandle->Instance = CAN2;
|—————Node:assignment_expression Text: CanHandle->Instance = CAN2
|——————Node:field_expression Text: CanHandle->Instance
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Instance
|——————Node:= Text: =
|——————Node:identifier Text: CAN2
|—————Node:; Text: ;
|————Node:ERROR Text: }
|—————Node:} Text: }
|————Node:#endif Text: #endif
|———Node:expression_statement Text: CanHandle->Init.TimeTriggeredMode = DISABLE;
|————Node:assignment_expression Text: CanHandle->Init.TimeTriggeredMode = DISABLE
|—————Node:field_expression Text: CanHandle->Init.TimeTriggeredMode
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: TimeTriggeredMode
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.AutoBusOff = DISABLE;
|————Node:assignment_expression Text: CanHandle->Init.AutoBusOff = DISABLE
|—————Node:field_expression Text: CanHandle->Init.AutoBusOff
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: AutoBusOff
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.AutoWakeUp = DISABLE;
|————Node:assignment_expression Text: CanHandle->Init.AutoWakeUp = DISABLE
|—————Node:field_expression Text: CanHandle->Init.AutoWakeUp
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: AutoWakeUp
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.AutoRetransmission  = DISABLE;
|————Node:assignment_expression Text: CanHandle->Init.AutoRetransmission  = DISABLE
|—————Node:field_expression Text: CanHandle->Init.AutoRetransmission
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: AutoRetransmission
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.ReceiveFifoLocked  = DISABLE;
|————Node:assignment_expression Text: CanHandle->Init.ReceiveFifoLocked  = DISABLE
|—————Node:field_expression Text: CanHandle->Init.ReceiveFifoLocked
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: ReceiveFifoLocked
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.TransmitFifoPriority = ENABLE;
|————Node:assignment_expression Text: CanHandle->Init.TransmitFifoPriority = ENABLE
|—————Node:field_expression Text: CanHandle->Init.TransmitFifoPriority
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: TransmitFifoPriority
|—————Node:= Text: =
|—————Node:identifier Text: ENABLE
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.Mode = CAN_MODE_NORMAL;
|————Node:assignment_expression Text: CanHandle->Init.Mode = CAN_MODE_NORMAL
|—————Node:field_expression Text: CanHandle->Init.Mode
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: Mode
|—————Node:= Text: =
|—————Node:identifier Text: CAN_MODE_NORMAL
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::setBaudRate( uint32_t baudrate ) {

  CAN_FilterTypeDef sFilterConfig;
  /* Calculate and set baudrate */
  calculateBaudrate( n_pCanHandle, baudrate );

  /*Initializes CAN */
  HAL_CAN_Init( n_pCanHandle );

  /* CAN filter init */
   if ( _portNumber == 1 ) {
	sFilterConfig.FilterBank = 0; // Can1 0 to 13
   } else {
	sFilterConfig.FilterBank = 14; // Can2 14 to 27
   }
  sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
  sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
  sFilterConfig.FilterIdHigh = 0x0000;
  sFilterConfig.FilterIdLow = 0x0000;
  sFilterConfig.FilterMaskIdHigh = 0x0000;
  sFilterConfig.FilterMaskIdLow = 0x0000;
  sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
  sFilterConfig.FilterActivation = ENABLE;
  sFilterConfig.SlaveStartFilterBank = 14; // Define that filter bank from 14 to 27 are for Can2, this is not relevant for devices with only one CAN
  
  if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
  {
    /* Filter configuration Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error configuring filter"));
  }

  /* Start the CAN peripheral */
  if (HAL_CAN_Start( n_pCanHandle ) != HAL_OK)
  {
    /* Start Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error starting"));
  }

  /* Activate CAN RX notification */
  if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating int"));
  }
  /* Activate CAN TX notification */
  if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating TX int"));
  }
  if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 startet"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 startet"));}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::setBaudRate( uint32_t baudrate )
|———Node:qualified_identifier Text: stm32Can::setBaudRate
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: setBaudRate
|———Node:parameter_list Text: ( uint32_t baudrate )
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t baudrate
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: baudrate
|————Node:) Text: )
|——Node:compound_statement Text: {

  CAN_FilterTypeDef sFilterConfig;
  /* Calculate and set baudrate */
  calculateBaudrate( n_pCanHandle, baudrate );

  /*Initializes CAN */
  HAL_CAN_Init( n_pCanHandle );

  /* CAN filter init */
   if ( _portNumber == 1 ) {
	sFilterConfig.FilterBank = 0; // Can1 0 to 13
   } else {
	sFilterConfig.FilterBank = 14; // Can2 14 to 27
   }
  sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
  sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
  sFilterConfig.FilterIdHigh = 0x0000;
  sFilterConfig.FilterIdLow = 0x0000;
  sFilterConfig.FilterMaskIdHigh = 0x0000;
  sFilterConfig.FilterMaskIdLow = 0x0000;
  sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
  sFilterConfig.FilterActivation = ENABLE;
  sFilterConfig.SlaveStartFilterBank = 14; // Define that filter bank from 14 to 27 are for Can2, this is not relevant for devices with only one CAN
  
  if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
  {
    /* Filter configuration Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error configuring filter"));
  }

  /* Start the CAN peripheral */
  if (HAL_CAN_Start( n_pCanHandle ) != HAL_OK)
  {
    /* Start Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error starting"));
  }

  /* Activate CAN RX notification */
  if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating int"));
  }
  /* Activate CAN TX notification */
  if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating TX int"));
  }
  if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 startet"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 startet"));}
}
|———Node:{ Text: {
|———Node:declaration Text: CAN_FilterTypeDef sFilterConfig;
|————Node:type_identifier Text: CAN_FilterTypeDef
|————Node:identifier Text: sFilterConfig
|————Node:; Text: ;
|———Node:comment Text: /* Calculate and set baudrate */
|———Node:expression_statement Text: calculateBaudrate( n_pCanHandle, baudrate );
|————Node:call_expression Text: calculateBaudrate( n_pCanHandle, baudrate )
|—————Node:identifier Text: calculateBaudrate
|—————Node:argument_list Text: ( n_pCanHandle, baudrate )
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: baudrate
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*Initializes CAN */
|———Node:expression_statement Text: HAL_CAN_Init( n_pCanHandle );
|————Node:call_expression Text: HAL_CAN_Init( n_pCanHandle )
|—————Node:identifier Text: HAL_CAN_Init
|—————Node:argument_list Text: ( n_pCanHandle )
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* CAN filter init */
|———Node:if_statement Text: if ( _portNumber == 1 ) {
	sFilterConfig.FilterBank = 0; // Can1 0 to 13
   } else {
	sFilterConfig.FilterBank = 14; // Can2 14 to 27
   }
|————Node:if Text: if
|————Node:condition_clause Text: ( _portNumber == 1 )
|—————Node:( Text: (
|—————Node:binary_expression Text: _portNumber == 1
|——————Node:identifier Text: _portNumber
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
	sFilterConfig.FilterBank = 0; // Can1 0 to 13
   }
|—————Node:{ Text: {
|—————Node:expression_statement Text: sFilterConfig.FilterBank = 0;
|——————Node:assignment_expression Text: sFilterConfig.FilterBank = 0
|———————Node:field_expression Text: sFilterConfig.FilterBank
|————————Node:identifier Text: sFilterConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: FilterBank
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:comment Text: // Can1 0 to 13
|—————Node:} Text: }
|————Node:else_clause Text: else {
	sFilterConfig.FilterBank = 14; // Can2 14 to 27
   }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
	sFilterConfig.FilterBank = 14; // Can2 14 to 27
   }
|——————Node:{ Text: {
|——————Node:expression_statement Text: sFilterConfig.FilterBank = 14;
|———————Node:assignment_expression Text: sFilterConfig.FilterBank = 14
|————————Node:field_expression Text: sFilterConfig.FilterBank
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterBank
|————————Node:= Text: =
|————————Node:number_literal Text: 14
|———————Node:; Text: ;
|——————Node:comment Text: // Can2 14 to 27
|——————Node:} Text: }
|———Node:expression_statement Text: sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
|————Node:assignment_expression Text: sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK
|—————Node:field_expression Text: sFilterConfig.FilterMode
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterMode
|—————Node:= Text: =
|—————Node:identifier Text: CAN_FILTERMODE_IDMASK
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
|————Node:assignment_expression Text: sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT
|—————Node:field_expression Text: sFilterConfig.FilterScale
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterScale
|—————Node:= Text: =
|—————Node:identifier Text: CAN_FILTERSCALE_32BIT
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterIdHigh = 0x0000;
|————Node:assignment_expression Text: sFilterConfig.FilterIdHigh = 0x0000
|—————Node:field_expression Text: sFilterConfig.FilterIdHigh
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterIdHigh
|—————Node:= Text: =
|—————Node:number_literal Text: 0x0000
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterIdLow = 0x0000;
|————Node:assignment_expression Text: sFilterConfig.FilterIdLow = 0x0000
|—————Node:field_expression Text: sFilterConfig.FilterIdLow
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterIdLow
|—————Node:= Text: =
|—————Node:number_literal Text: 0x0000
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterMaskIdHigh = 0x0000;
|————Node:assignment_expression Text: sFilterConfig.FilterMaskIdHigh = 0x0000
|—————Node:field_expression Text: sFilterConfig.FilterMaskIdHigh
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterMaskIdHigh
|—————Node:= Text: =
|—————Node:number_literal Text: 0x0000
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterMaskIdLow = 0x0000;
|————Node:assignment_expression Text: sFilterConfig.FilterMaskIdLow = 0x0000
|—————Node:field_expression Text: sFilterConfig.FilterMaskIdLow
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterMaskIdLow
|—————Node:= Text: =
|—————Node:number_literal Text: 0x0000
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
|————Node:assignment_expression Text: sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0
|—————Node:field_expression Text: sFilterConfig.FilterFIFOAssignment
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterFIFOAssignment
|—————Node:= Text: =
|—————Node:identifier Text: CAN_RX_FIFO0
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterActivation = ENABLE;
|————Node:assignment_expression Text: sFilterConfig.FilterActivation = ENABLE
|—————Node:field_expression Text: sFilterConfig.FilterActivation
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterActivation
|—————Node:= Text: =
|—————Node:identifier Text: ENABLE
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.SlaveStartFilterBank = 14;
|————Node:assignment_expression Text: sFilterConfig.SlaveStartFilterBank = 14
|—————Node:field_expression Text: sFilterConfig.SlaveStartFilterBank
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: SlaveStartFilterBank
|—————Node:= Text: =
|—————Node:number_literal Text: 14
|————Node:; Text: ;
|———Node:comment Text: // Define that filter bank from 14 to 27 are for Can2, this is not relevant for devices with only one CAN
|———Node:if_statement Text: if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
  {
    /* Filter configuration Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error configuring filter"));
  }
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig )
|———————Node:identifier Text: HAL_CAN_ConfigFilter
|———————Node:argument_list Text: ( n_pCanHandle, &sFilterConfig )
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &sFilterConfig
|—————————Node:& Text: &
|—————————Node:identifier Text: sFilterConfig
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
    /* Filter configuration Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error configuring filter"));
  }
|—————Node:{ Text: {
|—————Node:comment Text: /* Filter configuration Error */
|—————Node:comment Text: //Error_Handler();
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - error configuring filter"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - error configuring filter"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - error configuring filter"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - error configuring filter")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - error configuring filter")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - error configuring filter"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - error configuring filter
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Start the CAN peripheral */
|———Node:if_statement Text: if (HAL_CAN_Start( n_pCanHandle ) != HAL_OK)
  {
    /* Start Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error starting"));
  }
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_Start( n_pCanHandle ) != HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_Start( n_pCanHandle ) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_Start( n_pCanHandle )
|———————Node:identifier Text: HAL_CAN_Start
|———————Node:argument_list Text: ( n_pCanHandle )
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
    /* Start Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error starting"));
  }
|—————Node:{ Text: {
|—————Node:comment Text: /* Start Error */
|—————Node:comment Text: //Error_Handler();
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - error starting"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - error starting"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - error starting"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - error starting")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - error starting")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - error starting"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - error starting
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Activate CAN RX notification */
|———Node:if_statement Text: if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating int"));
  }
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING)
|———————Node:identifier Text: HAL_CAN_ActivateNotification
|———————Node:argument_list Text: ( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING)
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_IT_RX_FIFO0_MSG_PENDING
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating int"));
  }
|—————Node:{ Text: {
|—————Node:comment Text: /* Notification Error */
|—————Node:comment Text: //Error_Handler();
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - error activating int"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - error activating int"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - error activating int"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - error activating int")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - error activating int")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - error activating int"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - error activating int
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Activate CAN TX notification */
|———Node:if_statement Text: if (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK)
  {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating TX int"));
  }
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_ActivateNotification( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|———————Node:identifier Text: HAL_CAN_ActivateNotification
|———————Node:argument_list Text: ( n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_IT_TX_MAILBOX_EMPTY
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
    /* Notification Error */
    //Error_Handler();
    DEBUG(Serial.println("stm32Can - error activating TX int"));
  }
|—————Node:{ Text: {
|—————Node:comment Text: /* Notification Error */
|—————Node:comment Text: //Error_Handler();
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - error activating TX int"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - error activating TX int"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - error activating TX int"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - error activating TX int")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - error activating TX int")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - error activating TX int"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - error activating TX int
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 startet"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 startet"));}
|————Node:if Text: if
|————Node:condition_clause Text: (n_pCanHandle->Instance == CAN1)
|—————Node:( Text: (
|—————Node:binary_expression Text: n_pCanHandle->Instance == CAN1
|——————Node:field_expression Text: n_pCanHandle->Instance
|———————Node:identifier Text: n_pCanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Instance
|——————Node:== Text: ==
|——————Node:identifier Text: CAN1
|—————Node:) Text: )
|————Node:compound_statement Text: {DEBUG(Serial.println("stm32Can - CAN1 startet"));}
|—————Node:{ Text: {
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - CAN1 startet"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - CAN1 startet"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - CAN1 startet"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - CAN1 startet")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - CAN1 startet")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - CAN1 startet"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - CAN1 startet
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {DEBUG(Serial.println("stm32Can - CAN2 startet"));}
|—————Node:else Text: else
|—————Node:compound_statement Text: {DEBUG(Serial.println("stm32Can - CAN2 startet"));}
|——————Node:{ Text: {
|——————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - CAN2 startet"));
|———————Node:call_expression Text: DEBUG(Serial.println("stm32Can - CAN2 startet"))
|————————Node:identifier Text: DEBUG
|————————Node:argument_list Text: (Serial.println("stm32Can - CAN2 startet"))
|—————————Node:( Text: (
|—————————Node:call_expression Text: Serial.println("stm32Can - CAN2 startet")
|——————————Node:field_expression Text: Serial.println
|———————————Node:identifier Text: Serial
|———————————Node:. Text: .
|———————————Node:field_identifier Text: println
|——————————Node:argument_list Text: ("stm32Can - CAN2 startet")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "stm32Can - CAN2 startet"
|————————————Node:" Text: "
|————————————Node:string_content Text: stm32Can - CAN2 startet
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool stm32Can::write(CAN_message_t &msg, bool wait_sent) {
  if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 write"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 write"));}
  bool ret = true;
  uint32_t TxMailbox;
  CAN_TxHeaderTypeDef TxHeader;
 
  __HAL_CAN_DISABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);

  if ( msg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
  {
	  TxHeader.ExtId = msg.id;
	  TxHeader.IDE   = CAN_ID_EXT;
  }
  else // Standard ID otherwise
  {
	  TxHeader.StdId = msg.id;
	  TxHeader.IDE   = CAN_ID_STD;
  }
  
  TxHeader.RTR   = CAN_RTR_DATA;
  TxHeader.DLC   = msg.len;
  TxHeader.TransmitGlobalTime = DISABLE;

//  if ( wait_sent ) {
//      /* Start the Transmission process */
//     if ( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK )
//      {
//        /* Transmission request Error */
//        ret = false;
//      }
//  }
//  else
//  {
//    uint8_t prio = (uint8_t) ((msg.id >> 26) & 0x7);
    if( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK ) {
      if( addToRingBuffer(txRing, msg)==false ) {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
    }
//  }
  __HAL_CAN_ENABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);
  DEBUG(Serial.println("stm32Can - Write end"));
  return ret;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::write(CAN_message_t &msg, bool wait_sent)
|———Node:qualified_identifier Text: stm32Can::write
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: write
|———Node:parameter_list Text: (CAN_message_t &msg, bool wait_sent)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_message_t &msg
|—————Node:type_identifier Text: CAN_message_t
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool wait_sent
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: wait_sent
|————Node:) Text: )
|——Node:compound_statement Text: {
  if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 write"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 write"));}
  bool ret = true;
  uint32_t TxMailbox;
  CAN_TxHeaderTypeDef TxHeader;
 
  __HAL_CAN_DISABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);

  if ( msg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
  {
	  TxHeader.ExtId = msg.id;
	  TxHeader.IDE   = CAN_ID_EXT;
  }
  else // Standard ID otherwise
  {
	  TxHeader.StdId = msg.id;
	  TxHeader.IDE   = CAN_ID_STD;
  }
  
  TxHeader.RTR   = CAN_RTR_DATA;
  TxHeader.DLC   = msg.len;
  TxHeader.TransmitGlobalTime = DISABLE;

//  if ( wait_sent ) {
//      /* Start the Transmission process */
//     if ( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK )
//      {
//        /* Transmission request Error */
//        ret = false;
//      }
//  }
//  else
//  {
//    uint8_t prio = (uint8_t) ((msg.id >> 26) & 0x7);
    if( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK ) {
      if( addToRingBuffer(txRing, msg)==false ) {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
    }
//  }
  __HAL_CAN_ENABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);
  DEBUG(Serial.println("stm32Can - Write end"));
  return ret;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (n_pCanHandle->Instance == CAN1) {DEBUG(Serial.println("stm32Can - CAN1 write"));}
  else {DEBUG(Serial.println("stm32Can - CAN2 write"));}
|————Node:if Text: if
|————Node:condition_clause Text: (n_pCanHandle->Instance == CAN1)
|—————Node:( Text: (
|—————Node:binary_expression Text: n_pCanHandle->Instance == CAN1
|——————Node:field_expression Text: n_pCanHandle->Instance
|———————Node:identifier Text: n_pCanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Instance
|——————Node:== Text: ==
|——————Node:identifier Text: CAN1
|—————Node:) Text: )
|————Node:compound_statement Text: {DEBUG(Serial.println("stm32Can - CAN1 write"));}
|—————Node:{ Text: {
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - CAN1 write"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - CAN1 write"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - CAN1 write"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - CAN1 write")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - CAN1 write")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - CAN1 write"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - CAN1 write
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {DEBUG(Serial.println("stm32Can - CAN2 write"));}
|—————Node:else Text: else
|—————Node:compound_statement Text: {DEBUG(Serial.println("stm32Can - CAN2 write"));}
|——————Node:{ Text: {
|——————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - CAN2 write"));
|———————Node:call_expression Text: DEBUG(Serial.println("stm32Can - CAN2 write"))
|————————Node:identifier Text: DEBUG
|————————Node:argument_list Text: (Serial.println("stm32Can - CAN2 write"))
|—————————Node:( Text: (
|—————————Node:call_expression Text: Serial.println("stm32Can - CAN2 write")
|——————————Node:field_expression Text: Serial.println
|———————————Node:identifier Text: Serial
|———————————Node:. Text: .
|———————————Node:field_identifier Text: println
|——————————Node:argument_list Text: ("stm32Can - CAN2 write")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "stm32Can - CAN2 write"
|————————————Node:" Text: "
|————————————Node:string_content Text: stm32Can - CAN2 write
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:declaration Text: bool ret = true;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: ret = true
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:declaration Text: uint32_t TxMailbox;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: TxMailbox
|————Node:; Text: ;
|———Node:declaration Text: CAN_TxHeaderTypeDef TxHeader;
|————Node:type_identifier Text: CAN_TxHeaderTypeDef
|————Node:identifier Text: TxHeader
|————Node:; Text: ;
|———Node:expression_statement Text: __HAL_CAN_DISABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);
|————Node:call_expression Text: __HAL_CAN_DISABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|—————Node:identifier Text: __HAL_CAN_DISABLE_IT
|—————Node:argument_list Text: (n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_IT_TX_MAILBOX_EMPTY
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ( msg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
  {
	  TxHeader.ExtId = msg.id;
	  TxHeader.IDE   = CAN_ID_EXT;
  }
  else // Standard ID otherwise
  {
	  TxHeader.StdId = msg.id;
	  TxHeader.IDE   = CAN_ID_STD;
  }
|————Node:if Text: if
|————Node:condition_clause Text: ( msg.flags.extended == 1 )
|—————Node:( Text: (
|—————Node:binary_expression Text: msg.flags.extended == 1
|——————Node:field_expression Text: msg.flags.extended
|———————Node:field_expression Text: msg.flags
|————————Node:identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: flags
|———————Node:. Text: .
|———————Node:field_identifier Text: extended
|——————Node:== Text: ==
|——————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:comment Text: // Extended ID when msg.flags.extended is 1
|————Node:compound_statement Text: {
	  TxHeader.ExtId = msg.id;
	  TxHeader.IDE   = CAN_ID_EXT;
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: TxHeader.ExtId = msg.id;
|——————Node:assignment_expression Text: TxHeader.ExtId = msg.id
|———————Node:field_expression Text: TxHeader.ExtId
|————————Node:identifier Text: TxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: ExtId
|———————Node:= Text: =
|———————Node:field_expression Text: msg.id
|————————Node:identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|——————Node:; Text: ;
|—————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_EXT;
|——————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_EXT
|———————Node:field_expression Text: TxHeader.IDE
|————————Node:identifier Text: TxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: IDE
|———————Node:= Text: =
|———————Node:identifier Text: CAN_ID_EXT
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else // Standard ID otherwise
  {
	  TxHeader.StdId = msg.id;
	  TxHeader.IDE   = CAN_ID_STD;
  }
|—————Node:else Text: else
|—————Node:comment Text: // Standard ID otherwise
|—————Node:compound_statement Text: {
	  TxHeader.StdId = msg.id;
	  TxHeader.IDE   = CAN_ID_STD;
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: TxHeader.StdId = msg.id;
|———————Node:assignment_expression Text: TxHeader.StdId = msg.id
|————————Node:field_expression Text: TxHeader.StdId
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: StdId
|————————Node:= Text: =
|————————Node:field_expression Text: msg.id
|—————————Node:identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: id
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_STD;
|———————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_STD
|————————Node:field_expression Text: TxHeader.IDE
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: IDE
|————————Node:= Text: =
|————————Node:identifier Text: CAN_ID_STD
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: TxHeader.RTR   = CAN_RTR_DATA;
|————Node:assignment_expression Text: TxHeader.RTR   = CAN_RTR_DATA
|—————Node:field_expression Text: TxHeader.RTR
|——————Node:identifier Text: TxHeader
|——————Node:. Text: .
|——————Node:field_identifier Text: RTR
|—————Node:= Text: =
|—————Node:identifier Text: CAN_RTR_DATA
|————Node:; Text: ;
|———Node:expression_statement Text: TxHeader.DLC   = msg.len;
|————Node:assignment_expression Text: TxHeader.DLC   = msg.len
|—————Node:field_expression Text: TxHeader.DLC
|——————Node:identifier Text: TxHeader
|——————Node:. Text: .
|——————Node:field_identifier Text: DLC
|—————Node:= Text: =
|—————Node:field_expression Text: msg.len
|——————Node:identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: len
|————Node:; Text: ;
|———Node:expression_statement Text: TxHeader.TransmitGlobalTime = DISABLE;
|————Node:assignment_expression Text: TxHeader.TransmitGlobalTime = DISABLE
|—————Node:field_expression Text: TxHeader.TransmitGlobalTime
|——————Node:identifier Text: TxHeader
|——————Node:. Text: .
|——————Node:field_identifier Text: TransmitGlobalTime
|—————Node:= Text: =
|—————Node:identifier Text: DISABLE
|————Node:; Text: ;
|———Node:comment Text: //  if ( wait_sent ) {
|———Node:comment Text: //      /* Start the Transmission process */
|———Node:comment Text: //     if ( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK )
|———Node:comment Text: //      {
|———Node:comment Text: //        /* Transmission request Error */
|———Node:comment Text: //        ret = false;
|———Node:comment Text: //      }
|———Node:comment Text: //  }
|———Node:comment Text: //  else
|———Node:comment Text: //  {
|———Node:comment Text: //    uint8_t prio = (uint8_t) ((msg.id >> 26) & 0x7);
|———Node:if_statement Text: if( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK ) {
      if( addToRingBuffer(txRing, msg)==false ) {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
    }
|————Node:if Text: if
|————Node:condition_clause Text: ( HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK )
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_AddTxMessage( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox)
|———————Node:identifier Text: HAL_CAN_AddTxMessage
|———————Node:argument_list Text: ( n_pCanHandle, &TxHeader, msg.buf, &TxMailbox)
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &TxHeader
|—————————Node:& Text: &
|—————————Node:identifier Text: TxHeader
|————————Node:, Text: ,
|————————Node:field_expression Text: msg.buf
|—————————Node:identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: buf
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &TxMailbox
|—————————Node:& Text: &
|—————————Node:identifier Text: TxMailbox
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
      if( addToRingBuffer(txRing, msg)==false ) {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if( addToRingBuffer(txRing, msg)==false ) {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
|——————Node:if Text: if
|——————Node:condition_clause Text: ( addToRingBuffer(txRing, msg)==false )
|———————Node:( Text: (
|———————Node:binary_expression Text: addToRingBuffer(txRing, msg)==false
|————————Node:call_expression Text: addToRingBuffer(txRing, msg)
|—————————Node:identifier Text: addToRingBuffer
|—————————Node:argument_list Text: (txRing, msg)
|——————————Node:( Text: (
|——————————Node:identifier Text: txRing
|——————————Node:, Text: ,
|——————————Node:identifier Text: msg
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:false Text: false
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        DEBUG(Serial.println("TX full"));
        ret= false;; // no more room
      }
|———————Node:{ Text: {
|———————Node:expression_statement Text: DEBUG(Serial.println("TX full"));
|————————Node:call_expression Text: DEBUG(Serial.println("TX full"))
|—————————Node:identifier Text: DEBUG
|—————————Node:argument_list Text: (Serial.println("TX full"))
|——————————Node:( Text: (
|——————————Node:call_expression Text: Serial.println("TX full")
|———————————Node:field_expression Text: Serial.println
|————————————Node:identifier Text: Serial
|————————————Node:. Text: .
|————————————Node:field_identifier Text: println
|———————————Node:argument_list Text: ("TX full")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "TX full"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: TX full
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: ret= false;
|————————Node:assignment_expression Text: ret= false
|—————————Node:identifier Text: ret
|—————————Node:= Text: =
|—————————Node:false Text: false
|————————Node:; Text: ;
|———————Node:expression_statement Text: ;
|————————Node:; Text: ;
|———————Node:comment Text: // no more room
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:comment Text: //  }
|———Node:expression_statement Text: __HAL_CAN_ENABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY);
|————Node:call_expression Text: __HAL_CAN_ENABLE_IT(n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|—————Node:identifier Text: __HAL_CAN_ENABLE_IT
|—————Node:argument_list Text: (n_pCanHandle, CAN_IT_TX_MAILBOX_EMPTY)
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_IT_TX_MAILBOX_EMPTY
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println("stm32Can - Write end"));
|————Node:call_expression Text: DEBUG(Serial.println("stm32Can - Write end"))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println("stm32Can - Write end"))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println("stm32Can - Write end")
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ("stm32Can - Write end")
|————————Node:( Text: (
|————————Node:string_literal Text: "stm32Can - Write end"
|—————————Node:" Text: "
|—————————Node:string_content Text: stm32Can - Write end
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool stm32Can::read(CAN_message_t &msg) {
  bool ret;
  __HAL_CAN_DISABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING ); 
  ret = removeFromRingBuffer(rxRing, msg);
  __HAL_CAN_ENABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING ); 
  return ret;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::read(CAN_message_t &msg)
|———Node:qualified_identifier Text: stm32Can::read
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: read
|———Node:parameter_list Text: (CAN_message_t &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_message_t &msg
|—————Node:type_identifier Text: CAN_message_t
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
  bool ret;
  __HAL_CAN_DISABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING ); 
  ret = removeFromRingBuffer(rxRing, msg);
  __HAL_CAN_ENABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING ); 
  return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: bool ret;
|————Node:primitive_type Text: bool
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:expression_statement Text: __HAL_CAN_DISABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING );
|————Node:call_expression Text: __HAL_CAN_DISABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING )
|—————Node:identifier Text: __HAL_CAN_DISABLE_IT
|—————Node:argument_list Text: ( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING )
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_IT_RX_FIFO0_MSG_PENDING
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ret = removeFromRingBuffer(rxRing, msg);
|————Node:assignment_expression Text: ret = removeFromRingBuffer(rxRing, msg)
|—————Node:identifier Text: ret
|—————Node:= Text: =
|—————Node:call_expression Text: removeFromRingBuffer(rxRing, msg)
|——————Node:identifier Text: removeFromRingBuffer
|——————Node:argument_list Text: (rxRing, msg)
|———————Node:( Text: (
|———————Node:identifier Text: rxRing
|———————Node:, Text: ,
|———————Node:identifier Text: msg
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: __HAL_CAN_ENABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING );
|————Node:call_expression Text: __HAL_CAN_ENABLE_IT( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING )
|—————Node:identifier Text: __HAL_CAN_ENABLE_IT
|—————Node:argument_list Text: ( n_pCanHandle, CAN_IT_RX_FIFO0_MSG_PENDING )
|——————Node:( Text: (
|——————Node:identifier Text: n_pCanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: CAN_IT_RX_FIFO0_MSG_PENDING
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool stm32Can::readdebug(CAN_message_t &msg) {
  bool ret;
  CAN_RxHeaderTypeDef   RxHeader;

  /* For debug usage - this can be used to read a message if interupt not is working */
  if (HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
	else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
    msg.flags.remote = RxHeader.RTR;
    msg.priority     = RxHeader.FilterMatchIndex;
    msg.timestamp    = RxHeader.Timestamp;
    msg.len          = RxHeader.DLC;
    ret = true;
  }
  else
  {
    ret = false;
  }

  uint32_t test;

  /* print the timing parameters */
  DEBUG(Serial.println( "Debug - timing settings" ));
    
  test = (uint32_t) n_pCanHandle->Init.SyncJumpWidth;
  DEBUG(Serial.print( "SyncJumpWidth: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.TimeSeg1;
  DEBUG(Serial.print( "TimeSeg1: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.TimeSeg2;
  DEBUG(Serial.print( "TimeSeg2: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.Prescaler;
  DEBUG(Serial.print( "Prescaler: " ));
  DEBUG(Serial.println( test ));
      
  return ret;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::readdebug(CAN_message_t &msg)
|———Node:qualified_identifier Text: stm32Can::readdebug
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: readdebug
|———Node:parameter_list Text: (CAN_message_t &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_message_t &msg
|—————Node:type_identifier Text: CAN_message_t
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
  bool ret;
  CAN_RxHeaderTypeDef   RxHeader;

  /* For debug usage - this can be used to read a message if interupt not is working */
  if (HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
	else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
    msg.flags.remote = RxHeader.RTR;
    msg.priority     = RxHeader.FilterMatchIndex;
    msg.timestamp    = RxHeader.Timestamp;
    msg.len          = RxHeader.DLC;
    ret = true;
  }
  else
  {
    ret = false;
  }

  uint32_t test;

  /* print the timing parameters */
  DEBUG(Serial.println( "Debug - timing settings" ));
    
  test = (uint32_t) n_pCanHandle->Init.SyncJumpWidth;
  DEBUG(Serial.print( "SyncJumpWidth: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.TimeSeg1;
  DEBUG(Serial.print( "TimeSeg1: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.TimeSeg2;
  DEBUG(Serial.print( "TimeSeg2: " ));
  DEBUG(Serial.println( test ));
    
  test = (uint32_t) n_pCanHandle->Init.Prescaler;
  DEBUG(Serial.print( "Prescaler: " ));
  DEBUG(Serial.println( test ));
      
  return ret;
}
|———Node:{ Text: {
|———Node:declaration Text: bool ret;
|————Node:primitive_type Text: bool
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:declaration Text: CAN_RxHeaderTypeDef   RxHeader;
|————Node:type_identifier Text: CAN_RxHeaderTypeDef
|————Node:identifier Text: RxHeader
|————Node:; Text: ;
|———Node:comment Text: /* For debug usage - this can be used to read a message if interupt not is working */
|———Node:if_statement Text: if (HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
	else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
    msg.flags.remote = RxHeader.RTR;
    msg.priority     = RxHeader.FilterMatchIndex;
    msg.timestamp    = RxHeader.Timestamp;
    msg.len          = RxHeader.DLC;
    ret = true;
  }
  else
  {
    ret = false;
  }
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf ) == HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf ) == HAL_OK
|——————Node:call_expression Text: HAL_CAN_GetRxMessage( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf )
|———————Node:identifier Text: HAL_CAN_GetRxMessage
|———————Node:argument_list Text: ( n_pCanHandle, CAN_RX_FIFO0, &RxHeader, msg.buf )
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_RX_FIFO0
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &RxHeader
|—————————Node:& Text: &
|—————————Node:identifier Text: RxHeader
|————————Node:, Text: ,
|————————Node:field_expression Text: msg.buf
|—————————Node:identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: buf
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
	else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
    msg.flags.remote = RxHeader.RTR;
    msg.priority     = RxHeader.FilterMatchIndex;
    msg.timestamp    = RxHeader.Timestamp;
    msg.len          = RxHeader.DLC;
    ret = true;
  }
|—————Node:{ Text: {
|—————Node:if_statement Text: if ( RxHeader.IDE == CAN_ID_STD )
	{
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
	else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
|——————Node:if Text: if
|——————Node:condition_clause Text: ( RxHeader.IDE == CAN_ID_STD )
|———————Node:( Text: (
|———————Node:binary_expression Text: RxHeader.IDE == CAN_ID_STD
|————————Node:field_expression Text: RxHeader.IDE
|—————————Node:identifier Text: RxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: IDE
|————————Node:== Text: ==
|————————Node:identifier Text: CAN_ID_STD
|———————Node:) Text: )
|——————Node:compound_statement Text: {
		msg.id = RxHeader.StdId;
		msg.flags.extended = 0;
	}
|———————Node:{ Text: {
|———————Node:expression_statement Text: msg.id = RxHeader.StdId;
|————————Node:assignment_expression Text: msg.id = RxHeader.StdId
|—————————Node:field_expression Text: msg.id
|——————————Node:identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: id
|—————————Node:= Text: =
|—————————Node:field_expression Text: RxHeader.StdId
|——————————Node:identifier Text: RxHeader
|——————————Node:. Text: .
|——————————Node:field_identifier Text: StdId
|————————Node:; Text: ;
|———————Node:expression_statement Text: msg.flags.extended = 0;
|————————Node:assignment_expression Text: msg.flags.extended = 0
|—————————Node:field_expression Text: msg.flags.extended
|——————————Node:field_expression Text: msg.flags
|———————————Node:identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:. Text: .
|——————————Node:field_identifier Text: extended
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
	{
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
|———————Node:else Text: else
|———————Node:compound_statement Text: {
		msg.id = RxHeader.ExtId;
		msg.flags.extended = 1;
	}
|————————Node:{ Text: {
|————————Node:expression_statement Text: msg.id = RxHeader.ExtId;
|—————————Node:assignment_expression Text: msg.id = RxHeader.ExtId
|——————————Node:field_expression Text: msg.id
|———————————Node:identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|——————————Node:= Text: =
|——————————Node:field_expression Text: RxHeader.ExtId
|———————————Node:identifier Text: RxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ExtId
|—————————Node:; Text: ;
|————————Node:expression_statement Text: msg.flags.extended = 1;
|—————————Node:assignment_expression Text: msg.flags.extended = 1
|——————————Node:field_expression Text: msg.flags.extended
|———————————Node:field_expression Text: msg.flags
|————————————Node:identifier Text: msg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: flags
|———————————Node:. Text: .
|———————————Node:field_identifier Text: extended
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:expression_statement Text: msg.flags.remote = RxHeader.RTR;
|——————Node:assignment_expression Text: msg.flags.remote = RxHeader.RTR
|———————Node:field_expression Text: msg.flags.remote
|————————Node:field_expression Text: msg.flags
|—————————Node:identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: flags
|————————Node:. Text: .
|————————Node:field_identifier Text: remote
|———————Node:= Text: =
|———————Node:field_expression Text: RxHeader.RTR
|————————Node:identifier Text: RxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: RTR
|——————Node:; Text: ;
|—————Node:expression_statement Text: msg.priority     = RxHeader.FilterMatchIndex;
|——————Node:assignment_expression Text: msg.priority     = RxHeader.FilterMatchIndex
|———————Node:field_expression Text: msg.priority
|————————Node:identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: priority
|———————Node:= Text: =
|———————Node:field_expression Text: RxHeader.FilterMatchIndex
|————————Node:identifier Text: RxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: FilterMatchIndex
|——————Node:; Text: ;
|—————Node:expression_statement Text: msg.timestamp    = RxHeader.Timestamp;
|——————Node:assignment_expression Text: msg.timestamp    = RxHeader.Timestamp
|———————Node:field_expression Text: msg.timestamp
|————————Node:identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: timestamp
|———————Node:= Text: =
|———————Node:field_expression Text: RxHeader.Timestamp
|————————Node:identifier Text: RxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: Timestamp
|——————Node:; Text: ;
|—————Node:expression_statement Text: msg.len          = RxHeader.DLC;
|——————Node:assignment_expression Text: msg.len          = RxHeader.DLC
|———————Node:field_expression Text: msg.len
|————————Node:identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: len
|———————Node:= Text: =
|———————Node:field_expression Text: RxHeader.DLC
|————————Node:identifier Text: RxHeader
|————————Node:. Text: .
|————————Node:field_identifier Text: DLC
|——————Node:; Text: ;
|—————Node:expression_statement Text: ret = true;
|——————Node:assignment_expression Text: ret = true
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
  {
    ret = false;
  }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
    ret = false;
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: ret = false;
|———————Node:assignment_expression Text: ret = false
|————————Node:identifier Text: ret
|————————Node:= Text: =
|————————Node:false Text: false
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:declaration Text: uint32_t test;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: test
|————Node:; Text: ;
|———Node:comment Text: /* print the timing parameters */
|———Node:expression_statement Text: DEBUG(Serial.println( "Debug - timing settings" ));
|————Node:call_expression Text: DEBUG(Serial.println( "Debug - timing settings" ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println( "Debug - timing settings" ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println( "Debug - timing settings" )
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ( "Debug - timing settings" )
|————————Node:( Text: (
|————————Node:string_literal Text: "Debug - timing settings"
|—————————Node:" Text: "
|—————————Node:string_content Text: Debug - timing settings
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: test = (uint32_t) n_pCanHandle->Init.SyncJumpWidth;
|————Node:assignment_expression Text: test = (uint32_t) n_pCanHandle->Init.SyncJumpWidth
|—————Node:identifier Text: test
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t) n_pCanHandle->Init.SyncJumpWidth
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:field_expression Text: n_pCanHandle->Init.SyncJumpWidth
|———————Node:field_expression Text: n_pCanHandle->Init
|————————Node:identifier Text: n_pCanHandle
|————————Node:-> Text: ->
|————————Node:field_identifier Text: Init
|———————Node:. Text: .
|———————Node:field_identifier Text: SyncJumpWidth
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.print( "SyncJumpWidth: " ));
|————Node:call_expression Text: DEBUG(Serial.print( "SyncJumpWidth: " ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.print( "SyncJumpWidth: " ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.print( "SyncJumpWidth: " )
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ( "SyncJumpWidth: " )
|————————Node:( Text: (
|————————Node:string_literal Text: "SyncJumpWidth: "
|—————————Node:" Text: "
|—————————Node:string_content Text: SyncJumpWidth: 
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println( test ));
|————Node:call_expression Text: DEBUG(Serial.println( test ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println( test ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println( test )
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ( test )
|————————Node:( Text: (
|————————Node:identifier Text: test
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: test = (uint32_t) n_pCanHandle->Init.TimeSeg1;
|————Node:assignment_expression Text: test = (uint32_t) n_pCanHandle->Init.TimeSeg1
|—————Node:identifier Text: test
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t) n_pCanHandle->Init.TimeSeg1
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:field_expression Text: n_pCanHandle->Init.TimeSeg1
|———————Node:field_expression Text: n_pCanHandle->Init
|————————Node:identifier Text: n_pCanHandle
|————————Node:-> Text: ->
|————————Node:field_identifier Text: Init
|———————Node:. Text: .
|———————Node:field_identifier Text: TimeSeg1
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.print( "TimeSeg1: " ));
|————Node:call_expression Text: DEBUG(Serial.print( "TimeSeg1: " ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.print( "TimeSeg1: " ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.print( "TimeSeg1: " )
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ( "TimeSeg1: " )
|————————Node:( Text: (
|————————Node:string_literal Text: "TimeSeg1: "
|—————————Node:" Text: "
|—————————Node:string_content Text: TimeSeg1: 
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println( test ));
|————Node:call_expression Text: DEBUG(Serial.println( test ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println( test ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println( test )
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ( test )
|————————Node:( Text: (
|————————Node:identifier Text: test
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: test = (uint32_t) n_pCanHandle->Init.TimeSeg2;
|————Node:assignment_expression Text: test = (uint32_t) n_pCanHandle->Init.TimeSeg2
|—————Node:identifier Text: test
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t) n_pCanHandle->Init.TimeSeg2
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:field_expression Text: n_pCanHandle->Init.TimeSeg2
|———————Node:field_expression Text: n_pCanHandle->Init
|————————Node:identifier Text: n_pCanHandle
|————————Node:-> Text: ->
|————————Node:field_identifier Text: Init
|———————Node:. Text: .
|———————Node:field_identifier Text: TimeSeg2
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.print( "TimeSeg2: " ));
|————Node:call_expression Text: DEBUG(Serial.print( "TimeSeg2: " ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.print( "TimeSeg2: " ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.print( "TimeSeg2: " )
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ( "TimeSeg2: " )
|————————Node:( Text: (
|————————Node:string_literal Text: "TimeSeg2: "
|—————————Node:" Text: "
|—————————Node:string_content Text: TimeSeg2: 
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println( test ));
|————Node:call_expression Text: DEBUG(Serial.println( test ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println( test ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println( test )
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ( test )
|————————Node:( Text: (
|————————Node:identifier Text: test
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: test = (uint32_t) n_pCanHandle->Init.Prescaler;
|————Node:assignment_expression Text: test = (uint32_t) n_pCanHandle->Init.Prescaler
|—————Node:identifier Text: test
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t) n_pCanHandle->Init.Prescaler
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:field_expression Text: n_pCanHandle->Init.Prescaler
|———————Node:field_expression Text: n_pCanHandle->Init
|————————Node:identifier Text: n_pCanHandle
|————————Node:-> Text: ->
|————————Node:field_identifier Text: Init
|———————Node:. Text: .
|———————Node:field_identifier Text: Prescaler
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.print( "Prescaler: " ));
|————Node:call_expression Text: DEBUG(Serial.print( "Prescaler: " ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.print( "Prescaler: " ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.print( "Prescaler: " )
|———————Node:field_expression Text: Serial.print
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: print
|———————Node:argument_list Text: ( "Prescaler: " )
|————————Node:( Text: (
|————————Node:string_literal Text: "Prescaler: "
|—————————Node:" Text: "
|—————————Node:string_content Text: Prescaler: 
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: DEBUG(Serial.println( test ));
|————Node:call_expression Text: DEBUG(Serial.println( test ))
|—————Node:identifier Text: DEBUG
|—————Node:argument_list Text: (Serial.println( test ))
|——————Node:( Text: (
|——————Node:call_expression Text: Serial.println( test )
|———————Node:field_expression Text: Serial.println
|————————Node:identifier Text: Serial
|————————Node:. Text: .
|————————Node:field_identifier Text: println
|———————Node:argument_list Text: ( test )
|————————Node:( Text: (
|————————Node:identifier Text: test
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return ret;
|————Node:return Text: return
|————Node:identifier Text: ret
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint32_t stm32Can::available( void ) 
{ 
  return ringBufferCount(rxRing); 
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: stm32Can::available( void )
|———Node:qualified_identifier Text: stm32Can::available
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: available
|———Node:parameter_list Text: ( void )
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: { 
  return ringBufferCount(rxRing); 
}
|———Node:{ Text: {
|———Node:return_statement Text: return ringBufferCount(rxRing);
|————Node:return Text: return
|————Node:call_expression Text: ringBufferCount(rxRing)
|—————Node:identifier Text: ringBufferCount
|—————Node:argument_list Text: (rxRing)
|——————Node:( Text: (
|——————Node:identifier Text: rxRing
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:expression_statement Text: ;
|——Node:; Text: ;
|—Node:function_definition Text: bool stm32Can::setFilter( uint32_t FilterID, uint32_t FilterMask, uint8_t FilterBank, bool IDStdOrExt )
{	
	CAN_FilterTypeDef sFilterConfig;
	
	// Define filter
	sFilterConfig.FilterBank = FilterBank;
	sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
	sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	sFilterConfig.FilterActivation = ENABLE;

	switch ( IDStdOrExt ) {
		case IDStd: // Standard
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
			sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
			break;
		case IDExt: // Extended
			sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
			sFilterConfig.FilterIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
			sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
			sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
			break;
	}
 
	// Enable filter
	if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
	{
		/* Filter configuration Error */
		DEBUG(Serial.println("stm32Can - error configuring filter"));

		return 1;
	}
	else
	{
		return 0;
	}
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::setFilter( uint32_t FilterID, uint32_t FilterMask, uint8_t FilterBank, bool IDStdOrExt )
|———Node:qualified_identifier Text: stm32Can::setFilter
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: setFilter
|———Node:parameter_list Text: ( uint32_t FilterID, uint32_t FilterMask, uint8_t FilterBank, bool IDStdOrExt )
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t FilterID
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: FilterID
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t FilterMask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: FilterMask
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t FilterBank
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: FilterBank
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool IDStdOrExt
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: IDStdOrExt
|————Node:) Text: )
|——Node:compound_statement Text: {	
	CAN_FilterTypeDef sFilterConfig;
	
	// Define filter
	sFilterConfig.FilterBank = FilterBank;
	sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
	sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	sFilterConfig.FilterActivation = ENABLE;

	switch ( IDStdOrExt ) {
		case IDStd: // Standard
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
			sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
			break;
		case IDExt: // Extended
			sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
			sFilterConfig.FilterIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
			sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
			sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
			break;
	}
 
	// Enable filter
	if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
	{
		/* Filter configuration Error */
		DEBUG(Serial.println("stm32Can - error configuring filter"));

		return 1;
	}
	else
	{
		return 0;
	}
}
|———Node:{ Text: {
|———Node:declaration Text: CAN_FilterTypeDef sFilterConfig;
|————Node:type_identifier Text: CAN_FilterTypeDef
|————Node:identifier Text: sFilterConfig
|————Node:; Text: ;
|———Node:comment Text: // Define filter
|———Node:expression_statement Text: sFilterConfig.FilterBank = FilterBank;
|————Node:assignment_expression Text: sFilterConfig.FilterBank = FilterBank
|—————Node:field_expression Text: sFilterConfig.FilterBank
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterBank
|—————Node:= Text: =
|—————Node:identifier Text: FilterBank
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
|————Node:assignment_expression Text: sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK
|—————Node:field_expression Text: sFilterConfig.FilterMode
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterMode
|—————Node:= Text: =
|—————Node:identifier Text: CAN_FILTERMODE_IDMASK
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
|————Node:assignment_expression Text: sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT
|—————Node:field_expression Text: sFilterConfig.FilterScale
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterScale
|—————Node:= Text: =
|—————Node:identifier Text: CAN_FILTERSCALE_32BIT
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
|————Node:assignment_expression Text: sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0
|—————Node:field_expression Text: sFilterConfig.FilterFIFOAssignment
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterFIFOAssignment
|—————Node:= Text: =
|—————Node:identifier Text: CAN_FILTER_FIFO0
|————Node:; Text: ;
|———Node:expression_statement Text: sFilterConfig.FilterActivation = ENABLE;
|————Node:assignment_expression Text: sFilterConfig.FilterActivation = ENABLE
|—————Node:field_expression Text: sFilterConfig.FilterActivation
|——————Node:identifier Text: sFilterConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: FilterActivation
|—————Node:= Text: =
|—————Node:identifier Text: ENABLE
|————Node:; Text: ;
|———Node:switch_statement Text: switch ( IDStdOrExt ) {
		case IDStd: // Standard
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
			sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
			break;
		case IDExt: // Extended
			sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
			sFilterConfig.FilterIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
			sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
			sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
			break;
	}
|————Node:switch Text: switch
|————Node:condition_clause Text: ( IDStdOrExt )
|—————Node:( Text: (
|—————Node:identifier Text: IDStdOrExt
|—————Node:) Text: )
|————Node:compound_statement Text: {
		case IDStd: // Standard
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
			sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
			break;
		case IDExt: // Extended
			sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
			sFilterConfig.FilterIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
			sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
			sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
			break;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case IDStd: // Standard
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
			sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
			break;
|——————Node:case Text: case
|——————Node:identifier Text: IDStd
|——————Node:: Text: :
|——————Node:comment Text: // Standard
|——————Node:expression_statement Text: sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5);
|———————Node:assignment_expression Text: sFilterConfig.FilterIdHigh = (uint16_t) (FilterID << 5)
|————————Node:field_expression Text: sFilterConfig.FilterIdHigh
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterIdHigh
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterID << 5)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterID << 5)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterID << 5
|———————————Node:identifier Text: FilterID
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 5
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterIdLow = 0;
|———————Node:assignment_expression Text: sFilterConfig.FilterIdLow = 0
|————————Node:field_expression Text: sFilterConfig.FilterIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterIdLow
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5);
|———————Node:assignment_expression Text: sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask << 5)
|————————Node:field_expression Text: sFilterConfig.FilterMaskIdHigh
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMaskIdHigh
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterMask << 5)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterMask << 5)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterMask << 5
|———————————Node:identifier Text: FilterMask
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 5
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterMaskIdLow = CAN_ID_EXT;
|———————Node:assignment_expression Text: sFilterConfig.FilterMaskIdLow = CAN_ID_EXT
|————————Node:field_expression Text: sFilterConfig.FilterMaskIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMaskIdLow
|————————Node:= Text: =
|————————Node:identifier Text: CAN_ID_EXT
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case IDExt: // Extended
			sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
			sFilterConfig.FilterIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
			sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
			sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
			sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
			break;
|——————Node:case Text: case
|——————Node:identifier Text: IDExt
|——————Node:: Text: :
|——————Node:comment Text: // Extended
|——————Node:expression_statement Text: sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3);
|———————Node:assignment_expression Text: sFilterConfig.FilterIdLow = (uint16_t) (FilterID << 3)
|————————Node:field_expression Text: sFilterConfig.FilterIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterIdLow
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterID << 3)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterID << 3)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterID << 3
|———————————Node:identifier Text: FilterID
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 3
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterIdLow |= CAN_ID_EXT;
|———————Node:assignment_expression Text: sFilterConfig.FilterIdLow |= CAN_ID_EXT
|————————Node:field_expression Text: sFilterConfig.FilterIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterIdLow
|————————Node:|= Text: |=
|————————Node:identifier Text: CAN_ID_EXT
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13);
|———————Node:assignment_expression Text: sFilterConfig.FilterIdHigh = (uint16_t) (FilterID >> 13)
|————————Node:field_expression Text: sFilterConfig.FilterIdHigh
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterIdHigh
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterID >> 13)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterID >> 13)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterID >> 13
|———————————Node:identifier Text: FilterID
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 13
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3);
|———————Node:assignment_expression Text: sFilterConfig.FilterMaskIdLow = (uint16_t) (FilterMask << 3)
|————————Node:field_expression Text: sFilterConfig.FilterMaskIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMaskIdLow
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterMask << 3)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterMask << 3)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterMask << 3
|———————————Node:identifier Text: FilterMask
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 3
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT;
|———————Node:assignment_expression Text: sFilterConfig.FilterMaskIdLow |= CAN_ID_EXT
|————————Node:field_expression Text: sFilterConfig.FilterMaskIdLow
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMaskIdLow
|————————Node:|= Text: |=
|————————Node:identifier Text: CAN_ID_EXT
|———————Node:; Text: ;
|——————Node:expression_statement Text: sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13);
|———————Node:assignment_expression Text: sFilterConfig.FilterMaskIdHigh = (uint16_t) (FilterMask >> 13)
|————————Node:field_expression Text: sFilterConfig.FilterMaskIdHigh
|—————————Node:identifier Text: sFilterConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMaskIdHigh
|————————Node:= Text: =
|————————Node:cast_expression Text: (uint16_t) (FilterMask >> 13)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: uint16_t
|——————————Node:primitive_type Text: uint16_t
|—————————Node:) Text: )
|—————————Node:parenthesized_expression Text: (FilterMask >> 13)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: FilterMask >> 13
|———————————Node:identifier Text: FilterMask
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 13
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: // Enable filter
|———Node:if_statement Text: if (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
	{
		/* Filter configuration Error */
		DEBUG(Serial.println("stm32Can - error configuring filter"));

		return 1;
	}
	else
	{
		return 0;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK)
|—————Node:( Text: (
|—————Node:binary_expression Text: HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig ) != HAL_OK
|——————Node:call_expression Text: HAL_CAN_ConfigFilter( n_pCanHandle, &sFilterConfig )
|———————Node:identifier Text: HAL_CAN_ConfigFilter
|———————Node:argument_list Text: ( n_pCanHandle, &sFilterConfig )
|————————Node:( Text: (
|————————Node:identifier Text: n_pCanHandle
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &sFilterConfig
|—————————Node:& Text: &
|—————————Node:identifier Text: sFilterConfig
|————————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: HAL_OK
|—————Node:) Text: )
|————Node:compound_statement Text: {
		/* Filter configuration Error */
		DEBUG(Serial.println("stm32Can - error configuring filter"));

		return 1;
	}
|—————Node:{ Text: {
|—————Node:comment Text: /* Filter configuration Error */
|—————Node:expression_statement Text: DEBUG(Serial.println("stm32Can - error configuring filter"));
|——————Node:call_expression Text: DEBUG(Serial.println("stm32Can - error configuring filter"))
|———————Node:identifier Text: DEBUG
|———————Node:argument_list Text: (Serial.println("stm32Can - error configuring filter"))
|————————Node:( Text: (
|————————Node:call_expression Text: Serial.println("stm32Can - error configuring filter")
|—————————Node:field_expression Text: Serial.println
|——————————Node:identifier Text: Serial
|——————————Node:. Text: .
|——————————Node:field_identifier Text: println
|—————————Node:argument_list Text: ("stm32Can - error configuring filter")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "stm32Can - error configuring filter"
|———————————Node:" Text: "
|———————————Node:string_content Text: stm32Can - error configuring filter
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return 1;
|——————Node:return Text: return
|——————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
	{
		return 0;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		return 0;
	}
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::initializeBuffers() {
    if( isInitialized() )
      return;
  
    // set up the transmit and receive ring buffers
    if(tx_buffer==0)
      tx_buffer=new CAN_message_t[sizeTxBuffer];
      
    initRingBuffer(txRing, tx_buffer, sizeTxBuffer);

    if(rx_buffer==0)
      rx_buffer=new CAN_message_t[sizeRxBuffer];

    initRingBuffer(rxRing, rx_buffer, sizeRxBuffer);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::initializeBuffers()
|———Node:qualified_identifier Text: stm32Can::initializeBuffers
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: initializeBuffers
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if( isInitialized() )
      return;
  
    // set up the transmit and receive ring buffers
    if(tx_buffer==0)
      tx_buffer=new CAN_message_t[sizeTxBuffer];
      
    initRingBuffer(txRing, tx_buffer, sizeTxBuffer);

    if(rx_buffer==0)
      rx_buffer=new CAN_message_t[sizeRxBuffer];

    initRingBuffer(rxRing, rx_buffer, sizeRxBuffer);
}
|———Node:{ Text: {
|———Node:if_statement Text: if( isInitialized() )
      return;
|————Node:if Text: if
|————Node:condition_clause Text: ( isInitialized() )
|—————Node:( Text: (
|—————Node:call_expression Text: isInitialized()
|——————Node:identifier Text: isInitialized
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:return_statement Text: return;
|—————Node:return Text: return
|—————Node:; Text: ;
|———Node:comment Text: // set up the transmit and receive ring buffers
|———Node:if_statement Text: if(tx_buffer==0)
      tx_buffer=new CAN_message_t[sizeTxBuffer];
|————Node:if Text: if
|————Node:condition_clause Text: (tx_buffer==0)
|—————Node:( Text: (
|—————Node:binary_expression Text: tx_buffer==0
|——————Node:identifier Text: tx_buffer
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: tx_buffer=new CAN_message_t[sizeTxBuffer];
|—————Node:assignment_expression Text: tx_buffer=new CAN_message_t[sizeTxBuffer]
|——————Node:identifier Text: tx_buffer
|——————Node:= Text: =
|——————Node:new_expression Text: new CAN_message_t[sizeTxBuffer]
|———————Node:new Text: new
|———————Node:type_identifier Text: CAN_message_t
|———————Node:new_declarator Text: [sizeTxBuffer]
|————————Node:[ Text: [
|————————Node:identifier Text: sizeTxBuffer
|————————Node:] Text: ]
|—————Node:; Text: ;
|———Node:expression_statement Text: initRingBuffer(txRing, tx_buffer, sizeTxBuffer);
|————Node:call_expression Text: initRingBuffer(txRing, tx_buffer, sizeTxBuffer)
|—————Node:identifier Text: initRingBuffer
|—————Node:argument_list Text: (txRing, tx_buffer, sizeTxBuffer)
|——————Node:( Text: (
|——————Node:identifier Text: txRing
|——————Node:, Text: ,
|——————Node:identifier Text: tx_buffer
|——————Node:, Text: ,
|——————Node:identifier Text: sizeTxBuffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if(rx_buffer==0)
      rx_buffer=new CAN_message_t[sizeRxBuffer];
|————Node:if Text: if
|————Node:condition_clause Text: (rx_buffer==0)
|—————Node:( Text: (
|—————Node:binary_expression Text: rx_buffer==0
|——————Node:identifier Text: rx_buffer
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: rx_buffer=new CAN_message_t[sizeRxBuffer];
|—————Node:assignment_expression Text: rx_buffer=new CAN_message_t[sizeRxBuffer]
|——————Node:identifier Text: rx_buffer
|——————Node:= Text: =
|——————Node:new_expression Text: new CAN_message_t[sizeRxBuffer]
|———————Node:new Text: new
|———————Node:type_identifier Text: CAN_message_t
|———————Node:new_declarator Text: [sizeRxBuffer]
|————————Node:[ Text: [
|————————Node:identifier Text: sizeRxBuffer
|————————Node:] Text: ]
|—————Node:; Text: ;
|———Node:expression_statement Text: initRingBuffer(rxRing, rx_buffer, sizeRxBuffer);
|————Node:call_expression Text: initRingBuffer(rxRing, rx_buffer, sizeRxBuffer)
|—————Node:identifier Text: initRingBuffer
|—————Node:argument_list Text: (rxRing, rx_buffer, sizeRxBuffer)
|——————Node:( Text: (
|——————Node:identifier Text: rxRing
|——————Node:, Text: ,
|——————Node:identifier Text: rx_buffer
|——————Node:, Text: ,
|——————Node:identifier Text: sizeRxBuffer
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::initRingBuffer(RingbufferTypeDef &ring, volatile CAN_message_t *buffer, uint32_t size)
{
    ring.buffer = buffer;
    ring.size = size;
    ring.head = 0;
    ring.tail = 0;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::initRingBuffer(RingbufferTypeDef &ring, volatile CAN_message_t *buffer, uint32_t size)
|———Node:qualified_identifier Text: stm32Can::initRingBuffer
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: initRingBuffer
|———Node:parameter_list Text: (RingbufferTypeDef &ring, volatile CAN_message_t *buffer, uint32_t size)
|————Node:( Text: (
|————Node:parameter_declaration Text: RingbufferTypeDef &ring
|—————Node:type_identifier Text: RingbufferTypeDef
|—————Node:reference_declarator Text: &ring
|——————Node:& Text: &
|——————Node:identifier Text: ring
|————Node:, Text: ,
|————Node:parameter_declaration Text: volatile CAN_message_t *buffer
|—————Node:type_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:type_identifier Text: CAN_message_t
|—————Node:pointer_declarator Text: *buffer
|——————Node:* Text: *
|——————Node:identifier Text: buffer
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t size
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: size
|————Node:) Text: )
|——Node:compound_statement Text: {
    ring.buffer = buffer;
    ring.size = size;
    ring.head = 0;
    ring.tail = 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: ring.buffer = buffer;
|————Node:assignment_expression Text: ring.buffer = buffer
|—————Node:field_expression Text: ring.buffer
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: buffer
|—————Node:= Text: =
|—————Node:identifier Text: buffer
|————Node:; Text: ;
|———Node:expression_statement Text: ring.size = size;
|————Node:assignment_expression Text: ring.size = size
|—————Node:field_expression Text: ring.size
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: size
|—————Node:= Text: =
|—————Node:identifier Text: size
|————Node:; Text: ;
|———Node:expression_statement Text: ring.head = 0;
|————Node:assignment_expression Text: ring.head = 0
|—————Node:field_expression Text: ring.head
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: head
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: ring.tail = 0;
|————Node:assignment_expression Text: ring.tail = 0
|—————Node:field_expression Text: ring.tail
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: tail
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool stm32Can::addToRingBuffer (RingbufferTypeDef &ring, const CAN_message_t &msg)
{
    uint16_t nextEntry;

    nextEntry =(ring.head + 1) % ring.size;

    /* check if the ring buffer is full */

    if(nextEntry == ring.tail) {
        return(false);
    }

    /* add the element to the ring */

    memcpy((void *)&ring.buffer[ring.head],(void *)&msg, sizeof(CAN_message_t));

    /* bump the head to point to the next free entry */

    ring.head = nextEntry;

    return(true);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::addToRingBuffer (RingbufferTypeDef &ring, const CAN_message_t &msg)
|———Node:qualified_identifier Text: stm32Can::addToRingBuffer
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: addToRingBuffer
|———Node:parameter_list Text: (RingbufferTypeDef &ring, const CAN_message_t &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: RingbufferTypeDef &ring
|—————Node:type_identifier Text: RingbufferTypeDef
|—————Node:reference_declarator Text: &ring
|——————Node:& Text: &
|——————Node:identifier Text: ring
|————Node:, Text: ,
|————Node:parameter_declaration Text: const CAN_message_t &msg
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CAN_message_t
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint16_t nextEntry;

    nextEntry =(ring.head + 1) % ring.size;

    /* check if the ring buffer is full */

    if(nextEntry == ring.tail) {
        return(false);
    }

    /* add the element to the ring */

    memcpy((void *)&ring.buffer[ring.head],(void *)&msg, sizeof(CAN_message_t));

    /* bump the head to point to the next free entry */

    ring.head = nextEntry;

    return(true);
}
|———Node:{ Text: {
|———Node:declaration Text: uint16_t nextEntry;
|————Node:primitive_type Text: uint16_t
|————Node:identifier Text: nextEntry
|————Node:; Text: ;
|———Node:expression_statement Text: nextEntry =(ring.head + 1) % ring.size;
|————Node:assignment_expression Text: nextEntry =(ring.head + 1) % ring.size
|—————Node:identifier Text: nextEntry
|—————Node:= Text: =
|—————Node:binary_expression Text: (ring.head + 1) % ring.size
|——————Node:parenthesized_expression Text: (ring.head + 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: ring.head + 1
|————————Node:field_expression Text: ring.head
|—————————Node:identifier Text: ring
|—————————Node:. Text: .
|—————————Node:field_identifier Text: head
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:% Text: %
|——————Node:field_expression Text: ring.size
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: size
|————Node:; Text: ;
|———Node:comment Text: /* check if the ring buffer is full */
|———Node:if_statement Text: if(nextEntry == ring.tail) {
        return(false);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (nextEntry == ring.tail)
|—————Node:( Text: (
|—————Node:binary_expression Text: nextEntry == ring.tail
|——————Node:identifier Text: nextEntry
|——————Node:== Text: ==
|——————Node:field_expression Text: ring.tail
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: tail
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return(false);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return(false);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (false)
|———————Node:( Text: (
|———————Node:false Text: false
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* add the element to the ring */
|———Node:expression_statement Text: memcpy((void *)&ring.buffer[ring.head],(void *)&msg, sizeof(CAN_message_t));
|————Node:call_expression Text: memcpy((void *)&ring.buffer[ring.head],(void *)&msg, sizeof(CAN_message_t))
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: ((void *)&ring.buffer[ring.head],(void *)&msg, sizeof(CAN_message_t))
|——————Node:( Text: (
|——————Node:cast_expression Text: (void *)&ring.buffer[ring.head]
|———————Node:( Text: (
|———————Node:type_descriptor Text: void *
|————————Node:primitive_type Text: void
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:pointer_expression Text: &ring.buffer[ring.head]
|————————Node:& Text: &
|————————Node:subscript_expression Text: ring.buffer[ring.head]
|—————————Node:field_expression Text: ring.buffer
|——————————Node:identifier Text: ring
|——————————Node:. Text: .
|——————————Node:field_identifier Text: buffer
|—————————Node:subscript_argument_list Text: [ring.head]
|——————————Node:[ Text: [
|——————————Node:field_expression Text: ring.head
|———————————Node:identifier Text: ring
|———————————Node:. Text: .
|———————————Node:field_identifier Text: head
|——————————Node:] Text: ]
|——————Node:, Text: ,
|——————Node:cast_expression Text: (void *)&msg
|———————Node:( Text: (
|———————Node:type_descriptor Text: void *
|————————Node:primitive_type Text: void
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:pointer_expression Text: &msg
|————————Node:& Text: &
|————————Node:identifier Text: msg
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(CAN_message_t)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (CAN_message_t)
|————————Node:( Text: (
|————————Node:identifier Text: CAN_message_t
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* bump the head to point to the next free entry */
|———Node:expression_statement Text: ring.head = nextEntry;
|————Node:assignment_expression Text: ring.head = nextEntry
|—————Node:field_expression Text: ring.head
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: head
|—————Node:= Text: =
|—————Node:identifier Text: nextEntry
|————Node:; Text: ;
|———Node:return_statement Text: return(true);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (true)
|—————Node:( Text: (
|—————Node:true Text: true
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 * \brief Remove a CAN message from the specified ring buffer.
 *
 * \param ring - ring buffer to use.
 * \param msg - message structure to fill in.
 *
 * \retval true if a message was removed, false if the ring is empty.
 *
 */
|—Node:function_definition Text: bool stm32Can::removeFromRingBuffer(RingbufferTypeDef &ring, CAN_message_t &msg)
{

    /* check if the ring buffer has data available */

    if(isRingBufferEmpty(ring) == true) {
        return(false);
    }

    /* copy the message */

    memcpy((void *)&msg,(void *)&ring.buffer[ring.tail], sizeof(CAN_message_t));

    /* bump the tail pointer */

    ring.tail =(ring.tail + 1) % ring.size;

    return(true);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::removeFromRingBuffer(RingbufferTypeDef &ring, CAN_message_t &msg)
|———Node:qualified_identifier Text: stm32Can::removeFromRingBuffer
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: removeFromRingBuffer
|———Node:parameter_list Text: (RingbufferTypeDef &ring, CAN_message_t &msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: RingbufferTypeDef &ring
|—————Node:type_identifier Text: RingbufferTypeDef
|—————Node:reference_declarator Text: &ring
|——————Node:& Text: &
|——————Node:identifier Text: ring
|————Node:, Text: ,
|————Node:parameter_declaration Text: CAN_message_t &msg
|—————Node:type_identifier Text: CAN_message_t
|—————Node:reference_declarator Text: &msg
|——————Node:& Text: &
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {

    /* check if the ring buffer has data available */

    if(isRingBufferEmpty(ring) == true) {
        return(false);
    }

    /* copy the message */

    memcpy((void *)&msg,(void *)&ring.buffer[ring.tail], sizeof(CAN_message_t));

    /* bump the tail pointer */

    ring.tail =(ring.tail + 1) % ring.size;

    return(true);
}
|———Node:{ Text: {
|———Node:comment Text: /* check if the ring buffer has data available */
|———Node:if_statement Text: if(isRingBufferEmpty(ring) == true) {
        return(false);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (isRingBufferEmpty(ring) == true)
|—————Node:( Text: (
|—————Node:binary_expression Text: isRingBufferEmpty(ring) == true
|——————Node:call_expression Text: isRingBufferEmpty(ring)
|———————Node:identifier Text: isRingBufferEmpty
|———————Node:argument_list Text: (ring)
|————————Node:( Text: (
|————————Node:identifier Text: ring
|————————Node:) Text: )
|——————Node:== Text: ==
|——————Node:true Text: true
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return(false);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return(false);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (false)
|———————Node:( Text: (
|———————Node:false Text: false
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* copy the message */
|———Node:expression_statement Text: memcpy((void *)&msg,(void *)&ring.buffer[ring.tail], sizeof(CAN_message_t));
|————Node:call_expression Text: memcpy((void *)&msg,(void *)&ring.buffer[ring.tail], sizeof(CAN_message_t))
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: ((void *)&msg,(void *)&ring.buffer[ring.tail], sizeof(CAN_message_t))
|——————Node:( Text: (
|——————Node:cast_expression Text: (void *)&msg
|———————Node:( Text: (
|———————Node:type_descriptor Text: void *
|————————Node:primitive_type Text: void
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:pointer_expression Text: &msg
|————————Node:& Text: &
|————————Node:identifier Text: msg
|——————Node:, Text: ,
|——————Node:cast_expression Text: (void *)&ring.buffer[ring.tail]
|———————Node:( Text: (
|———————Node:type_descriptor Text: void *
|————————Node:primitive_type Text: void
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:pointer_expression Text: &ring.buffer[ring.tail]
|————————Node:& Text: &
|————————Node:subscript_expression Text: ring.buffer[ring.tail]
|—————————Node:field_expression Text: ring.buffer
|——————————Node:identifier Text: ring
|——————————Node:. Text: .
|——————————Node:field_identifier Text: buffer
|—————————Node:subscript_argument_list Text: [ring.tail]
|——————————Node:[ Text: [
|——————————Node:field_expression Text: ring.tail
|———————————Node:identifier Text: ring
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tail
|——————————Node:] Text: ]
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(CAN_message_t)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (CAN_message_t)
|————————Node:( Text: (
|————————Node:identifier Text: CAN_message_t
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* bump the tail pointer */
|———Node:expression_statement Text: ring.tail =(ring.tail + 1) % ring.size;
|————Node:assignment_expression Text: ring.tail =(ring.tail + 1) % ring.size
|—————Node:field_expression Text: ring.tail
|——————Node:identifier Text: ring
|——————Node:. Text: .
|——————Node:field_identifier Text: tail
|—————Node:= Text: =
|—————Node:binary_expression Text: (ring.tail + 1) % ring.size
|——————Node:parenthesized_expression Text: (ring.tail + 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: ring.tail + 1
|————————Node:field_expression Text: ring.tail
|—————————Node:identifier Text: ring
|—————————Node:. Text: .
|—————————Node:field_identifier Text: tail
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:% Text: %
|——————Node:field_expression Text: ring.size
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: size
|————Node:; Text: ;
|———Node:return_statement Text: return(true);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (true)
|—————Node:( Text: (
|—————Node:true Text: true
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 * \brief Check if the specified ring buffer is empty.
 *
 * \param ring - ring buffer to use.
 *
 * \retval true if the ring contains data, false if the ring is empty.
 *
 */
|—Node:function_definition Text: bool stm32Can::isRingBufferEmpty(RingbufferTypeDef &ring)
{
    if(ring.head == ring.tail) {
        return(true);
    }

    return(false);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: stm32Can::isRingBufferEmpty(RingbufferTypeDef &ring)
|———Node:qualified_identifier Text: stm32Can::isRingBufferEmpty
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: isRingBufferEmpty
|———Node:parameter_list Text: (RingbufferTypeDef &ring)
|————Node:( Text: (
|————Node:parameter_declaration Text: RingbufferTypeDef &ring
|—————Node:type_identifier Text: RingbufferTypeDef
|—————Node:reference_declarator Text: &ring
|——————Node:& Text: &
|——————Node:identifier Text: ring
|————Node:) Text: )
|——Node:compound_statement Text: {
    if(ring.head == ring.tail) {
        return(true);
    }

    return(false);
}
|———Node:{ Text: {
|———Node:if_statement Text: if(ring.head == ring.tail) {
        return(true);
    }
|————Node:if Text: if
|————Node:condition_clause Text: (ring.head == ring.tail)
|—————Node:( Text: (
|—————Node:binary_expression Text: ring.head == ring.tail
|——————Node:field_expression Text: ring.head
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: head
|——————Node:== Text: ==
|——————Node:field_expression Text: ring.tail
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: tail
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return(true);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return(true);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (true)
|———————Node:( Text: (
|———————Node:true Text: true
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return(false);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (false)
|—————Node:( Text: (
|—————Node:false Text: false
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 * \brief Count the number of entries in the specified ring buffer.
 *
 * \param ring - ring buffer to use.
 *
 * \retval a count of the number of elements in the ring buffer.
 *
 */
|—Node:function_definition Text: uint32_t stm32Can::ringBufferCount(RingbufferTypeDef &ring)
{
    int32_t entries;

    entries = ring.head - ring.tail;

    if(entries < 0) {
        entries += ring.size;
    }

    return((uint32_t)entries);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: stm32Can::ringBufferCount(RingbufferTypeDef &ring)
|———Node:qualified_identifier Text: stm32Can::ringBufferCount
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: ringBufferCount
|———Node:parameter_list Text: (RingbufferTypeDef &ring)
|————Node:( Text: (
|————Node:parameter_declaration Text: RingbufferTypeDef &ring
|—————Node:type_identifier Text: RingbufferTypeDef
|—————Node:reference_declarator Text: &ring
|——————Node:& Text: &
|——————Node:identifier Text: ring
|————Node:) Text: )
|——Node:compound_statement Text: {
    int32_t entries;

    entries = ring.head - ring.tail;

    if(entries < 0) {
        entries += ring.size;
    }

    return((uint32_t)entries);
}
|———Node:{ Text: {
|———Node:declaration Text: int32_t entries;
|————Node:primitive_type Text: int32_t
|————Node:identifier Text: entries
|————Node:; Text: ;
|———Node:expression_statement Text: entries = ring.head - ring.tail;
|————Node:assignment_expression Text: entries = ring.head - ring.tail
|—————Node:identifier Text: entries
|—————Node:= Text: =
|—————Node:binary_expression Text: ring.head - ring.tail
|——————Node:field_expression Text: ring.head
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: head
|——————Node:- Text: -
|——————Node:field_expression Text: ring.tail
|———————Node:identifier Text: ring
|———————Node:. Text: .
|———————Node:field_identifier Text: tail
|————Node:; Text: ;
|———Node:if_statement Text: if(entries < 0) {
        entries += ring.size;
    }
|————Node:if Text: if
|————Node:condition_clause Text: (entries < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: entries < 0
|——————Node:identifier Text: entries
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        entries += ring.size;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: entries += ring.size;
|——————Node:assignment_expression Text: entries += ring.size
|———————Node:identifier Text: entries
|———————Node:+= Text: +=
|———————Node:field_expression Text: ring.size
|————————Node:identifier Text: ring
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return((uint32_t)entries);
|————Node:return Text: return
|————Node:parenthesized_expression Text: ((uint32_t)entries)
|—————Node:( Text: (
|—————Node:cast_expression Text: (uint32_t)entries
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:identifier Text: entries
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::calculateBaudrate( CAN_HandleTypeDef *CanHandle, int baudrate )
{
  int sjw = 1;
  int bs1 = 1;
  int bs2 = 1;
  int prescaler = 1;
  uint32_t _SyncJumpWidth;
  uint32_t _TimeSeg1;
  uint32_t _TimeSeg2;
  uint32_t _Prescaler;
  
  bool shouldBrake = false;
  
  uint32_t frequency = getAPB1Clock();
  
  for (; sjw <= 4 && !shouldBrake; )
  {
    for (; prescaler <= 1024 && !shouldBrake; )
    {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
    if (!shouldBrake)
    {
      bs1 = 1;
      sjw++;
    }
  }

  CanHandle->Init.SyncJumpWidth = _SyncJumpWidth;
  CanHandle->Init.TimeSeg1 = _TimeSeg1;
  CanHandle->Init.TimeSeg2 = _TimeSeg2;
  CanHandle->Init.Prescaler = _Prescaler;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::calculateBaudrate( CAN_HandleTypeDef *CanHandle, int baudrate )
|———Node:qualified_identifier Text: stm32Can::calculateBaudrate
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: calculateBaudrate
|———Node:parameter_list Text: ( CAN_HandleTypeDef *CanHandle, int baudrate )
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_HandleTypeDef *CanHandle
|—————Node:type_identifier Text: CAN_HandleTypeDef
|—————Node:pointer_declarator Text: *CanHandle
|——————Node:* Text: *
|——————Node:identifier Text: CanHandle
|————Node:, Text: ,
|————Node:parameter_declaration Text: int baudrate
|—————Node:primitive_type Text: int
|—————Node:identifier Text: baudrate
|————Node:) Text: )
|——Node:compound_statement Text: {
  int sjw = 1;
  int bs1 = 1;
  int bs2 = 1;
  int prescaler = 1;
  uint32_t _SyncJumpWidth;
  uint32_t _TimeSeg1;
  uint32_t _TimeSeg2;
  uint32_t _Prescaler;
  
  bool shouldBrake = false;
  
  uint32_t frequency = getAPB1Clock();
  
  for (; sjw <= 4 && !shouldBrake; )
  {
    for (; prescaler <= 1024 && !shouldBrake; )
    {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
    if (!shouldBrake)
    {
      bs1 = 1;
      sjw++;
    }
  }

  CanHandle->Init.SyncJumpWidth = _SyncJumpWidth;
  CanHandle->Init.TimeSeg1 = _TimeSeg1;
  CanHandle->Init.TimeSeg2 = _TimeSeg2;
  CanHandle->Init.Prescaler = _Prescaler;
}
|———Node:{ Text: {
|———Node:declaration Text: int sjw = 1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: sjw = 1
|—————Node:identifier Text: sjw
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: int bs1 = 1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: bs1 = 1
|—————Node:identifier Text: bs1
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: int bs2 = 1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: bs2 = 1
|—————Node:identifier Text: bs2
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: int prescaler = 1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: prescaler = 1
|—————Node:identifier Text: prescaler
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: uint32_t _SyncJumpWidth;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: _SyncJumpWidth
|————Node:; Text: ;
|———Node:declaration Text: uint32_t _TimeSeg1;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: _TimeSeg1
|————Node:; Text: ;
|———Node:declaration Text: uint32_t _TimeSeg2;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: _TimeSeg2
|————Node:; Text: ;
|———Node:declaration Text: uint32_t _Prescaler;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: _Prescaler
|————Node:; Text: ;
|———Node:declaration Text: bool shouldBrake = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: shouldBrake = false
|—————Node:identifier Text: shouldBrake
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: uint32_t frequency = getAPB1Clock();
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: frequency = getAPB1Clock()
|—————Node:identifier Text: frequency
|—————Node:= Text: =
|—————Node:call_expression Text: getAPB1Clock()
|——————Node:identifier Text: getAPB1Clock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:for_statement Text: for (; sjw <= 4 && !shouldBrake; )
  {
    for (; prescaler <= 1024 && !shouldBrake; )
    {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
    if (!shouldBrake)
    {
      bs1 = 1;
      sjw++;
    }
  }
|————Node:for Text: for
|————Node:( Text: (
|————Node:; Text: ;
|————Node:binary_expression Text: sjw <= 4 && !shouldBrake
|—————Node:binary_expression Text: sjw <= 4
|——————Node:identifier Text: sjw
|——————Node:<= Text: <=
|——————Node:number_literal Text: 4
|—————Node:&& Text: &&
|—————Node:unary_expression Text: !shouldBrake
|——————Node:! Text: !
|——————Node:identifier Text: shouldBrake
|————Node:; Text: ;
|————Node:) Text: )
|————Node:compound_statement Text: {
    for (; prescaler <= 1024 && !shouldBrake; )
    {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
    if (!shouldBrake)
    {
      bs1 = 1;
      sjw++;
    }
  }
|—————Node:{ Text: {
|—————Node:for_statement Text: for (; prescaler <= 1024 && !shouldBrake; )
    {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:; Text: ;
|——————Node:binary_expression Text: prescaler <= 1024 && !shouldBrake
|———————Node:binary_expression Text: prescaler <= 1024
|————————Node:identifier Text: prescaler
|————————Node:<= Text: <=
|————————Node:number_literal Text: 1024
|———————Node:&& Text: &&
|———————Node:unary_expression Text: !shouldBrake
|————————Node:! Text: !
|————————Node:identifier Text: shouldBrake
|——————Node:; Text: ;
|——————Node:) Text: )
|——————Node:compound_statement Text: {
      for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
      if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
    }
|———————Node:{ Text: {
|———————Node:for_statement Text: for (; bs2 <= 8 && !shouldBrake; )
      {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:; Text: ;
|————————Node:binary_expression Text: bs2 <= 8 && !shouldBrake
|—————————Node:binary_expression Text: bs2 <= 8
|——————————Node:identifier Text: bs2
|——————————Node:<= Text: <=
|——————————Node:number_literal Text: 8
|—————————Node:&& Text: &&
|—————————Node:unary_expression Text: !shouldBrake
|——————————Node:! Text: !
|——————————Node:identifier Text: shouldBrake
|————————Node:; Text: ;
|————————Node:) Text: )
|————————Node:compound_statement Text: {
        for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
        if (!shouldBrake)
        {
          bs2++;
        }
      }
|—————————Node:{ Text: {
|—————————Node:for_statement Text: for (; bs1 <= 16 && !shouldBrake; )
        {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:; Text: ;
|——————————Node:binary_expression Text: bs1 <= 16 && !shouldBrake
|———————————Node:binary_expression Text: bs1 <= 16
|————————————Node:identifier Text: bs1
|————————————Node:<= Text: <=
|————————————Node:number_literal Text: 16
|———————————Node:&& Text: &&
|———————————Node:unary_expression Text: !shouldBrake
|————————————Node:! Text: !
|————————————Node:identifier Text: shouldBrake
|——————————Node:; Text: ;
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
          int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
          
          if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
          bs1++;
        }
|———————————Node:{ Text: {
|———————————Node:declaration Text: int calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)));
|————————————Node:primitive_type Text: int
|————————————Node:init_declarator Text: calcBaudrate = (int)(frequency / (prescaler * (sjw + bs1 + bs2)))
|—————————————Node:identifier Text: calcBaudrate
|—————————————Node:= Text: =
|—————————————Node:cast_expression Text: (int)(frequency / (prescaler * (sjw + bs1 + bs2)))
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: int
|———————————————Node:primitive_type Text: int
|——————————————Node:) Text: )
|——————————————Node:parenthesized_expression Text: (frequency / (prescaler * (sjw + bs1 + bs2)))
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: frequency / (prescaler * (sjw + bs1 + bs2))
|————————————————Node:identifier Text: frequency
|————————————————Node:/ Text: /
|————————————————Node:parenthesized_expression Text: (prescaler * (sjw + bs1 + bs2))
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: prescaler * (sjw + bs1 + bs2)
|——————————————————Node:identifier Text: prescaler
|——————————————————Node:* Text: *
|——————————————————Node:parenthesized_expression Text: (sjw + bs1 + bs2)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: sjw + bs1 + bs2
|————————————————————Node:binary_expression Text: sjw + bs1
|—————————————————————Node:identifier Text: sjw
|—————————————————————Node:+ Text: +
|—————————————————————Node:identifier Text: bs1
|————————————————————Node:+ Text: +
|————————————————————Node:identifier Text: bs2
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if (calcBaudrate == baudrate)
          {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (calcBaudrate == baudrate)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: calcBaudrate == baudrate
|——————————————Node:identifier Text: calcBaudrate
|——————————————Node:== Text: ==
|——————————————Node:identifier Text: baudrate
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
            if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;

            if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;

            if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;

            _Prescaler = prescaler;

            shouldBrake = true;
          }
|—————————————Node:{ Text: {
|—————————————Node:if_statement Text: if (sjw == 1)
              _SyncJumpWidth = CAN_SJW_1TQ;
            else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (sjw == 1)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: sjw == 1
|————————————————Node:identifier Text: sjw
|————————————————Node:== Text: ==
|————————————————Node:number_literal Text: 1
|———————————————Node:) Text: )
|——————————————Node:expression_statement Text: _SyncJumpWidth = CAN_SJW_1TQ;
|———————————————Node:assignment_expression Text: _SyncJumpWidth = CAN_SJW_1TQ
|————————————————Node:identifier Text: _SyncJumpWidth
|————————————————Node:= Text: =
|————————————————Node:identifier Text: CAN_SJW_1TQ
|———————————————Node:; Text: ;
|——————————————Node:else_clause Text: else if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|———————————————Node:else Text: else
|———————————————Node:if_statement Text: if (sjw == 2)
              _SyncJumpWidth = CAN_SJW_2TQ;
            else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (sjw == 2)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: sjw == 2
|——————————————————Node:identifier Text: sjw
|——————————————————Node:== Text: ==
|——————————————————Node:number_literal Text: 2
|—————————————————Node:) Text: )
|————————————————Node:expression_statement Text: _SyncJumpWidth = CAN_SJW_2TQ;
|—————————————————Node:assignment_expression Text: _SyncJumpWidth = CAN_SJW_2TQ
|——————————————————Node:identifier Text: _SyncJumpWidth
|——————————————————Node:= Text: =
|——————————————————Node:identifier Text: CAN_SJW_2TQ
|—————————————————Node:; Text: ;
|————————————————Node:else_clause Text: else if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|—————————————————Node:else Text: else
|—————————————————Node:if_statement Text: if (sjw == 3)
              _SyncJumpWidth = CAN_SJW_3TQ;
            else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|——————————————————Node:if Text: if
|——————————————————Node:condition_clause Text: (sjw == 3)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: sjw == 3
|————————————————————Node:identifier Text: sjw
|————————————————————Node:== Text: ==
|————————————————————Node:number_literal Text: 3
|———————————————————Node:) Text: )
|——————————————————Node:expression_statement Text: _SyncJumpWidth = CAN_SJW_3TQ;
|———————————————————Node:assignment_expression Text: _SyncJumpWidth = CAN_SJW_3TQ
|————————————————————Node:identifier Text: _SyncJumpWidth
|————————————————————Node:= Text: =
|————————————————————Node:identifier Text: CAN_SJW_3TQ
|———————————————————Node:; Text: ;
|——————————————————Node:else_clause Text: else if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|———————————————————Node:else Text: else
|———————————————————Node:if_statement Text: if (sjw == 4)
              _SyncJumpWidth = CAN_SJW_4TQ;
|————————————————————Node:if Text: if
|————————————————————Node:condition_clause Text: (sjw == 4)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: sjw == 4
|——————————————————————Node:identifier Text: sjw
|——————————————————————Node:== Text: ==
|——————————————————————Node:number_literal Text: 4
|—————————————————————Node:) Text: )
|————————————————————Node:expression_statement Text: _SyncJumpWidth = CAN_SJW_4TQ;
|—————————————————————Node:assignment_expression Text: _SyncJumpWidth = CAN_SJW_4TQ
|——————————————————————Node:identifier Text: _SyncJumpWidth
|——————————————————————Node:= Text: =
|——————————————————————Node:identifier Text: CAN_SJW_4TQ
|—————————————————————Node:; Text: ;
|—————————————Node:if_statement Text: if (bs1 == 1)
              _TimeSeg1 = CAN_BS1_1TQ;
            else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (bs1 == 1)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: bs1 == 1
|————————————————Node:identifier Text: bs1
|————————————————Node:== Text: ==
|————————————————Node:number_literal Text: 1
|———————————————Node:) Text: )
|——————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_1TQ;
|———————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_1TQ
|————————————————Node:identifier Text: _TimeSeg1
|————————————————Node:= Text: =
|————————————————Node:identifier Text: CAN_BS1_1TQ
|———————————————Node:; Text: ;
|——————————————Node:else_clause Text: else if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————Node:else Text: else
|———————————————Node:if_statement Text: if (bs1 == 2)
              _TimeSeg1 = CAN_BS1_2TQ;
            else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (bs1 == 2)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: bs1 == 2
|——————————————————Node:identifier Text: bs1
|——————————————————Node:== Text: ==
|——————————————————Node:number_literal Text: 2
|—————————————————Node:) Text: )
|————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_2TQ;
|—————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_2TQ
|——————————————————Node:identifier Text: _TimeSeg1
|——————————————————Node:= Text: =
|——————————————————Node:identifier Text: CAN_BS1_2TQ
|—————————————————Node:; Text: ;
|————————————————Node:else_clause Text: else if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————Node:else Text: else
|—————————————————Node:if_statement Text: if (bs1 == 3)
              _TimeSeg1 = CAN_BS1_3TQ;
            else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————Node:if Text: if
|——————————————————Node:condition_clause Text: (bs1 == 3)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: bs1 == 3
|————————————————————Node:identifier Text: bs1
|————————————————————Node:== Text: ==
|————————————————————Node:number_literal Text: 3
|———————————————————Node:) Text: )
|——————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_3TQ;
|———————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_3TQ
|————————————————————Node:identifier Text: _TimeSeg1
|————————————————————Node:= Text: =
|————————————————————Node:identifier Text: CAN_BS1_3TQ
|———————————————————Node:; Text: ;
|——————————————————Node:else_clause Text: else if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————Node:else Text: else
|———————————————————Node:if_statement Text: if (bs1 == 4)
              _TimeSeg1 = CAN_BS1_4TQ;
            else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————Node:if Text: if
|————————————————————Node:condition_clause Text: (bs1 == 4)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: bs1 == 4
|——————————————————————Node:identifier Text: bs1
|——————————————————————Node:== Text: ==
|——————————————————————Node:number_literal Text: 4
|—————————————————————Node:) Text: )
|————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_4TQ;
|—————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_4TQ
|——————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————Node:= Text: =
|——————————————————————Node:identifier Text: CAN_BS1_4TQ
|—————————————————————Node:; Text: ;
|————————————————————Node:else_clause Text: else if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————Node:else Text: else
|—————————————————————Node:if_statement Text: if (bs1 == 5)
              _TimeSeg1 = CAN_BS1_5TQ;
            else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————Node:if Text: if
|——————————————————————Node:condition_clause Text: (bs1 == 5)
|———————————————————————Node:( Text: (
|———————————————————————Node:binary_expression Text: bs1 == 5
|————————————————————————Node:identifier Text: bs1
|————————————————————————Node:== Text: ==
|————————————————————————Node:number_literal Text: 5
|———————————————————————Node:) Text: )
|——————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_5TQ;
|———————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_5TQ
|————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————Node:= Text: =
|————————————————————————Node:identifier Text: CAN_BS1_5TQ
|———————————————————————Node:; Text: ;
|——————————————————————Node:else_clause Text: else if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————Node:else Text: else
|———————————————————————Node:if_statement Text: if (bs1 == 6)
              _TimeSeg1 = CAN_BS1_6TQ;
            else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————Node:if Text: if
|————————————————————————Node:condition_clause Text: (bs1 == 6)
|—————————————————————————Node:( Text: (
|—————————————————————————Node:binary_expression Text: bs1 == 6
|——————————————————————————Node:identifier Text: bs1
|——————————————————————————Node:== Text: ==
|——————————————————————————Node:number_literal Text: 6
|—————————————————————————Node:) Text: )
|————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_6TQ;
|—————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_6TQ
|——————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————Node:= Text: =
|——————————————————————————Node:identifier Text: CAN_BS1_6TQ
|—————————————————————————Node:; Text: ;
|————————————————————————Node:else_clause Text: else if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————Node:else Text: else
|—————————————————————————Node:if_statement Text: if (bs1 == 7)
              _TimeSeg1 = CAN_BS1_7TQ;
            else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————————Node:if Text: if
|——————————————————————————Node:condition_clause Text: (bs1 == 7)
|———————————————————————————Node:( Text: (
|———————————————————————————Node:binary_expression Text: bs1 == 7
|————————————————————————————Node:identifier Text: bs1
|————————————————————————————Node:== Text: ==
|————————————————————————————Node:number_literal Text: 7
|———————————————————————————Node:) Text: )
|——————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_7TQ;
|———————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_7TQ
|————————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————————Node:= Text: =
|————————————————————————————Node:identifier Text: CAN_BS1_7TQ
|———————————————————————————Node:; Text: ;
|——————————————————————————Node:else_clause Text: else if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————————Node:else Text: else
|———————————————————————————Node:if_statement Text: if (bs1 == 8)
              _TimeSeg1 = CAN_BS1_8TQ;
            else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————————Node:if Text: if
|————————————————————————————Node:condition_clause Text: (bs1 == 8)
|—————————————————————————————Node:( Text: (
|—————————————————————————————Node:binary_expression Text: bs1 == 8
|——————————————————————————————Node:identifier Text: bs1
|——————————————————————————————Node:== Text: ==
|——————————————————————————————Node:number_literal Text: 8
|—————————————————————————————Node:) Text: )
|————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_8TQ;
|—————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_8TQ
|——————————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————————Node:= Text: =
|——————————————————————————————Node:identifier Text: CAN_BS1_8TQ
|—————————————————————————————Node:; Text: ;
|————————————————————————————Node:else_clause Text: else if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————————Node:else Text: else
|—————————————————————————————Node:if_statement Text: if (bs1 == 9)
              _TimeSeg1 = CAN_BS1_9TQ;
            else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————————————Node:if Text: if
|——————————————————————————————Node:condition_clause Text: (bs1 == 9)
|———————————————————————————————Node:( Text: (
|———————————————————————————————Node:binary_expression Text: bs1 == 9
|————————————————————————————————Node:identifier Text: bs1
|————————————————————————————————Node:== Text: ==
|————————————————————————————————Node:number_literal Text: 9
|———————————————————————————————Node:) Text: )
|——————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_9TQ;
|———————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_9TQ
|————————————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————————————Node:= Text: =
|————————————————————————————————Node:identifier Text: CAN_BS1_9TQ
|———————————————————————————————Node:; Text: ;
|——————————————————————————————Node:else_clause Text: else if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————————————Node:else Text: else
|———————————————————————————————Node:if_statement Text: if (bs1 == 10)
              _TimeSeg1 = CAN_BS1_10TQ;
            else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————————————Node:if Text: if
|————————————————————————————————Node:condition_clause Text: (bs1 == 10)
|—————————————————————————————————Node:( Text: (
|—————————————————————————————————Node:binary_expression Text: bs1 == 10
|——————————————————————————————————Node:identifier Text: bs1
|——————————————————————————————————Node:== Text: ==
|——————————————————————————————————Node:number_literal Text: 10
|—————————————————————————————————Node:) Text: )
|————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_10TQ;
|—————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_10TQ
|——————————————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————————————Node:= Text: =
|——————————————————————————————————Node:identifier Text: CAN_BS1_10TQ
|—————————————————————————————————Node:; Text: ;
|————————————————————————————————Node:else_clause Text: else if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————————————Node:else Text: else
|—————————————————————————————————Node:if_statement Text: if (bs1 == 11)
              _TimeSeg1 = CAN_BS1_11TQ;
            else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————————————————Node:if Text: if
|——————————————————————————————————Node:condition_clause Text: (bs1 == 11)
|———————————————————————————————————Node:( Text: (
|———————————————————————————————————Node:binary_expression Text: bs1 == 11
|————————————————————————————————————Node:identifier Text: bs1
|————————————————————————————————————Node:== Text: ==
|————————————————————————————————————Node:number_literal Text: 11
|———————————————————————————————————Node:) Text: )
|——————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_11TQ;
|———————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_11TQ
|————————————————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————————————————Node:= Text: =
|————————————————————————————————————Node:identifier Text: CAN_BS1_11TQ
|———————————————————————————————————Node:; Text: ;
|——————————————————————————————————Node:else_clause Text: else if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————————————————Node:else Text: else
|———————————————————————————————————Node:if_statement Text: if (bs1 == 12)
              _TimeSeg1 = CAN_BS1_12TQ;
            else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————————————————Node:if Text: if
|————————————————————————————————————Node:condition_clause Text: (bs1 == 12)
|—————————————————————————————————————Node:( Text: (
|—————————————————————————————————————Node:binary_expression Text: bs1 == 12
|——————————————————————————————————————Node:identifier Text: bs1
|——————————————————————————————————————Node:== Text: ==
|——————————————————————————————————————Node:number_literal Text: 12
|—————————————————————————————————————Node:) Text: )
|————————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_12TQ;
|—————————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_12TQ
|——————————————————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————————————————Node:= Text: =
|——————————————————————————————————————Node:identifier Text: CAN_BS1_12TQ
|—————————————————————————————————————Node:; Text: ;
|————————————————————————————————————Node:else_clause Text: else if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————————————————Node:else Text: else
|—————————————————————————————————————Node:if_statement Text: if (bs1 == 13)
              _TimeSeg1 = CAN_BS1_13TQ;
            else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————————————————————Node:if Text: if
|——————————————————————————————————————Node:condition_clause Text: (bs1 == 13)
|———————————————————————————————————————Node:( Text: (
|———————————————————————————————————————Node:binary_expression Text: bs1 == 13
|————————————————————————————————————————Node:identifier Text: bs1
|————————————————————————————————————————Node:== Text: ==
|————————————————————————————————————————Node:number_literal Text: 13
|———————————————————————————————————————Node:) Text: )
|——————————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_13TQ;
|———————————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_13TQ
|————————————————————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————————————————————Node:= Text: =
|————————————————————————————————————————Node:identifier Text: CAN_BS1_13TQ
|———————————————————————————————————————Node:; Text: ;
|——————————————————————————————————————Node:else_clause Text: else if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————————————————————Node:else Text: else
|———————————————————————————————————————Node:if_statement Text: if (bs1 == 14)
              _TimeSeg1 = CAN_BS1_14TQ;
            else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————————————————————Node:if Text: if
|————————————————————————————————————————Node:condition_clause Text: (bs1 == 14)
|—————————————————————————————————————————Node:( Text: (
|—————————————————————————————————————————Node:binary_expression Text: bs1 == 14
|——————————————————————————————————————————Node:identifier Text: bs1
|——————————————————————————————————————————Node:== Text: ==
|——————————————————————————————————————————Node:number_literal Text: 14
|—————————————————————————————————————————Node:) Text: )
|————————————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_14TQ;
|—————————————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_14TQ
|——————————————————————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————————————————————Node:= Text: =
|——————————————————————————————————————————Node:identifier Text: CAN_BS1_14TQ
|—————————————————————————————————————————Node:; Text: ;
|————————————————————————————————————————Node:else_clause Text: else if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————————————————————Node:else Text: else
|—————————————————————————————————————————Node:if_statement Text: if (bs1 == 15)
              _TimeSeg1 = CAN_BS1_15TQ;
            else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|——————————————————————————————————————————Node:if Text: if
|——————————————————————————————————————————Node:condition_clause Text: (bs1 == 15)
|———————————————————————————————————————————Node:( Text: (
|———————————————————————————————————————————Node:binary_expression Text: bs1 == 15
|————————————————————————————————————————————Node:identifier Text: bs1
|————————————————————————————————————————————Node:== Text: ==
|————————————————————————————————————————————Node:number_literal Text: 15
|———————————————————————————————————————————Node:) Text: )
|——————————————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_15TQ;
|———————————————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_15TQ
|————————————————————————————————————————————Node:identifier Text: _TimeSeg1
|————————————————————————————————————————————Node:= Text: =
|————————————————————————————————————————————Node:identifier Text: CAN_BS1_15TQ
|———————————————————————————————————————————Node:; Text: ;
|——————————————————————————————————————————Node:else_clause Text: else if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|———————————————————————————————————————————Node:else Text: else
|———————————————————————————————————————————Node:if_statement Text: if (bs1 == 16)
              _TimeSeg1 = CAN_BS1_16TQ;
|————————————————————————————————————————————Node:if Text: if
|————————————————————————————————————————————Node:condition_clause Text: (bs1 == 16)
|—————————————————————————————————————————————Node:( Text: (
|—————————————————————————————————————————————Node:binary_expression Text: bs1 == 16
|——————————————————————————————————————————————Node:identifier Text: bs1
|——————————————————————————————————————————————Node:== Text: ==
|——————————————————————————————————————————————Node:number_literal Text: 16
|—————————————————————————————————————————————Node:) Text: )
|————————————————————————————————————————————Node:expression_statement Text: _TimeSeg1 = CAN_BS1_16TQ;
|—————————————————————————————————————————————Node:assignment_expression Text: _TimeSeg1 = CAN_BS1_16TQ
|——————————————————————————————————————————————Node:identifier Text: _TimeSeg1
|——————————————————————————————————————————————Node:= Text: =
|——————————————————————————————————————————————Node:identifier Text: CAN_BS1_16TQ
|—————————————————————————————————————————————Node:; Text: ;
|—————————————Node:if_statement Text: if (bs2 == 1)
              _TimeSeg2 = CAN_BS2_1TQ;
            else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (bs2 == 1)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: bs2 == 1
|————————————————Node:identifier Text: bs2
|————————————————Node:== Text: ==
|————————————————Node:number_literal Text: 1
|———————————————Node:) Text: )
|——————————————Node:expression_statement Text: _TimeSeg2 = CAN_BS2_1TQ;
|———————————————Node:assignment_expression Text: _TimeSeg2 = CAN_BS2_1TQ
|————————————————Node:identifier Text: _TimeSeg2
|————————————————Node:= Text: =
|————————————————Node:identifier Text: CAN_BS2_1TQ
|———————————————Node:; Text: ;
|——————————————Node:else_clause Text: else if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|———————————————Node:else Text: else
|———————————————Node:if_statement Text: if (bs2 == 2)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (bs2 == 2)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: bs2 == 2
|——————————————————Node:identifier Text: bs2
|——————————————————Node:== Text: ==
|——————————————————Node:number_literal Text: 2
|—————————————————Node:) Text: )
|————————————————Node:expression_statement Text: _TimeSeg2 = CAN_BS2_2TQ;
|—————————————————Node:assignment_expression Text: _TimeSeg2 = CAN_BS2_2TQ
|——————————————————Node:identifier Text: _TimeSeg2
|——————————————————Node:= Text: =
|——————————————————Node:identifier Text: CAN_BS2_2TQ
|—————————————————Node:; Text: ;
|————————————————Node:else_clause Text: else if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|—————————————————Node:else Text: else
|—————————————————Node:if_statement Text: if (bs2 == 3)
              _TimeSeg2 = CAN_BS2_2TQ;
            else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|——————————————————Node:if Text: if
|——————————————————Node:condition_clause Text: (bs2 == 3)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: bs2 == 3
|————————————————————Node:identifier Text: bs2
|————————————————————Node:== Text: ==
|————————————————————Node:number_literal Text: 3
|———————————————————Node:) Text: )
|——————————————————Node:expression_statement Text: _TimeSeg2 = CAN_BS2_2TQ;
|———————————————————Node:assignment_expression Text: _TimeSeg2 = CAN_BS2_2TQ
|————————————————————Node:identifier Text: _TimeSeg2
|————————————————————Node:= Text: =
|————————————————————Node:identifier Text: CAN_BS2_2TQ
|———————————————————Node:; Text: ;
|——————————————————Node:else_clause Text: else if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|———————————————————Node:else Text: else
|———————————————————Node:if_statement Text: if (bs2 == 4)
              _TimeSeg2 = CAN_BS2_2TQ;
|————————————————————Node:if Text: if
|————————————————————Node:condition_clause Text: (bs2 == 4)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: bs2 == 4
|——————————————————————Node:identifier Text: bs2
|——————————————————————Node:== Text: ==
|——————————————————————Node:number_literal Text: 4
|—————————————————————Node:) Text: )
|————————————————————Node:expression_statement Text: _TimeSeg2 = CAN_BS2_2TQ;
|—————————————————————Node:assignment_expression Text: _TimeSeg2 = CAN_BS2_2TQ
|——————————————————————Node:identifier Text: _TimeSeg2
|——————————————————————Node:= Text: =
|——————————————————————Node:identifier Text: CAN_BS2_2TQ
|—————————————————————Node:; Text: ;
|—————————————Node:expression_statement Text: _Prescaler = prescaler;
|——————————————Node:assignment_expression Text: _Prescaler = prescaler
|———————————————Node:identifier Text: _Prescaler
|———————————————Node:= Text: =
|———————————————Node:identifier Text: prescaler
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: shouldBrake = true;
|——————————————Node:assignment_expression Text: shouldBrake = true
|———————————————Node:identifier Text: shouldBrake
|———————————————Node:= Text: =
|———————————————Node:true Text: true
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: bs1++;
|————————————Node:update_expression Text: bs1++
|—————————————Node:identifier Text: bs1
|—————————————Node:++ Text: ++
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:if_statement Text: if (!shouldBrake)
        {
          bs2++;
        }
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (!shouldBrake)
|———————————Node:( Text: (
|———————————Node:unary_expression Text: !shouldBrake
|————————————Node:! Text: !
|————————————Node:identifier Text: shouldBrake
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
          bs2++;
        }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: bs2++;
|————————————Node:update_expression Text: bs2++
|—————————————Node:identifier Text: bs2
|—————————————Node:++ Text: ++
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:if_statement Text: if (!shouldBrake)
      {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
|————————Node:if Text: if
|————————Node:condition_clause Text: (!shouldBrake)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !shouldBrake
|——————————Node:! Text: !
|——————————Node:identifier Text: shouldBrake
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
        bs1 = 1;
        bs2 = 1;
        prescaler++;
      }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: bs1 = 1;
|——————————Node:assignment_expression Text: bs1 = 1
|———————————Node:identifier Text: bs1
|———————————Node:= Text: =
|———————————Node:number_literal Text: 1
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: bs2 = 1;
|——————————Node:assignment_expression Text: bs2 = 1
|———————————Node:identifier Text: bs2
|———————————Node:= Text: =
|———————————Node:number_literal Text: 1
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: prescaler++;
|——————————Node:update_expression Text: prescaler++
|———————————Node:identifier Text: prescaler
|———————————Node:++ Text: ++
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:if_statement Text: if (!shouldBrake)
    {
      bs1 = 1;
      sjw++;
    }
|——————Node:if Text: if
|——————Node:condition_clause Text: (!shouldBrake)
|———————Node:( Text: (
|———————Node:unary_expression Text: !shouldBrake
|————————Node:! Text: !
|————————Node:identifier Text: shouldBrake
|———————Node:) Text: )
|——————Node:compound_statement Text: {
      bs1 = 1;
      sjw++;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: bs1 = 1;
|————————Node:assignment_expression Text: bs1 = 1
|—————————Node:identifier Text: bs1
|—————————Node:= Text: =
|—————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:expression_statement Text: sjw++;
|————————Node:update_expression Text: sjw++
|—————————Node:identifier Text: sjw
|—————————Node:++ Text: ++
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: CanHandle->Init.SyncJumpWidth = _SyncJumpWidth;
|————Node:assignment_expression Text: CanHandle->Init.SyncJumpWidth = _SyncJumpWidth
|—————Node:field_expression Text: CanHandle->Init.SyncJumpWidth
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: SyncJumpWidth
|—————Node:= Text: =
|—————Node:identifier Text: _SyncJumpWidth
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.TimeSeg1 = _TimeSeg1;
|————Node:assignment_expression Text: CanHandle->Init.TimeSeg1 = _TimeSeg1
|—————Node:field_expression Text: CanHandle->Init.TimeSeg1
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: TimeSeg1
|—————Node:= Text: =
|—————Node:identifier Text: _TimeSeg1
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.TimeSeg2 = _TimeSeg2;
|————Node:assignment_expression Text: CanHandle->Init.TimeSeg2 = _TimeSeg2
|—————Node:field_expression Text: CanHandle->Init.TimeSeg2
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: TimeSeg2
|—————Node:= Text: =
|—————Node:identifier Text: _TimeSeg2
|————Node:; Text: ;
|———Node:expression_statement Text: CanHandle->Init.Prescaler = _Prescaler;
|————Node:assignment_expression Text: CanHandle->Init.Prescaler = _Prescaler
|—————Node:field_expression Text: CanHandle->Init.Prescaler
|——————Node:field_expression Text: CanHandle->Init
|———————Node:identifier Text: CanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Init
|——————Node:. Text: .
|——————Node:field_identifier Text: Prescaler
|—————Node:= Text: =
|—————Node:identifier Text: _Prescaler
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint32_t stm32Can::getAPB1Clock()
{
  RCC_ClkInitTypeDef clkInit;
  uint32_t flashLatency;
  HAL_RCC_GetClockConfig(&clkInit, &flashLatency);

  uint32_t hclkClock = HAL_RCC_GetHCLKFreq();
  uint8_t clockDivider = 1;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV1)
    clockDivider = 1;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV2)
    clockDivider = 2;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV4)
    clockDivider = 4;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV8)
    clockDivider = 8;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV16)
    clockDivider = 16;

  uint32_t apb1Clock = hclkClock / clockDivider;

  return apb1Clock;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: stm32Can::getAPB1Clock()
|———Node:qualified_identifier Text: stm32Can::getAPB1Clock
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: getAPB1Clock
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
  RCC_ClkInitTypeDef clkInit;
  uint32_t flashLatency;
  HAL_RCC_GetClockConfig(&clkInit, &flashLatency);

  uint32_t hclkClock = HAL_RCC_GetHCLKFreq();
  uint8_t clockDivider = 1;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV1)
    clockDivider = 1;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV2)
    clockDivider = 2;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV4)
    clockDivider = 4;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV8)
    clockDivider = 8;
  if (clkInit.APB1CLKDivider == RCC_HCLK_DIV16)
    clockDivider = 16;

  uint32_t apb1Clock = hclkClock / clockDivider;

  return apb1Clock;
}
|———Node:{ Text: {
|———Node:declaration Text: RCC_ClkInitTypeDef clkInit;
|————Node:type_identifier Text: RCC_ClkInitTypeDef
|————Node:identifier Text: clkInit
|————Node:; Text: ;
|———Node:declaration Text: uint32_t flashLatency;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: flashLatency
|————Node:; Text: ;
|———Node:expression_statement Text: HAL_RCC_GetClockConfig(&clkInit, &flashLatency);
|————Node:call_expression Text: HAL_RCC_GetClockConfig(&clkInit, &flashLatency)
|—————Node:identifier Text: HAL_RCC_GetClockConfig
|—————Node:argument_list Text: (&clkInit, &flashLatency)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &clkInit
|———————Node:& Text: &
|———————Node:identifier Text: clkInit
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &flashLatency
|———————Node:& Text: &
|———————Node:identifier Text: flashLatency
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t hclkClock = HAL_RCC_GetHCLKFreq();
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: hclkClock = HAL_RCC_GetHCLKFreq()
|—————Node:identifier Text: hclkClock
|—————Node:= Text: =
|—————Node:call_expression Text: HAL_RCC_GetHCLKFreq()
|——————Node:identifier Text: HAL_RCC_GetHCLKFreq
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint8_t clockDivider = 1;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: clockDivider = 1
|—————Node:identifier Text: clockDivider
|—————Node:= Text: =
|—————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:if_statement Text: if (clkInit.APB1CLKDivider == RCC_HCLK_DIV1)
    clockDivider = 1;
|————Node:if Text: if
|————Node:condition_clause Text: (clkInit.APB1CLKDivider == RCC_HCLK_DIV1)
|—————Node:( Text: (
|—————Node:binary_expression Text: clkInit.APB1CLKDivider == RCC_HCLK_DIV1
|——————Node:field_expression Text: clkInit.APB1CLKDivider
|———————Node:identifier Text: clkInit
|———————Node:. Text: .
|———————Node:field_identifier Text: APB1CLKDivider
|——————Node:== Text: ==
|——————Node:identifier Text: RCC_HCLK_DIV1
|—————Node:) Text: )
|————Node:expression_statement Text: clockDivider = 1;
|—————Node:assignment_expression Text: clockDivider = 1
|——————Node:identifier Text: clockDivider
|——————Node:= Text: =
|——————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (clkInit.APB1CLKDivider == RCC_HCLK_DIV2)
    clockDivider = 2;
|————Node:if Text: if
|————Node:condition_clause Text: (clkInit.APB1CLKDivider == RCC_HCLK_DIV2)
|—————Node:( Text: (
|—————Node:binary_expression Text: clkInit.APB1CLKDivider == RCC_HCLK_DIV2
|——————Node:field_expression Text: clkInit.APB1CLKDivider
|———————Node:identifier Text: clkInit
|———————Node:. Text: .
|———————Node:field_identifier Text: APB1CLKDivider
|——————Node:== Text: ==
|——————Node:identifier Text: RCC_HCLK_DIV2
|—————Node:) Text: )
|————Node:expression_statement Text: clockDivider = 2;
|—————Node:assignment_expression Text: clockDivider = 2
|——————Node:identifier Text: clockDivider
|——————Node:= Text: =
|——————Node:number_literal Text: 2
|—————Node:; Text: ;
|———Node:if_statement Text: if (clkInit.APB1CLKDivider == RCC_HCLK_DIV4)
    clockDivider = 4;
|————Node:if Text: if
|————Node:condition_clause Text: (clkInit.APB1CLKDivider == RCC_HCLK_DIV4)
|—————Node:( Text: (
|—————Node:binary_expression Text: clkInit.APB1CLKDivider == RCC_HCLK_DIV4
|——————Node:field_expression Text: clkInit.APB1CLKDivider
|———————Node:identifier Text: clkInit
|———————Node:. Text: .
|———————Node:field_identifier Text: APB1CLKDivider
|——————Node:== Text: ==
|——————Node:identifier Text: RCC_HCLK_DIV4
|—————Node:) Text: )
|————Node:expression_statement Text: clockDivider = 4;
|—————Node:assignment_expression Text: clockDivider = 4
|——————Node:identifier Text: clockDivider
|——————Node:= Text: =
|——————Node:number_literal Text: 4
|—————Node:; Text: ;
|———Node:if_statement Text: if (clkInit.APB1CLKDivider == RCC_HCLK_DIV8)
    clockDivider = 8;
|————Node:if Text: if
|————Node:condition_clause Text: (clkInit.APB1CLKDivider == RCC_HCLK_DIV8)
|—————Node:( Text: (
|—————Node:binary_expression Text: clkInit.APB1CLKDivider == RCC_HCLK_DIV8
|——————Node:field_expression Text: clkInit.APB1CLKDivider
|———————Node:identifier Text: clkInit
|———————Node:. Text: .
|———————Node:field_identifier Text: APB1CLKDivider
|——————Node:== Text: ==
|——————Node:identifier Text: RCC_HCLK_DIV8
|—————Node:) Text: )
|————Node:expression_statement Text: clockDivider = 8;
|—————Node:assignment_expression Text: clockDivider = 8
|——————Node:identifier Text: clockDivider
|——————Node:= Text: =
|——————Node:number_literal Text: 8
|—————Node:; Text: ;
|———Node:if_statement Text: if (clkInit.APB1CLKDivider == RCC_HCLK_DIV16)
    clockDivider = 16;
|————Node:if Text: if
|————Node:condition_clause Text: (clkInit.APB1CLKDivider == RCC_HCLK_DIV16)
|—————Node:( Text: (
|—————Node:binary_expression Text: clkInit.APB1CLKDivider == RCC_HCLK_DIV16
|——————Node:field_expression Text: clkInit.APB1CLKDivider
|———————Node:identifier Text: clkInit
|———————Node:. Text: .
|———————Node:field_identifier Text: APB1CLKDivider
|——————Node:== Text: ==
|——————Node:identifier Text: RCC_HCLK_DIV16
|—————Node:) Text: )
|————Node:expression_statement Text: clockDivider = 16;
|—————Node:assignment_expression Text: clockDivider = 16
|——————Node:identifier Text: clockDivider
|——————Node:= Text: =
|——————Node:number_literal Text: 16
|—————Node:; Text: ;
|———Node:declaration Text: uint32_t apb1Clock = hclkClock / clockDivider;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: apb1Clock = hclkClock / clockDivider
|—————Node:identifier Text: apb1Clock
|—————Node:= Text: =
|—————Node:binary_expression Text: hclkClock / clockDivider
|——————Node:identifier Text: hclkClock
|——————Node:/ Text: /
|——————Node:identifier Text: clockDivider
|————Node:; Text: ;
|———Node:return_statement Text: return apb1Clock;
|————Node:return Text: return
|————Node:identifier Text: apb1Clock
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::enableMBInterrupts()
{
    if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    }
#ifdef CAN2
    else
    {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
#endif
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::enableMBInterrupts()
|———Node:qualified_identifier Text: stm32Can::enableMBInterrupts
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: enableMBInterrupts
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    }
#ifdef CAN2
    else
    {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
#endif
}
|———Node:{ Text: {
|———Node:if_statement Text: if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    }
|————Node:if Text: if
|————Node:condition_clause Text: (n_pCanHandle->Instance == CAN1)
|—————Node:( Text: (
|—————Node:binary_expression Text: n_pCanHandle->Instance == CAN1
|——————Node:field_expression Text: n_pCanHandle->Instance
|———————Node:identifier Text: n_pCanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Instance
|——————Node:== Text: ==
|——————Node:identifier Text: CAN1
|—————Node:) Text: )
|————Node:compound_statement Text: {
      HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: HAL_NVIC_EnableIRQ( CAN1_TX_IRQn );
|——————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN1_TX_IRQn )
|———————Node:identifier Text: HAL_NVIC_EnableIRQ
|———————Node:argument_list Text: ( CAN1_TX_IRQn )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_TX_IRQn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_ifdef Text: #ifdef CAN2
    else
    {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
#endif
|————Node:#ifdef Text: #ifdef
|————Node:identifier Text: CAN2
|————Node:expression_statement Text: else
    {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
|—————Node:compound_literal_expression Text: else
    {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
|——————Node:type_identifier Text: else
|——————Node:initializer_list Text: {
      HAL_NVIC_EnableIRQ( CAN2_TX_IRQn );
    }
|———————Node:{ Text: {
|———————Node:call_expression Text: HAL_NVIC_EnableIRQ( CAN2_TX_IRQn )
|————————Node:identifier Text: HAL_NVIC_EnableIRQ
|————————Node:argument_list Text: ( CAN2_TX_IRQn )
|—————————Node:( Text: (
|—————————Node:identifier Text: CAN2_TX_IRQn
|—————————Node:) Text: )
|———————Node:ERROR Text: ;
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:; Text: 
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::disableMBInterrupts()
{
    if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_DisableIRQ( CAN1_TX_IRQn );
    }
#ifdef CAN2
    else
    {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
#endif
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::disableMBInterrupts()
|———Node:qualified_identifier Text: stm32Can::disableMBInterrupts
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: disableMBInterrupts
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_DisableIRQ( CAN1_TX_IRQn );
    }
#ifdef CAN2
    else
    {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
#endif
}
|———Node:{ Text: {
|———Node:if_statement Text: if (n_pCanHandle->Instance == CAN1) 
    {
      HAL_NVIC_DisableIRQ( CAN1_TX_IRQn );
    }
|————Node:if Text: if
|————Node:condition_clause Text: (n_pCanHandle->Instance == CAN1)
|—————Node:( Text: (
|—————Node:binary_expression Text: n_pCanHandle->Instance == CAN1
|——————Node:field_expression Text: n_pCanHandle->Instance
|———————Node:identifier Text: n_pCanHandle
|———————Node:-> Text: ->
|———————Node:field_identifier Text: Instance
|——————Node:== Text: ==
|——————Node:identifier Text: CAN1
|—————Node:) Text: )
|————Node:compound_statement Text: {
      HAL_NVIC_DisableIRQ( CAN1_TX_IRQn );
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: HAL_NVIC_DisableIRQ( CAN1_TX_IRQn );
|——————Node:call_expression Text: HAL_NVIC_DisableIRQ( CAN1_TX_IRQn )
|———————Node:identifier Text: HAL_NVIC_DisableIRQ
|———————Node:argument_list Text: ( CAN1_TX_IRQn )
|————————Node:( Text: (
|————————Node:identifier Text: CAN1_TX_IRQn
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:preproc_ifdef Text: #ifdef CAN2
    else
    {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
#endif
|————Node:#ifdef Text: #ifdef
|————Node:identifier Text: CAN2
|————Node:expression_statement Text: else
    {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
|—————Node:compound_literal_expression Text: else
    {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
|——————Node:type_identifier Text: else
|——————Node:initializer_list Text: {
      HAL_NVIC_DisableIRQ( CAN2_TX_IRQn );
    }
|———————Node:{ Text: {
|———————Node:call_expression Text: HAL_NVIC_DisableIRQ( CAN2_TX_IRQn )
|————————Node:identifier Text: HAL_NVIC_DisableIRQ
|————————Node:argument_list Text: ( CAN2_TX_IRQn )
|—————————Node:( Text: (
|—————————Node:identifier Text: CAN2_TX_IRQn
|—————————Node:) Text: )
|———————Node:ERROR Text: ;
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:; Text: 
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:comment Text: /* Interupt functions */
|—Node:linkage_specification Text: extern "C" void HAL_CAN_TxMailbox0CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB0 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void HAL_CAN_TxMailbox0CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB0 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: HAL_CAN_TxMailbox0CompleteCallback( CAN_HandleTypeDef *CanHandle )
|————Node:identifier Text: HAL_CAN_TxMailbox0CompleteCallback
|————Node:parameter_list Text: ( CAN_HandleTypeDef *CanHandle )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: CAN_HandleTypeDef *CanHandle
|——————Node:type_identifier Text: CAN_HandleTypeDef
|——————Node:pointer_declarator Text: *CanHandle
|———————Node:* Text: *
|———————Node:identifier Text: CanHandle
|—————Node:) Text: )
|———Node:compound_statement Text: {
  DEBUG(Serial.println( "MB0 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|————Node:{ Text: {
|————Node:expression_statement Text: DEBUG(Serial.println( "MB0 Empty int" ));
|—————Node:call_expression Text: DEBUG(Serial.println( "MB0 Empty int" ))
|——————Node:identifier Text: DEBUG
|——————Node:argument_list Text: (Serial.println( "MB0 Empty int" ))
|———————Node:( Text: (
|———————Node:call_expression Text: Serial.println( "MB0 Empty int" )
|————————Node:field_expression Text: Serial.println
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: println
|————————Node:argument_list Text: ( "MB0 Empty int" )
|—————————Node:( Text: (
|—————————Node:string_literal Text: "MB0 Empty int"
|——————————Node:" Text: "
|——————————Node:string_content Text: MB0 Empty int
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: uint32_t TxMailbox;
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: TxMailbox
|—————Node:; Text: ;
|————Node:declaration Text: CAN_message_t txmsg;
|—————Node:type_identifier Text: CAN_message_t
|—————Node:identifier Text: txmsg
|—————Node:; Text: ;
|————Node:declaration Text: CAN_TxHeaderTypeDef TxHeader;
|—————Node:type_identifier Text: CAN_TxHeaderTypeDef
|—————Node:identifier Text: TxHeader
|—————Node:; Text: ;
|————Node:if_statement Text: if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
|——————Node:( Text: (
|——————Node:call_expression Text: pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg)
|———————Node:field_expression Text: pointerToClass->removeFromRingBuffer
|————————Node:identifier Text: pointerToClass
|————————Node:-> Text: ->
|————————Node:field_identifier Text: removeFromRingBuffer
|———————Node:argument_list Text: (pointerToClass->txRing, txmsg)
|————————Node:( Text: (
|————————Node:field_expression Text: pointerToClass->txRing
|—————————Node:identifier Text: pointerToClass
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txRing
|————————Node:, Text: ,
|————————Node:identifier Text: txmsg
|————————Node:) Text: )
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: ( txmsg.flags.extended == 1 )
|————————Node:( Text: (
|————————Node:binary_expression Text: txmsg.flags.extended == 1
|—————————Node:field_expression Text: txmsg.flags.extended
|——————————Node:field_expression Text: txmsg.flags
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:. Text: .
|——————————Node:field_identifier Text: extended
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|———————Node:comment Text: // Extended ID when msg.flags.extended is 1
|———————Node:compound_statement Text: {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: TxHeader.ExtId = txmsg.id;
|—————————Node:assignment_expression Text: TxHeader.ExtId = txmsg.id
|——————————Node:field_expression Text: TxHeader.ExtId
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ExtId
|——————————Node:= Text: =
|——————————Node:field_expression Text: txmsg.id
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|—————————Node:; Text: ;
|————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_EXT;
|—————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_EXT
|——————————Node:field_expression Text: TxHeader.IDE
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: IDE
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_ID_EXT
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|————————Node:else Text: else
|————————Node:comment Text: // Standard ID otherwise
|————————Node:compound_statement Text: {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: TxHeader.StdId = txmsg.id;
|——————————Node:assignment_expression Text: TxHeader.StdId = txmsg.id
|———————————Node:field_expression Text: TxHeader.StdId
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: StdId
|———————————Node:= Text: =
|———————————Node:field_expression Text: txmsg.id
|————————————Node:identifier Text: txmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: id
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_STD;
|——————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_STD
|———————————Node:field_expression Text: TxHeader.IDE
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: IDE
|———————————Node:= Text: =
|———————————Node:identifier Text: CAN_ID_STD
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:expression_statement Text: TxHeader.RTR   = CAN_RTR_DATA;
|———————Node:assignment_expression Text: TxHeader.RTR   = CAN_RTR_DATA
|————————Node:field_expression Text: TxHeader.RTR
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: RTR
|————————Node:= Text: =
|————————Node:identifier Text: CAN_RTR_DATA
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.DLC   = txmsg.len;
|———————Node:assignment_expression Text: TxHeader.DLC   = txmsg.len
|————————Node:field_expression Text: TxHeader.DLC
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|————————Node:= Text: =
|————————Node:field_expression Text: txmsg.len
|—————————Node:identifier Text: txmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: len
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.TransmitGlobalTime = DISABLE;
|———————Node:assignment_expression Text: TxHeader.TransmitGlobalTime = DISABLE
|————————Node:field_expression Text: TxHeader.TransmitGlobalTime
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: TransmitGlobalTime
|————————Node:= Text: =
|————————Node:identifier Text: DISABLE
|———————Node:; Text: ;
|——————Node:expression_statement Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;
|———————Node:binary_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK
|————————Node:call_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|—————————Node:identifier Text: HAL_CAN_AddTxMessage
|—————————Node:argument_list Text: (CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|——————————Node:( Text: (
|——————————Node:identifier Text: CanHandle
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxHeader
|———————————Node:& Text: &
|———————————Node:identifier Text: TxHeader
|——————————Node:, Text: ,
|——————————Node:field_expression Text: txmsg.buf
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: buf
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxMailbox
|———————————Node:& Text: &
|———————————Node:identifier Text: TxMailbox
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: HAL_OK
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|—Node:linkage_specification Text: extern "C" void HAL_CAN_TxMailbox1CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB1 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void HAL_CAN_TxMailbox1CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB1 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: HAL_CAN_TxMailbox1CompleteCallback( CAN_HandleTypeDef *CanHandle )
|————Node:identifier Text: HAL_CAN_TxMailbox1CompleteCallback
|————Node:parameter_list Text: ( CAN_HandleTypeDef *CanHandle )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: CAN_HandleTypeDef *CanHandle
|——————Node:type_identifier Text: CAN_HandleTypeDef
|——————Node:pointer_declarator Text: *CanHandle
|———————Node:* Text: *
|———————Node:identifier Text: CanHandle
|—————Node:) Text: )
|———Node:compound_statement Text: {
  DEBUG(Serial.println( "MB1 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|————Node:{ Text: {
|————Node:expression_statement Text: DEBUG(Serial.println( "MB1 Empty int" ));
|—————Node:call_expression Text: DEBUG(Serial.println( "MB1 Empty int" ))
|——————Node:identifier Text: DEBUG
|——————Node:argument_list Text: (Serial.println( "MB1 Empty int" ))
|———————Node:( Text: (
|———————Node:call_expression Text: Serial.println( "MB1 Empty int" )
|————————Node:field_expression Text: Serial.println
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: println
|————————Node:argument_list Text: ( "MB1 Empty int" )
|—————————Node:( Text: (
|—————————Node:string_literal Text: "MB1 Empty int"
|——————————Node:" Text: "
|——————————Node:string_content Text: MB1 Empty int
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: uint32_t TxMailbox;
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: TxMailbox
|—————Node:; Text: ;
|————Node:declaration Text: CAN_message_t txmsg;
|—————Node:type_identifier Text: CAN_message_t
|—————Node:identifier Text: txmsg
|—————Node:; Text: ;
|————Node:declaration Text: CAN_TxHeaderTypeDef TxHeader;
|—————Node:type_identifier Text: CAN_TxHeaderTypeDef
|—————Node:identifier Text: TxHeader
|—————Node:; Text: ;
|————Node:if_statement Text: if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
|——————Node:( Text: (
|——————Node:call_expression Text: pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg)
|———————Node:field_expression Text: pointerToClass->removeFromRingBuffer
|————————Node:identifier Text: pointerToClass
|————————Node:-> Text: ->
|————————Node:field_identifier Text: removeFromRingBuffer
|———————Node:argument_list Text: (pointerToClass->txRing, txmsg)
|————————Node:( Text: (
|————————Node:field_expression Text: pointerToClass->txRing
|—————————Node:identifier Text: pointerToClass
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txRing
|————————Node:, Text: ,
|————————Node:identifier Text: txmsg
|————————Node:) Text: )
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: ( txmsg.flags.extended == 1 )
|————————Node:( Text: (
|————————Node:binary_expression Text: txmsg.flags.extended == 1
|—————————Node:field_expression Text: txmsg.flags.extended
|——————————Node:field_expression Text: txmsg.flags
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:. Text: .
|——————————Node:field_identifier Text: extended
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|———————Node:comment Text: // Extended ID when msg.flags.extended is 1
|———————Node:compound_statement Text: {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: TxHeader.ExtId = txmsg.id;
|—————————Node:assignment_expression Text: TxHeader.ExtId = txmsg.id
|——————————Node:field_expression Text: TxHeader.ExtId
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ExtId
|——————————Node:= Text: =
|——————————Node:field_expression Text: txmsg.id
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|—————————Node:; Text: ;
|————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_EXT;
|—————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_EXT
|——————————Node:field_expression Text: TxHeader.IDE
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: IDE
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_ID_EXT
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|————————Node:else Text: else
|————————Node:comment Text: // Standard ID otherwise
|————————Node:compound_statement Text: {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: TxHeader.StdId = txmsg.id;
|——————————Node:assignment_expression Text: TxHeader.StdId = txmsg.id
|———————————Node:field_expression Text: TxHeader.StdId
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: StdId
|———————————Node:= Text: =
|———————————Node:field_expression Text: txmsg.id
|————————————Node:identifier Text: txmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: id
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_STD;
|——————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_STD
|———————————Node:field_expression Text: TxHeader.IDE
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: IDE
|———————————Node:= Text: =
|———————————Node:identifier Text: CAN_ID_STD
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:expression_statement Text: TxHeader.RTR   = CAN_RTR_DATA;
|———————Node:assignment_expression Text: TxHeader.RTR   = CAN_RTR_DATA
|————————Node:field_expression Text: TxHeader.RTR
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: RTR
|————————Node:= Text: =
|————————Node:identifier Text: CAN_RTR_DATA
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.DLC   = txmsg.len;
|———————Node:assignment_expression Text: TxHeader.DLC   = txmsg.len
|————————Node:field_expression Text: TxHeader.DLC
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|————————Node:= Text: =
|————————Node:field_expression Text: txmsg.len
|—————————Node:identifier Text: txmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: len
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.TransmitGlobalTime = DISABLE;
|———————Node:assignment_expression Text: TxHeader.TransmitGlobalTime = DISABLE
|————————Node:field_expression Text: TxHeader.TransmitGlobalTime
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: TransmitGlobalTime
|————————Node:= Text: =
|————————Node:identifier Text: DISABLE
|———————Node:; Text: ;
|——————Node:expression_statement Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;
|———————Node:binary_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK
|————————Node:call_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|—————————Node:identifier Text: HAL_CAN_AddTxMessage
|—————————Node:argument_list Text: (CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|——————————Node:( Text: (
|——————————Node:identifier Text: CanHandle
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxHeader
|———————————Node:& Text: &
|———————————Node:identifier Text: TxHeader
|——————————Node:, Text: ,
|——————————Node:field_expression Text: txmsg.buf
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: buf
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxMailbox
|———————————Node:& Text: &
|———————————Node:identifier Text: TxMailbox
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: HAL_OK
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|—Node:linkage_specification Text: extern "C" void HAL_CAN_TxMailbox2CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB2 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void HAL_CAN_TxMailbox2CompleteCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "MB2 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: HAL_CAN_TxMailbox2CompleteCallback( CAN_HandleTypeDef *CanHandle )
|————Node:identifier Text: HAL_CAN_TxMailbox2CompleteCallback
|————Node:parameter_list Text: ( CAN_HandleTypeDef *CanHandle )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: CAN_HandleTypeDef *CanHandle
|——————Node:type_identifier Text: CAN_HandleTypeDef
|——————Node:pointer_declarator Text: *CanHandle
|———————Node:* Text: *
|———————Node:identifier Text: CanHandle
|—————Node:) Text: )
|———Node:compound_statement Text: {
  DEBUG(Serial.println( "MB2 Empty int" ));
  uint32_t TxMailbox;
  CAN_message_t txmsg;
  CAN_TxHeaderTypeDef TxHeader;
  if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
}
|————Node:{ Text: {
|————Node:expression_statement Text: DEBUG(Serial.println( "MB2 Empty int" ));
|—————Node:call_expression Text: DEBUG(Serial.println( "MB2 Empty int" ))
|——————Node:identifier Text: DEBUG
|——————Node:argument_list Text: (Serial.println( "MB2 Empty int" ))
|———————Node:( Text: (
|———————Node:call_expression Text: Serial.println( "MB2 Empty int" )
|————————Node:field_expression Text: Serial.println
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: println
|————————Node:argument_list Text: ( "MB2 Empty int" )
|—————————Node:( Text: (
|—————————Node:string_literal Text: "MB2 Empty int"
|——————————Node:" Text: "
|——————————Node:string_content Text: MB2 Empty int
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: uint32_t TxMailbox;
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: TxMailbox
|—————Node:; Text: ;
|————Node:declaration Text: CAN_message_t txmsg;
|—————Node:type_identifier Text: CAN_message_t
|—————Node:identifier Text: txmsg
|—————Node:; Text: ;
|————Node:declaration Text: CAN_TxHeaderTypeDef TxHeader;
|—————Node:type_identifier Text: CAN_TxHeaderTypeDef
|—————Node:identifier Text: TxHeader
|—————Node:; Text: ;
|————Node:if_statement Text: if ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
  {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: ( pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg) )
|——————Node:( Text: (
|——————Node:call_expression Text: pointerToClass->removeFromRingBuffer(pointerToClass->txRing, txmsg)
|———————Node:field_expression Text: pointerToClass->removeFromRingBuffer
|————————Node:identifier Text: pointerToClass
|————————Node:-> Text: ->
|————————Node:field_identifier Text: removeFromRingBuffer
|———————Node:argument_list Text: (pointerToClass->txRing, txmsg)
|————————Node:( Text: (
|————————Node:field_expression Text: pointerToClass->txRing
|—————————Node:identifier Text: pointerToClass
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: txRing
|————————Node:, Text: ,
|————————Node:identifier Text: txmsg
|————————Node:) Text: )
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
  
    TxHeader.RTR   = CAN_RTR_DATA;
    TxHeader.DLC   = txmsg.len;
    TxHeader.TransmitGlobalTime = DISABLE;

    HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;	
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if ( txmsg.flags.extended == 1 ) // Extended ID when msg.flags.extended is 1
    {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
    else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: ( txmsg.flags.extended == 1 )
|————————Node:( Text: (
|————————Node:binary_expression Text: txmsg.flags.extended == 1
|—————————Node:field_expression Text: txmsg.flags.extended
|——————————Node:field_expression Text: txmsg.flags
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: flags
|——————————Node:. Text: .
|——————————Node:field_identifier Text: extended
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|———————Node:comment Text: // Extended ID when msg.flags.extended is 1
|———————Node:compound_statement Text: {
	    TxHeader.ExtId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_EXT;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: TxHeader.ExtId = txmsg.id;
|—————————Node:assignment_expression Text: TxHeader.ExtId = txmsg.id
|——————————Node:field_expression Text: TxHeader.ExtId
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ExtId
|——————————Node:= Text: =
|——————————Node:field_expression Text: txmsg.id
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|—————————Node:; Text: ;
|————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_EXT;
|—————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_EXT
|——————————Node:field_expression Text: TxHeader.IDE
|———————————Node:identifier Text: TxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: IDE
|——————————Node:= Text: =
|——————————Node:identifier Text: CAN_ID_EXT
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else // Standard ID otherwise
    {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|————————Node:else Text: else
|————————Node:comment Text: // Standard ID otherwise
|————————Node:compound_statement Text: {
	    TxHeader.StdId = txmsg.id;
	    TxHeader.IDE   = CAN_ID_STD;
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: TxHeader.StdId = txmsg.id;
|——————————Node:assignment_expression Text: TxHeader.StdId = txmsg.id
|———————————Node:field_expression Text: TxHeader.StdId
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: StdId
|———————————Node:= Text: =
|———————————Node:field_expression Text: txmsg.id
|————————————Node:identifier Text: txmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: id
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: TxHeader.IDE   = CAN_ID_STD;
|——————————Node:assignment_expression Text: TxHeader.IDE   = CAN_ID_STD
|———————————Node:field_expression Text: TxHeader.IDE
|————————————Node:identifier Text: TxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: IDE
|———————————Node:= Text: =
|———————————Node:identifier Text: CAN_ID_STD
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:expression_statement Text: TxHeader.RTR   = CAN_RTR_DATA;
|———————Node:assignment_expression Text: TxHeader.RTR   = CAN_RTR_DATA
|————————Node:field_expression Text: TxHeader.RTR
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: RTR
|————————Node:= Text: =
|————————Node:identifier Text: CAN_RTR_DATA
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.DLC   = txmsg.len;
|———————Node:assignment_expression Text: TxHeader.DLC   = txmsg.len
|————————Node:field_expression Text: TxHeader.DLC
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|————————Node:= Text: =
|————————Node:field_expression Text: txmsg.len
|—————————Node:identifier Text: txmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: len
|———————Node:; Text: ;
|——————Node:expression_statement Text: TxHeader.TransmitGlobalTime = DISABLE;
|———————Node:assignment_expression Text: TxHeader.TransmitGlobalTime = DISABLE
|————————Node:field_expression Text: TxHeader.TransmitGlobalTime
|—————————Node:identifier Text: TxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: TransmitGlobalTime
|————————Node:= Text: =
|————————Node:identifier Text: DISABLE
|———————Node:; Text: ;
|——————Node:expression_statement Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK;
|———————Node:binary_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox) != HAL_OK
|————————Node:call_expression Text: HAL_CAN_AddTxMessage(CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|—————————Node:identifier Text: HAL_CAN_AddTxMessage
|—————————Node:argument_list Text: (CanHandle, &TxHeader, txmsg.buf, &TxMailbox)
|——————————Node:( Text: (
|——————————Node:identifier Text: CanHandle
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxHeader
|———————————Node:& Text: &
|———————————Node:identifier Text: TxHeader
|——————————Node:, Text: ,
|——————————Node:field_expression Text: txmsg.buf
|———————————Node:identifier Text: txmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: buf
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TxMailbox
|———————————Node:& Text: &
|———————————Node:identifier Text: TxMailbox
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: HAL_OK
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|—Node:comment Text: /**
  * @brief  Rx Fifo 0 message pending callback in non blocking mode
  * @param  CanHandle: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
|—Node:linkage_specification Text: extern "C" void HAL_CAN_RxFifo0MsgPendingCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "RxFifo0 int" ));
  CAN_message_t rxmsg;
  CAN_RxHeaderTypeDef   RxHeader;
  
  /* Get RX message */
  if (HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
	
    rxmsg.flags.remote = RxHeader.RTR;
    rxmsg.priority     = RxHeader.FilterMatchIndex;
    rxmsg.timestamp    = RxHeader.Timestamp;
    rxmsg.len          = RxHeader.DLC;

    if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
  }
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void HAL_CAN_RxFifo0MsgPendingCallback( CAN_HandleTypeDef *CanHandle )
{
  DEBUG(Serial.println( "RxFifo0 int" ));
  CAN_message_t rxmsg;
  CAN_RxHeaderTypeDef   RxHeader;
  
  /* Get RX message */
  if (HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
	
    rxmsg.flags.remote = RxHeader.RTR;
    rxmsg.priority     = RxHeader.FilterMatchIndex;
    rxmsg.timestamp    = RxHeader.Timestamp;
    rxmsg.len          = RxHeader.DLC;

    if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: HAL_CAN_RxFifo0MsgPendingCallback( CAN_HandleTypeDef *CanHandle )
|————Node:identifier Text: HAL_CAN_RxFifo0MsgPendingCallback
|————Node:parameter_list Text: ( CAN_HandleTypeDef *CanHandle )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: CAN_HandleTypeDef *CanHandle
|——————Node:type_identifier Text: CAN_HandleTypeDef
|——————Node:pointer_declarator Text: *CanHandle
|———————Node:* Text: *
|———————Node:identifier Text: CanHandle
|—————Node:) Text: )
|———Node:compound_statement Text: {
  DEBUG(Serial.println( "RxFifo0 int" ));
  CAN_message_t rxmsg;
  CAN_RxHeaderTypeDef   RxHeader;
  
  /* Get RX message */
  if (HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
	
    rxmsg.flags.remote = RxHeader.RTR;
    rxmsg.priority     = RxHeader.FilterMatchIndex;
    rxmsg.timestamp    = RxHeader.Timestamp;
    rxmsg.len          = RxHeader.DLC;

    if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
  }
}
|————Node:{ Text: {
|————Node:expression_statement Text: DEBUG(Serial.println( "RxFifo0 int" ));
|—————Node:call_expression Text: DEBUG(Serial.println( "RxFifo0 int" ))
|——————Node:identifier Text: DEBUG
|——————Node:argument_list Text: (Serial.println( "RxFifo0 int" ))
|———————Node:( Text: (
|———————Node:call_expression Text: Serial.println( "RxFifo0 int" )
|————————Node:field_expression Text: Serial.println
|—————————Node:identifier Text: Serial
|—————————Node:. Text: .
|—————————Node:field_identifier Text: println
|————————Node:argument_list Text: ( "RxFifo0 int" )
|—————————Node:( Text: (
|—————————Node:string_literal Text: "RxFifo0 int"
|——————————Node:" Text: "
|——————————Node:string_content Text: RxFifo0 int
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: CAN_message_t rxmsg;
|—————Node:type_identifier Text: CAN_message_t
|—————Node:identifier Text: rxmsg
|—————Node:; Text: ;
|————Node:declaration Text: CAN_RxHeaderTypeDef   RxHeader;
|—————Node:type_identifier Text: CAN_RxHeaderTypeDef
|—————Node:identifier Text: RxHeader
|—————Node:; Text: ;
|————Node:comment Text: /* Get RX message */
|————Node:if_statement Text: if (HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK)
  {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
	
    rxmsg.flags.remote = RxHeader.RTR;
    rxmsg.priority     = RxHeader.FilterMatchIndex;
    rxmsg.timestamp    = RxHeader.Timestamp;
    rxmsg.len          = RxHeader.DLC;

    if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK)
|——————Node:( Text: (
|——————Node:binary_expression Text: HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf ) == HAL_OK
|———————Node:call_expression Text: HAL_CAN_GetRxMessage( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf )
|————————Node:identifier Text: HAL_CAN_GetRxMessage
|————————Node:argument_list Text: ( CanHandle, CAN_RX_FIFO0, &RxHeader, rxmsg.buf )
|—————————Node:( Text: (
|—————————Node:identifier Text: CanHandle
|—————————Node:, Text: ,
|—————————Node:identifier Text: CAN_RX_FIFO0
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &RxHeader
|——————————Node:& Text: &
|——————————Node:identifier Text: RxHeader
|—————————Node:, Text: ,
|—————————Node:field_expression Text: rxmsg.buf
|——————————Node:identifier Text: rxmsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: buf
|—————————Node:) Text: )
|———————Node:== Text: ==
|———————Node:identifier Text: HAL_OK
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
	
    rxmsg.flags.remote = RxHeader.RTR;
    rxmsg.priority     = RxHeader.FilterMatchIndex;
    rxmsg.timestamp    = RxHeader.Timestamp;
    rxmsg.len          = RxHeader.DLC;

    if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if ( RxHeader.IDE == CAN_ID_STD )
	{
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
	else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
|———————Node:if Text: if
|———————Node:condition_clause Text: ( RxHeader.IDE == CAN_ID_STD )
|————————Node:( Text: (
|————————Node:binary_expression Text: RxHeader.IDE == CAN_ID_STD
|—————————Node:field_expression Text: RxHeader.IDE
|——————————Node:identifier Text: RxHeader
|——————————Node:. Text: .
|——————————Node:field_identifier Text: IDE
|—————————Node:== Text: ==
|—————————Node:identifier Text: CAN_ID_STD
|————————Node:) Text: )
|———————Node:compound_statement Text: {
		rxmsg.id = RxHeader.StdId;
		rxmsg.flags.extended = 0;
	}
|————————Node:{ Text: {
|————————Node:expression_statement Text: rxmsg.id = RxHeader.StdId;
|—————————Node:assignment_expression Text: rxmsg.id = RxHeader.StdId
|——————————Node:field_expression Text: rxmsg.id
|———————————Node:identifier Text: rxmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|——————————Node:= Text: =
|——————————Node:field_expression Text: RxHeader.StdId
|———————————Node:identifier Text: RxHeader
|———————————Node:. Text: .
|———————————Node:field_identifier Text: StdId
|—————————Node:; Text: ;
|————————Node:expression_statement Text: rxmsg.flags.extended = 0;
|—————————Node:assignment_expression Text: rxmsg.flags.extended = 0
|——————————Node:field_expression Text: rxmsg.flags.extended
|———————————Node:field_expression Text: rxmsg.flags
|————————————Node:identifier Text: rxmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: flags
|———————————Node:. Text: .
|———————————Node:field_identifier Text: extended
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
	{
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
|————————Node:else Text: else
|————————Node:compound_statement Text: {
		rxmsg.id = RxHeader.ExtId;
		rxmsg.flags.extended = 1;
	}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: rxmsg.id = RxHeader.ExtId;
|——————————Node:assignment_expression Text: rxmsg.id = RxHeader.ExtId
|———————————Node:field_expression Text: rxmsg.id
|————————————Node:identifier Text: rxmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: id
|———————————Node:= Text: =
|———————————Node:field_expression Text: RxHeader.ExtId
|————————————Node:identifier Text: RxHeader
|————————————Node:. Text: .
|————————————Node:field_identifier Text: ExtId
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: rxmsg.flags.extended = 1;
|——————————Node:assignment_expression Text: rxmsg.flags.extended = 1
|———————————Node:field_expression Text: rxmsg.flags.extended
|————————————Node:field_expression Text: rxmsg.flags
|—————————————Node:identifier Text: rxmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: flags
|————————————Node:. Text: .
|————————————Node:field_identifier Text: extended
|———————————Node:= Text: =
|———————————Node:number_literal Text: 1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:expression_statement Text: rxmsg.flags.remote = RxHeader.RTR;
|———————Node:assignment_expression Text: rxmsg.flags.remote = RxHeader.RTR
|————————Node:field_expression Text: rxmsg.flags.remote
|—————————Node:field_expression Text: rxmsg.flags
|——————————Node:identifier Text: rxmsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: flags
|—————————Node:. Text: .
|—————————Node:field_identifier Text: remote
|————————Node:= Text: =
|————————Node:field_expression Text: RxHeader.RTR
|—————————Node:identifier Text: RxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: RTR
|———————Node:; Text: ;
|——————Node:expression_statement Text: rxmsg.priority     = RxHeader.FilterMatchIndex;
|———————Node:assignment_expression Text: rxmsg.priority     = RxHeader.FilterMatchIndex
|————————Node:field_expression Text: rxmsg.priority
|—————————Node:identifier Text: rxmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: priority
|————————Node:= Text: =
|————————Node:field_expression Text: RxHeader.FilterMatchIndex
|—————————Node:identifier Text: RxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: FilterMatchIndex
|———————Node:; Text: ;
|——————Node:expression_statement Text: rxmsg.timestamp    = RxHeader.Timestamp;
|———————Node:assignment_expression Text: rxmsg.timestamp    = RxHeader.Timestamp
|————————Node:field_expression Text: rxmsg.timestamp
|—————————Node:identifier Text: rxmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: timestamp
|————————Node:= Text: =
|————————Node:field_expression Text: RxHeader.Timestamp
|—————————Node:identifier Text: RxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Timestamp
|———————Node:; Text: ;
|——————Node:expression_statement Text: rxmsg.len          = RxHeader.DLC;
|———————Node:assignment_expression Text: rxmsg.len          = RxHeader.DLC
|————————Node:field_expression Text: rxmsg.len
|—————————Node:identifier Text: rxmsg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: len
|————————Node:= Text: =
|————————Node:field_expression Text: RxHeader.DLC
|—————————Node:identifier Text: RxHeader
|—————————Node:. Text: .
|—————————Node:field_identifier Text: DLC
|———————Node:; Text: ;
|——————Node:if_statement Text: if (CanHandle->Instance == CAN1) 
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: (CanHandle->Instance == CAN1)
|————————Node:( Text: (
|————————Node:binary_expression Text: CanHandle->Instance == CAN1
|—————————Node:field_expression Text: CanHandle->Instance
|——————————Node:identifier Text: CanHandle
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: Instance
|—————————Node:== Text: ==
|—————————Node:identifier Text: CAN1
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
|—————————Node:call_expression Text: pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg)
|——————————Node:field_expression Text: pointerToClass->addToRingBuffer
|———————————Node:identifier Text: pointerToClass
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: addToRingBuffer
|——————————Node:argument_list Text: (pointerToClass->rxRing, rxmsg)
|———————————Node:( Text: (
|———————————Node:field_expression Text: pointerToClass->rxRing
|————————————Node:identifier Text: pointerToClass
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rxRing
|———————————Node:, Text: ,
|———————————Node:identifier Text: rxmsg
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:preproc_ifdef Text: #ifdef CAN2
    else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
#endif
|———————Node:#ifdef Text: #ifdef
|———————Node:identifier Text: CAN2
|———————Node:expression_statement Text: else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
|————————Node:compound_literal_expression Text: else
    {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
|—————————Node:type_identifier Text: else
|—————————Node:initializer_list Text: {
      pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg);
    }
|——————————Node:{ Text: {
|——————————Node:call_expression Text: pointerToClass->addToRingBuffer(pointerToClass->rxRing, rxmsg)
|———————————Node:field_expression Text: pointerToClass->addToRingBuffer
|————————————Node:identifier Text: pointerToClass
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: addToRingBuffer
|———————————Node:argument_list Text: (pointerToClass->rxRing, rxmsg)
|————————————Node:( Text: (
|————————————Node:field_expression Text: pointerToClass->rxRing
|—————————————Node:identifier Text: pointerToClass
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rxRing
|————————————Node:, Text: ,
|————————————Node:identifier Text: rxmsg
|————————————Node:) Text: )
|——————————Node:ERROR Text: ;
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:; Text: 
|———————Node:#endif Text: #endif
|——————Node:} Text: }
|————Node:} Text: }
|—Node:function_definition Text: void stm32Can::enableLoopBack( bool yes ) {
if ( yes ) { n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK; }	
else { n_pCanHandle->Init.Mode = CAN_MODE_NORMAL; }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::enableLoopBack( bool yes )
|———Node:qualified_identifier Text: stm32Can::enableLoopBack
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: enableLoopBack
|———Node:parameter_list Text: ( bool yes )
|————Node:( Text: (
|————Node:parameter_declaration Text: bool yes
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: yes
|————Node:) Text: )
|——Node:compound_statement Text: {
if ( yes ) { n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK; }	
else { n_pCanHandle->Init.Mode = CAN_MODE_NORMAL; }
}
|———Node:{ Text: {
|———Node:if_statement Text: if ( yes ) { n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK; }	
else { n_pCanHandle->Init.Mode = CAN_MODE_NORMAL; }
|————Node:if Text: if
|————Node:condition_clause Text: ( yes )
|—————Node:( Text: (
|—————Node:identifier Text: yes
|—————Node:) Text: )
|————Node:compound_statement Text: { n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK; }
|—————Node:{ Text: {
|—————Node:expression_statement Text: n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK;
|——————Node:assignment_expression Text: n_pCanHandle->Init.Mode = CAN_MODE_LOOPBACK
|———————Node:field_expression Text: n_pCanHandle->Init.Mode
|————————Node:field_expression Text: n_pCanHandle->Init
|—————————Node:identifier Text: n_pCanHandle
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: Init
|————————Node:. Text: .
|————————Node:field_identifier Text: Mode
|———————Node:= Text: =
|———————Node:identifier Text: CAN_MODE_LOOPBACK
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else { n_pCanHandle->Init.Mode = CAN_MODE_NORMAL; }
|—————Node:else Text: else
|—————Node:compound_statement Text: { n_pCanHandle->Init.Mode = CAN_MODE_NORMAL; }
|——————Node:{ Text: {
|——————Node:expression_statement Text: n_pCanHandle->Init.Mode = CAN_MODE_NORMAL;
|———————Node:assignment_expression Text: n_pCanHandle->Init.Mode = CAN_MODE_NORMAL
|————————Node:field_expression Text: n_pCanHandle->Init.Mode
|—————————Node:field_expression Text: n_pCanHandle->Init
|——————————Node:identifier Text: n_pCanHandle
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: Init
|—————————Node:. Text: .
|—————————Node:field_identifier Text: Mode
|————————Node:= Text: =
|————————Node:identifier Text: CAN_MODE_NORMAL
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void stm32Can::enableFIFO(bool status)
{
  //Nothing to do here. The FIFO is on by default.
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: stm32Can::enableFIFO(bool status)
|———Node:qualified_identifier Text: stm32Can::enableFIFO
|————Node:namespace_identifier Text: stm32Can
|————Node::: Text: ::
|————Node:identifier Text: enableFIFO
|———Node:parameter_list Text: (bool status)
|————Node:( Text: (
|————Node:parameter_declaration Text: bool status
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: status
|————Node:) Text: )
|——Node:compound_statement Text: {
  //Nothing to do here. The FIFO is on by default.
}
|———Node:{ Text: {
|———Node:comment Text: //Nothing to do here. The FIFO is on by default.
|———Node:} Text: }
|—Node:comment Text: /**
* @brief  functions handles CAN RX0 interrupt request.
* @param  None
* @retval None
*/
|—Node:linkage_specification Text: extern "C" void CAN1_RX0_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan1 );
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void CAN1_RX0_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan1 );
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: CAN1_RX0_IRQHandler( void )
|————Node:identifier Text: CAN1_RX0_IRQHandler
|————Node:parameter_list Text: ( void )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: void
|——————Node:primitive_type Text: void
|—————Node:) Text: )
|———Node:compound_statement Text: {
  HAL_CAN_IRQHandler( &hcan1 );
}
|————Node:{ Text: {
|————Node:expression_statement Text: HAL_CAN_IRQHandler( &hcan1 );
|—————Node:call_expression Text: HAL_CAN_IRQHandler( &hcan1 )
|——————Node:identifier Text: HAL_CAN_IRQHandler
|——————Node:argument_list Text: ( &hcan1 )
|———————Node:( Text: (
|———————Node:pointer_expression Text: &hcan1
|————————Node:& Text: &
|————————Node:identifier Text: hcan1
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|—Node:preproc_ifdef Text: #ifdef CAN2
extern "C" void CAN2_RX0_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: CAN2
|——Node:linkage_specification Text: extern "C" void CAN2_RX0_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
|———Node:extern Text: extern
|———Node:string_literal Text: "C"
|————Node:" Text: "
|————Node:string_content Text: C
|————Node:" Text: "
|———Node:function_definition Text: void CAN2_RX0_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
|————Node:primitive_type Text: void
|————Node:function_declarator Text: CAN2_RX0_IRQHandler( void )
|—————Node:identifier Text: CAN2_RX0_IRQHandler
|—————Node:parameter_list Text: ( void )
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:compound_statement Text: {
  HAL_CAN_IRQHandler( &hcan2 );
}
|—————Node:{ Text: {
|—————Node:expression_statement Text: HAL_CAN_IRQHandler( &hcan2 );
|——————Node:call_expression Text: HAL_CAN_IRQHandler( &hcan2 )
|———————Node:identifier Text: HAL_CAN_IRQHandler
|———————Node:argument_list Text: ( &hcan2 )
|————————Node:( Text: (
|————————Node:pointer_expression Text: &hcan2
|—————————Node:& Text: &
|—————————Node:identifier Text: hcan2
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|——Node:#endif Text: #endif
|—Node:comment Text: /**
* @brief  functions handles CAN TX interrupt request.
* @param  None
* @retval None
*/
|—Node:linkage_specification Text: extern "C" void CAN1_TX_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan1 );
}
|——Node:extern Text: extern
|——Node:string_literal Text: "C"
|———Node:" Text: "
|———Node:string_content Text: C
|———Node:" Text: "
|——Node:function_definition Text: void CAN1_TX_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan1 );
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: CAN1_TX_IRQHandler( void )
|————Node:identifier Text: CAN1_TX_IRQHandler
|————Node:parameter_list Text: ( void )
|—————Node:( Text: (
|—————Node:parameter_declaration Text: void
|——————Node:primitive_type Text: void
|—————Node:) Text: )
|———Node:compound_statement Text: {
  HAL_CAN_IRQHandler( &hcan1 );
}
|————Node:{ Text: {
|————Node:expression_statement Text: HAL_CAN_IRQHandler( &hcan1 );
|—————Node:call_expression Text: HAL_CAN_IRQHandler( &hcan1 )
|——————Node:identifier Text: HAL_CAN_IRQHandler
|——————Node:argument_list Text: ( &hcan1 )
|———————Node:( Text: (
|———————Node:pointer_expression Text: &hcan1
|————————Node:& Text: &
|————————Node:identifier Text: hcan1
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|—Node:preproc_ifdef Text: #ifdef CAN2
extern "C" void CAN2_TX_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
#endif
|——Node:#ifdef Text: #ifdef
|——Node:identifier Text: CAN2
|——Node:linkage_specification Text: extern "C" void CAN2_TX_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
|———Node:extern Text: extern
|———Node:string_literal Text: "C"
|————Node:" Text: "
|————Node:string_content Text: C
|————Node:" Text: "
|———Node:function_definition Text: void CAN2_TX_IRQHandler( void )
{
  HAL_CAN_IRQHandler( &hcan2 );
}
|————Node:primitive_type Text: void
|————Node:function_declarator Text: CAN2_TX_IRQHandler( void )
|—————Node:identifier Text: CAN2_TX_IRQHandler
|—————Node:parameter_list Text: ( void )
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|————Node:compound_statement Text: {
  HAL_CAN_IRQHandler( &hcan2 );
}
|—————Node:{ Text: {
|—————Node:expression_statement Text: HAL_CAN_IRQHandler( &hcan2 );
|——————Node:call_expression Text: HAL_CAN_IRQHandler( &hcan2 )
|———————Node:identifier Text: HAL_CAN_IRQHandler
|———————Node:argument_list Text: ( &hcan2 )
|————————Node:( Text: (
|————————Node:pointer_expression Text: &hcan2
|—————————Node:& Text: &
|—————————Node:identifier Text: hcan2
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|——Node:#endif Text: #endif
