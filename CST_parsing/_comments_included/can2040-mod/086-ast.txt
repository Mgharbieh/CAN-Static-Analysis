can2040-mod-src\can2040.c

|Node:translation_unit
|—Node:comment Text: // Software CANbus implementation for rp2040
|—Node:comment Text: //
|—Node:comment Text: // Copyright (C) 2022  Kevin O'Connor <kevin@koconnor.net>
|—Node:comment Text: //
|—Node:comment Text: // This file may be distributed under the terms of the GNU GPLv3 license.
|—Node:preproc_include Text: #include <stdint.h> // uint32_t

|——Node:#include Text: #include
|——Node:system_lib_string Text: <stdint.h>
|——Node:comment Text: // uint32_t
|—Node:preproc_include Text: #include <string.h> // memset

|——Node:#include Text: #include
|——Node:system_lib_string Text: <string.h>
|——Node:comment Text: // memset
|—Node:preproc_include Text: #include "RP2040.h" // hw_set_bits

|——Node:#include Text: #include
|——Node:string_literal Text: "RP2040.h"
|———Node:" Text: "
|———Node:string_content Text: RP2040.h
|———Node:" Text: "
|——Node:comment Text: // hw_set_bits
|—Node:preproc_include Text: #include "can2040.h" // can2040_setup

|——Node:#include Text: #include
|——Node:string_literal Text: "can2040.h"
|———Node:" Text: "
|———Node:string_content Text: can2040.h
|———Node:" Text: "
|——Node:comment Text: // can2040_setup
|—Node:preproc_include Text: #include "hardware/regs/dreq.h" // DREQ_PIO0_RX1

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/regs/dreq.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/regs/dreq.h
|———Node:" Text: "
|——Node:comment Text: // DREQ_PIO0_RX1
|—Node:preproc_include Text: #include "hardware/structs/dma.h" // dma_hw

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/structs/dma.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/structs/dma.h
|———Node:" Text: "
|——Node:comment Text: // dma_hw
|—Node:preproc_include Text: #include "hardware/structs/iobank0.h" // iobank0_hw

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/structs/iobank0.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/structs/iobank0.h
|———Node:" Text: "
|——Node:comment Text: // iobank0_hw
|—Node:preproc_include Text: #include "hardware/structs/padsbank0.h" // padsbank0_hw

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/structs/padsbank0.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/structs/padsbank0.h
|———Node:" Text: "
|——Node:comment Text: // padsbank0_hw
|—Node:preproc_include Text: #include "hardware/structs/pio.h" // pio0_hw

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/structs/pio.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/structs/pio.h
|———Node:" Text: "
|——Node:comment Text: // pio0_hw
|—Node:preproc_include Text: #include "hardware/structs/resets.h" // RESETS_RESET_PIO0_BITS

|——Node:#include Text: #include
|——Node:string_literal Text: "hardware/structs/resets.h"
|———Node:" Text: "
|———Node:string_content Text: hardware/structs/resets.h
|———Node:" Text: "
|——Node:comment Text: // RESETS_RESET_PIO0_BITS
|—Node:comment Text: /****************************************************************
 * rp2040 and low-level helper functions
 ****************************************************************/
|—Node:comment Text: // Helper compiler definitions
|—Node:preproc_function_def Text: #define barrier() __asm__ __volatile__("": : :"memory")

|——Node:#define Text: #define
|——Node:identifier Text: barrier
|——Node:preproc_params Text: ()
|———Node:( Text: (
|———Node:) Text: )
|——Node:preproc_arg Text: __asm__ __volatile__("": : :"memory")
|—Node:preproc_function_def Text: #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))

|——Node:#define Text: #define
|——Node:identifier Text: ARRAY_SIZE
|——Node:preproc_params Text: (a)
|———Node:( Text: (
|———Node:identifier Text: a
|———Node:) Text: )
|——Node:preproc_arg Text: (sizeof(a) / sizeof(a[0]))
|—Node:preproc_function_def Text: #define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

|——Node:#define Text: #define
|——Node:identifier Text: DIV_ROUND_UP
|——Node:preproc_params Text: (n,d)
|———Node:( Text: (
|———Node:identifier Text: n
|———Node:, Text: ,
|———Node:identifier Text: d
|———Node:) Text: )
|——Node:preproc_arg Text: (((n) + (d) - 1) / (d))
|—Node:comment Text: // Helper functions for writing to "io" memory
|—Node:function_definition Text: static inline void writel(void *addr, uint32_t val) {
    barrier();
    *(volatile uint32_t *)addr = val;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:storage_class_specifier Text: inline
|———Node:inline Text: inline
|——Node:primitive_type Text: void
|——Node:function_declarator Text: writel(void *addr, uint32_t val)
|———Node:identifier Text: writel
|———Node:parameter_list Text: (void *addr, uint32_t val)
|————Node:( Text: (
|————Node:parameter_declaration Text: void *addr
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *addr
|——————Node:* Text: *
|——————Node:identifier Text: addr
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t val
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
    barrier();
    *(volatile uint32_t *)addr = val;
}
|———Node:{ Text: {
|———Node:expression_statement Text: barrier();
|————Node:call_expression Text: barrier()
|—————Node:identifier Text: barrier
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: *(volatile uint32_t *)addr = val;
|————Node:assignment_expression Text: *(volatile uint32_t *)addr = val
|—————Node:pointer_expression Text: *(volatile uint32_t *)addr
|——————Node:* Text: *
|——————Node:cast_expression Text: (volatile uint32_t *)addr
|———————Node:( Text: (
|———————Node:type_descriptor Text: volatile uint32_t *
|————————Node:type_qualifier Text: volatile
|—————————Node:volatile Text: volatile
|————————Node:primitive_type Text: uint32_t
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:identifier Text: addr
|—————Node:= Text: =
|—————Node:identifier Text: val
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: static inline uint32_t readl(const void *addr) {
    uint32_t val = *(volatile const uint32_t *)addr;
    barrier();
    return val;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:storage_class_specifier Text: inline
|———Node:inline Text: inline
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: readl(const void *addr)
|———Node:identifier Text: readl
|———Node:parameter_list Text: (const void *addr)
|————Node:( Text: (
|————Node:parameter_declaration Text: const void *addr
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *addr
|——————Node:* Text: *
|——————Node:identifier Text: addr
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t val = *(volatile const uint32_t *)addr;
    barrier();
    return val;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t val = *(volatile const uint32_t *)addr;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: val = *(volatile const uint32_t *)addr
|—————Node:identifier Text: val
|—————Node:= Text: =
|—————Node:pointer_expression Text: *(volatile const uint32_t *)addr
|——————Node:* Text: *
|——————Node:cast_expression Text: (volatile const uint32_t *)addr
|———————Node:( Text: (
|———————Node:type_descriptor Text: volatile const uint32_t *
|————————Node:type_qualifier Text: volatile
|—————————Node:volatile Text: volatile
|————————Node:type_qualifier Text: const
|—————————Node:const Text: const
|————————Node:primitive_type Text: uint32_t
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:identifier Text: addr
|————Node:; Text: ;
|———Node:expression_statement Text: barrier();
|————Node:call_expression Text: barrier()
|—————Node:identifier Text: barrier
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return val;
|————Node:return Text: return
|————Node:identifier Text: val
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // rp2040 helper function to clear a hardware reset bit
|—Node:function_definition Text: static void
rp2040_clear_reset(uint32_t reset_bit)
{
    if (resets_hw->reset & reset_bit) {
        resets_hw->reset &= reset_bit;
        hw_clear_bits(&resets_hw->reset, reset_bit);
        while (!(resets_hw->reset_done & reset_bit))
            ;
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: rp2040_clear_reset(uint32_t reset_bit)
|———Node:identifier Text: rp2040_clear_reset
|———Node:parameter_list Text: (uint32_t reset_bit)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t reset_bit
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: reset_bit
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (resets_hw->reset & reset_bit) {
        resets_hw->reset &= reset_bit;
        hw_clear_bits(&resets_hw->reset, reset_bit);
        while (!(resets_hw->reset_done & reset_bit))
            ;
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (resets_hw->reset & reset_bit) {
        resets_hw->reset &= reset_bit;
        hw_clear_bits(&resets_hw->reset, reset_bit);
        while (!(resets_hw->reset_done & reset_bit))
            ;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (resets_hw->reset & reset_bit)
|—————Node:( Text: (
|—————Node:binary_expression Text: resets_hw->reset & reset_bit
|——————Node:field_expression Text: resets_hw->reset
|———————Node:identifier Text: resets_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: reset
|——————Node:& Text: &
|——————Node:identifier Text: reset_bit
|—————Node:) Text: )
|————Node:compound_statement Text: {
        resets_hw->reset &= reset_bit;
        hw_clear_bits(&resets_hw->reset, reset_bit);
        while (!(resets_hw->reset_done & reset_bit))
            ;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: resets_hw->reset &= reset_bit;
|——————Node:assignment_expression Text: resets_hw->reset &= reset_bit
|———————Node:field_expression Text: resets_hw->reset
|————————Node:identifier Text: resets_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: reset
|———————Node:&= Text: &=
|———————Node:identifier Text: reset_bit
|——————Node:; Text: ;
|—————Node:expression_statement Text: hw_clear_bits(&resets_hw->reset, reset_bit);
|——————Node:call_expression Text: hw_clear_bits(&resets_hw->reset, reset_bit)
|———————Node:identifier Text: hw_clear_bits
|———————Node:argument_list Text: (&resets_hw->reset, reset_bit)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &resets_hw->reset
|—————————Node:& Text: &
|—————————Node:field_expression Text: resets_hw->reset
|——————————Node:identifier Text: resets_hw
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: reset
|————————Node:, Text: ,
|————————Node:identifier Text: reset_bit
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:while_statement Text: while (!(resets_hw->reset_done & reset_bit))
            ;
|——————Node:while Text: while
|——————Node:parenthesized_expression Text: (!(resets_hw->reset_done & reset_bit))
|———————Node:( Text: (
|———————Node:unary_expression Text: !(resets_hw->reset_done & reset_bit)
|————————Node:! Text: !
|————————Node:parenthesized_expression Text: (resets_hw->reset_done & reset_bit)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: resets_hw->reset_done & reset_bit
|——————————Node:field_expression Text: resets_hw->reset_done
|———————————Node:identifier Text: resets_hw
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: reset_done
|——————————Node:& Text: &
|——————————Node:identifier Text: reset_bit
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:expression_statement Text: ;
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: // Helper to set the mode and extended function of a pin
|—Node:function_definition Text: static void
rp2040_gpio_peripheral(uint32_t gpio, int func, int pull_up)
{
    padsbank0_hw->io[gpio] = (
        PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0));
    iobank0_hw->io[gpio].ctrl = func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: rp2040_gpio_peripheral(uint32_t gpio, int func, int pull_up)
|———Node:identifier Text: rp2040_gpio_peripheral
|———Node:parameter_list Text: (uint32_t gpio, int func, int pull_up)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t gpio
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: gpio
|————Node:, Text: ,
|————Node:parameter_declaration Text: int func
|—————Node:primitive_type Text: int
|—————Node:identifier Text: func
|————Node:, Text: ,
|————Node:parameter_declaration Text: int pull_up
|—————Node:primitive_type Text: int
|—————Node:identifier Text: pull_up
|————Node:) Text: )
|——Node:compound_statement Text: {
    padsbank0_hw->io[gpio] = (
        PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0));
    iobank0_hw->io[gpio].ctrl = func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
}
|———Node:{ Text: {
|———Node:expression_statement Text: padsbank0_hw->io[gpio] = (
        PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0));
|————Node:assignment_expression Text: padsbank0_hw->io[gpio] = (
        PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0))
|—————Node:subscript_expression Text: padsbank0_hw->io[gpio]
|——————Node:field_expression Text: padsbank0_hw->io
|———————Node:identifier Text: padsbank0_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: io
|——————Node:[ Text: [
|——————Node:identifier Text: gpio
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (
        PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0))
|——————Node:( Text: (
|——————Node:binary_expression Text: PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0)
|———————Node:binary_expression Text: PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
|————————Node:binary_expression Text: PADS_BANK0_GPIO0_IE_BITS
        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
|—————————Node:identifier Text: PADS_BANK0_GPIO0_IE_BITS
|—————————Node:| Text: |
|—————————Node:parenthesized_expression Text: (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB
|———————————Node:identifier Text: PADS_BANK0_GPIO0_DRIVE_VALUE_4MA
|———————————Node:<< Text: <<
|———————————Node:identifier Text: PADS_BANK0_GPIO0_DRIVE_MSB
|——————————Node:) Text: )
|————————Node:| Text: |
|————————Node:parenthesized_expression Text: (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
|—————————Node:( Text: (
|—————————Node:conditional_expression Text: pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0
|——————————Node:binary_expression Text: pull_up > 0
|———————————Node:identifier Text: pull_up
|———————————Node:> Text: >
|———————————Node:number_literal Text: 0
|——————————Node:? Text: ?
|——————————Node:identifier Text: PADS_BANK0_GPIO0_PUE_BITS
|——————————Node:: Text: :
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:| Text: |
|———————Node:parenthesized_expression Text: (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0)
|————————Node:( Text: (
|————————Node:conditional_expression Text: pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0
|—————————Node:binary_expression Text: pull_up < 0
|——————————Node:identifier Text: pull_up
|——————————Node:< Text: <
|——————————Node:number_literal Text: 0
|—————————Node:? Text: ?
|—————————Node:identifier Text: PADS_BANK0_GPIO0_PDE_BITS
|—————————Node:: Text: :
|—————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: iobank0_hw->io[gpio].ctrl = func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
|————Node:assignment_expression Text: iobank0_hw->io[gpio].ctrl = func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB
|—————Node:field_expression Text: iobank0_hw->io[gpio].ctrl
|——————Node:subscript_expression Text: iobank0_hw->io[gpio]
|———————Node:field_expression Text: iobank0_hw->io
|————————Node:identifier Text: iobank0_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: io
|———————Node:[ Text: [
|———————Node:identifier Text: gpio
|———————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB
|——————Node:identifier Text: func
|——————Node:<< Text: <<
|——————Node:identifier Text: IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * rp2040 PIO support
 ****************************************************************/
|—Node:preproc_def Text: #define PIO_CLOCK_PER_BIT 32

|——Node:#define Text: #define
|——Node:identifier Text: PIO_CLOCK_PER_BIT
|——Node:preproc_arg Text: 32
|—Node:preproc_def Text: #define can2040_offset_sync_found_end_of_message 2u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_sync_found_end_of_message
|——Node:preproc_arg Text: 2u
|—Node:preproc_def Text: #define can2040_offset_sync_signal_start 4u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_sync_signal_start
|——Node:preproc_arg Text: 4u
|—Node:preproc_def Text: #define can2040_offset_sync_entry 6u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_sync_entry
|——Node:preproc_arg Text: 6u
|—Node:preproc_def Text: #define can2040_offset_sync_end 13u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_sync_end
|——Node:preproc_arg Text: 13u
|—Node:preproc_def Text: #define can2040_offset_shared_rx_read 13u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_shared_rx_read
|——Node:preproc_arg Text: 13u
|—Node:preproc_def Text: #define can2040_offset_shared_rx_end 15u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_shared_rx_end
|——Node:preproc_arg Text: 15u
|—Node:preproc_def Text: #define can2040_offset_ack_no_match 18u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_ack_no_match
|——Node:preproc_arg Text: 18u
|—Node:preproc_def Text: #define can2040_offset_ack_end 25u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_ack_end
|——Node:preproc_arg Text: 25u
|—Node:preproc_def Text: #define can2040_offset_tx_got_recessive 25u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_tx_got_recessive
|——Node:preproc_arg Text: 25u
|—Node:preproc_def Text: #define can2040_offset_tx_start 26u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_tx_start
|——Node:preproc_arg Text: 26u
|—Node:preproc_def Text: #define can2040_offset_tx_conflict 31u

|——Node:#define Text: #define
|——Node:identifier Text: can2040_offset_tx_conflict
|——Node:preproc_arg Text: 31u
|—Node:declaration Text: static const uint16_t can2040_program_instructions[] = {
    0x0085, //  0: jmp    y--, 5
    0x0048, //  1: jmp    x--, 8
    0xe13a, //  2: set    x, 26                  [1]
    0x00cc, //  3: jmp    pin, 12
    0xc000, //  4: irq    nowait 0
    0x00c0, //  5: jmp    pin, 0
    0xc040, //  6: irq    clear 0
    0xe228, //  7: set    x, 8                   [2]
    0xf242, //  8: set    y, 2                   [18]
    0xc104, //  9: irq    nowait 4               [1]
    0x03c5, // 10: jmp    pin, 5                 [3]
    0x0307, // 11: jmp    7                      [3]
    0x0043, // 12: jmp    x--, 3
    0x20c4, // 13: wait   1 irq, 4
    0x4001, // 14: in     pins, 1
    0xa046, // 15: mov    y, isr
    0x00b2, // 16: jmp    x != y, 18
    0xc002, // 17: irq    nowait 2
    0x40eb, // 18: in     osr, 11
    0x4054, // 19: in     y, 20
    0xa047, // 20: mov    y, osr
    0x8080, // 21: pull   noblock
    0xa027, // 22: mov    x, osr
    0x0098, // 23: jmp    y--, 24
    0xa0e2, // 24: mov    osr, y
    0xa242, // 25: nop                           [2]
    0x6021, // 26: out    x, 1
    0xa001, // 27: mov    pins, x
    0x20c4, // 28: wait   1 irq, 4
    0x00d9, // 29: jmp    pin, 25
    0x023a, // 30: jmp    !x, 26                 [2]
    0xc027, // 31: irq    wait 7
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: can2040_program_instructions[] = {
    0x0085, //  0: jmp    y--, 5
    0x0048, //  1: jmp    x--, 8
    0xe13a, //  2: set    x, 26                  [1]
    0x00cc, //  3: jmp    pin, 12
    0xc000, //  4: irq    nowait 0
    0x00c0, //  5: jmp    pin, 0
    0xc040, //  6: irq    clear 0
    0xe228, //  7: set    x, 8                   [2]
    0xf242, //  8: set    y, 2                   [18]
    0xc104, //  9: irq    nowait 4               [1]
    0x03c5, // 10: jmp    pin, 5                 [3]
    0x0307, // 11: jmp    7                      [3]
    0x0043, // 12: jmp    x--, 3
    0x20c4, // 13: wait   1 irq, 4
    0x4001, // 14: in     pins, 1
    0xa046, // 15: mov    y, isr
    0x00b2, // 16: jmp    x != y, 18
    0xc002, // 17: irq    nowait 2
    0x40eb, // 18: in     osr, 11
    0x4054, // 19: in     y, 20
    0xa047, // 20: mov    y, osr
    0x8080, // 21: pull   noblock
    0xa027, // 22: mov    x, osr
    0x0098, // 23: jmp    y--, 24
    0xa0e2, // 24: mov    osr, y
    0xa242, // 25: nop                           [2]
    0x6021, // 26: out    x, 1
    0xa001, // 27: mov    pins, x
    0x20c4, // 28: wait   1 irq, 4
    0x00d9, // 29: jmp    pin, 25
    0x023a, // 30: jmp    !x, 26                 [2]
    0xc027, // 31: irq    wait 7
}
|———Node:array_declarator Text: can2040_program_instructions[]
|————Node:identifier Text: can2040_program_instructions
|————Node:[ Text: [
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
    0x0085, //  0: jmp    y--, 5
    0x0048, //  1: jmp    x--, 8
    0xe13a, //  2: set    x, 26                  [1]
    0x00cc, //  3: jmp    pin, 12
    0xc000, //  4: irq    nowait 0
    0x00c0, //  5: jmp    pin, 0
    0xc040, //  6: irq    clear 0
    0xe228, //  7: set    x, 8                   [2]
    0xf242, //  8: set    y, 2                   [18]
    0xc104, //  9: irq    nowait 4               [1]
    0x03c5, // 10: jmp    pin, 5                 [3]
    0x0307, // 11: jmp    7                      [3]
    0x0043, // 12: jmp    x--, 3
    0x20c4, // 13: wait   1 irq, 4
    0x4001, // 14: in     pins, 1
    0xa046, // 15: mov    y, isr
    0x00b2, // 16: jmp    x != y, 18
    0xc002, // 17: irq    nowait 2
    0x40eb, // 18: in     osr, 11
    0x4054, // 19: in     y, 20
    0xa047, // 20: mov    y, osr
    0x8080, // 21: pull   noblock
    0xa027, // 22: mov    x, osr
    0x0098, // 23: jmp    y--, 24
    0xa0e2, // 24: mov    osr, y
    0xa242, // 25: nop                           [2]
    0x6021, // 26: out    x, 1
    0xa001, // 27: mov    pins, x
    0x20c4, // 28: wait   1 irq, 4
    0x00d9, // 29: jmp    pin, 25
    0x023a, // 30: jmp    !x, 26                 [2]
    0xc027, // 31: irq    wait 7
}
|————Node:{ Text: {
|————Node:number_literal Text: 0x0085
|————Node:, Text: ,
|————Node:comment Text: //  0: jmp    y--, 5
|————Node:number_literal Text: 0x0048
|————Node:, Text: ,
|————Node:comment Text: //  1: jmp    x--, 8
|————Node:number_literal Text: 0xe13a
|————Node:, Text: ,
|————Node:comment Text: //  2: set    x, 26                  [1]
|————Node:number_literal Text: 0x00cc
|————Node:, Text: ,
|————Node:comment Text: //  3: jmp    pin, 12
|————Node:number_literal Text: 0xc000
|————Node:, Text: ,
|————Node:comment Text: //  4: irq    nowait 0
|————Node:number_literal Text: 0x00c0
|————Node:, Text: ,
|————Node:comment Text: //  5: jmp    pin, 0
|————Node:number_literal Text: 0xc040
|————Node:, Text: ,
|————Node:comment Text: //  6: irq    clear 0
|————Node:number_literal Text: 0xe228
|————Node:, Text: ,
|————Node:comment Text: //  7: set    x, 8                   [2]
|————Node:number_literal Text: 0xf242
|————Node:, Text: ,
|————Node:comment Text: //  8: set    y, 2                   [18]
|————Node:number_literal Text: 0xc104
|————Node:, Text: ,
|————Node:comment Text: //  9: irq    nowait 4               [1]
|————Node:number_literal Text: 0x03c5
|————Node:, Text: ,
|————Node:comment Text: // 10: jmp    pin, 5                 [3]
|————Node:number_literal Text: 0x0307
|————Node:, Text: ,
|————Node:comment Text: // 11: jmp    7                      [3]
|————Node:number_literal Text: 0x0043
|————Node:, Text: ,
|————Node:comment Text: // 12: jmp    x--, 3
|————Node:number_literal Text: 0x20c4
|————Node:, Text: ,
|————Node:comment Text: // 13: wait   1 irq, 4
|————Node:number_literal Text: 0x4001
|————Node:, Text: ,
|————Node:comment Text: // 14: in     pins, 1
|————Node:number_literal Text: 0xa046
|————Node:, Text: ,
|————Node:comment Text: // 15: mov    y, isr
|————Node:number_literal Text: 0x00b2
|————Node:, Text: ,
|————Node:comment Text: // 16: jmp    x != y, 18
|————Node:number_literal Text: 0xc002
|————Node:, Text: ,
|————Node:comment Text: // 17: irq    nowait 2
|————Node:number_literal Text: 0x40eb
|————Node:, Text: ,
|————Node:comment Text: // 18: in     osr, 11
|————Node:number_literal Text: 0x4054
|————Node:, Text: ,
|————Node:comment Text: // 19: in     y, 20
|————Node:number_literal Text: 0xa047
|————Node:, Text: ,
|————Node:comment Text: // 20: mov    y, osr
|————Node:number_literal Text: 0x8080
|————Node:, Text: ,
|————Node:comment Text: // 21: pull   noblock
|————Node:number_literal Text: 0xa027
|————Node:, Text: ,
|————Node:comment Text: // 22: mov    x, osr
|————Node:number_literal Text: 0x0098
|————Node:, Text: ,
|————Node:comment Text: // 23: jmp    y--, 24
|————Node:number_literal Text: 0xa0e2
|————Node:, Text: ,
|————Node:comment Text: // 24: mov    osr, y
|————Node:number_literal Text: 0xa242
|————Node:, Text: ,
|————Node:comment Text: // 25: nop                           [2]
|————Node:number_literal Text: 0x6021
|————Node:, Text: ,
|————Node:comment Text: // 26: out    x, 1
|————Node:number_literal Text: 0xa001
|————Node:, Text: ,
|————Node:comment Text: // 27: mov    pins, x
|————Node:number_literal Text: 0x20c4
|————Node:, Text: ,
|————Node:comment Text: // 28: wait   1 irq, 4
|————Node:number_literal Text: 0x00d9
|————Node:, Text: ,
|————Node:comment Text: // 29: jmp    pin, 25
|————Node:number_literal Text: 0x023a
|————Node:, Text: ,
|————Node:comment Text: // 30: jmp    !x, 26                 [2]
|————Node:number_literal Text: 0xc027
|————Node:, Text: ,
|————Node:comment Text: // 31: irq    wait 7
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: // Setup PIO "sync" state machine (state machine 0)
|—Node:function_definition Text: static void
pio_sync_setup(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[0];
    sm->execctrl = (
        cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = (
        1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB);
    sm->instr = 0xe080; // set pindirs, 0
    sm->pinctrl = 0;
    pio_hw->txf[0] = PIO_CLOCK_PER_BIT / 2 * 8 - 5 - 1;
    sm->instr = 0x80a0; // pull block
    sm->instr = can2040_offset_sync_entry; // jmp sync_entry
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_setup(struct can2040 *cd)
|———Node:identifier Text: pio_sync_setup
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[0];
    sm->execctrl = (
        cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = (
        1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB);
    sm->instr = 0xe080; // set pindirs, 0
    sm->pinctrl = 0;
    pio_hw->txf[0] = PIO_CLOCK_PER_BIT / 2 * 8 - 5 - 1;
    sm->instr = 0x80a0; // pull block
    sm->instr = can2040_offset_sync_entry; // jmp sync_entry
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[0];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[0]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[0]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[0]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 0
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->execctrl = (
        cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
|————Node:assignment_expression Text: sm->execctrl = (
        cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|—————Node:field_expression Text: sm->execctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: execctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (
        cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|——————Node:( Text: (
|——————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|———————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
        | (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|————————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
|—————————Node:field_expression Text: cd->gpio_rx
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: gpio_rx
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_SM0_EXECCTRL_JMP_PIN_LSB
|————————Node:| Text: |
|————————Node:binary_expression Text: (can2040_offset_sync_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|—————————Node:parenthesized_expression Text: (can2040_offset_sync_end - 1)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: can2040_offset_sync_end - 1
|———————————Node:identifier Text: can2040_offset_sync_end
|———————————Node:- Text: -
|———————————Node:number_literal Text: 1
|——————————Node:) Text: )
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|———————Node:| Text: |
|———————Node:binary_expression Text: can2040_offset_sync_signal_start << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|————————Node:identifier Text: can2040_offset_sync_signal_start
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->pinctrl = (
        1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB);
|————Node:assignment_expression Text: sm->pinctrl = (
        1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB)
|—————Node:field_expression Text: sm->pinctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pinctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (
        1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
        | cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB
|———————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_PINCTRL_SET_COUNT_LSB
|———————Node:| Text: |
|———————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_PINCTRL_SET_BASE_LSB
|————————Node:field_expression Text: cd->gpio_rx
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: gpio_rx
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_PINCTRL_SET_BASE_LSB
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0xe080;
|————Node:assignment_expression Text: sm->instr = 0xe080
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe080
|————Node:; Text: ;
|———Node:comment Text: // set pindirs, 0
|———Node:expression_statement Text: sm->pinctrl = 0;
|————Node:assignment_expression Text: sm->pinctrl = 0
|—————Node:field_expression Text: sm->pinctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pinctrl
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->txf[0] = PIO_CLOCK_PER_BIT / 2 * 8 - 5 - 1;
|————Node:assignment_expression Text: pio_hw->txf[0] = PIO_CLOCK_PER_BIT / 2 * 8 - 5 - 1
|—————Node:subscript_expression Text: pio_hw->txf[0]
|——————Node:field_expression Text: pio_hw->txf
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txf
|——————Node:[ Text: [
|——————Node:number_literal Text: 0
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:binary_expression Text: PIO_CLOCK_PER_BIT / 2 * 8 - 5 - 1
|——————Node:binary_expression Text: PIO_CLOCK_PER_BIT / 2 * 8 - 5
|———————Node:binary_expression Text: PIO_CLOCK_PER_BIT / 2 * 8
|————————Node:binary_expression Text: PIO_CLOCK_PER_BIT / 2
|—————————Node:identifier Text: PIO_CLOCK_PER_BIT
|—————————Node:/ Text: /
|—————————Node:number_literal Text: 2
|————————Node:* Text: *
|————————Node:number_literal Text: 8
|———————Node:- Text: -
|———————Node:number_literal Text: 5
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0x80a0;
|————Node:assignment_expression Text: sm->instr = 0x80a0
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0x80a0
|————Node:; Text: ;
|———Node:comment Text: // pull block
|———Node:expression_statement Text: sm->instr = can2040_offset_sync_entry;
|————Node:assignment_expression Text: sm->instr = can2040_offset_sync_entry
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_sync_entry
|————Node:; Text: ;
|———Node:comment Text: // jmp sync_entry
|———Node:} Text: }
|—Node:comment Text: // Setup PIO "rx" state machine (state machine 1)
|—Node:function_definition Text: static void
pio_rx_setup(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[1];
    sm->execctrl = (
        (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
    sm->shiftctrl = 0; // flush fifo on a restart
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS);
    sm->instr = can2040_offset_shared_rx_read; // jmp shared_rx_read
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_rx_setup(struct can2040 *cd)
|———Node:identifier Text: pio_rx_setup
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[1];
    sm->execctrl = (
        (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
    sm->shiftctrl = 0; // flush fifo on a restart
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS);
    sm->instr = can2040_offset_shared_rx_read; // jmp shared_rx_read
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[1];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[1]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[1]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[1]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->execctrl = (
        (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
|————Node:assignment_expression Text: sm->execctrl = (
        (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|—————Node:field_expression Text: sm->execctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: execctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (
        (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|——————Node:( Text: (
|——————Node:binary_expression Text: (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|———————Node:binary_expression Text: (can2040_offset_shared_rx_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|————————Node:parenthesized_expression Text: (can2040_offset_shared_rx_end - 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: can2040_offset_shared_rx_end - 1
|——————————Node:identifier Text: can2040_offset_shared_rx_end
|——————————Node:- Text: -
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|———————Node:| Text: |
|———————Node:binary_expression Text: can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|————————Node:identifier Text: can2040_offset_shared_rx_read
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
|————Node:assignment_expression Text: sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB
|—————Node:field_expression Text: sm->pinctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pinctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB
|——————Node:field_expression Text: cd->gpio_rx
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: gpio_rx
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_SM0_PINCTRL_IN_BASE_LSB
|————Node:; Text: ;
|———Node:expression_statement Text: sm->shiftctrl = 0;
|————Node:assignment_expression Text: sm->shiftctrl = 0
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // flush fifo on a restart
|———Node:expression_statement Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS);
|————Node:assignment_expression Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS)
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS)
|——————Node:( Text: (
|——————Node:binary_expression Text: PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
                     | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS
|———————Node:binary_expression Text: PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
                     | 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
|————————Node:identifier Text: PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS
|————————Node:| Text: |
|————————Node:binary_expression Text: 8 << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
|—————————Node:number_literal Text: 8
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB
|———————Node:| Text: |
|———————Node:identifier Text: PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = can2040_offset_shared_rx_read;
|————Node:assignment_expression Text: sm->instr = can2040_offset_shared_rx_read
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_shared_rx_read
|————Node:; Text: ;
|———Node:comment Text: // jmp shared_rx_read
|———Node:} Text: }
|—Node:comment Text: // Setup PIO "ack" state machine (state machine 2)
|—Node:function_definition Text: static void
pio_ack_setup(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[2];
    sm->execctrl = (
        (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
    sm->shiftctrl = 0;
    sm->instr = 0xe040; // set y, 0
    sm->instr = 0xa0e2; // mov osr, y
    sm->instr = 0xa02a, // mov x, !y
    sm->instr = can2040_offset_ack_no_match; // jmp ack_no_match
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_ack_setup(struct can2040 *cd)
|———Node:identifier Text: pio_ack_setup
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[2];
    sm->execctrl = (
        (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
    sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
    sm->shiftctrl = 0;
    sm->instr = 0xe040; // set y, 0
    sm->instr = 0xa0e2; // mov osr, y
    sm->instr = 0xa02a, // mov x, !y
    sm->instr = can2040_offset_ack_no_match; // jmp ack_no_match
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[2];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[2]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[2]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[2]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 2
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->execctrl = (
        (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB);
|————Node:assignment_expression Text: sm->execctrl = (
        (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|—————Node:field_expression Text: sm->execctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: execctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (
        (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB)
|——————Node:( Text: (
|——————Node:binary_expression Text: (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
        | can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|———————Node:binary_expression Text: (can2040_offset_ack_end - 1) << PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|————————Node:parenthesized_expression Text: (can2040_offset_ack_end - 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: can2040_offset_ack_end - 1
|——————————Node:identifier Text: can2040_offset_ack_end
|——————————Node:- Text: -
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_TOP_LSB
|———————Node:| Text: |
|———————Node:binary_expression Text: can2040_offset_shared_rx_read << PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|————————Node:identifier Text: can2040_offset_shared_rx_read
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB;
|————Node:assignment_expression Text: sm->pinctrl = cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB
|—————Node:field_expression Text: sm->pinctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pinctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_PINCTRL_IN_BASE_LSB
|——————Node:field_expression Text: cd->gpio_rx
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: gpio_rx
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_SM0_PINCTRL_IN_BASE_LSB
|————Node:; Text: ;
|———Node:expression_statement Text: sm->shiftctrl = 0;
|————Node:assignment_expression Text: sm->shiftctrl = 0
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0xe040;
|————Node:assignment_expression Text: sm->instr = 0xe040
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe040
|————Node:; Text: ;
|———Node:comment Text: // set y, 0
|———Node:expression_statement Text: sm->instr = 0xa0e2;
|————Node:assignment_expression Text: sm->instr = 0xa0e2
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xa0e2
|————Node:; Text: ;
|———Node:comment Text: // mov osr, y
|———Node:expression_statement Text: sm->instr = 0xa02a, // mov x, !y
    sm->instr = can2040_offset_ack_no_match;
|————Node:comma_expression Text: sm->instr = 0xa02a, // mov x, !y
    sm->instr = can2040_offset_ack_no_match
|—————Node:assignment_expression Text: sm->instr = 0xa02a
|——————Node:field_expression Text: sm->instr
|———————Node:identifier Text: sm
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr
|——————Node:= Text: =
|——————Node:number_literal Text: 0xa02a
|—————Node:, Text: ,
|—————Node:comment Text: // mov x, !y
|—————Node:assignment_expression Text: sm->instr = can2040_offset_ack_no_match
|——————Node:field_expression Text: sm->instr
|———————Node:identifier Text: sm
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr
|——————Node:= Text: =
|——————Node:identifier Text: can2040_offset_ack_no_match
|————Node:; Text: ;
|———Node:comment Text: // jmp ack_no_match
|———Node:} Text: }
|—Node:comment Text: // Setup PIO "tx" state machine (state machine 3)
|—Node:function_definition Text: static void
pio_tx_setup(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->execctrl = cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB;
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
    sm->pinctrl = (1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB);
    sm->instr = 0xe001; // set pins, 1
    sm->instr = 0xe081; // set pindirs, 1
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_tx_setup(struct can2040 *cd)
|———Node:identifier Text: pio_tx_setup
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->execctrl = cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB;
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
    sm->pinctrl = (1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB);
    sm->instr = 0xe001; // set pins, 1
    sm->instr = 0xe081; // set pindirs, 1
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[3];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[3]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[3]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[3]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->execctrl = cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB;
|————Node:assignment_expression Text: sm->execctrl = cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
|—————Node:field_expression Text: sm->execctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: execctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: cd->gpio_rx << PIO_SM0_EXECCTRL_JMP_PIN_LSB
|——————Node:field_expression Text: cd->gpio_rx
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: gpio_rx
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_SM0_EXECCTRL_JMP_PIN_LSB
|————Node:; Text: ;
|———Node:expression_statement Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
|————Node:assignment_expression Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS)
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS)
|——————Node:( Text: (
|——————Node:binary_expression Text: PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS
|———————Node:identifier Text: PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
|———————Node:| Text: |
|———————Node:identifier Text: PIO_SM0_SHIFTCTRL_AUTOPULL_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->pinctrl = (1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB);
|————Node:assignment_expression Text: sm->pinctrl = (1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB)
|—————Node:field_expression Text: sm->pinctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pinctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB
|———————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
                   | cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
|————————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
                   | 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
|—————————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_SET_COUNT_LSB
|——————————Node:number_literal Text: 1
|——————————Node:<< Text: <<
|——————————Node:identifier Text: PIO_SM0_PINCTRL_SET_COUNT_LSB
|—————————Node:| Text: |
|—————————Node:binary_expression Text: 1 << PIO_SM0_PINCTRL_OUT_COUNT_LSB
|——————————Node:number_literal Text: 1
|——————————Node:<< Text: <<
|——————————Node:identifier Text: PIO_SM0_PINCTRL_OUT_COUNT_LSB
|————————Node:| Text: |
|————————Node:binary_expression Text: cd->gpio_tx << PIO_SM0_PINCTRL_SET_BASE_LSB
|—————————Node:field_expression Text: cd->gpio_tx
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: gpio_tx
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_SM0_PINCTRL_SET_BASE_LSB
|———————Node:| Text: |
|———————Node:binary_expression Text: cd->gpio_tx << PIO_SM0_PINCTRL_OUT_BASE_LSB
|————————Node:field_expression Text: cd->gpio_tx
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: gpio_tx
|————————Node:<< Text: <<
|————————Node:identifier Text: PIO_SM0_PINCTRL_OUT_BASE_LSB
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0xe001;
|————Node:assignment_expression Text: sm->instr = 0xe001
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe001
|————Node:; Text: ;
|———Node:comment Text: // set pins, 1
|———Node:expression_statement Text: sm->instr = 0xe081;
|————Node:assignment_expression Text: sm->instr = 0xe081
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe081
|————Node:; Text: ;
|———Node:comment Text: // set pindirs, 1
|———Node:} Text: }
|—Node:comment Text: // Check if the PIO "tx" state machine stopped due to passive/dominant conflict
|—Node:function_definition Text: static int
pio_tx_did_conflict(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    return pio_hw->sm[3].addr == can2040_offset_tx_conflict;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: pio_tx_did_conflict(struct can2040 *cd)
|———Node:identifier Text: pio_tx_did_conflict
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    return pio_hw->sm[3].addr == can2040_offset_tx_conflict;
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:return_statement Text: return pio_hw->sm[3].addr == can2040_offset_tx_conflict;
|————Node:return Text: return
|————Node:binary_expression Text: pio_hw->sm[3].addr == can2040_offset_tx_conflict
|—————Node:field_expression Text: pio_hw->sm[3].addr
|——————Node:subscript_expression Text: pio_hw->sm[3]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: addr
|—————Node:== Text: ==
|—————Node:identifier Text: can2040_offset_tx_conflict
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Flush and halt PIO "tx" state machine
|—Node:function_definition Text: static void
pio_tx_reset(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->ctrl = ((0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB));
    pio_hw->irq = (1 << 2) | (1<< 3); // clear irq 2 and 3
    // Clear tx fifo
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->shiftctrl = 0;
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_tx_reset(struct can2040 *cd)
|———Node:identifier Text: pio_tx_reset
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->ctrl = ((0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB));
    pio_hw->irq = (1 << 2) | (1<< 3); // clear irq 2 and 3
    // Clear tx fifo
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->shiftctrl = 0;
    sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->ctrl = ((0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB));
|————Node:assignment_expression Text: pio_hw->ctrl = ((0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB))
|—————Node:field_expression Text: pio_hw->ctrl
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: ((0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB))
|——————Node:( Text: (
|——————Node:binary_expression Text: (0x07 << PIO_CTRL_SM_ENABLE_LSB)
                    | (0x08 << PIO_CTRL_SM_RESTART_LSB)
|———————Node:parenthesized_expression Text: (0x07 << PIO_CTRL_SM_ENABLE_LSB)
|————————Node:( Text: (
|————————Node:binary_expression Text: 0x07 << PIO_CTRL_SM_ENABLE_LSB
|—————————Node:number_literal Text: 0x07
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_CTRL_SM_ENABLE_LSB
|————————Node:) Text: )
|———————Node:| Text: |
|———————Node:parenthesized_expression Text: (0x08 << PIO_CTRL_SM_RESTART_LSB)
|————————Node:( Text: (
|————————Node:binary_expression Text: 0x08 << PIO_CTRL_SM_RESTART_LSB
|—————————Node:number_literal Text: 0x08
|—————————Node:<< Text: <<
|—————————Node:identifier Text: PIO_CTRL_SM_RESTART_LSB
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->irq = (1 << 2) | (1<< 3);
|————Node:assignment_expression Text: pio_hw->irq = (1 << 2) | (1<< 3)
|—————Node:field_expression Text: pio_hw->irq
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: irq
|—————Node:= Text: =
|—————Node:binary_expression Text: (1 << 2) | (1<< 3)
|——————Node:parenthesized_expression Text: (1 << 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1 << 2
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: (1<< 3)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1<< 3
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:number_literal Text: 3
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // clear irq 2 and 3
|———Node:comment Text: // Clear tx fifo
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[3];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[3]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[3]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[3]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->shiftctrl = 0;
|————Node:assignment_expression Text: sm->shiftctrl = 0
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS);
|————Node:assignment_expression Text: sm->shiftctrl = (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS)
|—————Node:field_expression Text: sm->shiftctrl
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: shiftctrl
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS)
|——————Node:( Text: (
|——————Node:binary_expression Text: PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
                     | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS
|———————Node:identifier Text: PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS
|———————Node:| Text: |
|———————Node:identifier Text: PIO_SM0_SHIFTCTRL_AUTOPULL_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Queue a message for transmission on PIO "tx" state machine
|—Node:function_definition Text: static void
pio_tx_send(struct can2040 *cd, uint32_t *data, uint32_t count)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_tx_reset(cd);
    pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xa242; // nop [2]
    int i;
    for (i=0; i<count; i++)
        pio_hw->txf[3] = data[i];
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->instr = 0xe001; // set pins, 1
    sm->instr = can2040_offset_tx_start; // jmp tx_start
    sm->instr = 0x20c0; // wait 1 irq, 0
    pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_tx_send(struct can2040 *cd, uint32_t *data, uint32_t count)
|———Node:identifier Text: pio_tx_send
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t *data, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t *data
|—————Node:primitive_type Text: uint32_t
|—————Node:pointer_declarator Text: *data
|——————Node:* Text: *
|——————Node:identifier Text: data
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_tx_reset(cd);
    pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xa242; // nop [2]
    int i;
    for (i=0; i<count; i++)
        pio_hw->txf[3] = data[i];
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->instr = 0xe001; // set pins, 1
    sm->instr = can2040_offset_tx_start; // jmp tx_start
    sm->instr = 0x20c0; // wait 1 irq, 0
    pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_tx_reset(cd);
|————Node:call_expression Text: pio_tx_reset(cd)
|—————Node:identifier Text: pio_tx_reset
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xa242;
|————Node:assignment_expression Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xa242
|—————Node:subscript_expression Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive]
|——————Node:field_expression Text: pio_hw->instr_mem
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr_mem
|——————Node:[ Text: [
|——————Node:identifier Text: can2040_offset_tx_got_recessive
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0xa242
|————Node:; Text: ;
|———Node:comment Text: // nop [2]
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<count; i++)
        pio_hw->txf[3] = data[i];
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<count
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: count
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:expression_statement Text: pio_hw->txf[3] = data[i];
|—————Node:assignment_expression Text: pio_hw->txf[3] = data[i]
|——————Node:subscript_expression Text: pio_hw->txf[3]
|———————Node:field_expression Text: pio_hw->txf
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: txf
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:subscript_expression Text: data[i]
|———————Node:identifier Text: data
|———————Node:[ Text: [
|———————Node:identifier Text: i
|———————Node:] Text: ]
|—————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[3];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[3]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[3]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[3]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0xe001;
|————Node:assignment_expression Text: sm->instr = 0xe001
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe001
|————Node:; Text: ;
|———Node:comment Text: // set pins, 1
|———Node:expression_statement Text: sm->instr = can2040_offset_tx_start;
|————Node:assignment_expression Text: sm->instr = can2040_offset_tx_start
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_tx_start
|————Node:; Text: ;
|———Node:comment Text: // jmp tx_start
|———Node:expression_statement Text: sm->instr = 0x20c0;
|————Node:assignment_expression Text: sm->instr = 0x20c0
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0x20c0
|————Node:; Text: ;
|———Node:comment Text: // wait 1 irq, 0
|———Node:expression_statement Text: pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;
|————Node:assignment_expression Text: pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB
|—————Node:field_expression Text: pio_hw->ctrl
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: 0x0f << PIO_CTRL_SM_ENABLE_LSB
|——————Node:number_literal Text: 0x0f
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_CTRL_SM_ENABLE_LSB
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Set PIO "ack" state machine to check a given CRC sequence
|—Node:function_definition Text: static void
pio_ack_check(struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
    pio_hw->txf[2] = key;

    // Raise irq after ack completes
    pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_ack_check(struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
|———Node:identifier Text: pio_ack_check
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t crc_bits
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: crc_bits
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t rx_bit_pos
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: rx_bit_pos
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
    pio_hw->txf[2] = key;

    // Raise irq after ack completes
    pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21)
|—————Node:identifier Text: key
|—————Node:= Text: =
|—————Node:binary_expression Text: (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21)
|——————Node:parenthesized_expression Text: (crc_bits & 0x1fffff)
|———————Node:( Text: (
|———————Node:binary_expression Text: crc_bits & 0x1fffff
|————————Node:identifier Text: crc_bits
|————————Node:& Text: &
|————————Node:number_literal Text: 0x1fffff
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: ((-rx_bit_pos) << 21)
|———————Node:( Text: (
|———————Node:binary_expression Text: (-rx_bit_pos) << 21
|————————Node:parenthesized_expression Text: (-rx_bit_pos)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: -rx_bit_pos
|——————————Node:- Text: -
|——————————Node:identifier Text: rx_bit_pos
|—————————Node:) Text: )
|————————Node:<< Text: <<
|————————Node:number_literal Text: 21
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->txf[2] = key;
|————Node:assignment_expression Text: pio_hw->txf[2] = key
|—————Node:subscript_expression Text: pio_hw->txf[2]
|——————Node:field_expression Text: pio_hw->txf
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txf
|——————Node:[ Text: [
|——————Node:number_literal Text: 2
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: key
|————Node:; Text: ;
|———Node:comment Text: // Raise irq after ack completes
|———Node:expression_statement Text: pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
|————Node:assignment_expression Text: pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS)
|—————Node:field_expression Text: pio_hw->inte0
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: inte0
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS)
|——————Node:( Text: (
|——————Node:binary_expression Text: PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|———————Node:binary_expression Text: PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM2_BITS
|————————Node:identifier Text: PIO_IRQ0_INTE_SM0_BITS
|————————Node:| Text: |
|————————Node:identifier Text: PIO_IRQ0_INTE_SM2_BITS
|———————Node:| Text: |
|———————Node:identifier Text: PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Set PIO "ack" state machine to check a CRC and inject an ack on success
|—Node:function_definition Text: static void
pio_ack_inject(struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_tx_reset(cd);
    pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xc023; // irq wait 3
    pio_hw->txf[3] = 0x7fffffff;
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->instr = 0xe001; // set pins, 1
    sm->instr = can2040_offset_tx_start; // jmp tx_start
    sm->instr = 0x20c2; // wait 1 irq, 2
    pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;

    uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
    pio_hw->txf[2] = key;

    // Raise irq after ack completes
    pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_ack_inject(struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
|———Node:identifier Text: pio_ack_inject
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t crc_bits, uint32_t rx_bit_pos)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t crc_bits
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: crc_bits
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t rx_bit_pos
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: rx_bit_pos
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_tx_reset(cd);
    pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xc023; // irq wait 3
    pio_hw->txf[3] = 0x7fffffff;
    struct pio_sm_hw *sm = &pio_hw->sm[3];
    sm->instr = 0xe001; // set pins, 1
    sm->instr = can2040_offset_tx_start; // jmp tx_start
    sm->instr = 0x20c2; // wait 1 irq, 2
    pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;

    uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
    pio_hw->txf[2] = key;

    // Raise irq after ack completes
    pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_tx_reset(cd);
|————Node:call_expression Text: pio_tx_reset(cd)
|—————Node:identifier Text: pio_tx_reset
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xc023;
|————Node:assignment_expression Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive] = 0xc023
|—————Node:subscript_expression Text: pio_hw->instr_mem[can2040_offset_tx_got_recessive]
|——————Node:field_expression Text: pio_hw->instr_mem
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr_mem
|——————Node:[ Text: [
|——————Node:identifier Text: can2040_offset_tx_got_recessive
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0xc023
|————Node:; Text: ;
|———Node:comment Text: // irq wait 3
|———Node:expression_statement Text: pio_hw->txf[3] = 0x7fffffff;
|————Node:assignment_expression Text: pio_hw->txf[3] = 0x7fffffff
|—————Node:subscript_expression Text: pio_hw->txf[3]
|——————Node:field_expression Text: pio_hw->txf
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txf
|——————Node:[ Text: [
|——————Node:number_literal Text: 3
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0x7fffffff
|————Node:; Text: ;
|———Node:declaration Text: struct pio_sm_hw *sm = &pio_hw->sm[3];
|————Node:struct_specifier Text: struct pio_sm_hw
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pio_sm_hw
|————Node:init_declarator Text: *sm = &pio_hw->sm[3]
|—————Node:pointer_declarator Text: *sm
|——————Node:* Text: *
|——————Node:identifier Text: sm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &pio_hw->sm[3]
|——————Node:& Text: &
|——————Node:subscript_expression Text: pio_hw->sm[3]
|———————Node:field_expression Text: pio_hw->sm
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: sm
|———————Node:[ Text: [
|———————Node:number_literal Text: 3
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: sm->instr = 0xe001;
|————Node:assignment_expression Text: sm->instr = 0xe001
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe001
|————Node:; Text: ;
|———Node:comment Text: // set pins, 1
|———Node:expression_statement Text: sm->instr = can2040_offset_tx_start;
|————Node:assignment_expression Text: sm->instr = can2040_offset_tx_start
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_tx_start
|————Node:; Text: ;
|———Node:comment Text: // jmp tx_start
|———Node:expression_statement Text: sm->instr = 0x20c2;
|————Node:assignment_expression Text: sm->instr = 0x20c2
|—————Node:field_expression Text: sm->instr
|——————Node:identifier Text: sm
|——————Node:-> Text: ->
|——————Node:field_identifier Text: instr
|—————Node:= Text: =
|—————Node:number_literal Text: 0x20c2
|————Node:; Text: ;
|———Node:comment Text: // wait 1 irq, 2
|———Node:expression_statement Text: pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB;
|————Node:assignment_expression Text: pio_hw->ctrl = 0x0f << PIO_CTRL_SM_ENABLE_LSB
|—————Node:field_expression Text: pio_hw->ctrl
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: 0x0f << PIO_CTRL_SM_ENABLE_LSB
|——————Node:number_literal Text: 0x0f
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_CTRL_SM_ENABLE_LSB
|————Node:; Text: ;
|———Node:declaration Text: uint32_t key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: key = (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21)
|—————Node:identifier Text: key
|—————Node:= Text: =
|—————Node:binary_expression Text: (crc_bits & 0x1fffff) | ((-rx_bit_pos) << 21)
|——————Node:parenthesized_expression Text: (crc_bits & 0x1fffff)
|———————Node:( Text: (
|———————Node:binary_expression Text: crc_bits & 0x1fffff
|————————Node:identifier Text: crc_bits
|————————Node:& Text: &
|————————Node:number_literal Text: 0x1fffff
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: ((-rx_bit_pos) << 21)
|———————Node:( Text: (
|———————Node:binary_expression Text: (-rx_bit_pos) << 21
|————————Node:parenthesized_expression Text: (-rx_bit_pos)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: -rx_bit_pos
|——————————Node:- Text: -
|——————————Node:identifier Text: rx_bit_pos
|—————————Node:) Text: )
|————————Node:<< Text: <<
|————————Node:number_literal Text: 21
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->txf[2] = key;
|————Node:assignment_expression Text: pio_hw->txf[2] = key
|—————Node:subscript_expression Text: pio_hw->txf[2]
|——————Node:field_expression Text: pio_hw->txf
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txf
|——————Node:[ Text: [
|——————Node:number_literal Text: 2
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:identifier Text: key
|————Node:; Text: ;
|———Node:comment Text: // Raise irq after ack completes
|———Node:expression_statement Text: pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS);
|————Node:assignment_expression Text: pio_hw->inte0 = (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS)
|—————Node:field_expression Text: pio_hw->inte0
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: inte0
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS)
|——————Node:( Text: (
|——————Node:binary_expression Text: PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
                     | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|———————Node:binary_expression Text: PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM3_BITS
|————————Node:identifier Text: PIO_IRQ0_INTE_SM0_BITS
|————————Node:| Text: |
|————————Node:identifier Text: PIO_IRQ0_INTE_SM3_BITS
|———————Node:| Text: |
|———————Node:identifier Text: PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Cancel any pending checks on PIO "ack" state machine
|—Node:function_definition Text: static void
pio_ack_cancel(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->txf[2] = 0;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_ack_cancel(struct can2040 *cd)
|———Node:identifier Text: pio_ack_cancel
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->txf[2] = 0;
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->txf[2] = 0;
|————Node:assignment_expression Text: pio_hw->txf[2] = 0
|—————Node:subscript_expression Text: pio_hw->txf[2]
|——————Node:field_expression Text: pio_hw->txf
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: txf
|——————Node:[ Text: [
|——————Node:number_literal Text: 2
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Test if PIO "rx" state machine has overflowed its fifos
|—Node:function_definition Text: static int
pio_rx_check_stall(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    return pio_hw->fdebug & (1 << (PIO_FDEBUG_RXSTALL_LSB + 1));
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: pio_rx_check_stall(struct can2040 *cd)
|———Node:identifier Text: pio_rx_check_stall
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    return pio_hw->fdebug & (1 << (PIO_FDEBUG_RXSTALL_LSB + 1));
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:return_statement Text: return pio_hw->fdebug & (1 << (PIO_FDEBUG_RXSTALL_LSB + 1));
|————Node:return Text: return
|————Node:binary_expression Text: pio_hw->fdebug & (1 << (PIO_FDEBUG_RXSTALL_LSB + 1))
|—————Node:field_expression Text: pio_hw->fdebug
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: fdebug
|—————Node:& Text: &
|—————Node:parenthesized_expression Text: (1 << (PIO_FDEBUG_RXSTALL_LSB + 1))
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 << (PIO_FDEBUG_RXSTALL_LSB + 1)
|———————Node:number_literal Text: 1
|———————Node:<< Text: <<
|———————Node:parenthesized_expression Text: (PIO_FDEBUG_RXSTALL_LSB + 1)
|————————Node:( Text: (
|————————Node:binary_expression Text: PIO_FDEBUG_RXSTALL_LSB + 1
|—————————Node:identifier Text: PIO_FDEBUG_RXSTALL_LSB
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Enable host irq on a "may start transmit" signal (sm irq 0)
|—Node:function_definition Text: static void
pio_sync_set_may_start_tx_irq(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->inte0 = PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_set_may_start_tx_irq(struct can2040 *cd)
|———Node:identifier Text: pio_sync_set_may_start_tx_irq
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->inte0 = PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->inte0 = PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
|————Node:assignment_expression Text: pio_hw->inte0 = PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|—————Node:field_expression Text: pio_hw->inte0
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: inte0
|—————Node:= Text: =
|—————Node:binary_expression Text: PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|——————Node:identifier Text: PIO_IRQ0_INTE_SM0_BITS
|——————Node:| Text: |
|——————Node:identifier Text: PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Atomically enable "may start transmit" signal (sm irq 0)
|—Node:function_definition Text: static void
pio_sync_atomic_enable_may_start_tx_irq(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    hw_set_bits(&pio_hw->inte0, PIO_IRQ0_INTE_SM0_BITS);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_atomic_enable_may_start_tx_irq(struct can2040 *cd)
|———Node:identifier Text: pio_sync_atomic_enable_may_start_tx_irq
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    hw_set_bits(&pio_hw->inte0, PIO_IRQ0_INTE_SM0_BITS);
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: hw_set_bits(&pio_hw->inte0, PIO_IRQ0_INTE_SM0_BITS);
|————Node:call_expression Text: hw_set_bits(&pio_hw->inte0, PIO_IRQ0_INTE_SM0_BITS)
|—————Node:identifier Text: hw_set_bits
|—————Node:argument_list Text: (&pio_hw->inte0, PIO_IRQ0_INTE_SM0_BITS)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &pio_hw->inte0
|———————Node:& Text: &
|———————Node:field_expression Text: pio_hw->inte0
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: inte0
|——————Node:, Text: ,
|——————Node:identifier Text: PIO_IRQ0_INTE_SM0_BITS
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Disable PIO host irqs (except for normal data read irq)
|—Node:function_definition Text: static void
pio_sync_disable_irqs(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->inte0 = PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_disable_irqs(struct can2040 *cd)
|———Node:identifier Text: pio_sync_disable_irqs
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->inte0 = PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->inte0 = PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS;
|————Node:assignment_expression Text: pio_hw->inte0 = PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|—————Node:field_expression Text: pio_hw->inte0
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: inte0
|—————Node:= Text: =
|—————Node:identifier Text: PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Set PIO "sync" machine to signal "start transmit" (sm irq 0) on 11 idle bits
|—Node:function_definition Text: static void
pio_sync_normal_start_signal(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
    pio_hw->instr_mem[eom_idx] = 0xe13a; // set x, 26 [1]
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_normal_start_signal(struct can2040 *cd)
|———Node:identifier Text: pio_sync_normal_start_signal
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
    pio_hw->instr_mem[eom_idx] = 0xe13a; // set x, 26 [1]
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: eom_idx = can2040_offset_sync_found_end_of_message
|—————Node:identifier Text: eom_idx
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_sync_found_end_of_message
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->instr_mem[eom_idx] = 0xe13a;
|————Node:assignment_expression Text: pio_hw->instr_mem[eom_idx] = 0xe13a
|—————Node:subscript_expression Text: pio_hw->instr_mem[eom_idx]
|——————Node:field_expression Text: pio_hw->instr_mem
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr_mem
|——————Node:[ Text: [
|——————Node:identifier Text: eom_idx
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0xe13a
|————Node:; Text: ;
|———Node:comment Text: // set x, 26 [1]
|———Node:} Text: }
|—Node:comment Text: // Set PIO "sync" machine to signal "start transmit" (sm irq 0) on 17 idle bits
|—Node:function_definition Text: static void
pio_sync_slow_start_signal(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
    pio_hw->instr_mem[eom_idx] = 0xa127; // mov x, osr [1]
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sync_slow_start_signal(struct can2040 *cd)
|———Node:identifier Text: pio_sync_slow_start_signal
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
    pio_hw->instr_mem[eom_idx] = 0xa127; // mov x, osr [1]
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: uint32_t eom_idx = can2040_offset_sync_found_end_of_message;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: eom_idx = can2040_offset_sync_found_end_of_message
|—————Node:identifier Text: eom_idx
|—————Node:= Text: =
|—————Node:identifier Text: can2040_offset_sync_found_end_of_message
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->instr_mem[eom_idx] = 0xa127;
|————Node:assignment_expression Text: pio_hw->instr_mem[eom_idx] = 0xa127
|—————Node:subscript_expression Text: pio_hw->instr_mem[eom_idx]
|——————Node:field_expression Text: pio_hw->instr_mem
|———————Node:identifier Text: pio_hw
|———————Node:-> Text: ->
|———————Node:field_identifier Text: instr_mem
|——————Node:[ Text: [
|——————Node:identifier Text: eom_idx
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:number_literal Text: 0xa127
|————Node:; Text: ;
|———Node:comment Text: // mov x, osr [1]
|———Node:} Text: }
|—Node:comment Text: // Setup PIO state machines
|—Node:function_definition Text: static void
pio_sm_setup(struct can2040 *cd)
{
    // Reset state machines
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->ctrl = PIO_CTRL_SM_RESTART_BITS | PIO_CTRL_CLKDIV_RESTART_BITS;
    pio_hw->fdebug = 0xffffffff;

    // Load pio program
    int i;
    for (i=0; i<ARRAY_SIZE(can2040_program_instructions); i++)
        pio_hw->instr_mem[i] = can2040_program_instructions[i];

    // Set initial state machine state
    pio_sync_setup(cd);
    pio_rx_setup(cd);
    pio_ack_setup(cd);
    pio_tx_setup(cd);

    // Start state machines
    pio_hw->ctrl = 0x07 << PIO_CTRL_SM_ENABLE_LSB;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_sm_setup(struct can2040 *cd)
|———Node:identifier Text: pio_sm_setup
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    // Reset state machines
    pio_hw_t *pio_hw = cd->pio_hw;
    pio_hw->ctrl = PIO_CTRL_SM_RESTART_BITS | PIO_CTRL_CLKDIV_RESTART_BITS;
    pio_hw->fdebug = 0xffffffff;

    // Load pio program
    int i;
    for (i=0; i<ARRAY_SIZE(can2040_program_instructions); i++)
        pio_hw->instr_mem[i] = can2040_program_instructions[i];

    // Set initial state machine state
    pio_sync_setup(cd);
    pio_rx_setup(cd);
    pio_ack_setup(cd);
    pio_tx_setup(cd);

    // Start state machines
    pio_hw->ctrl = 0x07 << PIO_CTRL_SM_ENABLE_LSB;
}
|———Node:{ Text: {
|———Node:comment Text: // Reset state machines
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->ctrl = PIO_CTRL_SM_RESTART_BITS | PIO_CTRL_CLKDIV_RESTART_BITS;
|————Node:assignment_expression Text: pio_hw->ctrl = PIO_CTRL_SM_RESTART_BITS | PIO_CTRL_CLKDIV_RESTART_BITS
|—————Node:field_expression Text: pio_hw->ctrl
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: PIO_CTRL_SM_RESTART_BITS | PIO_CTRL_CLKDIV_RESTART_BITS
|——————Node:identifier Text: PIO_CTRL_SM_RESTART_BITS
|——————Node:| Text: |
|——————Node:identifier Text: PIO_CTRL_CLKDIV_RESTART_BITS
|————Node:; Text: ;
|———Node:expression_statement Text: pio_hw->fdebug = 0xffffffff;
|————Node:assignment_expression Text: pio_hw->fdebug = 0xffffffff
|—————Node:field_expression Text: pio_hw->fdebug
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: fdebug
|—————Node:= Text: =
|—————Node:number_literal Text: 0xffffffff
|————Node:; Text: ;
|———Node:comment Text: // Load pio program
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<ARRAY_SIZE(can2040_program_instructions); i++)
        pio_hw->instr_mem[i] = can2040_program_instructions[i];
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<ARRAY_SIZE(can2040_program_instructions)
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:call_expression Text: ARRAY_SIZE(can2040_program_instructions)
|——————Node:identifier Text: ARRAY_SIZE
|——————Node:argument_list Text: (can2040_program_instructions)
|———————Node:( Text: (
|———————Node:identifier Text: can2040_program_instructions
|———————Node:) Text: )
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:expression_statement Text: pio_hw->instr_mem[i] = can2040_program_instructions[i];
|—————Node:assignment_expression Text: pio_hw->instr_mem[i] = can2040_program_instructions[i]
|——————Node:subscript_expression Text: pio_hw->instr_mem[i]
|———————Node:field_expression Text: pio_hw->instr_mem
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: instr_mem
|———————Node:[ Text: [
|———————Node:identifier Text: i
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:subscript_expression Text: can2040_program_instructions[i]
|———————Node:identifier Text: can2040_program_instructions
|———————Node:[ Text: [
|———————Node:identifier Text: i
|———————Node:] Text: ]
|—————Node:; Text: ;
|———Node:comment Text: // Set initial state machine state
|———Node:expression_statement Text: pio_sync_setup(cd);
|————Node:call_expression Text: pio_sync_setup(cd)
|—————Node:identifier Text: pio_sync_setup
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_rx_setup(cd);
|————Node:call_expression Text: pio_rx_setup(cd)
|—————Node:identifier Text: pio_rx_setup
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_ack_setup(cd);
|————Node:call_expression Text: pio_ack_setup(cd)
|—————Node:identifier Text: pio_ack_setup
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_tx_setup(cd);
|————Node:call_expression Text: pio_tx_setup(cd)
|—————Node:identifier Text: pio_tx_setup
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Start state machines
|———Node:expression_statement Text: pio_hw->ctrl = 0x07 << PIO_CTRL_SM_ENABLE_LSB;
|————Node:assignment_expression Text: pio_hw->ctrl = 0x07 << PIO_CTRL_SM_ENABLE_LSB
|—————Node:field_expression Text: pio_hw->ctrl
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ctrl
|—————Node:= Text: =
|—————Node:binary_expression Text: 0x07 << PIO_CTRL_SM_ENABLE_LSB
|——————Node:number_literal Text: 0x07
|——————Node:<< Text: <<
|——————Node:identifier Text: PIO_CTRL_SM_ENABLE_LSB
|————Node:; Text: ;
|———Node:} Text: }
|—Node:preproc_def Text: #define PIO_FUNC 6

|——Node:#define Text: #define
|——Node:identifier Text: PIO_FUNC
|——Node:preproc_arg Text: 6
|—Node:comment Text: // Initial setup of gpio pins and PIO state machines
|—Node:function_definition Text: static void
pio_setup(struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate)
{
    // Configure pio0 clock
    uint32_t rb = cd->pio_num ? RESETS_RESET_PIO1_BITS : RESETS_RESET_PIO0_BITS;
    rp2040_clear_reset(rb);

    // Setup and sync pio state machine clocks
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t div = (256 / PIO_CLOCK_PER_BIT) * sys_clock / bitrate;
    int i;
    for (i=0; i<4; i++)
        pio_hw->sm[i].clkdiv = div << PIO_SM0_CLKDIV_FRAC_LSB;

    // Configure state machines
    pio_sm_setup(cd);

    // Map Rx/Tx gpios
    rp2040_gpio_peripheral(cd->gpio_rx, PIO_FUNC, 1);
    rp2040_gpio_peripheral(cd->gpio_tx, PIO_FUNC, 0);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: pio_setup(struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate)
|———Node:identifier Text: pio_setup
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t sys_clock
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: sys_clock
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t bitrate
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: bitrate
|————Node:) Text: )
|——Node:compound_statement Text: {
    // Configure pio0 clock
    uint32_t rb = cd->pio_num ? RESETS_RESET_PIO1_BITS : RESETS_RESET_PIO0_BITS;
    rp2040_clear_reset(rb);

    // Setup and sync pio state machine clocks
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t div = (256 / PIO_CLOCK_PER_BIT) * sys_clock / bitrate;
    int i;
    for (i=0; i<4; i++)
        pio_hw->sm[i].clkdiv = div << PIO_SM0_CLKDIV_FRAC_LSB;

    // Configure state machines
    pio_sm_setup(cd);

    // Map Rx/Tx gpios
    rp2040_gpio_peripheral(cd->gpio_rx, PIO_FUNC, 1);
    rp2040_gpio_peripheral(cd->gpio_tx, PIO_FUNC, 0);
}
|———Node:{ Text: {
|———Node:comment Text: // Configure pio0 clock
|———Node:declaration Text: uint32_t rb = cd->pio_num ? RESETS_RESET_PIO1_BITS : RESETS_RESET_PIO0_BITS;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: rb = cd->pio_num ? RESETS_RESET_PIO1_BITS : RESETS_RESET_PIO0_BITS
|—————Node:identifier Text: rb
|—————Node:= Text: =
|—————Node:conditional_expression Text: cd->pio_num ? RESETS_RESET_PIO1_BITS : RESETS_RESET_PIO0_BITS
|——————Node:field_expression Text: cd->pio_num
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: pio_num
|——————Node:? Text: ?
|——————Node:identifier Text: RESETS_RESET_PIO1_BITS
|——————Node:: Text: :
|——————Node:identifier Text: RESETS_RESET_PIO0_BITS
|————Node:; Text: ;
|———Node:expression_statement Text: rp2040_clear_reset(rb);
|————Node:call_expression Text: rp2040_clear_reset(rb)
|—————Node:identifier Text: rp2040_clear_reset
|—————Node:argument_list Text: (rb)
|——————Node:( Text: (
|——————Node:identifier Text: rb
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Setup and sync pio state machine clocks
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: uint32_t div = (256 / PIO_CLOCK_PER_BIT) * sys_clock / bitrate;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: div = (256 / PIO_CLOCK_PER_BIT) * sys_clock / bitrate
|—————Node:identifier Text: div
|—————Node:= Text: =
|—————Node:binary_expression Text: (256 / PIO_CLOCK_PER_BIT) * sys_clock / bitrate
|——————Node:binary_expression Text: (256 / PIO_CLOCK_PER_BIT) * sys_clock
|———————Node:parenthesized_expression Text: (256 / PIO_CLOCK_PER_BIT)
|————————Node:( Text: (
|————————Node:binary_expression Text: 256 / PIO_CLOCK_PER_BIT
|—————————Node:number_literal Text: 256
|—————————Node:/ Text: /
|—————————Node:identifier Text: PIO_CLOCK_PER_BIT
|————————Node:) Text: )
|———————Node:* Text: *
|———————Node:identifier Text: sys_clock
|——————Node:/ Text: /
|——————Node:identifier Text: bitrate
|————Node:; Text: ;
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<4; i++)
        pio_hw->sm[i].clkdiv = div << PIO_SM0_CLKDIV_FRAC_LSB;
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<4
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:number_literal Text: 4
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:expression_statement Text: pio_hw->sm[i].clkdiv = div << PIO_SM0_CLKDIV_FRAC_LSB;
|—————Node:assignment_expression Text: pio_hw->sm[i].clkdiv = div << PIO_SM0_CLKDIV_FRAC_LSB
|——————Node:field_expression Text: pio_hw->sm[i].clkdiv
|———————Node:subscript_expression Text: pio_hw->sm[i]
|————————Node:field_expression Text: pio_hw->sm
|—————————Node:identifier Text: pio_hw
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: sm
|————————Node:[ Text: [
|————————Node:identifier Text: i
|————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: clkdiv
|——————Node:= Text: =
|——————Node:binary_expression Text: div << PIO_SM0_CLKDIV_FRAC_LSB
|———————Node:identifier Text: div
|———————Node:<< Text: <<
|———————Node:identifier Text: PIO_SM0_CLKDIV_FRAC_LSB
|—————Node:; Text: ;
|———Node:comment Text: // Configure state machines
|———Node:expression_statement Text: pio_sm_setup(cd);
|————Node:call_expression Text: pio_sm_setup(cd)
|—————Node:identifier Text: pio_sm_setup
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Map Rx/Tx gpios
|———Node:expression_statement Text: rp2040_gpio_peripheral(cd->gpio_rx, PIO_FUNC, 1);
|————Node:call_expression Text: rp2040_gpio_peripheral(cd->gpio_rx, PIO_FUNC, 1)
|—————Node:identifier Text: rp2040_gpio_peripheral
|—————Node:argument_list Text: (cd->gpio_rx, PIO_FUNC, 1)
|——————Node:( Text: (
|——————Node:field_expression Text: cd->gpio_rx
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: gpio_rx
|——————Node:, Text: ,
|——————Node:identifier Text: PIO_FUNC
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: rp2040_gpio_peripheral(cd->gpio_tx, PIO_FUNC, 0);
|————Node:call_expression Text: rp2040_gpio_peripheral(cd->gpio_tx, PIO_FUNC, 0)
|—————Node:identifier Text: rp2040_gpio_peripheral
|—————Node:argument_list Text: (cd->gpio_tx, PIO_FUNC, 0)
|——————Node:( Text: (
|——————Node:field_expression Text: cd->gpio_tx
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: gpio_tx
|——————Node:, Text: ,
|——————Node:identifier Text: PIO_FUNC
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * CRC calculation
 ****************************************************************/
|—Node:comment Text: // Calculated 4-bit crc table (see scripts/crc.py)
|—Node:declaration Text: static const uint16_t crc_table[16] = {
    0x0000, 0x4599, 0x4eab, 0x0b32, 0x58cf, 0x1d56, 0x1664, 0x53fd,
    0x7407, 0x319e, 0x3aac, 0x7f35, 0x2cc8, 0x6951, 0x6263, 0x27fa
};
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:primitive_type Text: uint16_t
|——Node:init_declarator Text: crc_table[16] = {
    0x0000, 0x4599, 0x4eab, 0x0b32, 0x58cf, 0x1d56, 0x1664, 0x53fd,
    0x7407, 0x319e, 0x3aac, 0x7f35, 0x2cc8, 0x6951, 0x6263, 0x27fa
}
|———Node:array_declarator Text: crc_table[16]
|————Node:identifier Text: crc_table
|————Node:[ Text: [
|————Node:number_literal Text: 16
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
    0x0000, 0x4599, 0x4eab, 0x0b32, 0x58cf, 0x1d56, 0x1664, 0x53fd,
    0x7407, 0x319e, 0x3aac, 0x7f35, 0x2cc8, 0x6951, 0x6263, 0x27fa
}
|————Node:{ Text: {
|————Node:number_literal Text: 0x0000
|————Node:, Text: ,
|————Node:number_literal Text: 0x4599
|————Node:, Text: ,
|————Node:number_literal Text: 0x4eab
|————Node:, Text: ,
|————Node:number_literal Text: 0x0b32
|————Node:, Text: ,
|————Node:number_literal Text: 0x58cf
|————Node:, Text: ,
|————Node:number_literal Text: 0x1d56
|————Node:, Text: ,
|————Node:number_literal Text: 0x1664
|————Node:, Text: ,
|————Node:number_literal Text: 0x53fd
|————Node:, Text: ,
|————Node:number_literal Text: 0x7407
|————Node:, Text: ,
|————Node:number_literal Text: 0x319e
|————Node:, Text: ,
|————Node:number_literal Text: 0x3aac
|————Node:, Text: ,
|————Node:number_literal Text: 0x7f35
|————Node:, Text: ,
|————Node:number_literal Text: 0x2cc8
|————Node:, Text: ,
|————Node:number_literal Text: 0x6951
|————Node:, Text: ,
|————Node:number_literal Text: 0x6263
|————Node:, Text: ,
|————Node:number_literal Text: 0x27fa
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: // Update a crc with 'count' number of bits (count must be multiple of 4)
|—Node:function_definition Text: static uint32_t
crcbits(uint32_t crc, uint32_t data, uint32_t count)
{
    int i;
    for (i=count-4; i>=0; i-=4) {
        uint32_t pos = ((crc >> 11) ^ (data >> i)) & 0x0f;
        crc = (crc << 4) ^ crc_table[pos];
    }
    return crc;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: crcbits(uint32_t crc, uint32_t data, uint32_t count)
|———Node:identifier Text: crcbits
|———Node:parameter_list Text: (uint32_t crc, uint32_t data, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t crc
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: crc
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    int i;
    for (i=count-4; i>=0; i-=4) {
        uint32_t pos = ((crc >> 11) ^ (data >> i)) & 0x0f;
        crc = (crc << 4) ^ crc_table[pos];
    }
    return crc;
}
|———Node:{ Text: {
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=count-4; i>=0; i-=4) {
        uint32_t pos = ((crc >> 11) ^ (data >> i)) & 0x0f;
        crc = (crc << 4) ^ crc_table[pos];
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=count-4
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:binary_expression Text: count-4
|——————Node:identifier Text: count
|——————Node:- Text: -
|——————Node:number_literal Text: 4
|————Node:; Text: ;
|————Node:binary_expression Text: i>=0
|—————Node:identifier Text: i
|—————Node:>= Text: >=
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:assignment_expression Text: i-=4
|—————Node:identifier Text: i
|—————Node:-= Text: -=
|—————Node:number_literal Text: 4
|————Node:) Text: )
|————Node:compound_statement Text: {
        uint32_t pos = ((crc >> 11) ^ (data >> i)) & 0x0f;
        crc = (crc << 4) ^ crc_table[pos];
    }
|—————Node:{ Text: {
|—————Node:declaration Text: uint32_t pos = ((crc >> 11) ^ (data >> i)) & 0x0f;
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: pos = ((crc >> 11) ^ (data >> i)) & 0x0f
|———————Node:identifier Text: pos
|———————Node:= Text: =
|———————Node:binary_expression Text: ((crc >> 11) ^ (data >> i)) & 0x0f
|————————Node:parenthesized_expression Text: ((crc >> 11) ^ (data >> i))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (crc >> 11) ^ (data >> i)
|——————————Node:parenthesized_expression Text: (crc >> 11)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: crc >> 11
|————————————Node:identifier Text: crc
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 11
|———————————Node:) Text: )
|——————————Node:^ Text: ^
|——————————Node:parenthesized_expression Text: (data >> i)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: data >> i
|————————————Node:identifier Text: data
|————————————Node:>> Text: >>
|————————————Node:identifier Text: i
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0x0f
|——————Node:; Text: ;
|—————Node:expression_statement Text: crc = (crc << 4) ^ crc_table[pos];
|——————Node:assignment_expression Text: crc = (crc << 4) ^ crc_table[pos]
|———————Node:identifier Text: crc
|———————Node:= Text: =
|———————Node:binary_expression Text: (crc << 4) ^ crc_table[pos]
|————————Node:parenthesized_expression Text: (crc << 4)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: crc << 4
|——————————Node:identifier Text: crc
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 4
|—————————Node:) Text: )
|————————Node:^ Text: ^
|————————Node:subscript_expression Text: crc_table[pos]
|—————————Node:identifier Text: crc_table
|—————————Node:[ Text: [
|—————————Node:identifier Text: pos
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return crc;
|————Node:return Text: return
|————Node:identifier Text: crc
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Bit unstuffing
 ****************************************************************/
|—Node:comment Text: // Add 'count' number of bits from 'data' to the 'bu' unstuffer
|—Node:function_definition Text: static void
unstuf_add_bits(struct can2040_bitunstuffer *bu, uint32_t data, uint32_t count)
{
    uint32_t mask = (1 << count) - 1;
    bu->stuffed_bits = (bu->stuffed_bits << count) | (data & mask);
    bu->count_stuff = count;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: unstuf_add_bits(struct can2040_bitunstuffer *bu, uint32_t data, uint32_t count)
|———Node:identifier Text: unstuf_add_bits
|———Node:parameter_list Text: (struct can2040_bitunstuffer *bu, uint32_t data, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040_bitunstuffer *bu
|—————Node:struct_specifier Text: struct can2040_bitunstuffer
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_bitunstuffer
|—————Node:pointer_declarator Text: *bu
|——————Node:* Text: *
|——————Node:identifier Text: bu
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t mask = (1 << count) - 1;
    bu->stuffed_bits = (bu->stuffed_bits << count) | (data & mask);
    bu->count_stuff = count;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t mask = (1 << count) - 1;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: mask = (1 << count) - 1
|—————Node:identifier Text: mask
|—————Node:= Text: =
|—————Node:binary_expression Text: (1 << count) - 1
|——————Node:parenthesized_expression Text: (1 << count)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1 << count
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:identifier Text: count
|———————Node:) Text: )
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:expression_statement Text: bu->stuffed_bits = (bu->stuffed_bits << count) | (data & mask);
|————Node:assignment_expression Text: bu->stuffed_bits = (bu->stuffed_bits << count) | (data & mask)
|—————Node:field_expression Text: bu->stuffed_bits
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: stuffed_bits
|—————Node:= Text: =
|—————Node:binary_expression Text: (bu->stuffed_bits << count) | (data & mask)
|——————Node:parenthesized_expression Text: (bu->stuffed_bits << count)
|———————Node:( Text: (
|———————Node:binary_expression Text: bu->stuffed_bits << count
|————————Node:field_expression Text: bu->stuffed_bits
|—————————Node:identifier Text: bu
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: stuffed_bits
|————————Node:<< Text: <<
|————————Node:identifier Text: count
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: (data & mask)
|———————Node:( Text: (
|———————Node:binary_expression Text: data & mask
|————————Node:identifier Text: data
|————————Node:& Text: &
|————————Node:identifier Text: mask
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: bu->count_stuff = count;
|————Node:assignment_expression Text: bu->count_stuff = count
|—————Node:field_expression Text: bu->count_stuff
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: count_stuff
|—————Node:= Text: =
|—————Node:identifier Text: count
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Reset state and set the next desired 'count' unstuffed bits to extract
|—Node:function_definition Text: static void
unstuf_set_count(struct can2040_bitunstuffer *bu, uint32_t count)
{
    bu->unstuffed_bits = 0;
    bu->count_unstuff = count;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: unstuf_set_count(struct can2040_bitunstuffer *bu, uint32_t count)
|———Node:identifier Text: unstuf_set_count
|———Node:parameter_list Text: (struct can2040_bitunstuffer *bu, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040_bitunstuffer *bu
|—————Node:struct_specifier Text: struct can2040_bitunstuffer
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_bitunstuffer
|—————Node:pointer_declarator Text: *bu
|——————Node:* Text: *
|——————Node:identifier Text: bu
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    bu->unstuffed_bits = 0;
    bu->count_unstuff = count;
}
|———Node:{ Text: {
|———Node:expression_statement Text: bu->unstuffed_bits = 0;
|————Node:assignment_expression Text: bu->unstuffed_bits = 0
|—————Node:field_expression Text: bu->unstuffed_bits
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: unstuffed_bits
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: bu->count_unstuff = count;
|————Node:assignment_expression Text: bu->count_unstuff = count
|—————Node:field_expression Text: bu->count_unstuff
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: count_unstuff
|—————Node:= Text: =
|—————Node:identifier Text: count
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Clear bitstuffing state (used after crc field to avoid bitstuffing ack field)
|—Node:function_definition Text: static void
unstuf_clear_state(struct can2040_bitunstuffer *bu)
{
    uint32_t lb = 1 << bu->count_stuff;
    bu->stuffed_bits = (bu->stuffed_bits & (lb - 1)) | lb;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: unstuf_clear_state(struct can2040_bitunstuffer *bu)
|———Node:identifier Text: unstuf_clear_state
|———Node:parameter_list Text: (struct can2040_bitunstuffer *bu)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040_bitunstuffer *bu
|—————Node:struct_specifier Text: struct can2040_bitunstuffer
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_bitunstuffer
|—————Node:pointer_declarator Text: *bu
|——————Node:* Text: *
|——————Node:identifier Text: bu
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t lb = 1 << bu->count_stuff;
    bu->stuffed_bits = (bu->stuffed_bits & (lb - 1)) | lb;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t lb = 1 << bu->count_stuff;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: lb = 1 << bu->count_stuff
|—————Node:identifier Text: lb
|—————Node:= Text: =
|—————Node:binary_expression Text: 1 << bu->count_stuff
|——————Node:number_literal Text: 1
|——————Node:<< Text: <<
|——————Node:field_expression Text: bu->count_stuff
|———————Node:identifier Text: bu
|———————Node:-> Text: ->
|———————Node:field_identifier Text: count_stuff
|————Node:; Text: ;
|———Node:expression_statement Text: bu->stuffed_bits = (bu->stuffed_bits & (lb - 1)) | lb;
|————Node:assignment_expression Text: bu->stuffed_bits = (bu->stuffed_bits & (lb - 1)) | lb
|—————Node:field_expression Text: bu->stuffed_bits
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: stuffed_bits
|—————Node:= Text: =
|—————Node:binary_expression Text: (bu->stuffed_bits & (lb - 1)) | lb
|——————Node:parenthesized_expression Text: (bu->stuffed_bits & (lb - 1))
|———————Node:( Text: (
|———————Node:binary_expression Text: bu->stuffed_bits & (lb - 1)
|————————Node:field_expression Text: bu->stuffed_bits
|—————————Node:identifier Text: bu
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: stuffed_bits
|————————Node:& Text: &
|————————Node:parenthesized_expression Text: (lb - 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: lb - 1
|——————————Node:identifier Text: lb
|——————————Node:- Text: -
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:identifier Text: lb
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Pull bits from unstuffer (as specified in unstuf_set_count() )
|—Node:function_definition Text: static int
unstuf_pull_bits(struct can2040_bitunstuffer *bu)
{
    uint32_t sb = bu->stuffed_bits, edges = sb ^ (sb >> 1);
    uint32_t ub = bu->unstuffed_bits;
    uint32_t cs = bu->count_stuff, cu = bu->count_unstuff;
    for (;;) {
        if (!cu) {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
        if (!cs) {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
        cs--;
        if ((edges >> (cs+1)) & 0xf) {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        } else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: int
|——Node:function_declarator Text: unstuf_pull_bits(struct can2040_bitunstuffer *bu)
|———Node:identifier Text: unstuf_pull_bits
|———Node:parameter_list Text: (struct can2040_bitunstuffer *bu)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040_bitunstuffer *bu
|—————Node:struct_specifier Text: struct can2040_bitunstuffer
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_bitunstuffer
|—————Node:pointer_declarator Text: *bu
|——————Node:* Text: *
|——————Node:identifier Text: bu
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t sb = bu->stuffed_bits, edges = sb ^ (sb >> 1);
    uint32_t ub = bu->unstuffed_bits;
    uint32_t cs = bu->count_stuff, cu = bu->count_unstuff;
    for (;;) {
        if (!cu) {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
        if (!cs) {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
        cs--;
        if ((edges >> (cs+1)) & 0xf) {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        } else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
    }
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t sb = bu->stuffed_bits, edges = sb ^ (sb >> 1);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: sb = bu->stuffed_bits
|—————Node:identifier Text: sb
|—————Node:= Text: =
|—————Node:field_expression Text: bu->stuffed_bits
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: stuffed_bits
|————Node:, Text: ,
|————Node:init_declarator Text: edges = sb ^ (sb >> 1)
|—————Node:identifier Text: edges
|—————Node:= Text: =
|—————Node:binary_expression Text: sb ^ (sb >> 1)
|——————Node:identifier Text: sb
|——————Node:^ Text: ^
|——————Node:parenthesized_expression Text: (sb >> 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: sb >> 1
|————————Node:identifier Text: sb
|————————Node:>> Text: >>
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ub = bu->unstuffed_bits;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: ub = bu->unstuffed_bits
|—————Node:identifier Text: ub
|—————Node:= Text: =
|—————Node:field_expression Text: bu->unstuffed_bits
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: unstuffed_bits
|————Node:; Text: ;
|———Node:declaration Text: uint32_t cs = bu->count_stuff, cu = bu->count_unstuff;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: cs = bu->count_stuff
|—————Node:identifier Text: cs
|—————Node:= Text: =
|—————Node:field_expression Text: bu->count_stuff
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: count_stuff
|————Node:, Text: ,
|————Node:init_declarator Text: cu = bu->count_unstuff
|—————Node:identifier Text: cu
|—————Node:= Text: =
|—————Node:field_expression Text: bu->count_unstuff
|——————Node:identifier Text: bu
|——————Node:-> Text: ->
|——————Node:field_identifier Text: count_unstuff
|————Node:; Text: ;
|———Node:for_statement Text: for (;;) {
        if (!cu) {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
        if (!cs) {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
        cs--;
        if ((edges >> (cs+1)) & 0xf) {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        } else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:; Text: ;
|————Node:; Text: ;
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (!cu) {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
        if (!cs) {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
        cs--;
        if ((edges >> (cs+1)) & 0xf) {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        } else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!cu) {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (!cu)
|———————Node:( Text: (
|———————Node:unary_expression Text: !cu
|————————Node:! Text: !
|————————Node:identifier Text: cu
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            // Extracted desired bits
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 0;
        }
|———————Node:{ Text: {
|———————Node:comment Text: // Extracted desired bits
|———————Node:expression_statement Text: bu->unstuffed_bits = ub;
|————————Node:assignment_expression Text: bu->unstuffed_bits = ub
|—————————Node:field_expression Text: bu->unstuffed_bits
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: unstuffed_bits
|—————————Node:= Text: =
|—————————Node:identifier Text: ub
|————————Node:; Text: ;
|———————Node:expression_statement Text: bu->count_stuff = cs;
|————————Node:assignment_expression Text: bu->count_stuff = cs
|—————————Node:field_expression Text: bu->count_stuff
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: count_stuff
|—————————Node:= Text: =
|—————————Node:identifier Text: cs
|————————Node:; Text: ;
|———————Node:expression_statement Text: bu->count_unstuff = cu;
|————————Node:assignment_expression Text: bu->count_unstuff = cu
|—————————Node:field_expression Text: bu->count_unstuff
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: count_unstuff
|—————————Node:= Text: =
|—————————Node:identifier Text: cu
|————————Node:; Text: ;
|———————Node:return_statement Text: return 0;
|————————Node:return Text: return
|————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (!cs) {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (!cs)
|———————Node:( Text: (
|———————Node:unary_expression Text: !cs
|————————Node:! Text: !
|————————Node:identifier Text: cs
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            // Need more data
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            return 1;
        }
|———————Node:{ Text: {
|———————Node:comment Text: // Need more data
|———————Node:expression_statement Text: bu->unstuffed_bits = ub;
|————————Node:assignment_expression Text: bu->unstuffed_bits = ub
|—————————Node:field_expression Text: bu->unstuffed_bits
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: unstuffed_bits
|—————————Node:= Text: =
|—————————Node:identifier Text: ub
|————————Node:; Text: ;
|———————Node:expression_statement Text: bu->count_stuff = cs;
|————————Node:assignment_expression Text: bu->count_stuff = cs
|—————————Node:field_expression Text: bu->count_stuff
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: count_stuff
|—————————Node:= Text: =
|—————————Node:identifier Text: cs
|————————Node:; Text: ;
|———————Node:expression_statement Text: bu->count_unstuff = cu;
|————————Node:assignment_expression Text: bu->count_unstuff = cu
|—————————Node:field_expression Text: bu->count_unstuff
|——————————Node:identifier Text: bu
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: count_unstuff
|—————————Node:= Text: =
|—————————Node:identifier Text: cu
|————————Node:; Text: ;
|———————Node:return_statement Text: return 1;
|————————Node:return Text: return
|————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: cs--;
|——————Node:update_expression Text: cs--
|———————Node:identifier Text: cs
|———————Node:-- Text: --
|——————Node:; Text: ;
|—————Node:if_statement Text: if ((edges >> (cs+1)) & 0xf) {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        } else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: ((edges >> (cs+1)) & 0xf)
|———————Node:( Text: (
|———————Node:binary_expression Text: (edges >> (cs+1)) & 0xf
|————————Node:parenthesized_expression Text: (edges >> (cs+1))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: edges >> (cs+1)
|——————————Node:identifier Text: edges
|——————————Node:>> Text: >>
|——————————Node:parenthesized_expression Text: (cs+1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: cs+1
|————————————Node:identifier Text: cs
|————————————Node:+ Text: +
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0xf
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            // Normal data
            cu--;
            ub |= ((sb >> cs) & 1) << cu;
        }
|———————Node:{ Text: {
|———————Node:comment Text: // Normal data
|———————Node:expression_statement Text: cu--;
|————————Node:update_expression Text: cu--
|—————————Node:identifier Text: cu
|—————————Node:-- Text: --
|————————Node:; Text: ;
|———————Node:expression_statement Text: ub |= ((sb >> cs) & 1) << cu;
|————————Node:assignment_expression Text: ub |= ((sb >> cs) & 1) << cu
|—————————Node:identifier Text: ub
|—————————Node:|= Text: |=
|—————————Node:binary_expression Text: ((sb >> cs) & 1) << cu
|——————————Node:parenthesized_expression Text: ((sb >> cs) & 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (sb >> cs) & 1
|————————————Node:parenthesized_expression Text: (sb >> cs)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: sb >> cs
|——————————————Node:identifier Text: sb
|——————————————Node:>> Text: >>
|——————————————Node:identifier Text: cs
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:identifier Text: cu
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
|———————Node:else Text: else
|———————Node:if_statement Text: if (((edges >> cs) & 0x1f) == 0x00) {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (((edges >> cs) & 0x1f) == 0x00)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ((edges >> cs) & 0x1f) == 0x00
|——————————Node:parenthesized_expression Text: ((edges >> cs) & 0x1f)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (edges >> cs) & 0x1f
|————————————Node:parenthesized_expression Text: (edges >> cs)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: edges >> cs
|——————————————Node:identifier Text: edges
|——————————————Node:>> Text: >>
|——————————————Node:identifier Text: cs
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x1f
|———————————Node:) Text: )
|——————————Node:== Text: ==
|——————————Node:number_literal Text: 0x00
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            // Six consecutive bits - a bitstuff error
            bu->unstuffed_bits = ub;
            bu->count_stuff = cs;
            bu->count_unstuff = cu;
            if ((sb >> cs) & 1)
                return -1;
            return -2;
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Six consecutive bits - a bitstuff error
|—————————Node:expression_statement Text: bu->unstuffed_bits = ub;
|——————————Node:assignment_expression Text: bu->unstuffed_bits = ub
|———————————Node:field_expression Text: bu->unstuffed_bits
|————————————Node:identifier Text: bu
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: unstuffed_bits
|———————————Node:= Text: =
|———————————Node:identifier Text: ub
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: bu->count_stuff = cs;
|——————————Node:assignment_expression Text: bu->count_stuff = cs
|———————————Node:field_expression Text: bu->count_stuff
|————————————Node:identifier Text: bu
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: count_stuff
|———————————Node:= Text: =
|———————————Node:identifier Text: cs
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: bu->count_unstuff = cu;
|——————————Node:assignment_expression Text: bu->count_unstuff = cu
|———————————Node:field_expression Text: bu->count_unstuff
|————————————Node:identifier Text: bu
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: count_unstuff
|———————————Node:= Text: =
|———————————Node:identifier Text: cu
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if ((sb >> cs) & 1)
                return -1;
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: ((sb >> cs) & 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (sb >> cs) & 1
|————————————Node:parenthesized_expression Text: (sb >> cs)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: sb >> cs
|——————————————Node:identifier Text: sb
|——————————————Node:>> Text: >>
|——————————————Node:identifier Text: cs
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|——————————Node:return_statement Text: return -1;
|———————————Node:return Text: return
|———————————Node:number_literal Text: -1
|———————————Node:; Text: ;
|—————————Node:return_statement Text: return -2;
|——————————Node:return Text: return
|——————————Node:number_literal Text: -2
|——————————Node:; Text: ;
|—————————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Bit stuffing
 ****************************************************************/
|—Node:comment Text: // Stuff 'num_bits' bits in '*pb' - upper bits must already be stuffed
|—Node:function_definition Text: static uint32_t
bitstuff(uint32_t *pb, uint32_t num_bits)
{
    uint32_t b = *pb, edges = b ^ (b >> 1), count = num_bits;
    int i;
    for (i=num_bits-1; i>=0; i--) {
        if (!((edges >> i) & 0xf)) {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
    }
    *pb = b;
    return count;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: bitstuff(uint32_t *pb, uint32_t num_bits)
|———Node:identifier Text: bitstuff
|———Node:parameter_list Text: (uint32_t *pb, uint32_t num_bits)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t *pb
|—————Node:primitive_type Text: uint32_t
|—————Node:pointer_declarator Text: *pb
|——————Node:* Text: *
|——————Node:identifier Text: pb
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t num_bits
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: num_bits
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t b = *pb, edges = b ^ (b >> 1), count = num_bits;
    int i;
    for (i=num_bits-1; i>=0; i--) {
        if (!((edges >> i) & 0xf)) {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
    }
    *pb = b;
    return count;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t b = *pb, edges = b ^ (b >> 1), count = num_bits;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: b = *pb
|—————Node:identifier Text: b
|—————Node:= Text: =
|—————Node:pointer_expression Text: *pb
|——————Node:* Text: *
|——————Node:identifier Text: pb
|————Node:, Text: ,
|————Node:init_declarator Text: edges = b ^ (b >> 1)
|—————Node:identifier Text: edges
|—————Node:= Text: =
|—————Node:binary_expression Text: b ^ (b >> 1)
|——————Node:identifier Text: b
|——————Node:^ Text: ^
|——————Node:parenthesized_expression Text: (b >> 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: b >> 1
|————————Node:identifier Text: b
|————————Node:>> Text: >>
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:init_declarator Text: count = num_bits
|—————Node:identifier Text: count
|—————Node:= Text: =
|—————Node:identifier Text: num_bits
|————Node:; Text: ;
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=num_bits-1; i>=0; i--) {
        if (!((edges >> i) & 0xf)) {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=num_bits-1
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:binary_expression Text: num_bits-1
|——————Node:identifier Text: num_bits
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|————Node:binary_expression Text: i>=0
|—————Node:identifier Text: i
|—————Node:>= Text: >=
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:update_expression Text: i--
|—————Node:identifier Text: i
|—————Node:-- Text: --
|————Node:) Text: )
|————Node:compound_statement Text: {
        if (!((edges >> i) & 0xf)) {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!((edges >> i) & 0xf)) {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (!((edges >> i) & 0xf))
|———————Node:( Text: (
|———————Node:unary_expression Text: !((edges >> i) & 0xf)
|————————Node:! Text: !
|————————Node:parenthesized_expression Text: ((edges >> i) & 0xf)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (edges >> i) & 0xf
|——————————Node:parenthesized_expression Text: (edges >> i)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: edges >> i
|————————————Node:identifier Text: edges
|————————————Node:>> Text: >>
|————————————Node:identifier Text: i
|———————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xf
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            uint32_t mask = (1 << (i + 1)) - 1;
            uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
            b = high ^ low ^ (1 << i);
            i -= 3;
            count++;
            edges = b ^ (b >> 1);
        }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t mask = (1 << (i + 1)) - 1;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: mask = (1 << (i + 1)) - 1
|—————————Node:identifier Text: mask
|—————————Node:= Text: =
|—————————Node:binary_expression Text: (1 << (i + 1)) - 1
|——————————Node:parenthesized_expression Text: (1 << (i + 1))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 1 << (i + 1)
|————————————Node:number_literal Text: 1
|————————————Node:<< Text: <<
|————————————Node:parenthesized_expression Text: (i + 1)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: i + 1
|——————————————Node:identifier Text: i
|——————————————Node:+ Text: +
|——————————————Node:number_literal Text: 1
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:- Text: -
|——————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:declaration Text: uint32_t low = b & mask, high = (b & ~(mask >> 1)) << 1;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: low = b & mask
|—————————Node:identifier Text: low
|—————————Node:= Text: =
|—————————Node:binary_expression Text: b & mask
|——————————Node:identifier Text: b
|——————————Node:& Text: &
|——————————Node:identifier Text: mask
|————————Node:, Text: ,
|————————Node:init_declarator Text: high = (b & ~(mask >> 1)) << 1
|—————————Node:identifier Text: high
|—————————Node:= Text: =
|—————————Node:binary_expression Text: (b & ~(mask >> 1)) << 1
|——————————Node:parenthesized_expression Text: (b & ~(mask >> 1))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: b & ~(mask >> 1)
|————————————Node:identifier Text: b
|————————————Node:& Text: &
|————————————Node:unary_expression Text: ~(mask >> 1)
|—————————————Node:~ Text: ~
|—————————————Node:parenthesized_expression Text: (mask >> 1)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: mask >> 1
|———————————————Node:identifier Text: mask
|———————————————Node:>> Text: >>
|———————————————Node:number_literal Text: 1
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:expression_statement Text: b = high ^ low ^ (1 << i);
|————————Node:assignment_expression Text: b = high ^ low ^ (1 << i)
|—————————Node:identifier Text: b
|—————————Node:= Text: =
|—————————Node:binary_expression Text: high ^ low ^ (1 << i)
|——————————Node:binary_expression Text: high ^ low
|———————————Node:identifier Text: high
|———————————Node:^ Text: ^
|———————————Node:identifier Text: low
|——————————Node:^ Text: ^
|——————————Node:parenthesized_expression Text: (1 << i)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 1 << i
|————————————Node:number_literal Text: 1
|————————————Node:<< Text: <<
|————————————Node:identifier Text: i
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: i -= 3;
|————————Node:assignment_expression Text: i -= 3
|—————————Node:identifier Text: i
|—————————Node:-= Text: -=
|—————————Node:number_literal Text: 3
|————————Node:; Text: ;
|———————Node:expression_statement Text: count++;
|————————Node:update_expression Text: count++
|—————————Node:identifier Text: count
|—————————Node:++ Text: ++
|————————Node:; Text: ;
|———————Node:expression_statement Text: edges = b ^ (b >> 1);
|————————Node:assignment_expression Text: edges = b ^ (b >> 1)
|—————————Node:identifier Text: edges
|—————————Node:= Text: =
|—————————Node:binary_expression Text: b ^ (b >> 1)
|——————————Node:identifier Text: b
|——————————Node:^ Text: ^
|——————————Node:parenthesized_expression Text: (b >> 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: b >> 1
|————————————Node:identifier Text: b
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: *pb = b;
|————Node:assignment_expression Text: *pb = b
|—————Node:pointer_expression Text: *pb
|——————Node:* Text: *
|——————Node:identifier Text: pb
|—————Node:= Text: =
|—————Node:identifier Text: b
|————Node:; Text: ;
|———Node:return_statement Text: return count;
|————Node:return Text: return
|————Node:identifier Text: count
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // State storage for building bit stuffed transmit messages
|—Node:struct_specifier Text: struct bitstuffer_s {
    uint32_t prev_stuffed, bitpos, *buf;
}
|——Node:struct Text: struct
|——Node:type_identifier Text: bitstuffer_s
|——Node:field_declaration_list Text: {
    uint32_t prev_stuffed, bitpos, *buf;
}
|———Node:{ Text: {
|———Node:field_declaration Text: uint32_t prev_stuffed, bitpos, *buf;
|————Node:primitive_type Text: uint32_t
|————Node:field_identifier Text: prev_stuffed
|————Node:, Text: ,
|————Node:field_identifier Text: bitpos
|————Node:, Text: ,
|————Node:pointer_declarator Text: *buf
|—————Node:* Text: *
|—————Node:field_identifier Text: buf
|————Node:; Text: ;
|———Node:} Text: }
|—Node:; Text: ;
|—Node:comment Text: // Push 'count' bits of 'data' into stuffer without performing bit stuffing
|—Node:function_definition Text: static void
bs_pushraw(struct bitstuffer_s *bs, uint32_t data, uint32_t count)
{
    uint32_t bitpos = bs->bitpos;
    uint32_t wp = bitpos / 32, bitused = bitpos % 32, bitavail = 32 - bitused;
    uint32_t *fb = &bs->buf[wp];
    if (bitavail >= count) {
        fb[0] |= data << (bitavail - count);
    } else {
        fb[0] |= data >> (count - bitavail);
        fb[1] |= data << (32 - (count - bitavail));
    }
    bs->bitpos = bitpos + count;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: bs_pushraw(struct bitstuffer_s *bs, uint32_t data, uint32_t count)
|———Node:identifier Text: bs_pushraw
|———Node:parameter_list Text: (struct bitstuffer_s *bs, uint32_t data, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct bitstuffer_s *bs
|—————Node:struct_specifier Text: struct bitstuffer_s
|——————Node:struct Text: struct
|——————Node:type_identifier Text: bitstuffer_s
|—————Node:pointer_declarator Text: *bs
|——————Node:* Text: *
|——————Node:identifier Text: bs
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t bitpos = bs->bitpos;
    uint32_t wp = bitpos / 32, bitused = bitpos % 32, bitavail = 32 - bitused;
    uint32_t *fb = &bs->buf[wp];
    if (bitavail >= count) {
        fb[0] |= data << (bitavail - count);
    } else {
        fb[0] |= data >> (count - bitavail);
        fb[1] |= data << (32 - (count - bitavail));
    }
    bs->bitpos = bitpos + count;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t bitpos = bs->bitpos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: bitpos = bs->bitpos
|—————Node:identifier Text: bitpos
|—————Node:= Text: =
|—————Node:field_expression Text: bs->bitpos
|——————Node:identifier Text: bs
|——————Node:-> Text: ->
|——————Node:field_identifier Text: bitpos
|————Node:; Text: ;
|———Node:declaration Text: uint32_t wp = bitpos / 32, bitused = bitpos % 32, bitavail = 32 - bitused;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: wp = bitpos / 32
|—————Node:identifier Text: wp
|—————Node:= Text: =
|—————Node:binary_expression Text: bitpos / 32
|——————Node:identifier Text: bitpos
|——————Node:/ Text: /
|——————Node:number_literal Text: 32
|————Node:, Text: ,
|————Node:init_declarator Text: bitused = bitpos % 32
|—————Node:identifier Text: bitused
|—————Node:= Text: =
|—————Node:binary_expression Text: bitpos % 32
|——————Node:identifier Text: bitpos
|——————Node:% Text: %
|——————Node:number_literal Text: 32
|————Node:, Text: ,
|————Node:init_declarator Text: bitavail = 32 - bitused
|—————Node:identifier Text: bitavail
|—————Node:= Text: =
|—————Node:binary_expression Text: 32 - bitused
|——————Node:number_literal Text: 32
|——————Node:- Text: -
|——————Node:identifier Text: bitused
|————Node:; Text: ;
|———Node:declaration Text: uint32_t *fb = &bs->buf[wp];
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: *fb = &bs->buf[wp]
|—————Node:pointer_declarator Text: *fb
|——————Node:* Text: *
|——————Node:identifier Text: fb
|—————Node:= Text: =
|—————Node:pointer_expression Text: &bs->buf[wp]
|——————Node:& Text: &
|——————Node:subscript_expression Text: bs->buf[wp]
|———————Node:field_expression Text: bs->buf
|————————Node:identifier Text: bs
|————————Node:-> Text: ->
|————————Node:field_identifier Text: buf
|———————Node:[ Text: [
|———————Node:identifier Text: wp
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:if_statement Text: if (bitavail >= count) {
        fb[0] |= data << (bitavail - count);
    } else {
        fb[0] |= data >> (count - bitavail);
        fb[1] |= data << (32 - (count - bitavail));
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (bitavail >= count)
|—————Node:( Text: (
|—————Node:binary_expression Text: bitavail >= count
|——————Node:identifier Text: bitavail
|——————Node:>= Text: >=
|——————Node:identifier Text: count
|—————Node:) Text: )
|————Node:compound_statement Text: {
        fb[0] |= data << (bitavail - count);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: fb[0] |= data << (bitavail - count);
|——————Node:assignment_expression Text: fb[0] |= data << (bitavail - count)
|———————Node:subscript_expression Text: fb[0]
|————————Node:identifier Text: fb
|————————Node:[ Text: [
|————————Node:number_literal Text: 0
|————————Node:] Text: ]
|———————Node:|= Text: |=
|———————Node:binary_expression Text: data << (bitavail - count)
|————————Node:identifier Text: data
|————————Node:<< Text: <<
|————————Node:parenthesized_expression Text: (bitavail - count)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: bitavail - count
|——————————Node:identifier Text: bitavail
|——————————Node:- Text: -
|——————————Node:identifier Text: count
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        fb[0] |= data >> (count - bitavail);
        fb[1] |= data << (32 - (count - bitavail));
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        fb[0] |= data >> (count - bitavail);
        fb[1] |= data << (32 - (count - bitavail));
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: fb[0] |= data >> (count - bitavail);
|———————Node:assignment_expression Text: fb[0] |= data >> (count - bitavail)
|————————Node:subscript_expression Text: fb[0]
|—————————Node:identifier Text: fb
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|————————Node:|= Text: |=
|————————Node:binary_expression Text: data >> (count - bitavail)
|—————————Node:identifier Text: data
|—————————Node:>> Text: >>
|—————————Node:parenthesized_expression Text: (count - bitavail)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: count - bitavail
|———————————Node:identifier Text: count
|———————————Node:- Text: -
|———————————Node:identifier Text: bitavail
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: fb[1] |= data << (32 - (count - bitavail));
|———————Node:assignment_expression Text: fb[1] |= data << (32 - (count - bitavail))
|————————Node:subscript_expression Text: fb[1]
|—————————Node:identifier Text: fb
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|————————Node:|= Text: |=
|————————Node:binary_expression Text: data << (32 - (count - bitavail))
|—————————Node:identifier Text: data
|—————————Node:<< Text: <<
|—————————Node:parenthesized_expression Text: (32 - (count - bitavail))
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 32 - (count - bitavail)
|———————————Node:number_literal Text: 32
|———————————Node:- Text: -
|———————————Node:parenthesized_expression Text: (count - bitavail)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: count - bitavail
|—————————————Node:identifier Text: count
|—————————————Node:- Text: -
|—————————————Node:identifier Text: bitavail
|————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: bs->bitpos = bitpos + count;
|————Node:assignment_expression Text: bs->bitpos = bitpos + count
|—————Node:field_expression Text: bs->bitpos
|——————Node:identifier Text: bs
|——————Node:-> Text: ->
|——————Node:field_identifier Text: bitpos
|—————Node:= Text: =
|—————Node:binary_expression Text: bitpos + count
|——————Node:identifier Text: bitpos
|——————Node:+ Text: +
|——————Node:identifier Text: count
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Push 'count' bits of 'data' into stuffer
|—Node:function_definition Text: static void
bs_push(struct bitstuffer_s *bs, uint32_t data, uint32_t count)
{
    data &= (1 << count) - 1;
    uint32_t stuf = (bs->prev_stuffed << count) | data;
    uint32_t newcount = bitstuff(&stuf, count);
    bs_pushraw(bs, stuf, newcount);
    bs->prev_stuffed = stuf;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: bs_push(struct bitstuffer_s *bs, uint32_t data, uint32_t count)
|———Node:identifier Text: bs_push
|———Node:parameter_list Text: (struct bitstuffer_s *bs, uint32_t data, uint32_t count)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct bitstuffer_s *bs
|—————Node:struct_specifier Text: struct bitstuffer_s
|——————Node:struct Text: struct
|——————Node:type_identifier Text: bitstuffer_s
|—————Node:pointer_declarator Text: *bs
|——————Node:* Text: *
|——————Node:identifier Text: bs
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t count
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: count
|————Node:) Text: )
|——Node:compound_statement Text: {
    data &= (1 << count) - 1;
    uint32_t stuf = (bs->prev_stuffed << count) | data;
    uint32_t newcount = bitstuff(&stuf, count);
    bs_pushraw(bs, stuf, newcount);
    bs->prev_stuffed = stuf;
}
|———Node:{ Text: {
|———Node:expression_statement Text: data &= (1 << count) - 1;
|————Node:assignment_expression Text: data &= (1 << count) - 1
|—————Node:identifier Text: data
|—————Node:&= Text: &=
|—————Node:binary_expression Text: (1 << count) - 1
|——————Node:parenthesized_expression Text: (1 << count)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1 << count
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:identifier Text: count
|———————Node:) Text: )
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: uint32_t stuf = (bs->prev_stuffed << count) | data;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: stuf = (bs->prev_stuffed << count) | data
|—————Node:identifier Text: stuf
|—————Node:= Text: =
|—————Node:binary_expression Text: (bs->prev_stuffed << count) | data
|——————Node:parenthesized_expression Text: (bs->prev_stuffed << count)
|———————Node:( Text: (
|———————Node:binary_expression Text: bs->prev_stuffed << count
|————————Node:field_expression Text: bs->prev_stuffed
|—————————Node:identifier Text: bs
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: prev_stuffed
|————————Node:<< Text: <<
|————————Node:identifier Text: count
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:identifier Text: data
|————Node:; Text: ;
|———Node:declaration Text: uint32_t newcount = bitstuff(&stuf, count);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: newcount = bitstuff(&stuf, count)
|—————Node:identifier Text: newcount
|—————Node:= Text: =
|—————Node:call_expression Text: bitstuff(&stuf, count)
|——————Node:identifier Text: bitstuff
|——————Node:argument_list Text: (&stuf, count)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &stuf
|————————Node:& Text: &
|————————Node:identifier Text: stuf
|———————Node:, Text: ,
|———————Node:identifier Text: count
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: bs_pushraw(bs, stuf, newcount);
|————Node:call_expression Text: bs_pushraw(bs, stuf, newcount)
|—————Node:identifier Text: bs_pushraw
|—————Node:argument_list Text: (bs, stuf, newcount)
|——————Node:( Text: (
|——————Node:identifier Text: bs
|——————Node:, Text: ,
|——————Node:identifier Text: stuf
|——————Node:, Text: ,
|——————Node:identifier Text: newcount
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: bs->prev_stuffed = stuf;
|————Node:assignment_expression Text: bs->prev_stuffed = stuf
|—————Node:field_expression Text: bs->prev_stuffed
|——————Node:identifier Text: bs
|——————Node:-> Text: ->
|——————Node:field_identifier Text: prev_stuffed
|—————Node:= Text: =
|—————Node:identifier Text: stuf
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Pad final word of stuffer with high bits
|—Node:function_definition Text: static uint32_t
bs_finalize(struct bitstuffer_s *bs)
{
    uint32_t bitpos = bs->bitpos;
    uint32_t words = DIV_ROUND_UP(bitpos, 32);
    uint32_t extra = words * 32 - bitpos;
    if (extra)
        bs->buf[words - 1] |= (1 << extra) - 1;
    return words;
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: bs_finalize(struct bitstuffer_s *bs)
|———Node:identifier Text: bs_finalize
|———Node:parameter_list Text: (struct bitstuffer_s *bs)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct bitstuffer_s *bs
|—————Node:struct_specifier Text: struct bitstuffer_s
|——————Node:struct Text: struct
|——————Node:type_identifier Text: bitstuffer_s
|—————Node:pointer_declarator Text: *bs
|——————Node:* Text: *
|——————Node:identifier Text: bs
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t bitpos = bs->bitpos;
    uint32_t words = DIV_ROUND_UP(bitpos, 32);
    uint32_t extra = words * 32 - bitpos;
    if (extra)
        bs->buf[words - 1] |= (1 << extra) - 1;
    return words;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t bitpos = bs->bitpos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: bitpos = bs->bitpos
|—————Node:identifier Text: bitpos
|—————Node:= Text: =
|—————Node:field_expression Text: bs->bitpos
|——————Node:identifier Text: bs
|——————Node:-> Text: ->
|——————Node:field_identifier Text: bitpos
|————Node:; Text: ;
|———Node:declaration Text: uint32_t words = DIV_ROUND_UP(bitpos, 32);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: words = DIV_ROUND_UP(bitpos, 32)
|—————Node:identifier Text: words
|—————Node:= Text: =
|—————Node:call_expression Text: DIV_ROUND_UP(bitpos, 32)
|——————Node:identifier Text: DIV_ROUND_UP
|——————Node:argument_list Text: (bitpos, 32)
|———————Node:( Text: (
|———————Node:identifier Text: bitpos
|———————Node:, Text: ,
|———————Node:number_literal Text: 32
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t extra = words * 32 - bitpos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: extra = words * 32 - bitpos
|—————Node:identifier Text: extra
|—————Node:= Text: =
|—————Node:binary_expression Text: words * 32 - bitpos
|——————Node:binary_expression Text: words * 32
|———————Node:identifier Text: words
|———————Node:* Text: *
|———————Node:number_literal Text: 32
|——————Node:- Text: -
|——————Node:identifier Text: bitpos
|————Node:; Text: ;
|———Node:if_statement Text: if (extra)
        bs->buf[words - 1] |= (1 << extra) - 1;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (extra)
|—————Node:( Text: (
|—————Node:identifier Text: extra
|—————Node:) Text: )
|————Node:expression_statement Text: bs->buf[words - 1] |= (1 << extra) - 1;
|—————Node:assignment_expression Text: bs->buf[words - 1] |= (1 << extra) - 1
|——————Node:subscript_expression Text: bs->buf[words - 1]
|———————Node:field_expression Text: bs->buf
|————————Node:identifier Text: bs
|————————Node:-> Text: ->
|————————Node:field_identifier Text: buf
|———————Node:[ Text: [
|———————Node:binary_expression Text: words - 1
|————————Node:identifier Text: words
|————————Node:- Text: -
|————————Node:number_literal Text: 1
|———————Node:] Text: ]
|——————Node:|= Text: |=
|——————Node:binary_expression Text: (1 << extra) - 1
|———————Node:parenthesized_expression Text: (1 << extra)
|————————Node:( Text: (
|————————Node:binary_expression Text: 1 << extra
|—————————Node:number_literal Text: 1
|—————————Node:<< Text: <<
|—————————Node:identifier Text: extra
|————————Node:) Text: )
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:return_statement Text: return words;
|————Node:return Text: return
|————Node:identifier Text: words
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Notification callbacks
 ****************************************************************/
|—Node:comment Text: // Report error to calling code (via callback interface)
|—Node:function_definition Text: static void
report_error(struct can2040 *cd, uint32_t error_code)
{
    struct can2040_msg msg = {};
    cd->rx_cb(cd, CAN2040_NOTIFY_ERROR | error_code, &msg);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: report_error(struct can2040 *cd, uint32_t error_code)
|———Node:identifier Text: report_error
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t error_code)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t error_code
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: error_code
|————Node:) Text: )
|——Node:compound_statement Text: {
    struct can2040_msg msg = {};
    cd->rx_cb(cd, CAN2040_NOTIFY_ERROR | error_code, &msg);
}
|———Node:{ Text: {
|———Node:declaration Text: struct can2040_msg msg = {};
|————Node:struct_specifier Text: struct can2040_msg
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can2040_msg
|————Node:init_declarator Text: msg = {}
|—————Node:identifier Text: msg
|—————Node:= Text: =
|—————Node:initializer_list Text: {}
|——————Node:{ Text: {
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:expression_statement Text: cd->rx_cb(cd, CAN2040_NOTIFY_ERROR | error_code, &msg);
|————Node:call_expression Text: cd->rx_cb(cd, CAN2040_NOTIFY_ERROR | error_code, &msg)
|—————Node:field_expression Text: cd->rx_cb
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_cb
|—————Node:argument_list Text: (cd, CAN2040_NOTIFY_ERROR | error_code, &msg)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:binary_expression Text: CAN2040_NOTIFY_ERROR | error_code
|———————Node:identifier Text: CAN2040_NOTIFY_ERROR
|———————Node:| Text: |
|———————Node:identifier Text: error_code
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &msg
|———————Node:& Text: &
|———————Node:identifier Text: msg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Report a received message to calling code (via callback interface)
|—Node:function_definition Text: static void
report_rx_msg(struct can2040 *cd)
{
    cd->rx_cb(cd, CAN2040_NOTIFY_RX, &cd->parse_msg);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: report_rx_msg(struct can2040 *cd)
|———Node:identifier Text: report_rx_msg
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->rx_cb(cd, CAN2040_NOTIFY_RX, &cd->parse_msg);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->rx_cb(cd, CAN2040_NOTIFY_RX, &cd->parse_msg);
|————Node:call_expression Text: cd->rx_cb(cd, CAN2040_NOTIFY_RX, &cd->parse_msg)
|—————Node:field_expression Text: cd->rx_cb
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_cb
|—————Node:argument_list Text: (cd, CAN2040_NOTIFY_RX, &cd->parse_msg)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: CAN2040_NOTIFY_RX
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &cd->parse_msg
|———————Node:& Text: &
|———————Node:field_expression Text: cd->parse_msg
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_msg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Report a message that was successfully transmited (via callback interface)
|—Node:function_definition Text: static void
report_tx_msg(struct can2040 *cd, struct can2040_msg *msg)
{
    cd->rx_cb(cd, CAN2040_NOTIFY_TX, msg);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: report_tx_msg(struct can2040 *cd, struct can2040_msg *msg)
|———Node:identifier Text: report_tx_msg
|———Node:parameter_list Text: (struct can2040 *cd, struct can2040_msg *msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can2040_msg *msg
|—————Node:struct_specifier Text: struct can2040_msg
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_msg
|—————Node:pointer_declarator Text: *msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->rx_cb(cd, CAN2040_NOTIFY_TX, msg);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->rx_cb(cd, CAN2040_NOTIFY_TX, msg);
|————Node:call_expression Text: cd->rx_cb(cd, CAN2040_NOTIFY_TX, msg)
|—————Node:field_expression Text: cd->rx_cb
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_cb
|—————Node:argument_list Text: (cd, CAN2040_NOTIFY_TX, msg)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: CAN2040_NOTIFY_TX
|——————Node:, Text: ,
|——————Node:identifier Text: msg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Transmit state tracking
 ****************************************************************/
|—Node:comment Text: // Transmit states (stored in cd->tx_state)
|—Node:enum_specifier Text: enum {
    TS_IDLE, TS_QUEUED, TS_CONFIRM_ACK, TS_ACKING_RX
}
|——Node:enum Text: enum
|——Node:enumerator_list Text: {
    TS_IDLE, TS_QUEUED, TS_CONFIRM_ACK, TS_ACKING_RX
}
|———Node:{ Text: {
|———Node:enumerator Text: TS_IDLE
|————Node:identifier Text: TS_IDLE
|———Node:, Text: ,
|———Node:enumerator Text: TS_QUEUED
|————Node:identifier Text: TS_QUEUED
|———Node:, Text: ,
|———Node:enumerator Text: TS_CONFIRM_ACK
|————Node:identifier Text: TS_CONFIRM_ACK
|———Node:, Text: ,
|———Node:enumerator Text: TS_ACKING_RX
|————Node:identifier Text: TS_ACKING_RX
|———Node:} Text: }
|—Node:; Text: ;
|—Node:comment Text: // Calculate queue array position from a transmit index
|—Node:function_definition Text: static uint32_t
tx_qpos(struct can2040 *cd, uint32_t pos)
{
    return pos % ARRAY_SIZE(cd->tx_queue);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: tx_qpos(struct can2040 *cd, uint32_t pos)
|———Node:identifier Text: tx_qpos
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t pos)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t pos
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: pos
|————Node:) Text: )
|——Node:compound_statement Text: {
    return pos % ARRAY_SIZE(cd->tx_queue);
}
|———Node:{ Text: {
|———Node:return_statement Text: return pos % ARRAY_SIZE(cd->tx_queue);
|————Node:return Text: return
|————Node:binary_expression Text: pos % ARRAY_SIZE(cd->tx_queue)
|—————Node:identifier Text: pos
|—————Node:% Text: %
|—————Node:call_expression Text: ARRAY_SIZE(cd->tx_queue)
|——————Node:identifier Text: ARRAY_SIZE
|——————Node:argument_list Text: (cd->tx_queue)
|———————Node:( Text: (
|———————Node:field_expression Text: cd->tx_queue
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_queue
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Queue the next message for transmission in the PIO
|—Node:function_definition Text: static void
tx_schedule_transmit(struct can2040 *cd)
{
    pio_sync_disable_irqs(cd);
    if (cd->tx_state >= TS_CONFIRM_ACK) {
        pio_ack_cancel(cd);
    } else if (cd->tx_state == TS_QUEUED) {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
    if (cd->tx_push_pos == cd->tx_pull_pos) {
        // No new messages to transmit
        cd->tx_state = TS_IDLE;
        return;
    }
    cd->tx_state = TS_QUEUED;
    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
    pio_tx_send(cd, qt->stuffed_data, qt->stuffed_words);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_schedule_transmit(struct can2040 *cd)
|———Node:identifier Text: tx_schedule_transmit
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_sync_disable_irqs(cd);
    if (cd->tx_state >= TS_CONFIRM_ACK) {
        pio_ack_cancel(cd);
    } else if (cd->tx_state == TS_QUEUED) {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
    if (cd->tx_push_pos == cd->tx_pull_pos) {
        // No new messages to transmit
        cd->tx_state = TS_IDLE;
        return;
    }
    cd->tx_state = TS_QUEUED;
    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
    pio_tx_send(cd, qt->stuffed_data, qt->stuffed_words);
}
|———Node:{ Text: {
|———Node:expression_statement Text: pio_sync_disable_irqs(cd);
|————Node:call_expression Text: pio_sync_disable_irqs(cd)
|—————Node:identifier Text: pio_sync_disable_irqs
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (cd->tx_state >= TS_CONFIRM_ACK) {
        pio_ack_cancel(cd);
    } else if (cd->tx_state == TS_QUEUED) {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->tx_state >= TS_CONFIRM_ACK)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->tx_state >= TS_CONFIRM_ACK
|——————Node:field_expression Text: cd->tx_state
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: tx_state
|——————Node:>= Text: >=
|——————Node:identifier Text: TS_CONFIRM_ACK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        pio_ack_cancel(cd);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: pio_ack_cancel(cd);
|——————Node:call_expression Text: pio_ack_cancel(cd)
|———————Node:identifier Text: pio_ack_cancel
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else if (cd->tx_state == TS_QUEUED) {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
|—————Node:else Text: else
|—————Node:if_statement Text: if (cd->tx_state == TS_QUEUED) {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (cd->tx_state == TS_QUEUED)
|———————Node:( Text: (
|———————Node:binary_expression Text: cd->tx_state == TS_QUEUED
|————————Node:field_expression Text: cd->tx_state
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: tx_state
|————————Node:== Text: ==
|————————Node:identifier Text: TS_QUEUED
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (!pio_tx_did_conflict(cd))
            // Already queued or actively transmitting
            return;
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (!pio_tx_did_conflict(cd))
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !pio_tx_did_conflict(cd)
|——————————Node:! Text: !
|——————————Node:call_expression Text: pio_tx_did_conflict(cd)
|———————————Node:identifier Text: pio_tx_did_conflict
|———————————Node:argument_list Text: (cd)
|————————————Node:( Text: (
|————————————Node:identifier Text: cd
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:comment Text: // Already queued or actively transmitting
|————————Node:return_statement Text: return;
|—————————Node:return Text: return
|—————————Node:; Text: ;
|———————Node:} Text: }
|———Node:if_statement Text: if (cd->tx_push_pos == cd->tx_pull_pos) {
        // No new messages to transmit
        cd->tx_state = TS_IDLE;
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->tx_push_pos == cd->tx_pull_pos)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->tx_push_pos == cd->tx_pull_pos
|——————Node:field_expression Text: cd->tx_push_pos
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: tx_push_pos
|——————Node:== Text: ==
|——————Node:field_expression Text: cd->tx_pull_pos
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: tx_pull_pos
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // No new messages to transmit
        cd->tx_state = TS_IDLE;
        return;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // No new messages to transmit
|—————Node:expression_statement Text: cd->tx_state = TS_IDLE;
|——————Node:assignment_expression Text: cd->tx_state = TS_IDLE
|———————Node:field_expression Text: cd->tx_state
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_state
|———————Node:= Text: =
|———————Node:identifier Text: TS_IDLE
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: cd->tx_state = TS_QUEUED;
|————Node:assignment_expression Text: cd->tx_state = TS_QUEUED
|—————Node:field_expression Text: cd->tx_state
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: tx_state
|—————Node:= Text: =
|—————Node:identifier Text: TS_QUEUED
|————Node:; Text: ;
|———Node:declaration Text: struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
|————Node:struct_specifier Text: struct can2040_transmit
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can2040_transmit
|————Node:init_declarator Text: *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|—————Node:pointer_declarator Text: *qt
|——————Node:* Text: *
|——————Node:identifier Text: qt
|—————Node:= Text: =
|—————Node:pointer_expression Text: &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|——————Node:& Text: &
|——————Node:subscript_expression Text: cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|———————Node:field_expression Text: cd->tx_queue
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_queue
|———————Node:[ Text: [
|———————Node:call_expression Text: tx_qpos(cd, cd->tx_pull_pos)
|————————Node:identifier Text: tx_qpos
|————————Node:argument_list Text: (cd, cd->tx_pull_pos)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:field_expression Text: cd->tx_pull_pos
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: tx_pull_pos
|—————————Node:) Text: )
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:expression_statement Text: pio_tx_send(cd, qt->stuffed_data, qt->stuffed_words);
|————Node:call_expression Text: pio_tx_send(cd, qt->stuffed_data, qt->stuffed_words)
|—————Node:identifier Text: pio_tx_send
|—————Node:argument_list Text: (cd, qt->stuffed_data, qt->stuffed_words)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:field_expression Text: qt->stuffed_data
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stuffed_data
|——————Node:, Text: ,
|——————Node:field_expression Text: qt->stuffed_words
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stuffed_words
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Setup for ack injection (if receiving) or ack confirmation (if transmit)
|—Node:function_definition Text: static void
tx_note_crc_start(struct can2040 *cd, uint32_t parse_crc)
{
    uint32_t cs = cd->unstuf.count_stuff;
    uint32_t crcstart_bitpos = cd->raw_bit_count - cs - 1;
    uint32_t last = ((cd->unstuf.stuffed_bits >> cs) << 15) | parse_crc;
    int crc_bitcount = bitstuff(&last, 15 + 1) - 1;

    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
    struct can2040_msg *pm = &cd->parse_msg;
    if (cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
        && qt->msg.data32[1] == pm->data32[1]) {
        // This is a self transmit - setup confirmation signal
        cd->tx_state = TS_CONFIRM_ACK;
        last = (last << 3) | 0x05;
        pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3);
        return;
    }

    // Inject ack
    cd->tx_state = TS_ACKING_RX;
    last = (last << 1) | 0x01;
    pio_ack_inject(cd, last, crcstart_bitpos + crc_bitcount + 1);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_note_crc_start(struct can2040 *cd, uint32_t parse_crc)
|———Node:identifier Text: tx_note_crc_start
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t parse_crc)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t parse_crc
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: parse_crc
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t cs = cd->unstuf.count_stuff;
    uint32_t crcstart_bitpos = cd->raw_bit_count - cs - 1;
    uint32_t last = ((cd->unstuf.stuffed_bits >> cs) << 15) | parse_crc;
    int crc_bitcount = bitstuff(&last, 15 + 1) - 1;

    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
    struct can2040_msg *pm = &cd->parse_msg;
    if (cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
        && qt->msg.data32[1] == pm->data32[1]) {
        // This is a self transmit - setup confirmation signal
        cd->tx_state = TS_CONFIRM_ACK;
        last = (last << 3) | 0x05;
        pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3);
        return;
    }

    // Inject ack
    cd->tx_state = TS_ACKING_RX;
    last = (last << 1) | 0x01;
    pio_ack_inject(cd, last, crcstart_bitpos + crc_bitcount + 1);
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t cs = cd->unstuf.count_stuff;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: cs = cd->unstuf.count_stuff
|—————Node:identifier Text: cs
|—————Node:= Text: =
|—————Node:field_expression Text: cd->unstuf.count_stuff
|——————Node:field_expression Text: cd->unstuf
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: unstuf
|——————Node:. Text: .
|——————Node:field_identifier Text: count_stuff
|————Node:; Text: ;
|———Node:declaration Text: uint32_t crcstart_bitpos = cd->raw_bit_count - cs - 1;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: crcstart_bitpos = cd->raw_bit_count - cs - 1
|—————Node:identifier Text: crcstart_bitpos
|—————Node:= Text: =
|—————Node:binary_expression Text: cd->raw_bit_count - cs - 1
|——————Node:binary_expression Text: cd->raw_bit_count - cs
|———————Node:field_expression Text: cd->raw_bit_count
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: raw_bit_count
|———————Node:- Text: -
|———————Node:identifier Text: cs
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: uint32_t last = ((cd->unstuf.stuffed_bits >> cs) << 15) | parse_crc;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: last = ((cd->unstuf.stuffed_bits >> cs) << 15) | parse_crc
|—————Node:identifier Text: last
|—————Node:= Text: =
|—————Node:binary_expression Text: ((cd->unstuf.stuffed_bits >> cs) << 15) | parse_crc
|——————Node:parenthesized_expression Text: ((cd->unstuf.stuffed_bits >> cs) << 15)
|———————Node:( Text: (
|———————Node:binary_expression Text: (cd->unstuf.stuffed_bits >> cs) << 15
|————————Node:parenthesized_expression Text: (cd->unstuf.stuffed_bits >> cs)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: cd->unstuf.stuffed_bits >> cs
|——————————Node:field_expression Text: cd->unstuf.stuffed_bits
|———————————Node:field_expression Text: cd->unstuf
|————————————Node:identifier Text: cd
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: unstuf
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stuffed_bits
|——————————Node:>> Text: >>
|——————————Node:identifier Text: cs
|—————————Node:) Text: )
|————————Node:<< Text: <<
|————————Node:number_literal Text: 15
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:identifier Text: parse_crc
|————Node:; Text: ;
|———Node:declaration Text: int crc_bitcount = bitstuff(&last, 15 + 1) - 1;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: crc_bitcount = bitstuff(&last, 15 + 1) - 1
|—————Node:identifier Text: crc_bitcount
|—————Node:= Text: =
|—————Node:binary_expression Text: bitstuff(&last, 15 + 1) - 1
|——————Node:call_expression Text: bitstuff(&last, 15 + 1)
|———————Node:identifier Text: bitstuff
|———————Node:argument_list Text: (&last, 15 + 1)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &last
|—————————Node:& Text: &
|—————————Node:identifier Text: last
|————————Node:, Text: ,
|————————Node:binary_expression Text: 15 + 1
|—————————Node:number_literal Text: 15
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|——————Node:- Text: -
|——————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:declaration Text: struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)];
|————Node:struct_specifier Text: struct can2040_transmit
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can2040_transmit
|————Node:init_declarator Text: *qt = &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|—————Node:pointer_declarator Text: *qt
|——————Node:* Text: *
|——————Node:identifier Text: qt
|—————Node:= Text: =
|—————Node:pointer_expression Text: &cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|——————Node:& Text: &
|——————Node:subscript_expression Text: cd->tx_queue[tx_qpos(cd, cd->tx_pull_pos)]
|———————Node:field_expression Text: cd->tx_queue
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_queue
|———————Node:[ Text: [
|———————Node:call_expression Text: tx_qpos(cd, cd->tx_pull_pos)
|————————Node:identifier Text: tx_qpos
|————————Node:argument_list Text: (cd, cd->tx_pull_pos)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:field_expression Text: cd->tx_pull_pos
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: tx_pull_pos
|—————————Node:) Text: )
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: struct can2040_msg *pm = &cd->parse_msg;
|————Node:struct_specifier Text: struct can2040_msg
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can2040_msg
|————Node:init_declarator Text: *pm = &cd->parse_msg
|—————Node:pointer_declarator Text: *pm
|——————Node:* Text: *
|——————Node:identifier Text: pm
|—————Node:= Text: =
|—————Node:pointer_expression Text: &cd->parse_msg
|——————Node:& Text: &
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|————Node:; Text: ;
|———Node:if_statement Text: if (cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
        && qt->msg.data32[1] == pm->data32[1]) {
        // This is a self transmit - setup confirmation signal
        cd->tx_state = TS_CONFIRM_ACK;
        last = (last << 3) | 0x05;
        pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
        && qt->msg.data32[1] == pm->data32[1])
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
        && qt->msg.data32[1] == pm->data32[1]
|——————Node:binary_expression Text: cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
        && qt->msg.data32[0] == pm->data32[0]
|———————Node:binary_expression Text: cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id && qt->msg.dlc == pm->dlc
|————————Node:binary_expression Text: cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
        && qt->msg.id == pm->id
|—————————Node:binary_expression Text: cd->tx_state == TS_QUEUED && qt->crc == cd->parse_crc
|——————————Node:binary_expression Text: cd->tx_state == TS_QUEUED
|———————————Node:field_expression Text: cd->tx_state
|————————————Node:identifier Text: cd
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: tx_state
|———————————Node:== Text: ==
|———————————Node:identifier Text: TS_QUEUED
|——————————Node:&& Text: &&
|——————————Node:binary_expression Text: qt->crc == cd->parse_crc
|———————————Node:field_expression Text: qt->crc
|————————————Node:identifier Text: qt
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: crc
|———————————Node:== Text: ==
|———————————Node:field_expression Text: cd->parse_crc
|————————————Node:identifier Text: cd
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: parse_crc
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: qt->msg.id == pm->id
|——————————Node:field_expression Text: qt->msg.id
|———————————Node:field_expression Text: qt->msg
|————————————Node:identifier Text: qt
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: msg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: id
|——————————Node:== Text: ==
|——————————Node:field_expression Text: pm->id
|———————————Node:identifier Text: pm
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: id
|————————Node:&& Text: &&
|————————Node:binary_expression Text: qt->msg.dlc == pm->dlc
|—————————Node:field_expression Text: qt->msg.dlc
|——————————Node:field_expression Text: qt->msg
|———————————Node:identifier Text: qt
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: dlc
|—————————Node:== Text: ==
|—————————Node:field_expression Text: pm->dlc
|——————————Node:identifier Text: pm
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: dlc
|———————Node:&& Text: &&
|———————Node:binary_expression Text: qt->msg.data32[0] == pm->data32[0]
|————————Node:subscript_expression Text: qt->msg.data32[0]
|—————————Node:field_expression Text: qt->msg.data32
|——————————Node:field_expression Text: qt->msg
|———————————Node:identifier Text: qt
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: data32
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|————————Node:== Text: ==
|————————Node:subscript_expression Text: pm->data32[0]
|—————————Node:field_expression Text: pm->data32
|——————————Node:identifier Text: pm
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: data32
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|——————Node:&& Text: &&
|——————Node:binary_expression Text: qt->msg.data32[1] == pm->data32[1]
|———————Node:subscript_expression Text: qt->msg.data32[1]
|————————Node:field_expression Text: qt->msg.data32
|—————————Node:field_expression Text: qt->msg
|——————————Node:identifier Text: qt
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: data32
|————————Node:[ Text: [
|————————Node:number_literal Text: 1
|————————Node:] Text: ]
|———————Node:== Text: ==
|———————Node:subscript_expression Text: pm->data32[1]
|————————Node:field_expression Text: pm->data32
|—————————Node:identifier Text: pm
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: data32
|————————Node:[ Text: [
|————————Node:number_literal Text: 1
|————————Node:] Text: ]
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // This is a self transmit - setup confirmation signal
        cd->tx_state = TS_CONFIRM_ACK;
        last = (last << 3) | 0x05;
        pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3);
        return;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // This is a self transmit - setup confirmation signal
|—————Node:expression_statement Text: cd->tx_state = TS_CONFIRM_ACK;
|——————Node:assignment_expression Text: cd->tx_state = TS_CONFIRM_ACK
|———————Node:field_expression Text: cd->tx_state
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_state
|———————Node:= Text: =
|———————Node:identifier Text: TS_CONFIRM_ACK
|——————Node:; Text: ;
|—————Node:expression_statement Text: last = (last << 3) | 0x05;
|——————Node:assignment_expression Text: last = (last << 3) | 0x05
|———————Node:identifier Text: last
|———————Node:= Text: =
|———————Node:binary_expression Text: (last << 3) | 0x05
|————————Node:parenthesized_expression Text: (last << 3)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: last << 3
|——————————Node:identifier Text: last
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 3
|—————————Node:) Text: )
|————————Node:| Text: |
|————————Node:number_literal Text: 0x05
|——————Node:; Text: ;
|—————Node:expression_statement Text: pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3);
|——————Node:call_expression Text: pio_ack_check(cd, last, crcstart_bitpos + crc_bitcount + 3)
|———————Node:identifier Text: pio_ack_check
|———————Node:argument_list Text: (cd, last, crcstart_bitpos + crc_bitcount + 3)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:identifier Text: last
|————————Node:, Text: ,
|————————Node:binary_expression Text: crcstart_bitpos + crc_bitcount + 3
|—————————Node:binary_expression Text: crcstart_bitpos + crc_bitcount
|——————————Node:identifier Text: crcstart_bitpos
|——————————Node:+ Text: +
|——————————Node:identifier Text: crc_bitcount
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 3
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: // Inject ack
|———Node:expression_statement Text: cd->tx_state = TS_ACKING_RX;
|————Node:assignment_expression Text: cd->tx_state = TS_ACKING_RX
|—————Node:field_expression Text: cd->tx_state
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: tx_state
|—————Node:= Text: =
|—————Node:identifier Text: TS_ACKING_RX
|————Node:; Text: ;
|———Node:expression_statement Text: last = (last << 1) | 0x01;
|————Node:assignment_expression Text: last = (last << 1) | 0x01
|—————Node:identifier Text: last
|—————Node:= Text: =
|—————Node:binary_expression Text: (last << 1) | 0x01
|——————Node:parenthesized_expression Text: (last << 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: last << 1
|————————Node:identifier Text: last
|————————Node:<< Text: <<
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:number_literal Text: 0x01
|————Node:; Text: ;
|———Node:expression_statement Text: pio_ack_inject(cd, last, crcstart_bitpos + crc_bitcount + 1);
|————Node:call_expression Text: pio_ack_inject(cd, last, crcstart_bitpos + crc_bitcount + 1)
|—————Node:identifier Text: pio_ack_inject
|—————Node:argument_list Text: (cd, last, crcstart_bitpos + crc_bitcount + 1)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: last
|——————Node:, Text: ,
|——————Node:binary_expression Text: crcstart_bitpos + crc_bitcount + 1
|———————Node:binary_expression Text: crcstart_bitpos + crc_bitcount
|————————Node:identifier Text: crcstart_bitpos
|————————Node:+ Text: +
|————————Node:identifier Text: crc_bitcount
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Ack phase succeeded - report message (rx or tx) to calling code
|—Node:function_definition Text: static void
tx_note_ack_success(struct can2040 *cd)
{
    if (cd->tx_state < TS_CONFIRM_ACK)
        return;

    if (cd->tx_state == TS_CONFIRM_ACK) {
        uint32_t tx_pull_pos = cd->tx_pull_pos;
        cd->tx_pull_pos++;
        report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg);
    } else {
        report_rx_msg(cd);
    }

    pio_sync_normal_start_signal(cd);
    tx_schedule_transmit(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_note_ack_success(struct can2040 *cd)
|———Node:identifier Text: tx_note_ack_success
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (cd->tx_state < TS_CONFIRM_ACK)
        return;

    if (cd->tx_state == TS_CONFIRM_ACK) {
        uint32_t tx_pull_pos = cd->tx_pull_pos;
        cd->tx_pull_pos++;
        report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg);
    } else {
        report_rx_msg(cd);
    }

    pio_sync_normal_start_signal(cd);
    tx_schedule_transmit(cd);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (cd->tx_state < TS_CONFIRM_ACK)
        return;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->tx_state < TS_CONFIRM_ACK)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->tx_state < TS_CONFIRM_ACK
|——————Node:field_expression Text: cd->tx_state
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: tx_state
|——————Node:< Text: <
|——————Node:identifier Text: TS_CONFIRM_ACK
|—————Node:) Text: )
|————Node:return_statement Text: return;
|—————Node:return Text: return
|—————Node:; Text: ;
|———Node:if_statement Text: if (cd->tx_state == TS_CONFIRM_ACK) {
        uint32_t tx_pull_pos = cd->tx_pull_pos;
        cd->tx_pull_pos++;
        report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg);
    } else {
        report_rx_msg(cd);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->tx_state == TS_CONFIRM_ACK)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->tx_state == TS_CONFIRM_ACK
|——————Node:field_expression Text: cd->tx_state
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: tx_state
|——————Node:== Text: ==
|——————Node:identifier Text: TS_CONFIRM_ACK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        uint32_t tx_pull_pos = cd->tx_pull_pos;
        cd->tx_pull_pos++;
        report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg);
    }
|—————Node:{ Text: {
|—————Node:declaration Text: uint32_t tx_pull_pos = cd->tx_pull_pos;
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: tx_pull_pos = cd->tx_pull_pos
|———————Node:identifier Text: tx_pull_pos
|———————Node:= Text: =
|———————Node:field_expression Text: cd->tx_pull_pos
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_pull_pos
|——————Node:; Text: ;
|—————Node:expression_statement Text: cd->tx_pull_pos++;
|——————Node:update_expression Text: cd->tx_pull_pos++
|———————Node:field_expression Text: cd->tx_pull_pos
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_pull_pos
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:expression_statement Text: report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg);
|——————Node:call_expression Text: report_tx_msg(cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg)
|———————Node:identifier Text: report_tx_msg
|———————Node:argument_list Text: (cd, &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg
|—————————Node:& Text: &
|—————————Node:field_expression Text: cd->tx_queue[tx_qpos(cd, tx_pull_pos)].msg
|——————————Node:subscript_expression Text: cd->tx_queue[tx_qpos(cd, tx_pull_pos)]
|———————————Node:field_expression Text: cd->tx_queue
|————————————Node:identifier Text: cd
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: tx_queue
|———————————Node:[ Text: [
|———————————Node:call_expression Text: tx_qpos(cd, tx_pull_pos)
|————————————Node:identifier Text: tx_qpos
|————————————Node:argument_list Text: (cd, tx_pull_pos)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: cd
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: tx_pull_pos
|—————————————Node:) Text: )
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        report_rx_msg(cd);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        report_rx_msg(cd);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: report_rx_msg(cd);
|———————Node:call_expression Text: report_rx_msg(cd)
|————————Node:identifier Text: report_rx_msg
|————————Node:argument_list Text: (cd)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: pio_sync_normal_start_signal(cd);
|————Node:call_expression Text: pio_sync_normal_start_signal(cd)
|—————Node:identifier Text: pio_sync_normal_start_signal
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: tx_schedule_transmit(cd);
|————Node:call_expression Text: tx_schedule_transmit(cd)
|—————Node:identifier Text: tx_schedule_transmit
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Parser found a new message start
|—Node:function_definition Text: static void
tx_note_message_start(struct can2040 *cd)
{
    pio_sync_set_may_start_tx_irq(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_note_message_start(struct can2040 *cd)
|———Node:identifier Text: tx_note_message_start
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_sync_set_may_start_tx_irq(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: pio_sync_set_may_start_tx_irq(cd);
|————Node:call_expression Text: pio_sync_set_may_start_tx_irq(cd)
|—————Node:identifier Text: pio_sync_set_may_start_tx_irq
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Parser found unexpected data on input
|—Node:function_definition Text: static void
tx_note_parse_error(struct can2040 *cd)
{
    pio_sync_slow_start_signal(cd);
    tx_schedule_transmit(cd);
    pio_sync_set_may_start_tx_irq(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_note_parse_error(struct can2040 *cd)
|———Node:identifier Text: tx_note_parse_error
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_sync_slow_start_signal(cd);
    tx_schedule_transmit(cd);
    pio_sync_set_may_start_tx_irq(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: pio_sync_slow_start_signal(cd);
|————Node:call_expression Text: pio_sync_slow_start_signal(cd)
|—————Node:identifier Text: pio_sync_slow_start_signal
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: tx_schedule_transmit(cd);
|————Node:call_expression Text: tx_schedule_transmit(cd)
|—————Node:identifier Text: tx_schedule_transmit
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pio_sync_set_may_start_tx_irq(cd);
|————Node:call_expression Text: pio_sync_set_may_start_tx_irq(cd)
|—————Node:identifier Text: pio_sync_set_may_start_tx_irq
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Received 10+ passive bits on the line (between 10 and 17 bits)
|—Node:function_definition Text: static void
tx_line_may_start_transmit(struct can2040 *cd)
{
    tx_schedule_transmit(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: tx_line_may_start_transmit(struct can2040 *cd)
|———Node:identifier Text: tx_line_may_start_transmit
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    tx_schedule_transmit(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: tx_schedule_transmit(cd);
|————Node:call_expression Text: tx_schedule_transmit(cd)
|—————Node:identifier Text: tx_schedule_transmit
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Input state tracking
 ****************************************************************/
|—Node:comment Text: // Parsing states (stored in cd->parse_state)
|—Node:enum_specifier Text: enum {
    MS_START, MS_HEADER, MS_EXT_HEADER, MS_DATA0, MS_DATA1,
    MS_CRC, MS_ACK, MS_EOF, MS_DISCARD
}
|——Node:enum Text: enum
|——Node:enumerator_list Text: {
    MS_START, MS_HEADER, MS_EXT_HEADER, MS_DATA0, MS_DATA1,
    MS_CRC, MS_ACK, MS_EOF, MS_DISCARD
}
|———Node:{ Text: {
|———Node:enumerator Text: MS_START
|————Node:identifier Text: MS_START
|———Node:, Text: ,
|———Node:enumerator Text: MS_HEADER
|————Node:identifier Text: MS_HEADER
|———Node:, Text: ,
|———Node:enumerator Text: MS_EXT_HEADER
|————Node:identifier Text: MS_EXT_HEADER
|———Node:, Text: ,
|———Node:enumerator Text: MS_DATA0
|————Node:identifier Text: MS_DATA0
|———Node:, Text: ,
|———Node:enumerator Text: MS_DATA1
|————Node:identifier Text: MS_DATA1
|———Node:, Text: ,
|———Node:enumerator Text: MS_CRC
|————Node:identifier Text: MS_CRC
|———Node:, Text: ,
|———Node:enumerator Text: MS_ACK
|————Node:identifier Text: MS_ACK
|———Node:, Text: ,
|———Node:enumerator Text: MS_EOF
|————Node:identifier Text: MS_EOF
|———Node:, Text: ,
|———Node:enumerator Text: MS_DISCARD
|————Node:identifier Text: MS_DISCARD
|———Node:} Text: }
|—Node:; Text: ;
|—Node:comment Text: // Transition to the next parsing state
|—Node:function_definition Text: static void
data_state_go_next(struct can2040 *cd, uint32_t state, uint32_t bits)
{
    cd->parse_state = state;
    unstuf_set_count(&cd->unstuf, bits);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_go_next(struct can2040 *cd, uint32_t state, uint32_t bits)
|———Node:identifier Text: data_state_go_next
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t state, uint32_t bits)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t state
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: state
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t bits
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: bits
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->parse_state = state;
    unstuf_set_count(&cd->unstuf, bits);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->parse_state = state;
|————Node:assignment_expression Text: cd->parse_state = state
|—————Node:field_expression Text: cd->parse_state
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_state
|—————Node:= Text: =
|—————Node:identifier Text: state
|————Node:; Text: ;
|———Node:expression_statement Text: unstuf_set_count(&cd->unstuf, bits);
|————Node:call_expression Text: unstuf_set_count(&cd->unstuf, bits)
|—————Node:identifier Text: unstuf_set_count
|—————Node:argument_list Text: (&cd->unstuf, bits)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &cd->unstuf
|———————Node:& Text: &
|———————Node:field_expression Text: cd->unstuf
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: unstuf
|——————Node:, Text: ,
|——————Node:identifier Text: bits
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Transition to the MS_DISCARD state - drop all bits until 6 passive bits
|—Node:function_definition Text: static void
data_state_go_discard(struct can2040 *cd)
{
    tx_note_parse_error(cd);
    data_state_go_next(cd, MS_DISCARD, 32);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_go_discard(struct can2040 *cd)
|———Node:identifier Text: data_state_go_discard
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    tx_note_parse_error(cd);
    data_state_go_next(cd, MS_DISCARD, 32);
}
|———Node:{ Text: {
|———Node:expression_statement Text: tx_note_parse_error(cd);
|————Node:call_expression Text: tx_note_parse_error(cd)
|—————Node:identifier Text: tx_note_parse_error
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_DISCARD, 32);
|————Node:call_expression Text: data_state_go_next(cd, MS_DISCARD, 32)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_DISCARD, 32)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_DISCARD
|——————Node:, Text: ,
|——————Node:number_literal Text: 32
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Received six dominant bits on the line
|—Node:function_definition Text: static void
data_state_line_error(struct can2040 *cd)
{
    data_state_go_discard(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_line_error(struct can2040 *cd)
|———Node:identifier Text: data_state_line_error
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    data_state_go_discard(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: data_state_go_discard(cd);
|————Node:call_expression Text: data_state_go_discard(cd)
|—————Node:identifier Text: data_state_go_discard
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Received six passive bits on the line
|—Node:function_definition Text: static void
data_state_line_passive(struct can2040 *cd)
{
    if (cd->parse_state == MS_START) {
        if (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff) {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
        data_state_go_next(cd, MS_START, 1);
        return;
    }

    if (pio_rx_check_stall(cd)) {
        // CPU couldn't keep up for some read data - must reset pio state
        cd->raw_bit_count = cd->unstuf.count_stuff = 0;
        pio_sm_setup(cd);
        report_error(cd, 0);
        data_state_go_discard(cd);
        return;
    }

    if (cd->parse_state != MS_EOF)
        tx_note_parse_error(cd);
    data_state_go_next(cd, MS_START, 1);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_line_passive(struct can2040 *cd)
|———Node:identifier Text: data_state_line_passive
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (cd->parse_state == MS_START) {
        if (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff) {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
        data_state_go_next(cd, MS_START, 1);
        return;
    }

    if (pio_rx_check_stall(cd)) {
        // CPU couldn't keep up for some read data - must reset pio state
        cd->raw_bit_count = cd->unstuf.count_stuff = 0;
        pio_sm_setup(cd);
        report_error(cd, 0);
        data_state_go_discard(cd);
        return;
    }

    if (cd->parse_state != MS_EOF)
        tx_note_parse_error(cd);
    data_state_go_next(cd, MS_START, 1);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (cd->parse_state == MS_START) {
        if (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff) {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
        data_state_go_next(cd, MS_START, 1);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->parse_state == MS_START)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->parse_state == MS_START
|——————Node:field_expression Text: cd->parse_state
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_state
|——————Node:== Text: ==
|——————Node:identifier Text: MS_START
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff) {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
        data_state_go_next(cd, MS_START, 1);
        return;
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff) {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (!cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff)
|———————Node:( Text: (
|———————Node:binary_expression Text: !cd->unstuf.count_stuff && cd->unstuf.stuffed_bits == 0xffffffff
|————————Node:unary_expression Text: !cd->unstuf.count_stuff
|—————————Node:! Text: !
|—————————Node:field_expression Text: cd->unstuf.count_stuff
|——————————Node:field_expression Text: cd->unstuf
|———————————Node:identifier Text: cd
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: unstuf
|——————————Node:. Text: .
|——————————Node:field_identifier Text: count_stuff
|————————Node:&& Text: &&
|————————Node:binary_expression Text: cd->unstuf.stuffed_bits == 0xffffffff
|—————————Node:field_expression Text: cd->unstuf.stuffed_bits
|——————————Node:field_expression Text: cd->unstuf
|———————————Node:identifier Text: cd
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: unstuf
|——————————Node:. Text: .
|——————————Node:field_identifier Text: stuffed_bits
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 0xffffffff
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            // Counter overflow in "sync" state machine - reset it
            pio_sync_setup(cd);
            cd->unstuf.stuffed_bits = 0;
            data_state_go_discard(cd);
            return;
        }
|———————Node:{ Text: {
|———————Node:comment Text: // Counter overflow in "sync" state machine - reset it
|———————Node:expression_statement Text: pio_sync_setup(cd);
|————————Node:call_expression Text: pio_sync_setup(cd)
|—————————Node:identifier Text: pio_sync_setup
|—————————Node:argument_list Text: (cd)
|——————————Node:( Text: (
|——————————Node:identifier Text: cd
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: cd->unstuf.stuffed_bits = 0;
|————————Node:assignment_expression Text: cd->unstuf.stuffed_bits = 0
|—————————Node:field_expression Text: cd->unstuf.stuffed_bits
|——————————Node:field_expression Text: cd->unstuf
|———————————Node:identifier Text: cd
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: unstuf
|——————————Node:. Text: .
|——————————Node:field_identifier Text: stuffed_bits
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: data_state_go_discard(cd);
|————————Node:call_expression Text: data_state_go_discard(cd)
|—————————Node:identifier Text: data_state_go_discard
|—————————Node:argument_list Text: (cd)
|——————————Node:( Text: (
|——————————Node:identifier Text: cd
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return;
|————————Node:return Text: return
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: data_state_go_next(cd, MS_START, 1);
|——————Node:call_expression Text: data_state_go_next(cd, MS_START, 1)
|———————Node:identifier Text: data_state_go_next
|———————Node:argument_list Text: (cd, MS_START, 1)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:identifier Text: MS_START
|————————Node:, Text: ,
|————————Node:number_literal Text: 1
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (pio_rx_check_stall(cd)) {
        // CPU couldn't keep up for some read data - must reset pio state
        cd->raw_bit_count = cd->unstuf.count_stuff = 0;
        pio_sm_setup(cd);
        report_error(cd, 0);
        data_state_go_discard(cd);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (pio_rx_check_stall(cd))
|—————Node:( Text: (
|—————Node:call_expression Text: pio_rx_check_stall(cd)
|——————Node:identifier Text: pio_rx_check_stall
|——————Node:argument_list Text: (cd)
|———————Node:( Text: (
|———————Node:identifier Text: cd
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // CPU couldn't keep up for some read data - must reset pio state
        cd->raw_bit_count = cd->unstuf.count_stuff = 0;
        pio_sm_setup(cd);
        report_error(cd, 0);
        data_state_go_discard(cd);
        return;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // CPU couldn't keep up for some read data - must reset pio state
|—————Node:expression_statement Text: cd->raw_bit_count = cd->unstuf.count_stuff = 0;
|——————Node:assignment_expression Text: cd->raw_bit_count = cd->unstuf.count_stuff = 0
|———————Node:field_expression Text: cd->raw_bit_count
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: raw_bit_count
|———————Node:= Text: =
|———————Node:assignment_expression Text: cd->unstuf.count_stuff = 0
|————————Node:field_expression Text: cd->unstuf.count_stuff
|—————————Node:field_expression Text: cd->unstuf
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: unstuf
|—————————Node:. Text: .
|—————————Node:field_identifier Text: count_stuff
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: pio_sm_setup(cd);
|——————Node:call_expression Text: pio_sm_setup(cd)
|———————Node:identifier Text: pio_sm_setup
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: report_error(cd, 0);
|——————Node:call_expression Text: report_error(cd, 0)
|———————Node:identifier Text: report_error
|———————Node:argument_list Text: (cd, 0)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: data_state_go_discard(cd);
|——————Node:call_expression Text: data_state_go_discard(cd)
|———————Node:identifier Text: data_state_go_discard
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (cd->parse_state != MS_EOF)
        tx_note_parse_error(cd);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (cd->parse_state != MS_EOF)
|—————Node:( Text: (
|—————Node:binary_expression Text: cd->parse_state != MS_EOF
|——————Node:field_expression Text: cd->parse_state
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_state
|——————Node:!= Text: !=
|——————Node:identifier Text: MS_EOF
|—————Node:) Text: )
|————Node:expression_statement Text: tx_note_parse_error(cd);
|—————Node:call_expression Text: tx_note_parse_error(cd)
|——————Node:identifier Text: tx_note_parse_error
|——————Node:argument_list Text: (cd)
|———————Node:( Text: (
|———————Node:identifier Text: cd
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_START, 1);
|————Node:call_expression Text: data_state_go_next(cd, MS_START, 1)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_START, 1)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_START
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Transition to MS_CRC state - await 16 bits of crc
|—Node:function_definition Text: static void
data_state_go_crc(struct can2040 *cd)
{
    cd->parse_crc &= 0x7fff;
    tx_note_crc_start(cd, cd->parse_crc);
    data_state_go_next(cd, MS_CRC, 16);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_go_crc(struct can2040 *cd)
|———Node:identifier Text: data_state_go_crc
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->parse_crc &= 0x7fff;
    tx_note_crc_start(cd, cd->parse_crc);
    data_state_go_next(cd, MS_CRC, 16);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->parse_crc &= 0x7fff;
|————Node:assignment_expression Text: cd->parse_crc &= 0x7fff
|—————Node:field_expression Text: cd->parse_crc
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_crc
|—————Node:&= Text: &=
|—————Node:number_literal Text: 0x7fff
|————Node:; Text: ;
|———Node:expression_statement Text: tx_note_crc_start(cd, cd->parse_crc);
|————Node:call_expression Text: tx_note_crc_start(cd, cd->parse_crc)
|—————Node:identifier Text: tx_note_crc_start
|—————Node:argument_list Text: (cd, cd->parse_crc)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:field_expression Text: cd->parse_crc
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_crc
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_CRC, 16);
|————Node:call_expression Text: data_state_go_next(cd, MS_CRC, 16)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_CRC, 16)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_CRC
|——————Node:, Text: ,
|——————Node:number_literal Text: 16
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Transition to MS_DATA0 state (if applicable) - await data bits
|—Node:function_definition Text: static void
data_state_go_data(struct can2040 *cd, uint32_t id, uint32_t data)
{
    if (data & (0x03 << 4)) {
        // Not a supported header
        data_state_go_discard(cd);
        return;
    }
    cd->parse_msg.data32[0] = cd->parse_msg.data32[1] = 0;
    uint32_t dlc = data & 0x0f;
    cd->parse_msg.dlc = dlc;
    if (data & (1 << 6)) {
        dlc = 0;
        id |= CAN2040_ID_RTR;
    }
    cd->parse_msg.id = id;
    if (dlc)
        data_state_go_next(cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8);
    else
        data_state_go_crc(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_go_data(struct can2040 *cd, uint32_t id, uint32_t data)
|———Node:identifier Text: data_state_go_data
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t id, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (data & (0x03 << 4)) {
        // Not a supported header
        data_state_go_discard(cd);
        return;
    }
    cd->parse_msg.data32[0] = cd->parse_msg.data32[1] = 0;
    uint32_t dlc = data & 0x0f;
    cd->parse_msg.dlc = dlc;
    if (data & (1 << 6)) {
        dlc = 0;
        id |= CAN2040_ID_RTR;
    }
    cd->parse_msg.id = id;
    if (dlc)
        data_state_go_next(cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8);
    else
        data_state_go_crc(cd);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (data & (0x03 << 4)) {
        // Not a supported header
        data_state_go_discard(cd);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (data & (0x03 << 4))
|—————Node:( Text: (
|—————Node:binary_expression Text: data & (0x03 << 4)
|——————Node:identifier Text: data
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: (0x03 << 4)
|———————Node:( Text: (
|———————Node:binary_expression Text: 0x03 << 4
|————————Node:number_literal Text: 0x03
|————————Node:<< Text: <<
|————————Node:number_literal Text: 4
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // Not a supported header
        data_state_go_discard(cd);
        return;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // Not a supported header
|—————Node:expression_statement Text: data_state_go_discard(cd);
|——————Node:call_expression Text: data_state_go_discard(cd)
|———————Node:identifier Text: data_state_go_discard
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: cd->parse_msg.data32[0] = cd->parse_msg.data32[1] = 0;
|————Node:assignment_expression Text: cd->parse_msg.data32[0] = cd->parse_msg.data32[1] = 0
|—————Node:subscript_expression Text: cd->parse_msg.data32[0]
|——————Node:field_expression Text: cd->parse_msg.data32
|———————Node:field_expression Text: cd->parse_msg
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_msg
|———————Node:. Text: .
|———————Node:field_identifier Text: data32
|——————Node:[ Text: [
|——————Node:number_literal Text: 0
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:assignment_expression Text: cd->parse_msg.data32[1] = 0
|——————Node:subscript_expression Text: cd->parse_msg.data32[1]
|———————Node:field_expression Text: cd->parse_msg.data32
|————————Node:field_expression Text: cd->parse_msg
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parse_msg
|————————Node:. Text: .
|————————Node:field_identifier Text: data32
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: uint32_t dlc = data & 0x0f;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: dlc = data & 0x0f
|—————Node:identifier Text: dlc
|—————Node:= Text: =
|—————Node:binary_expression Text: data & 0x0f
|——————Node:identifier Text: data
|——————Node:& Text: &
|——————Node:number_literal Text: 0x0f
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_msg.dlc = dlc;
|————Node:assignment_expression Text: cd->parse_msg.dlc = dlc
|—————Node:field_expression Text: cd->parse_msg.dlc
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: dlc
|—————Node:= Text: =
|—————Node:identifier Text: dlc
|————Node:; Text: ;
|———Node:if_statement Text: if (data & (1 << 6)) {
        dlc = 0;
        id |= CAN2040_ID_RTR;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (data & (1 << 6))
|—————Node:( Text: (
|—————Node:binary_expression Text: data & (1 << 6)
|——————Node:identifier Text: data
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: (1 << 6)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1 << 6
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:number_literal Text: 6
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        dlc = 0;
        id |= CAN2040_ID_RTR;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: dlc = 0;
|——————Node:assignment_expression Text: dlc = 0
|———————Node:identifier Text: dlc
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:expression_statement Text: id |= CAN2040_ID_RTR;
|——————Node:assignment_expression Text: id |= CAN2040_ID_RTR
|———————Node:identifier Text: id
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN2040_ID_RTR
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: cd->parse_msg.id = id;
|————Node:assignment_expression Text: cd->parse_msg.id = id
|—————Node:field_expression Text: cd->parse_msg.id
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|—————Node:= Text: =
|—————Node:identifier Text: id
|————Node:; Text: ;
|———Node:if_statement Text: if (dlc)
        data_state_go_next(cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8);
    else
        data_state_go_crc(cd);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dlc)
|—————Node:( Text: (
|—————Node:identifier Text: dlc
|—————Node:) Text: )
|————Node:expression_statement Text: data_state_go_next(cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8);
|—————Node:call_expression Text: data_state_go_next(cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8)
|——————Node:identifier Text: data_state_go_next
|——————Node:argument_list Text: (cd, MS_DATA0, dlc >= 4 ? 32 : dlc * 8)
|———————Node:( Text: (
|———————Node:identifier Text: cd
|———————Node:, Text: ,
|———————Node:identifier Text: MS_DATA0
|———————Node:, Text: ,
|———————Node:conditional_expression Text: dlc >= 4 ? 32 : dlc * 8
|————————Node:binary_expression Text: dlc >= 4
|—————————Node:identifier Text: dlc
|—————————Node:>= Text: >=
|—————————Node:number_literal Text: 4
|————————Node:? Text: ?
|————————Node:number_literal Text: 32
|————————Node:: Text: :
|————————Node:binary_expression Text: dlc * 8
|—————————Node:identifier Text: dlc
|—————————Node:* Text: *
|—————————Node:number_literal Text: 8
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:else_clause Text: else
        data_state_go_crc(cd);
|—————Node:else Text: else
|—————Node:expression_statement Text: data_state_go_crc(cd);
|——————Node:call_expression Text: data_state_go_crc(cd)
|———————Node:identifier Text: data_state_go_crc
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of first bit of header (after start-of-frame (SOF))
|—Node:function_definition Text: static void
data_state_update_start(struct can2040 *cd, uint32_t data)
{
    // Make sure there was at last 9 passive bits prior
    uint32_t ps = cd->unstuf.stuffed_bits >> (cd->unstuf.count_stuff + 2);
    if ((ps + 1) & 0x1ff) {
        data_state_go_discard(cd);
        return;
    }

    cd->parse_msg.id = data;
    tx_note_message_start(cd);
    data_state_go_next(cd, MS_HEADER, 17);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_start(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_start
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    // Make sure there was at last 9 passive bits prior
    uint32_t ps = cd->unstuf.stuffed_bits >> (cd->unstuf.count_stuff + 2);
    if ((ps + 1) & 0x1ff) {
        data_state_go_discard(cd);
        return;
    }

    cd->parse_msg.id = data;
    tx_note_message_start(cd);
    data_state_go_next(cd, MS_HEADER, 17);
}
|———Node:{ Text: {
|———Node:comment Text: // Make sure there was at last 9 passive bits prior
|———Node:declaration Text: uint32_t ps = cd->unstuf.stuffed_bits >> (cd->unstuf.count_stuff + 2);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: ps = cd->unstuf.stuffed_bits >> (cd->unstuf.count_stuff + 2)
|—————Node:identifier Text: ps
|—————Node:= Text: =
|—————Node:binary_expression Text: cd->unstuf.stuffed_bits >> (cd->unstuf.count_stuff + 2)
|——————Node:field_expression Text: cd->unstuf.stuffed_bits
|———————Node:field_expression Text: cd->unstuf
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: unstuf
|———————Node:. Text: .
|———————Node:field_identifier Text: stuffed_bits
|——————Node:>> Text: >>
|——————Node:parenthesized_expression Text: (cd->unstuf.count_stuff + 2)
|———————Node:( Text: (
|———————Node:binary_expression Text: cd->unstuf.count_stuff + 2
|————————Node:field_expression Text: cd->unstuf.count_stuff
|—————————Node:field_expression Text: cd->unstuf
|——————————Node:identifier Text: cd
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: unstuf
|—————————Node:. Text: .
|—————————Node:field_identifier Text: count_stuff
|————————Node:+ Text: +
|————————Node:number_literal Text: 2
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((ps + 1) & 0x1ff) {
        data_state_go_discard(cd);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((ps + 1) & 0x1ff)
|—————Node:( Text: (
|—————Node:binary_expression Text: (ps + 1) & 0x1ff
|——————Node:parenthesized_expression Text: (ps + 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: ps + 1
|————————Node:identifier Text: ps
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:& Text: &
|——————Node:number_literal Text: 0x1ff
|—————Node:) Text: )
|————Node:compound_statement Text: {
        data_state_go_discard(cd);
        return;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: data_state_go_discard(cd);
|——————Node:call_expression Text: data_state_go_discard(cd)
|———————Node:identifier Text: data_state_go_discard
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: cd->parse_msg.id = data;
|————Node:assignment_expression Text: cd->parse_msg.id = data
|—————Node:field_expression Text: cd->parse_msg.id
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|—————Node:= Text: =
|—————Node:identifier Text: data
|————Node:; Text: ;
|———Node:expression_statement Text: tx_note_message_start(cd);
|————Node:call_expression Text: tx_note_message_start(cd)
|—————Node:identifier Text: tx_note_message_start
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_HEADER, 17);
|————Node:call_expression Text: data_state_go_next(cd, MS_HEADER, 17)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_HEADER, 17)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_HEADER
|——————Node:, Text: ,
|——————Node:number_literal Text: 17
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of next 17 header bits
|—Node:function_definition Text: static void
data_state_update_header(struct can2040 *cd, uint32_t data)
{
    data |= cd->parse_msg.id << 17;
    cd->parse_crc = crcbits(0, data, 20);
    if ((data & 0x60) == 0x60) {
        // Extended header
        cd->parse_msg.id = data;
        data_state_go_next(cd, MS_EXT_HEADER, 20);
        return;
    }
    data_state_go_data(cd, (data >> 7) & 0x7ff, data);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_header(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_header
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    data |= cd->parse_msg.id << 17;
    cd->parse_crc = crcbits(0, data, 20);
    if ((data & 0x60) == 0x60) {
        // Extended header
        cd->parse_msg.id = data;
        data_state_go_next(cd, MS_EXT_HEADER, 20);
        return;
    }
    data_state_go_data(cd, (data >> 7) & 0x7ff, data);
}
|———Node:{ Text: {
|———Node:expression_statement Text: data |= cd->parse_msg.id << 17;
|————Node:assignment_expression Text: data |= cd->parse_msg.id << 17
|—————Node:identifier Text: data
|—————Node:|= Text: |=
|—————Node:binary_expression Text: cd->parse_msg.id << 17
|——————Node:field_expression Text: cd->parse_msg.id
|———————Node:field_expression Text: cd->parse_msg
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_msg
|———————Node:. Text: .
|———————Node:field_identifier Text: id
|——————Node:<< Text: <<
|——————Node:number_literal Text: 17
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_crc = crcbits(0, data, 20);
|————Node:assignment_expression Text: cd->parse_crc = crcbits(0, data, 20)
|—————Node:field_expression Text: cd->parse_crc
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_crc
|—————Node:= Text: =
|—————Node:call_expression Text: crcbits(0, data, 20)
|——————Node:identifier Text: crcbits
|——————Node:argument_list Text: (0, data, 20)
|———————Node:( Text: (
|———————Node:number_literal Text: 0
|———————Node:, Text: ,
|———————Node:identifier Text: data
|———————Node:, Text: ,
|———————Node:number_literal Text: 20
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((data & 0x60) == 0x60) {
        // Extended header
        cd->parse_msg.id = data;
        data_state_go_next(cd, MS_EXT_HEADER, 20);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((data & 0x60) == 0x60)
|—————Node:( Text: (
|—————Node:binary_expression Text: (data & 0x60) == 0x60
|——————Node:parenthesized_expression Text: (data & 0x60)
|———————Node:( Text: (
|———————Node:binary_expression Text: data & 0x60
|————————Node:identifier Text: data
|————————Node:& Text: &
|————————Node:number_literal Text: 0x60
|———————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: 0x60
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // Extended header
        cd->parse_msg.id = data;
        data_state_go_next(cd, MS_EXT_HEADER, 20);
        return;
    }
|—————Node:{ Text: {
|—————Node:comment Text: // Extended header
|—————Node:expression_statement Text: cd->parse_msg.id = data;
|——————Node:assignment_expression Text: cd->parse_msg.id = data
|———————Node:field_expression Text: cd->parse_msg.id
|————————Node:field_expression Text: cd->parse_msg
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parse_msg
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:identifier Text: data
|——————Node:; Text: ;
|—————Node:expression_statement Text: data_state_go_next(cd, MS_EXT_HEADER, 20);
|——————Node:call_expression Text: data_state_go_next(cd, MS_EXT_HEADER, 20)
|———————Node:identifier Text: data_state_go_next
|———————Node:argument_list Text: (cd, MS_EXT_HEADER, 20)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:identifier Text: MS_EXT_HEADER
|————————Node:, Text: ,
|————————Node:number_literal Text: 20
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: data_state_go_data(cd, (data >> 7) & 0x7ff, data);
|————Node:call_expression Text: data_state_go_data(cd, (data >> 7) & 0x7ff, data)
|—————Node:identifier Text: data_state_go_data
|—————Node:argument_list Text: (cd, (data >> 7) & 0x7ff, data)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:binary_expression Text: (data >> 7) & 0x7ff
|———————Node:parenthesized_expression Text: (data >> 7)
|————————Node:( Text: (
|————————Node:binary_expression Text: data >> 7
|—————————Node:identifier Text: data
|—————————Node:>> Text: >>
|—————————Node:number_literal Text: 7
|————————Node:) Text: )
|———————Node:& Text: &
|———————Node:number_literal Text: 0x7ff
|——————Node:, Text: ,
|——————Node:identifier Text: data
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of additional 20 bits of "extended header"
|—Node:function_definition Text: static void
data_state_update_ext_header(struct can2040 *cd, uint32_t data)
{
    cd->parse_crc = crcbits(cd->parse_crc, data, 20);
    uint32_t hdr1 = cd->parse_msg.id;
    uint32_t id = (((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF);
    data_state_go_data(cd, id, data);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_ext_header(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_ext_header
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->parse_crc = crcbits(cd->parse_crc, data, 20);
    uint32_t hdr1 = cd->parse_msg.id;
    uint32_t id = (((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF);
    data_state_go_data(cd, id, data);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->parse_crc = crcbits(cd->parse_crc, data, 20);
|————Node:assignment_expression Text: cd->parse_crc = crcbits(cd->parse_crc, data, 20)
|—————Node:field_expression Text: cd->parse_crc
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_crc
|—————Node:= Text: =
|—————Node:call_expression Text: crcbits(cd->parse_crc, data, 20)
|——————Node:identifier Text: crcbits
|——————Node:argument_list Text: (cd->parse_crc, data, 20)
|———————Node:( Text: (
|———————Node:field_expression Text: cd->parse_crc
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_crc
|———————Node:, Text: ,
|———————Node:identifier Text: data
|———————Node:, Text: ,
|———————Node:number_literal Text: 20
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t hdr1 = cd->parse_msg.id;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: hdr1 = cd->parse_msg.id
|—————Node:identifier Text: hdr1
|—————Node:= Text: =
|—————Node:field_expression Text: cd->parse_msg.id
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|————Node:; Text: ;
|———Node:declaration Text: uint32_t id = (((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: id = (((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF)
|—————Node:identifier Text: id
|—————Node:= Text: =
|—————Node:parenthesized_expression Text: (((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF)
|——————Node:( Text: (
|——————Node:binary_expression Text: ((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7) | CAN2040_ID_EFF
|———————Node:binary_expression Text: ((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
                   | (data >> 7)
|————————Node:binary_expression Text: ((hdr1 << 11) & 0x1ffc0000) | ((hdr1 << 13) & 0x3e000)
|—————————Node:parenthesized_expression Text: ((hdr1 << 11) & 0x1ffc0000)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (hdr1 << 11) & 0x1ffc0000
|———————————Node:parenthesized_expression Text: (hdr1 << 11)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: hdr1 << 11
|—————————————Node:identifier Text: hdr1
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 11
|————————————Node:) Text: )
|———————————Node:& Text: &
|———————————Node:number_literal Text: 0x1ffc0000
|——————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:parenthesized_expression Text: ((hdr1 << 13) & 0x3e000)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (hdr1 << 13) & 0x3e000
|———————————Node:parenthesized_expression Text: (hdr1 << 13)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: hdr1 << 13
|—————————————Node:identifier Text: hdr1
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 13
|————————————Node:) Text: )
|———————————Node:& Text: &
|———————————Node:number_literal Text: 0x3e000
|——————————Node:) Text: )
|————————Node:| Text: |
|————————Node:parenthesized_expression Text: (data >> 7)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: data >> 7
|——————————Node:identifier Text: data
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 7
|—————————Node:) Text: )
|———————Node:| Text: |
|———————Node:identifier Text: CAN2040_ID_EFF
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_data(cd, id, data);
|————Node:call_expression Text: data_state_go_data(cd, id, data)
|—————Node:identifier Text: data_state_go_data
|—————Node:argument_list Text: (cd, id, data)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:identifier Text: data
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of first 1-4 bytes of data content
|—Node:function_definition Text: static void
data_state_update_data0(struct can2040 *cd, uint32_t data)
{
    uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 4 ? 32 : dlc * 8;
    cd->parse_crc = crcbits(cd->parse_crc, data, bits);
    cd->parse_msg.data32[0] = __builtin_bswap32(data << (32 - bits));
    if (dlc > 4)
        data_state_go_next(cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8);
    else
        data_state_go_crc(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_data0(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_data0
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 4 ? 32 : dlc * 8;
    cd->parse_crc = crcbits(cd->parse_crc, data, bits);
    cd->parse_msg.data32[0] = __builtin_bswap32(data << (32 - bits));
    if (dlc > 4)
        data_state_go_next(cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8);
    else
        data_state_go_crc(cd);
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 4 ? 32 : dlc * 8;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: dlc = cd->parse_msg.dlc
|—————Node:identifier Text: dlc
|—————Node:= Text: =
|—————Node:field_expression Text: cd->parse_msg.dlc
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: dlc
|————Node:, Text: ,
|————Node:init_declarator Text: bits = dlc >= 4 ? 32 : dlc * 8
|—————Node:identifier Text: bits
|—————Node:= Text: =
|—————Node:conditional_expression Text: dlc >= 4 ? 32 : dlc * 8
|——————Node:binary_expression Text: dlc >= 4
|———————Node:identifier Text: dlc
|———————Node:>= Text: >=
|———————Node:number_literal Text: 4
|——————Node:? Text: ?
|——————Node:number_literal Text: 32
|——————Node:: Text: :
|——————Node:binary_expression Text: dlc * 8
|———————Node:identifier Text: dlc
|———————Node:* Text: *
|———————Node:number_literal Text: 8
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_crc = crcbits(cd->parse_crc, data, bits);
|————Node:assignment_expression Text: cd->parse_crc = crcbits(cd->parse_crc, data, bits)
|—————Node:field_expression Text: cd->parse_crc
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_crc
|—————Node:= Text: =
|—————Node:call_expression Text: crcbits(cd->parse_crc, data, bits)
|——————Node:identifier Text: crcbits
|——————Node:argument_list Text: (cd->parse_crc, data, bits)
|———————Node:( Text: (
|———————Node:field_expression Text: cd->parse_crc
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_crc
|———————Node:, Text: ,
|———————Node:identifier Text: data
|———————Node:, Text: ,
|———————Node:identifier Text: bits
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_msg.data32[0] = __builtin_bswap32(data << (32 - bits));
|————Node:assignment_expression Text: cd->parse_msg.data32[0] = __builtin_bswap32(data << (32 - bits))
|—————Node:subscript_expression Text: cd->parse_msg.data32[0]
|——————Node:field_expression Text: cd->parse_msg.data32
|———————Node:field_expression Text: cd->parse_msg
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_msg
|———————Node:. Text: .
|———————Node:field_identifier Text: data32
|——————Node:[ Text: [
|——————Node:number_literal Text: 0
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: __builtin_bswap32(data << (32 - bits))
|——————Node:identifier Text: __builtin_bswap32
|——————Node:argument_list Text: (data << (32 - bits))
|———————Node:( Text: (
|———————Node:binary_expression Text: data << (32 - bits)
|————————Node:identifier Text: data
|————————Node:<< Text: <<
|————————Node:parenthesized_expression Text: (32 - bits)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 32 - bits
|——————————Node:number_literal Text: 32
|——————————Node:- Text: -
|——————————Node:identifier Text: bits
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (dlc > 4)
        data_state_go_next(cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8);
    else
        data_state_go_crc(cd);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dlc > 4)
|—————Node:( Text: (
|—————Node:binary_expression Text: dlc > 4
|——————Node:identifier Text: dlc
|——————Node:> Text: >
|——————Node:number_literal Text: 4
|—————Node:) Text: )
|————Node:expression_statement Text: data_state_go_next(cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8);
|—————Node:call_expression Text: data_state_go_next(cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8)
|——————Node:identifier Text: data_state_go_next
|——————Node:argument_list Text: (cd, MS_DATA1, dlc >= 8 ? 32 : (dlc - 4) * 8)
|———————Node:( Text: (
|———————Node:identifier Text: cd
|———————Node:, Text: ,
|———————Node:identifier Text: MS_DATA1
|———————Node:, Text: ,
|———————Node:conditional_expression Text: dlc >= 8 ? 32 : (dlc - 4) * 8
|————————Node:binary_expression Text: dlc >= 8
|—————————Node:identifier Text: dlc
|—————————Node:>= Text: >=
|—————————Node:number_literal Text: 8
|————————Node:? Text: ?
|————————Node:number_literal Text: 32
|————————Node:: Text: :
|————————Node:binary_expression Text: (dlc - 4) * 8
|—————————Node:parenthesized_expression Text: (dlc - 4)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: dlc - 4
|———————————Node:identifier Text: dlc
|———————————Node:- Text: -
|———————————Node:number_literal Text: 4
|——————————Node:) Text: )
|—————————Node:* Text: *
|—————————Node:number_literal Text: 8
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:else_clause Text: else
        data_state_go_crc(cd);
|—————Node:else Text: else
|—————Node:expression_statement Text: data_state_go_crc(cd);
|——————Node:call_expression Text: data_state_go_crc(cd)
|———————Node:identifier Text: data_state_go_crc
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of bytes 5-8 of data content
|—Node:function_definition Text: static void
data_state_update_data1(struct can2040 *cd, uint32_t data)
{
    uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 8 ? 32 : (dlc - 4) * 8;
    cd->parse_crc = crcbits(cd->parse_crc, data, bits);
    cd->parse_msg.data32[1] = __builtin_bswap32(data << (32 - bits));
    data_state_go_crc(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_data1(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_data1
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 8 ? 32 : (dlc - 4) * 8;
    cd->parse_crc = crcbits(cd->parse_crc, data, bits);
    cd->parse_msg.data32[1] = __builtin_bswap32(data << (32 - bits));
    data_state_go_crc(cd);
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t dlc = cd->parse_msg.dlc, bits = dlc >= 8 ? 32 : (dlc - 4) * 8;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: dlc = cd->parse_msg.dlc
|—————Node:identifier Text: dlc
|—————Node:= Text: =
|—————Node:field_expression Text: cd->parse_msg.dlc
|——————Node:field_expression Text: cd->parse_msg
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: parse_msg
|——————Node:. Text: .
|——————Node:field_identifier Text: dlc
|————Node:, Text: ,
|————Node:init_declarator Text: bits = dlc >= 8 ? 32 : (dlc - 4) * 8
|—————Node:identifier Text: bits
|—————Node:= Text: =
|—————Node:conditional_expression Text: dlc >= 8 ? 32 : (dlc - 4) * 8
|——————Node:binary_expression Text: dlc >= 8
|———————Node:identifier Text: dlc
|———————Node:>= Text: >=
|———————Node:number_literal Text: 8
|——————Node:? Text: ?
|——————Node:number_literal Text: 32
|——————Node:: Text: :
|——————Node:binary_expression Text: (dlc - 4) * 8
|———————Node:parenthesized_expression Text: (dlc - 4)
|————————Node:( Text: (
|————————Node:binary_expression Text: dlc - 4
|—————————Node:identifier Text: dlc
|—————————Node:- Text: -
|—————————Node:number_literal Text: 4
|————————Node:) Text: )
|———————Node:* Text: *
|———————Node:number_literal Text: 8
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_crc = crcbits(cd->parse_crc, data, bits);
|————Node:assignment_expression Text: cd->parse_crc = crcbits(cd->parse_crc, data, bits)
|—————Node:field_expression Text: cd->parse_crc
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_crc
|—————Node:= Text: =
|—————Node:call_expression Text: crcbits(cd->parse_crc, data, bits)
|——————Node:identifier Text: crcbits
|——————Node:argument_list Text: (cd->parse_crc, data, bits)
|———————Node:( Text: (
|———————Node:field_expression Text: cd->parse_crc
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_crc
|———————Node:, Text: ,
|———————Node:identifier Text: data
|———————Node:, Text: ,
|———————Node:identifier Text: bits
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: cd->parse_msg.data32[1] = __builtin_bswap32(data << (32 - bits));
|————Node:assignment_expression Text: cd->parse_msg.data32[1] = __builtin_bswap32(data << (32 - bits))
|—————Node:subscript_expression Text: cd->parse_msg.data32[1]
|——————Node:field_expression Text: cd->parse_msg.data32
|———————Node:field_expression Text: cd->parse_msg
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: parse_msg
|———————Node:. Text: .
|———————Node:field_identifier Text: data32
|——————Node:[ Text: [
|——————Node:number_literal Text: 1
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:call_expression Text: __builtin_bswap32(data << (32 - bits))
|——————Node:identifier Text: __builtin_bswap32
|——————Node:argument_list Text: (data << (32 - bits))
|———————Node:( Text: (
|———————Node:binary_expression Text: data << (32 - bits)
|————————Node:identifier Text: data
|————————Node:<< Text: <<
|————————Node:parenthesized_expression Text: (32 - bits)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 32 - bits
|——————————Node:number_literal Text: 32
|——————————Node:- Text: -
|——————————Node:identifier Text: bits
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_crc(cd);
|————Node:call_expression Text: data_state_go_crc(cd)
|—————Node:identifier Text: data_state_go_crc
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of 16 bits of message CRC (15 crc bits + crc delimiter)
|—Node:function_definition Text: static void
data_state_update_crc(struct can2040 *cd, uint32_t data)
{
    if (((cd->parse_crc << 1) | 1) != data) {
        data_state_go_discard(cd);
        return;
    }

    unstuf_clear_state(&cd->unstuf);
    data_state_go_next(cd, MS_ACK, 2);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_crc(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_crc
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (((cd->parse_crc << 1) | 1) != data) {
        data_state_go_discard(cd);
        return;
    }

    unstuf_clear_state(&cd->unstuf);
    data_state_go_next(cd, MS_ACK, 2);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (((cd->parse_crc << 1) | 1) != data) {
        data_state_go_discard(cd);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (((cd->parse_crc << 1) | 1) != data)
|—————Node:( Text: (
|—————Node:binary_expression Text: ((cd->parse_crc << 1) | 1) != data
|——————Node:parenthesized_expression Text: ((cd->parse_crc << 1) | 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: (cd->parse_crc << 1) | 1
|————————Node:parenthesized_expression Text: (cd->parse_crc << 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: cd->parse_crc << 1
|——————————Node:field_expression Text: cd->parse_crc
|———————————Node:identifier Text: cd
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: parse_crc
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|————————Node:| Text: |
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: data
|—————Node:) Text: )
|————Node:compound_statement Text: {
        data_state_go_discard(cd);
        return;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: data_state_go_discard(cd);
|——————Node:call_expression Text: data_state_go_discard(cd)
|———————Node:identifier Text: data_state_go_discard
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: unstuf_clear_state(&cd->unstuf);
|————Node:call_expression Text: unstuf_clear_state(&cd->unstuf)
|—————Node:identifier Text: unstuf_clear_state
|—————Node:argument_list Text: (&cd->unstuf)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &cd->unstuf
|———————Node:& Text: &
|———————Node:field_expression Text: cd->unstuf
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: unstuf
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_ACK, 2);
|————Node:call_expression Text: data_state_go_next(cd, MS_ACK, 2)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_ACK, 2)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_ACK
|——————Node:, Text: ,
|——————Node:number_literal Text: 2
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of 2 bits of ack phase (ack, ack delimiter)
|—Node:function_definition Text: static void
data_state_update_ack(struct can2040 *cd, uint32_t data)
{
    if (data != 0x01) {
        data_state_go_discard(cd);
        return;
    }
    tx_note_ack_success(cd);
    data_state_go_next(cd, MS_EOF, 6);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_ack(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_ack
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (data != 0x01) {
        data_state_go_discard(cd);
        return;
    }
    tx_note_ack_success(cd);
    data_state_go_next(cd, MS_EOF, 6);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (data != 0x01) {
        data_state_go_discard(cd);
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (data != 0x01)
|—————Node:( Text: (
|—————Node:binary_expression Text: data != 0x01
|——————Node:identifier Text: data
|——————Node:!= Text: !=
|——————Node:number_literal Text: 0x01
|—————Node:) Text: )
|————Node:compound_statement Text: {
        data_state_go_discard(cd);
        return;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: data_state_go_discard(cd);
|——————Node:call_expression Text: data_state_go_discard(cd)
|———————Node:identifier Text: data_state_go_discard
|———————Node:argument_list Text: (cd)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: tx_note_ack_success(cd);
|————Node:call_expression Text: tx_note_ack_success(cd)
|—————Node:identifier Text: tx_note_ack_success
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_next(cd, MS_EOF, 6);
|————Node:call_expression Text: data_state_go_next(cd, MS_EOF, 6)
|—————Node:identifier Text: data_state_go_next
|—————Node:argument_list Text: (cd, MS_EOF, 6)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: MS_EOF
|——————Node:, Text: ,
|——————Node:number_literal Text: 6
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle reception of end-of-frame (EOF) bits (only called on an error)
|—Node:function_definition Text: static void
data_state_update_eof(struct can2040 *cd, uint32_t data)
{
    // The end-of-frame should have raised a bitstuff condition..
    data_state_go_discard(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_eof(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_eof
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    // The end-of-frame should have raised a bitstuff condition..
    data_state_go_discard(cd);
}
|———Node:{ Text: {
|———Node:comment Text: // The end-of-frame should have raised a bitstuff condition..
|———Node:expression_statement Text: data_state_go_discard(cd);
|————Node:call_expression Text: data_state_go_discard(cd)
|—————Node:identifier Text: data_state_go_discard
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Handle data received while in MS_DISCARD state
|—Node:function_definition Text: static void
data_state_update_discard(struct can2040 *cd, uint32_t data)
{
    data_state_go_discard(cd);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update_discard(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update_discard
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    data_state_go_discard(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: data_state_go_discard(cd);
|————Node:call_expression Text: data_state_go_discard(cd)
|—————Node:identifier Text: data_state_go_discard
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // Update parsing state after reading the bits of the current field
|—Node:function_definition Text: static void
data_state_update(struct can2040 *cd, uint32_t data)
{
    switch (cd->parse_state) {
    case MS_START: data_state_update_start(cd, data); break;
    case MS_HEADER: data_state_update_header(cd, data); break;
    case MS_EXT_HEADER: data_state_update_ext_header(cd, data); break;
    case MS_DATA0: data_state_update_data0(cd, data); break;
    case MS_DATA1: data_state_update_data1(cd, data); break;
    case MS_CRC: data_state_update_crc(cd, data); break;
    case MS_ACK: data_state_update_ack(cd, data); break;
    case MS_EOF: data_state_update_eof(cd, data); break;
    case MS_DISCARD: data_state_update_discard(cd, data); break;
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: data_state_update(struct can2040 *cd, uint32_t data)
|———Node:identifier Text: data_state_update
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t data)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t data
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: data
|————Node:) Text: )
|——Node:compound_statement Text: {
    switch (cd->parse_state) {
    case MS_START: data_state_update_start(cd, data); break;
    case MS_HEADER: data_state_update_header(cd, data); break;
    case MS_EXT_HEADER: data_state_update_ext_header(cd, data); break;
    case MS_DATA0: data_state_update_data0(cd, data); break;
    case MS_DATA1: data_state_update_data1(cd, data); break;
    case MS_CRC: data_state_update_crc(cd, data); break;
    case MS_ACK: data_state_update_ack(cd, data); break;
    case MS_EOF: data_state_update_eof(cd, data); break;
    case MS_DISCARD: data_state_update_discard(cd, data); break;
    }
}
|———Node:{ Text: {
|———Node:switch_statement Text: switch (cd->parse_state) {
    case MS_START: data_state_update_start(cd, data); break;
    case MS_HEADER: data_state_update_header(cd, data); break;
    case MS_EXT_HEADER: data_state_update_ext_header(cd, data); break;
    case MS_DATA0: data_state_update_data0(cd, data); break;
    case MS_DATA1: data_state_update_data1(cd, data); break;
    case MS_CRC: data_state_update_crc(cd, data); break;
    case MS_ACK: data_state_update_ack(cd, data); break;
    case MS_EOF: data_state_update_eof(cd, data); break;
    case MS_DISCARD: data_state_update_discard(cd, data); break;
    }
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (cd->parse_state)
|—————Node:( Text: (
|—————Node:field_expression Text: cd->parse_state
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: parse_state
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case MS_START: data_state_update_start(cd, data); break;
    case MS_HEADER: data_state_update_header(cd, data); break;
    case MS_EXT_HEADER: data_state_update_ext_header(cd, data); break;
    case MS_DATA0: data_state_update_data0(cd, data); break;
    case MS_DATA1: data_state_update_data1(cd, data); break;
    case MS_CRC: data_state_update_crc(cd, data); break;
    case MS_ACK: data_state_update_ack(cd, data); break;
    case MS_EOF: data_state_update_eof(cd, data); break;
    case MS_DISCARD: data_state_update_discard(cd, data); break;
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case MS_START: data_state_update_start(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_START
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_start(cd, data);
|———————Node:call_expression Text: data_state_update_start(cd, data)
|————————Node:identifier Text: data_state_update_start
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_HEADER: data_state_update_header(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_HEADER
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_header(cd, data);
|———————Node:call_expression Text: data_state_update_header(cd, data)
|————————Node:identifier Text: data_state_update_header
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_EXT_HEADER: data_state_update_ext_header(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_EXT_HEADER
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_ext_header(cd, data);
|———————Node:call_expression Text: data_state_update_ext_header(cd, data)
|————————Node:identifier Text: data_state_update_ext_header
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_DATA0: data_state_update_data0(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_DATA0
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_data0(cd, data);
|———————Node:call_expression Text: data_state_update_data0(cd, data)
|————————Node:identifier Text: data_state_update_data0
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_DATA1: data_state_update_data1(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_DATA1
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_data1(cd, data);
|———————Node:call_expression Text: data_state_update_data1(cd, data)
|————————Node:identifier Text: data_state_update_data1
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_CRC: data_state_update_crc(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_CRC
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_crc(cd, data);
|———————Node:call_expression Text: data_state_update_crc(cd, data)
|————————Node:identifier Text: data_state_update_crc
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_ACK: data_state_update_ack(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_ACK
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_ack(cd, data);
|———————Node:call_expression Text: data_state_update_ack(cd, data)
|————————Node:identifier Text: data_state_update_ack
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_EOF: data_state_update_eof(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_EOF
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_eof(cd, data);
|———————Node:call_expression Text: data_state_update_eof(cd, data)
|————————Node:identifier Text: data_state_update_eof
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case MS_DISCARD: data_state_update_discard(cd, data); break;
|——————Node:case Text: case
|——————Node:identifier Text: MS_DISCARD
|——————Node:: Text: :
|——————Node:expression_statement Text: data_state_update_discard(cd, data);
|———————Node:call_expression Text: data_state_update_discard(cd, data)
|————————Node:identifier Text: data_state_update_discard
|————————Node:argument_list Text: (cd, data)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: data
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Input processing
 ****************************************************************/
|—Node:comment Text: // Process an incoming byte of data from PIO "rx" state machine
|—Node:function_definition Text: static void
process_rx(struct can2040 *cd, uint32_t rx_byte)
{
    unstuf_add_bits(&cd->unstuf, rx_byte, 8);
    cd->raw_bit_count += 8;

    // undo bit stuffing
    for (;;) {
        int ret = unstuf_pull_bits(&cd->unstuf);
        if (!ret) {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        } else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: process_rx(struct can2040 *cd, uint32_t rx_byte)
|———Node:identifier Text: process_rx
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t rx_byte)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t rx_byte
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: rx_byte
|————Node:) Text: )
|——Node:compound_statement Text: {
    unstuf_add_bits(&cd->unstuf, rx_byte, 8);
    cd->raw_bit_count += 8;

    // undo bit stuffing
    for (;;) {
        int ret = unstuf_pull_bits(&cd->unstuf);
        if (!ret) {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        } else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
    }
}
|———Node:{ Text: {
|———Node:expression_statement Text: unstuf_add_bits(&cd->unstuf, rx_byte, 8);
|————Node:call_expression Text: unstuf_add_bits(&cd->unstuf, rx_byte, 8)
|—————Node:identifier Text: unstuf_add_bits
|—————Node:argument_list Text: (&cd->unstuf, rx_byte, 8)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &cd->unstuf
|———————Node:& Text: &
|———————Node:field_expression Text: cd->unstuf
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: unstuf
|——————Node:, Text: ,
|——————Node:identifier Text: rx_byte
|——————Node:, Text: ,
|——————Node:number_literal Text: 8
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: cd->raw_bit_count += 8;
|————Node:assignment_expression Text: cd->raw_bit_count += 8
|—————Node:field_expression Text: cd->raw_bit_count
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: raw_bit_count
|—————Node:+= Text: +=
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|———Node:comment Text: // undo bit stuffing
|———Node:for_statement Text: for (;;) {
        int ret = unstuf_pull_bits(&cd->unstuf);
        if (!ret) {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        } else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:; Text: ;
|————Node:; Text: ;
|————Node:) Text: )
|————Node:compound_statement Text: {
        int ret = unstuf_pull_bits(&cd->unstuf);
        if (!ret) {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        } else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
    }
|—————Node:{ Text: {
|—————Node:declaration Text: int ret = unstuf_pull_bits(&cd->unstuf);
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: ret = unstuf_pull_bits(&cd->unstuf)
|———————Node:identifier Text: ret
|———————Node:= Text: =
|———————Node:call_expression Text: unstuf_pull_bits(&cd->unstuf)
|————————Node:identifier Text: unstuf_pull_bits
|————————Node:argument_list Text: (&cd->unstuf)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &cd->unstuf
|——————————Node:& Text: &
|——————————Node:field_expression Text: cd->unstuf
|———————————Node:identifier Text: cd
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: unstuf
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (!ret) {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        } else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (!ret)
|———————Node:( Text: (
|———————Node:unary_expression Text: !ret
|————————Node:! Text: !
|————————Node:identifier Text: ret
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            // Pulled the next field - process it
            data_state_update(cd, cd->unstuf.unstuffed_bits);
        }
|———————Node:{ Text: {
|———————Node:comment Text: // Pulled the next field - process it
|———————Node:expression_statement Text: data_state_update(cd, cd->unstuf.unstuffed_bits);
|————————Node:call_expression Text: data_state_update(cd, cd->unstuf.unstuffed_bits)
|—————————Node:identifier Text: data_state_update
|—————————Node:argument_list Text: (cd, cd->unstuf.unstuffed_bits)
|——————————Node:( Text: (
|——————————Node:identifier Text: cd
|——————————Node:, Text: ,
|——————————Node:field_expression Text: cd->unstuf.unstuffed_bits
|———————————Node:field_expression Text: cd->unstuf
|————————————Node:identifier Text: cd
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: unstuf
|———————————Node:. Text: .
|———————————Node:field_identifier Text: unstuffed_bits
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
|———————Node:else Text: else
|———————Node:if_statement Text: if (ret > 0) {
            // Need more data
            break;
        } else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (ret > 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ret > 0
|——————————Node:identifier Text: ret
|——————————Node:> Text: >
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            // Need more data
            break;
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Need more data
|—————————Node:break_statement Text: break;
|——————————Node:break Text: break
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
            if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
        }
|——————————Node:{ Text: {
|——————————Node:if_statement Text: if (ret == -1) {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            } else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
|———————————Node:if Text: if
|———————————Node:parenthesized_expression Text: (ret == -1)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ret == -1
|—————————————Node:identifier Text: ret
|—————————————Node:== Text: ==
|—————————————Node:number_literal Text: -1
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
                // 6 consecutive high bits
                data_state_line_passive(cd);
            }
|————————————Node:{ Text: {
|————————————Node:comment Text: // 6 consecutive high bits
|————————————Node:expression_statement Text: data_state_line_passive(cd);
|—————————————Node:call_expression Text: data_state_line_passive(cd)
|——————————————Node:identifier Text: data_state_line_passive
|——————————————Node:argument_list Text: (cd)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: cd
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————————Node:else_clause Text: else {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
|————————————Node:else Text: else
|————————————Node:compound_statement Text: {
                // 6 consecutive low bits
                data_state_line_error(cd);
            }
|—————————————Node:{ Text: {
|—————————————Node:comment Text: // 6 consecutive low bits
|—————————————Node:expression_statement Text: data_state_line_error(cd);
|——————————————Node:call_expression Text: data_state_line_error(cd)
|———————————————Node:identifier Text: data_state_line_error
|———————————————Node:argument_list Text: (cd)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: cd
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|——————————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: // Main API irq notification function
|—Node:function_definition Text: void
can2040_pio_irq_handler(struct can2040 *cd)
{
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t ints = pio_hw->ints0;
    while (ints & PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS) {
        uint8_t rx_byte = pio_hw->rxf[1];
        process_rx(cd, rx_byte);
        ints = pio_hw->ints0;
    }

    if (ints & (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS))
        // Ack phase completed successfully
        tx_note_ack_success(cd);
    else if (ints & PIO_IRQ0_INTE_SM0_BITS)
        // Bus is idle, but not all bits may have been flushed yet
        tx_line_may_start_transmit(cd);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can2040_pio_irq_handler(struct can2040 *cd)
|———Node:identifier Text: can2040_pio_irq_handler
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    pio_hw_t *pio_hw = cd->pio_hw;
    uint32_t ints = pio_hw->ints0;
    while (ints & PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS) {
        uint8_t rx_byte = pio_hw->rxf[1];
        process_rx(cd, rx_byte);
        ints = pio_hw->ints0;
    }

    if (ints & (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS))
        // Ack phase completed successfully
        tx_note_ack_success(cd);
    else if (ints & PIO_IRQ0_INTE_SM0_BITS)
        // Bus is idle, but not all bits may have been flushed yet
        tx_line_may_start_transmit(cd);
}
|———Node:{ Text: {
|———Node:declaration Text: pio_hw_t *pio_hw = cd->pio_hw;
|————Node:type_identifier Text: pio_hw_t
|————Node:init_declarator Text: *pio_hw = cd->pio_hw
|—————Node:pointer_declarator Text: *pio_hw
|——————Node:* Text: *
|——————Node:identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ints = pio_hw->ints0;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: ints = pio_hw->ints0
|—————Node:identifier Text: ints
|—————Node:= Text: =
|—————Node:field_expression Text: pio_hw->ints0
|——————Node:identifier Text: pio_hw
|——————Node:-> Text: ->
|——————Node:field_identifier Text: ints0
|————Node:; Text: ;
|———Node:while_statement Text: while (ints & PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS) {
        uint8_t rx_byte = pio_hw->rxf[1];
        process_rx(cd, rx_byte);
        ints = pio_hw->ints0;
    }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (ints & PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS)
|—————Node:( Text: (
|—————Node:binary_expression Text: ints & PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|——————Node:identifier Text: ints
|——————Node:& Text: &
|——————Node:identifier Text: PIO_IRQ0_INTE_SM1_RXNEMPTY_BITS
|—————Node:) Text: )
|————Node:compound_statement Text: {
        uint8_t rx_byte = pio_hw->rxf[1];
        process_rx(cd, rx_byte);
        ints = pio_hw->ints0;
    }
|—————Node:{ Text: {
|—————Node:declaration Text: uint8_t rx_byte = pio_hw->rxf[1];
|——————Node:primitive_type Text: uint8_t
|——————Node:init_declarator Text: rx_byte = pio_hw->rxf[1]
|———————Node:identifier Text: rx_byte
|———————Node:= Text: =
|———————Node:subscript_expression Text: pio_hw->rxf[1]
|————————Node:field_expression Text: pio_hw->rxf
|—————————Node:identifier Text: pio_hw
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rxf
|————————Node:[ Text: [
|————————Node:number_literal Text: 1
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: process_rx(cd, rx_byte);
|——————Node:call_expression Text: process_rx(cd, rx_byte)
|———————Node:identifier Text: process_rx
|———————Node:argument_list Text: (cd, rx_byte)
|————————Node:( Text: (
|————————Node:identifier Text: cd
|————————Node:, Text: ,
|————————Node:identifier Text: rx_byte
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ints = pio_hw->ints0;
|——————Node:assignment_expression Text: ints = pio_hw->ints0
|———————Node:identifier Text: ints
|———————Node:= Text: =
|———————Node:field_expression Text: pio_hw->ints0
|————————Node:identifier Text: pio_hw
|————————Node:-> Text: ->
|————————Node:field_identifier Text: ints0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ints & (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS))
        // Ack phase completed successfully
        tx_note_ack_success(cd);
    else if (ints & PIO_IRQ0_INTE_SM0_BITS)
        // Bus is idle, but not all bits may have been flushed yet
        tx_line_may_start_transmit(cd);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ints & (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS))
|—————Node:( Text: (
|—————Node:binary_expression Text: ints & (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS)
|——————Node:identifier Text: ints
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: (PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS)
|———————Node:( Text: (
|———————Node:binary_expression Text: PIO_IRQ0_INTE_SM2_BITS|PIO_IRQ0_INTE_SM3_BITS
|————————Node:identifier Text: PIO_IRQ0_INTE_SM2_BITS
|————————Node:| Text: |
|————————Node:identifier Text: PIO_IRQ0_INTE_SM3_BITS
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:comment Text: // Ack phase completed successfully
|————Node:expression_statement Text: tx_note_ack_success(cd);
|—————Node:call_expression Text: tx_note_ack_success(cd)
|——————Node:identifier Text: tx_note_ack_success
|——————Node:argument_list Text: (cd)
|———————Node:( Text: (
|———————Node:identifier Text: cd
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:else_clause Text: else if (ints & PIO_IRQ0_INTE_SM0_BITS)
        // Bus is idle, but not all bits may have been flushed yet
        tx_line_may_start_transmit(cd);
|—————Node:else Text: else
|—————Node:if_statement Text: if (ints & PIO_IRQ0_INTE_SM0_BITS)
        // Bus is idle, but not all bits may have been flushed yet
        tx_line_may_start_transmit(cd);
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ints & PIO_IRQ0_INTE_SM0_BITS)
|———————Node:( Text: (
|———————Node:binary_expression Text: ints & PIO_IRQ0_INTE_SM0_BITS
|————————Node:identifier Text: ints
|————————Node:& Text: &
|————————Node:identifier Text: PIO_IRQ0_INTE_SM0_BITS
|———————Node:) Text: )
|——————Node:comment Text: // Bus is idle, but not all bits may have been flushed yet
|——————Node:expression_statement Text: tx_line_may_start_transmit(cd);
|———————Node:call_expression Text: tx_line_may_start_transmit(cd)
|————————Node:identifier Text: tx_line_may_start_transmit
|————————Node:argument_list Text: (cd)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:) Text: )
|———————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Transmit queuing
 ****************************************************************/
|—Node:comment Text: // API function to check if transmit space available
|—Node:function_definition Text: int
can2040_check_transmit(struct can2040 *cd)
{
    uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
    uint32_t tx_push_pos = cd->tx_push_pos;
    uint32_t pending = tx_push_pos - tx_pull_pos;
    return pending < ARRAY_SIZE(cd->tx_queue);
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: can2040_check_transmit(struct can2040 *cd)
|———Node:identifier Text: can2040_check_transmit
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
    uint32_t tx_push_pos = cd->tx_push_pos;
    uint32_t pending = tx_push_pos - tx_pull_pos;
    return pending < ARRAY_SIZE(cd->tx_queue);
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: tx_pull_pos = readl(&cd->tx_pull_pos)
|—————Node:identifier Text: tx_pull_pos
|—————Node:= Text: =
|—————Node:call_expression Text: readl(&cd->tx_pull_pos)
|——————Node:identifier Text: readl
|——————Node:argument_list Text: (&cd->tx_pull_pos)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &cd->tx_pull_pos
|————————Node:& Text: &
|————————Node:field_expression Text: cd->tx_pull_pos
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: tx_pull_pos
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t tx_push_pos = cd->tx_push_pos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: tx_push_pos = cd->tx_push_pos
|—————Node:identifier Text: tx_push_pos
|—————Node:= Text: =
|—————Node:field_expression Text: cd->tx_push_pos
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: tx_push_pos
|————Node:; Text: ;
|———Node:declaration Text: uint32_t pending = tx_push_pos - tx_pull_pos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: pending = tx_push_pos - tx_pull_pos
|—————Node:identifier Text: pending
|—————Node:= Text: =
|—————Node:binary_expression Text: tx_push_pos - tx_pull_pos
|——————Node:identifier Text: tx_push_pos
|——————Node:- Text: -
|——————Node:identifier Text: tx_pull_pos
|————Node:; Text: ;
|———Node:return_statement Text: return pending < ARRAY_SIZE(cd->tx_queue);
|————Node:return Text: return
|————Node:binary_expression Text: pending < ARRAY_SIZE(cd->tx_queue)
|—————Node:identifier Text: pending
|—————Node:< Text: <
|—————Node:call_expression Text: ARRAY_SIZE(cd->tx_queue)
|——————Node:identifier Text: ARRAY_SIZE
|——————Node:argument_list Text: (cd->tx_queue)
|———————Node:( Text: (
|———————Node:field_expression Text: cd->tx_queue
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_queue
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // API function to transmit a message
|—Node:function_definition Text: int
can2040_transmit(struct can2040 *cd, struct can2040_msg *msg)
{
    uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
    uint32_t tx_push_pos = cd->tx_push_pos;
    uint32_t pending = tx_push_pos - tx_pull_pos;
    if (pending >= ARRAY_SIZE(cd->tx_queue))
        // Tx queue full
        return -1;

    // Copy msg into transmit queue
    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, tx_push_pos)];
    uint32_t id = msg->id;
    if (id & CAN2040_ID_EFF)
        qt->msg.id = id & ~0x20000000;
    else
        qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff);
    qt->msg.dlc = msg->dlc & 0x0f;
    uint32_t data_len = qt->msg.dlc > 8 ? 8 : qt->msg.dlc;
    if (qt->msg.id & CAN2040_ID_RTR)
        data_len = 0;
    qt->msg.data32[0] = qt->msg.data32[1] = 0;
    memcpy(qt->msg.data, msg->data, data_len);

    // Calculate crc and stuff bits
    uint32_t crc = 0;
    memset(qt->stuffed_data, 0, sizeof(qt->stuffed_data));
    struct bitstuffer_s bs = { 1, 0, qt->stuffed_data };
    uint32_t edlc = qt->msg.dlc | (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0);
    if (qt->msg.id & CAN2040_ID_EFF) {
        // Extended header
        uint32_t id = qt->msg.id;
        uint32_t h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13);
        uint32_t h2 = ((id & 0x1fff) << 7) | edlc;
        crc = crcbits(crc, h1, 20);
        bs_push(&bs, h1, 19);
        crc = crcbits(crc, h2, 20);
        bs_push(&bs, h2, 20);
    } else {
        // Standard header
        uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
        crc = crcbits(crc, hdr, 20);
        bs_push(&bs, hdr, 19);
    }
    int i;
    for (i=0; i<data_len; i++) {
        uint32_t v = qt->msg.data[i];
        crc = crcbits(crc, v, 8);
        bs_push(&bs, v, 8);
    }
    qt->crc = crc & 0x7fff;
    bs_push(&bs, qt->crc, 15);
    bs_pushraw(&bs, 1, 1);
    qt->stuffed_words = bs_finalize(&bs);

    // Submit
    writel(&cd->tx_push_pos, tx_push_pos + 1);

    // Wakeup if in TS_IDLE state
    pio_sync_atomic_enable_may_start_tx_irq(cd);

    return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: can2040_transmit(struct can2040 *cd, struct can2040_msg *msg)
|———Node:identifier Text: can2040_transmit
|———Node:parameter_list Text: (struct can2040 *cd, struct can2040_msg *msg)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct can2040_msg *msg
|—————Node:struct_specifier Text: struct can2040_msg
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040_msg
|—————Node:pointer_declarator Text: *msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
    uint32_t tx_push_pos = cd->tx_push_pos;
    uint32_t pending = tx_push_pos - tx_pull_pos;
    if (pending >= ARRAY_SIZE(cd->tx_queue))
        // Tx queue full
        return -1;

    // Copy msg into transmit queue
    struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, tx_push_pos)];
    uint32_t id = msg->id;
    if (id & CAN2040_ID_EFF)
        qt->msg.id = id & ~0x20000000;
    else
        qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff);
    qt->msg.dlc = msg->dlc & 0x0f;
    uint32_t data_len = qt->msg.dlc > 8 ? 8 : qt->msg.dlc;
    if (qt->msg.id & CAN2040_ID_RTR)
        data_len = 0;
    qt->msg.data32[0] = qt->msg.data32[1] = 0;
    memcpy(qt->msg.data, msg->data, data_len);

    // Calculate crc and stuff bits
    uint32_t crc = 0;
    memset(qt->stuffed_data, 0, sizeof(qt->stuffed_data));
    struct bitstuffer_s bs = { 1, 0, qt->stuffed_data };
    uint32_t edlc = qt->msg.dlc | (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0);
    if (qt->msg.id & CAN2040_ID_EFF) {
        // Extended header
        uint32_t id = qt->msg.id;
        uint32_t h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13);
        uint32_t h2 = ((id & 0x1fff) << 7) | edlc;
        crc = crcbits(crc, h1, 20);
        bs_push(&bs, h1, 19);
        crc = crcbits(crc, h2, 20);
        bs_push(&bs, h2, 20);
    } else {
        // Standard header
        uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
        crc = crcbits(crc, hdr, 20);
        bs_push(&bs, hdr, 19);
    }
    int i;
    for (i=0; i<data_len; i++) {
        uint32_t v = qt->msg.data[i];
        crc = crcbits(crc, v, 8);
        bs_push(&bs, v, 8);
    }
    qt->crc = crc & 0x7fff;
    bs_push(&bs, qt->crc, 15);
    bs_pushraw(&bs, 1, 1);
    qt->stuffed_words = bs_finalize(&bs);

    // Submit
    writel(&cd->tx_push_pos, tx_push_pos + 1);

    // Wakeup if in TS_IDLE state
    pio_sync_atomic_enable_may_start_tx_irq(cd);

    return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t tx_pull_pos = readl(&cd->tx_pull_pos);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: tx_pull_pos = readl(&cd->tx_pull_pos)
|—————Node:identifier Text: tx_pull_pos
|—————Node:= Text: =
|—————Node:call_expression Text: readl(&cd->tx_pull_pos)
|——————Node:identifier Text: readl
|——————Node:argument_list Text: (&cd->tx_pull_pos)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &cd->tx_pull_pos
|————————Node:& Text: &
|————————Node:field_expression Text: cd->tx_pull_pos
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: tx_pull_pos
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: uint32_t tx_push_pos = cd->tx_push_pos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: tx_push_pos = cd->tx_push_pos
|—————Node:identifier Text: tx_push_pos
|—————Node:= Text: =
|—————Node:field_expression Text: cd->tx_push_pos
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: tx_push_pos
|————Node:; Text: ;
|———Node:declaration Text: uint32_t pending = tx_push_pos - tx_pull_pos;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: pending = tx_push_pos - tx_pull_pos
|—————Node:identifier Text: pending
|—————Node:= Text: =
|—————Node:binary_expression Text: tx_push_pos - tx_pull_pos
|——————Node:identifier Text: tx_push_pos
|——————Node:- Text: -
|——————Node:identifier Text: tx_pull_pos
|————Node:; Text: ;
|———Node:if_statement Text: if (pending >= ARRAY_SIZE(cd->tx_queue))
        // Tx queue full
        return -1;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (pending >= ARRAY_SIZE(cd->tx_queue))
|—————Node:( Text: (
|—————Node:binary_expression Text: pending >= ARRAY_SIZE(cd->tx_queue)
|——————Node:identifier Text: pending
|——————Node:>= Text: >=
|——————Node:call_expression Text: ARRAY_SIZE(cd->tx_queue)
|———————Node:identifier Text: ARRAY_SIZE
|———————Node:argument_list Text: (cd->tx_queue)
|————————Node:( Text: (
|————————Node:field_expression Text: cd->tx_queue
|—————————Node:identifier Text: cd
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: tx_queue
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:comment Text: // Tx queue full
|————Node:return_statement Text: return -1;
|—————Node:return Text: return
|—————Node:number_literal Text: -1
|—————Node:; Text: ;
|———Node:comment Text: // Copy msg into transmit queue
|———Node:declaration Text: struct can2040_transmit *qt = &cd->tx_queue[tx_qpos(cd, tx_push_pos)];
|————Node:struct_specifier Text: struct can2040_transmit
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can2040_transmit
|————Node:init_declarator Text: *qt = &cd->tx_queue[tx_qpos(cd, tx_push_pos)]
|—————Node:pointer_declarator Text: *qt
|——————Node:* Text: *
|——————Node:identifier Text: qt
|—————Node:= Text: =
|—————Node:pointer_expression Text: &cd->tx_queue[tx_qpos(cd, tx_push_pos)]
|——————Node:& Text: &
|——————Node:subscript_expression Text: cd->tx_queue[tx_qpos(cd, tx_push_pos)]
|———————Node:field_expression Text: cd->tx_queue
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_queue
|———————Node:[ Text: [
|———————Node:call_expression Text: tx_qpos(cd, tx_push_pos)
|————————Node:identifier Text: tx_qpos
|————————Node:argument_list Text: (cd, tx_push_pos)
|—————————Node:( Text: (
|—————————Node:identifier Text: cd
|—————————Node:, Text: ,
|—————————Node:identifier Text: tx_push_pos
|—————————Node:) Text: )
|———————Node:] Text: ]
|————Node:; Text: ;
|———Node:declaration Text: uint32_t id = msg->id;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: id = msg->id
|—————Node:identifier Text: id
|—————Node:= Text: =
|—————Node:field_expression Text: msg->id
|——————Node:identifier Text: msg
|——————Node:-> Text: ->
|——————Node:field_identifier Text: id
|————Node:; Text: ;
|———Node:if_statement Text: if (id & CAN2040_ID_EFF)
        qt->msg.id = id & ~0x20000000;
    else
        qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff);
|————Node:if Text: if
|————Node:parenthesized_expression Text: (id & CAN2040_ID_EFF)
|—————Node:( Text: (
|—————Node:binary_expression Text: id & CAN2040_ID_EFF
|——————Node:identifier Text: id
|——————Node:& Text: &
|——————Node:identifier Text: CAN2040_ID_EFF
|—————Node:) Text: )
|————Node:expression_statement Text: qt->msg.id = id & ~0x20000000;
|—————Node:assignment_expression Text: qt->msg.id = id & ~0x20000000
|——————Node:field_expression Text: qt->msg.id
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: id
|——————Node:= Text: =
|——————Node:binary_expression Text: id & ~0x20000000
|———————Node:identifier Text: id
|———————Node:& Text: &
|———————Node:unary_expression Text: ~0x20000000
|————————Node:~ Text: ~
|————————Node:number_literal Text: 0x20000000
|—————Node:; Text: ;
|————Node:else_clause Text: else
        qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff);
|—————Node:else Text: else
|—————Node:expression_statement Text: qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff);
|——————Node:assignment_expression Text: qt->msg.id = id & (CAN2040_ID_RTR | 0x7ff)
|———————Node:field_expression Text: qt->msg.id
|————————Node:field_expression Text: qt->msg
|—————————Node:identifier Text: qt
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: id & (CAN2040_ID_RTR | 0x7ff)
|————————Node:identifier Text: id
|————————Node:& Text: &
|————————Node:parenthesized_expression Text: (CAN2040_ID_RTR | 0x7ff)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: CAN2040_ID_RTR | 0x7ff
|——————————Node:identifier Text: CAN2040_ID_RTR
|——————————Node:| Text: |
|——————————Node:number_literal Text: 0x7ff
|—————————Node:) Text: )
|——————Node:; Text: ;
|———Node:expression_statement Text: qt->msg.dlc = msg->dlc & 0x0f;
|————Node:assignment_expression Text: qt->msg.dlc = msg->dlc & 0x0f
|—————Node:field_expression Text: qt->msg.dlc
|——————Node:field_expression Text: qt->msg
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: msg
|——————Node:. Text: .
|——————Node:field_identifier Text: dlc
|—————Node:= Text: =
|—————Node:binary_expression Text: msg->dlc & 0x0f
|——————Node:field_expression Text: msg->dlc
|———————Node:identifier Text: msg
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dlc
|——————Node:& Text: &
|——————Node:number_literal Text: 0x0f
|————Node:; Text: ;
|———Node:declaration Text: uint32_t data_len = qt->msg.dlc > 8 ? 8 : qt->msg.dlc;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: data_len = qt->msg.dlc > 8 ? 8 : qt->msg.dlc
|—————Node:identifier Text: data_len
|—————Node:= Text: =
|—————Node:conditional_expression Text: qt->msg.dlc > 8 ? 8 : qt->msg.dlc
|——————Node:binary_expression Text: qt->msg.dlc > 8
|———————Node:field_expression Text: qt->msg.dlc
|————————Node:field_expression Text: qt->msg
|—————————Node:identifier Text: qt
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: dlc
|———————Node:> Text: >
|———————Node:number_literal Text: 8
|——————Node:? Text: ?
|——————Node:number_literal Text: 8
|——————Node:: Text: :
|——————Node:field_expression Text: qt->msg.dlc
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: dlc
|————Node:; Text: ;
|———Node:if_statement Text: if (qt->msg.id & CAN2040_ID_RTR)
        data_len = 0;
|————Node:if Text: if
|————Node:parenthesized_expression Text: (qt->msg.id & CAN2040_ID_RTR)
|—————Node:( Text: (
|—————Node:binary_expression Text: qt->msg.id & CAN2040_ID_RTR
|——————Node:field_expression Text: qt->msg.id
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: id
|——————Node:& Text: &
|——————Node:identifier Text: CAN2040_ID_RTR
|—————Node:) Text: )
|————Node:expression_statement Text: data_len = 0;
|—————Node:assignment_expression Text: data_len = 0
|——————Node:identifier Text: data_len
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:expression_statement Text: qt->msg.data32[0] = qt->msg.data32[1] = 0;
|————Node:assignment_expression Text: qt->msg.data32[0] = qt->msg.data32[1] = 0
|—————Node:subscript_expression Text: qt->msg.data32[0]
|——————Node:field_expression Text: qt->msg.data32
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: data32
|——————Node:[ Text: [
|——————Node:number_literal Text: 0
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:assignment_expression Text: qt->msg.data32[1] = 0
|——————Node:subscript_expression Text: qt->msg.data32[1]
|———————Node:field_expression Text: qt->msg.data32
|————————Node:field_expression Text: qt->msg
|—————————Node:identifier Text: qt
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: data32
|———————Node:[ Text: [
|———————Node:number_literal Text: 1
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: memcpy(qt->msg.data, msg->data, data_len);
|————Node:call_expression Text: memcpy(qt->msg.data, msg->data, data_len)
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: (qt->msg.data, msg->data, data_len)
|——————Node:( Text: (
|——————Node:field_expression Text: qt->msg.data
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:, Text: ,
|——————Node:field_expression Text: msg->data
|———————Node:identifier Text: msg
|———————Node:-> Text: ->
|———————Node:field_identifier Text: data
|——————Node:, Text: ,
|——————Node:identifier Text: data_len
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Calculate crc and stuff bits
|———Node:declaration Text: uint32_t crc = 0;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: crc = 0
|—————Node:identifier Text: crc
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: memset(qt->stuffed_data, 0, sizeof(qt->stuffed_data));
|————Node:call_expression Text: memset(qt->stuffed_data, 0, sizeof(qt->stuffed_data))
|—————Node:identifier Text: memset
|—————Node:argument_list Text: (qt->stuffed_data, 0, sizeof(qt->stuffed_data))
|——————Node:( Text: (
|——————Node:field_expression Text: qt->stuffed_data
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stuffed_data
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(qt->stuffed_data)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (qt->stuffed_data)
|————————Node:( Text: (
|————————Node:field_expression Text: qt->stuffed_data
|—————————Node:identifier Text: qt
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: stuffed_data
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct bitstuffer_s bs = { 1, 0, qt->stuffed_data };
|————Node:struct_specifier Text: struct bitstuffer_s
|—————Node:struct Text: struct
|—————Node:type_identifier Text: bitstuffer_s
|————Node:init_declarator Text: bs = { 1, 0, qt->stuffed_data }
|—————Node:identifier Text: bs
|—————Node:= Text: =
|—————Node:initializer_list Text: { 1, 0, qt->stuffed_data }
|——————Node:{ Text: {
|——————Node:number_literal Text: 1
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:, Text: ,
|——————Node:field_expression Text: qt->stuffed_data
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: stuffed_data
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: uint32_t edlc = qt->msg.dlc | (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0);
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: edlc = qt->msg.dlc | (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0)
|—————Node:identifier Text: edlc
|—————Node:= Text: =
|—————Node:binary_expression Text: qt->msg.dlc | (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0)
|——————Node:field_expression Text: qt->msg.dlc
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: dlc
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: (qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0)
|———————Node:( Text: (
|———————Node:conditional_expression Text: qt->msg.id & CAN2040_ID_RTR ? 0x40 : 0
|————————Node:binary_expression Text: qt->msg.id & CAN2040_ID_RTR
|—————————Node:field_expression Text: qt->msg.id
|——————————Node:field_expression Text: qt->msg
|———————————Node:identifier Text: qt
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: msg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: id
|—————————Node:& Text: &
|—————————Node:identifier Text: CAN2040_ID_RTR
|————————Node:? Text: ?
|————————Node:number_literal Text: 0x40
|————————Node:: Text: :
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (qt->msg.id & CAN2040_ID_EFF) {
        // Extended header
        uint32_t id = qt->msg.id;
        uint32_t h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13);
        uint32_t h2 = ((id & 0x1fff) << 7) | edlc;
        crc = crcbits(crc, h1, 20);
        bs_push(&bs, h1, 19);
        crc = crcbits(crc, h2, 20);
        bs_push(&bs, h2, 20);
    } else {
        // Standard header
        uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
        crc = crcbits(crc, hdr, 20);
        bs_push(&bs, hdr, 19);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (qt->msg.id & CAN2040_ID_EFF)
|—————Node:( Text: (
|—————Node:binary_expression Text: qt->msg.id & CAN2040_ID_EFF
|——————Node:field_expression Text: qt->msg.id
|———————Node:field_expression Text: qt->msg
|————————Node:identifier Text: qt
|————————Node:-> Text: ->
|————————Node:field_identifier Text: msg
|———————Node:. Text: .
|———————Node:field_identifier Text: id
|——————Node:& Text: &
|——————Node:identifier Text: CAN2040_ID_EFF
|—————Node:) Text: )
|————Node:compound_statement Text: {
        // Extended header
        uint32_t id = qt->msg.id;
        uint32_t h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13);
        uint32_t h2 = ((id & 0x1fff) << 7) | edlc;
        crc = crcbits(crc, h1, 20);
        bs_push(&bs, h1, 19);
        crc = crcbits(crc, h2, 20);
        bs_push(&bs, h2, 20);
    }
|—————Node:{ Text: {
|—————Node:comment Text: // Extended header
|—————Node:declaration Text: uint32_t id = qt->msg.id;
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: id = qt->msg.id
|———————Node:identifier Text: id
|———————Node:= Text: =
|———————Node:field_expression Text: qt->msg.id
|————————Node:field_expression Text: qt->msg
|—————————Node:identifier Text: qt
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: msg
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|——————Node:; Text: ;
|—————Node:declaration Text: uint32_t h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13);
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: h1 = ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13)
|———————Node:identifier Text: h1
|———————Node:= Text: =
|———————Node:binary_expression Text: ((id & 0x1ffc0000) >> 11) | 0x60 | ((id & 0x3e000) >> 13)
|————————Node:binary_expression Text: ((id & 0x1ffc0000) >> 11) | 0x60
|—————————Node:parenthesized_expression Text: ((id & 0x1ffc0000) >> 11)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (id & 0x1ffc0000) >> 11
|———————————Node:parenthesized_expression Text: (id & 0x1ffc0000)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: id & 0x1ffc0000
|—————————————Node:identifier Text: id
|—————————————Node:& Text: &
|—————————————Node:number_literal Text: 0x1ffc0000
|————————————Node:) Text: )
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 11
|——————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:number_literal Text: 0x60
|————————Node:| Text: |
|————————Node:parenthesized_expression Text: ((id & 0x3e000) >> 13)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (id & 0x3e000) >> 13
|——————————Node:parenthesized_expression Text: (id & 0x3e000)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: id & 0x3e000
|————————————Node:identifier Text: id
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x3e000
|———————————Node:) Text: )
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 13
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: uint32_t h2 = ((id & 0x1fff) << 7) | edlc;
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: h2 = ((id & 0x1fff) << 7) | edlc
|———————Node:identifier Text: h2
|———————Node:= Text: =
|———————Node:binary_expression Text: ((id & 0x1fff) << 7) | edlc
|————————Node:parenthesized_expression Text: ((id & 0x1fff) << 7)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (id & 0x1fff) << 7
|——————————Node:parenthesized_expression Text: (id & 0x1fff)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: id & 0x1fff
|————————————Node:identifier Text: id
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x1fff
|———————————Node:) Text: )
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 7
|—————————Node:) Text: )
|————————Node:| Text: |
|————————Node:identifier Text: edlc
|——————Node:; Text: ;
|—————Node:expression_statement Text: crc = crcbits(crc, h1, 20);
|——————Node:assignment_expression Text: crc = crcbits(crc, h1, 20)
|———————Node:identifier Text: crc
|———————Node:= Text: =
|———————Node:call_expression Text: crcbits(crc, h1, 20)
|————————Node:identifier Text: crcbits
|————————Node:argument_list Text: (crc, h1, 20)
|—————————Node:( Text: (
|—————————Node:identifier Text: crc
|—————————Node:, Text: ,
|—————————Node:identifier Text: h1
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 20
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: bs_push(&bs, h1, 19);
|——————Node:call_expression Text: bs_push(&bs, h1, 19)
|———————Node:identifier Text: bs_push
|———————Node:argument_list Text: (&bs, h1, 19)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &bs
|—————————Node:& Text: &
|—————————Node:identifier Text: bs
|————————Node:, Text: ,
|————————Node:identifier Text: h1
|————————Node:, Text: ,
|————————Node:number_literal Text: 19
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: crc = crcbits(crc, h2, 20);
|——————Node:assignment_expression Text: crc = crcbits(crc, h2, 20)
|———————Node:identifier Text: crc
|———————Node:= Text: =
|———————Node:call_expression Text: crcbits(crc, h2, 20)
|————————Node:identifier Text: crcbits
|————————Node:argument_list Text: (crc, h2, 20)
|—————————Node:( Text: (
|—————————Node:identifier Text: crc
|—————————Node:, Text: ,
|—————————Node:identifier Text: h2
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 20
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: bs_push(&bs, h2, 20);
|——————Node:call_expression Text: bs_push(&bs, h2, 20)
|———————Node:identifier Text: bs_push
|———————Node:argument_list Text: (&bs, h2, 20)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &bs
|—————————Node:& Text: &
|—————————Node:identifier Text: bs
|————————Node:, Text: ,
|————————Node:identifier Text: h2
|————————Node:, Text: ,
|————————Node:number_literal Text: 20
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        // Standard header
        uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
        crc = crcbits(crc, hdr, 20);
        bs_push(&bs, hdr, 19);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        // Standard header
        uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
        crc = crcbits(crc, hdr, 20);
        bs_push(&bs, hdr, 19);
    }
|——————Node:{ Text: {
|——————Node:comment Text: // Standard header
|——————Node:declaration Text: uint32_t hdr = ((qt->msg.id & 0x7ff) << 7) | edlc;
|———————Node:primitive_type Text: uint32_t
|———————Node:init_declarator Text: hdr = ((qt->msg.id & 0x7ff) << 7) | edlc
|————————Node:identifier Text: hdr
|————————Node:= Text: =
|————————Node:binary_expression Text: ((qt->msg.id & 0x7ff) << 7) | edlc
|—————————Node:parenthesized_expression Text: ((qt->msg.id & 0x7ff) << 7)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (qt->msg.id & 0x7ff) << 7
|———————————Node:parenthesized_expression Text: (qt->msg.id & 0x7ff)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: qt->msg.id & 0x7ff
|—————————————Node:field_expression Text: qt->msg.id
|——————————————Node:field_expression Text: qt->msg
|———————————————Node:identifier Text: qt
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: msg
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: id
|—————————————Node:& Text: &
|—————————————Node:number_literal Text: 0x7ff
|————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 7
|——————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:identifier Text: edlc
|———————Node:; Text: ;
|——————Node:expression_statement Text: crc = crcbits(crc, hdr, 20);
|———————Node:assignment_expression Text: crc = crcbits(crc, hdr, 20)
|————————Node:identifier Text: crc
|————————Node:= Text: =
|————————Node:call_expression Text: crcbits(crc, hdr, 20)
|—————————Node:identifier Text: crcbits
|—————————Node:argument_list Text: (crc, hdr, 20)
|——————————Node:( Text: (
|——————————Node:identifier Text: crc
|——————————Node:, Text: ,
|——————————Node:identifier Text: hdr
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 20
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: bs_push(&bs, hdr, 19);
|———————Node:call_expression Text: bs_push(&bs, hdr, 19)
|————————Node:identifier Text: bs_push
|————————Node:argument_list Text: (&bs, hdr, 19)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &bs
|——————————Node:& Text: &
|——————————Node:identifier Text: bs
|—————————Node:, Text: ,
|—————————Node:identifier Text: hdr
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 19
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:declaration Text: int i;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:for_statement Text: for (i=0; i<data_len; i++) {
        uint32_t v = qt->msg.data[i];
        crc = crcbits(crc, v, 8);
        bs_push(&bs, v, 8);
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: i=0
|—————Node:identifier Text: i
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: i<data_len
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: data_len
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
        uint32_t v = qt->msg.data[i];
        crc = crcbits(crc, v, 8);
        bs_push(&bs, v, 8);
    }
|—————Node:{ Text: {
|—————Node:declaration Text: uint32_t v = qt->msg.data[i];
|——————Node:primitive_type Text: uint32_t
|——————Node:init_declarator Text: v = qt->msg.data[i]
|———————Node:identifier Text: v
|———————Node:= Text: =
|———————Node:subscript_expression Text: qt->msg.data[i]
|————————Node:field_expression Text: qt->msg.data
|—————————Node:field_expression Text: qt->msg
|——————————Node:identifier Text: qt
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: msg
|—————————Node:. Text: .
|—————————Node:field_identifier Text: data
|————————Node:[ Text: [
|————————Node:identifier Text: i
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: crc = crcbits(crc, v, 8);
|——————Node:assignment_expression Text: crc = crcbits(crc, v, 8)
|———————Node:identifier Text: crc
|———————Node:= Text: =
|———————Node:call_expression Text: crcbits(crc, v, 8)
|————————Node:identifier Text: crcbits
|————————Node:argument_list Text: (crc, v, 8)
|—————————Node:( Text: (
|—————————Node:identifier Text: crc
|—————————Node:, Text: ,
|—————————Node:identifier Text: v
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 8
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: bs_push(&bs, v, 8);
|——————Node:call_expression Text: bs_push(&bs, v, 8)
|———————Node:identifier Text: bs_push
|———————Node:argument_list Text: (&bs, v, 8)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &bs
|—————————Node:& Text: &
|—————————Node:identifier Text: bs
|————————Node:, Text: ,
|————————Node:identifier Text: v
|————————Node:, Text: ,
|————————Node:number_literal Text: 8
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: qt->crc = crc & 0x7fff;
|————Node:assignment_expression Text: qt->crc = crc & 0x7fff
|—————Node:field_expression Text: qt->crc
|——————Node:identifier Text: qt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: crc
|—————Node:= Text: =
|—————Node:binary_expression Text: crc & 0x7fff
|——————Node:identifier Text: crc
|——————Node:& Text: &
|——————Node:number_literal Text: 0x7fff
|————Node:; Text: ;
|———Node:expression_statement Text: bs_push(&bs, qt->crc, 15);
|————Node:call_expression Text: bs_push(&bs, qt->crc, 15)
|—————Node:identifier Text: bs_push
|—————Node:argument_list Text: (&bs, qt->crc, 15)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &bs
|———————Node:& Text: &
|———————Node:identifier Text: bs
|——————Node:, Text: ,
|——————Node:field_expression Text: qt->crc
|———————Node:identifier Text: qt
|———————Node:-> Text: ->
|———————Node:field_identifier Text: crc
|——————Node:, Text: ,
|——————Node:number_literal Text: 15
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: bs_pushraw(&bs, 1, 1);
|————Node:call_expression Text: bs_pushraw(&bs, 1, 1)
|—————Node:identifier Text: bs_pushraw
|—————Node:argument_list Text: (&bs, 1, 1)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &bs
|———————Node:& Text: &
|———————Node:identifier Text: bs
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:, Text: ,
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: qt->stuffed_words = bs_finalize(&bs);
|————Node:assignment_expression Text: qt->stuffed_words = bs_finalize(&bs)
|—————Node:field_expression Text: qt->stuffed_words
|——————Node:identifier Text: qt
|——————Node:-> Text: ->
|——————Node:field_identifier Text: stuffed_words
|—————Node:= Text: =
|—————Node:call_expression Text: bs_finalize(&bs)
|——————Node:identifier Text: bs_finalize
|——————Node:argument_list Text: (&bs)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &bs
|————————Node:& Text: &
|————————Node:identifier Text: bs
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Submit
|———Node:expression_statement Text: writel(&cd->tx_push_pos, tx_push_pos + 1);
|————Node:call_expression Text: writel(&cd->tx_push_pos, tx_push_pos + 1)
|—————Node:identifier Text: writel
|—————Node:argument_list Text: (&cd->tx_push_pos, tx_push_pos + 1)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &cd->tx_push_pos
|———————Node:& Text: &
|———————Node:field_expression Text: cd->tx_push_pos
|————————Node:identifier Text: cd
|————————Node:-> Text: ->
|————————Node:field_identifier Text: tx_push_pos
|——————Node:, Text: ,
|——————Node:binary_expression Text: tx_push_pos + 1
|———————Node:identifier Text: tx_push_pos
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Wakeup if in TS_IDLE state
|———Node:expression_statement Text: pio_sync_atomic_enable_may_start_tx_irq(cd);
|————Node:call_expression Text: pio_sync_atomic_enable_may_start_tx_irq(cd)
|—————Node:identifier Text: pio_sync_atomic_enable_may_start_tx_irq
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /****************************************************************
 * Setup
 ****************************************************************/
|—Node:comment Text: // API function to initialize can2040 code
|—Node:function_definition Text: void
can2040_setup(struct can2040 *cd, uint32_t pio_num)
{
    memset(cd, 0, sizeof(*cd));
    cd->pio_num = !!pio_num;
    cd->pio_hw = cd->pio_num ? pio1_hw : pio0_hw;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can2040_setup(struct can2040 *cd, uint32_t pio_num)
|———Node:identifier Text: can2040_setup
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t pio_num)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t pio_num
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: pio_num
|————Node:) Text: )
|——Node:compound_statement Text: {
    memset(cd, 0, sizeof(*cd));
    cd->pio_num = !!pio_num;
    cd->pio_hw = cd->pio_num ? pio1_hw : pio0_hw;
}
|———Node:{ Text: {
|———Node:expression_statement Text: memset(cd, 0, sizeof(*cd));
|————Node:call_expression Text: memset(cd, 0, sizeof(*cd))
|—————Node:identifier Text: memset
|—————Node:argument_list Text: (cd, 0, sizeof(*cd))
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(*cd)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (*cd)
|————————Node:( Text: (
|————————Node:pointer_expression Text: *cd
|—————————Node:* Text: *
|—————————Node:identifier Text: cd
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: cd->pio_num = !!pio_num;
|————Node:assignment_expression Text: cd->pio_num = !!pio_num
|—————Node:field_expression Text: cd->pio_num
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_num
|—————Node:= Text: =
|—————Node:unary_expression Text: !!pio_num
|——————Node:! Text: !
|——————Node:unary_expression Text: !pio_num
|———————Node:! Text: !
|———————Node:identifier Text: pio_num
|————Node:; Text: ;
|———Node:expression_statement Text: cd->pio_hw = cd->pio_num ? pio1_hw : pio0_hw;
|————Node:assignment_expression Text: cd->pio_hw = cd->pio_num ? pio1_hw : pio0_hw
|—————Node:field_expression Text: cd->pio_hw
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: pio_hw
|—————Node:= Text: =
|—————Node:conditional_expression Text: cd->pio_num ? pio1_hw : pio0_hw
|——————Node:field_expression Text: cd->pio_num
|———————Node:identifier Text: cd
|———————Node:-> Text: ->
|———————Node:field_identifier Text: pio_num
|——————Node:? Text: ?
|——————Node:identifier Text: pio1_hw
|——————Node:: Text: :
|——————Node:identifier Text: pio0_hw
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // API function to configure callback
|—Node:function_definition Text: void
can2040_callback_config(struct can2040 *cd, can2040_rx_cb rx_cb)
{
    cd->rx_cb = rx_cb;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can2040_callback_config(struct can2040 *cd, can2040_rx_cb rx_cb)
|———Node:identifier Text: can2040_callback_config
|———Node:parameter_list Text: (struct can2040 *cd, can2040_rx_cb rx_cb)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: can2040_rx_cb rx_cb
|—————Node:type_identifier Text: can2040_rx_cb
|—————Node:identifier Text: rx_cb
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->rx_cb = rx_cb;
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->rx_cb = rx_cb;
|————Node:assignment_expression Text: cd->rx_cb = rx_cb
|—————Node:field_expression Text: cd->rx_cb
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rx_cb
|—————Node:= Text: =
|—————Node:identifier Text: rx_cb
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // API function to start CANbus interface
|—Node:function_definition Text: void
can2040_start(struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate
              , uint32_t gpio_rx, uint32_t gpio_tx)
{
    cd->gpio_rx = gpio_rx;
    cd->gpio_tx = gpio_tx;
    pio_setup(cd, sys_clock, bitrate);
    data_state_go_discard(cd);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can2040_start(struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate
              , uint32_t gpio_rx, uint32_t gpio_tx)
|———Node:identifier Text: can2040_start
|———Node:parameter_list Text: (struct can2040 *cd, uint32_t sys_clock, uint32_t bitrate
              , uint32_t gpio_rx, uint32_t gpio_tx)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t sys_clock
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: sys_clock
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t bitrate
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: bitrate
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t gpio_rx
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: gpio_rx
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t gpio_tx
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: gpio_tx
|————Node:) Text: )
|——Node:compound_statement Text: {
    cd->gpio_rx = gpio_rx;
    cd->gpio_tx = gpio_tx;
    pio_setup(cd, sys_clock, bitrate);
    data_state_go_discard(cd);
}
|———Node:{ Text: {
|———Node:expression_statement Text: cd->gpio_rx = gpio_rx;
|————Node:assignment_expression Text: cd->gpio_rx = gpio_rx
|—————Node:field_expression Text: cd->gpio_rx
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: gpio_rx
|—————Node:= Text: =
|—————Node:identifier Text: gpio_rx
|————Node:; Text: ;
|———Node:expression_statement Text: cd->gpio_tx = gpio_tx;
|————Node:assignment_expression Text: cd->gpio_tx = gpio_tx
|—————Node:field_expression Text: cd->gpio_tx
|——————Node:identifier Text: cd
|——————Node:-> Text: ->
|——————Node:field_identifier Text: gpio_tx
|—————Node:= Text: =
|—————Node:identifier Text: gpio_tx
|————Node:; Text: ;
|———Node:expression_statement Text: pio_setup(cd, sys_clock, bitrate);
|————Node:call_expression Text: pio_setup(cd, sys_clock, bitrate)
|—————Node:identifier Text: pio_setup
|—————Node:argument_list Text: (cd, sys_clock, bitrate)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:, Text: ,
|——————Node:identifier Text: sys_clock
|——————Node:, Text: ,
|——————Node:identifier Text: bitrate
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: data_state_go_discard(cd);
|————Node:call_expression Text: data_state_go_discard(cd)
|—————Node:identifier Text: data_state_go_discard
|—————Node:argument_list Text: (cd)
|——————Node:( Text: (
|——————Node:identifier Text: cd
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: // API function to stop and uninitialize can2040 code
|—Node:function_definition Text: void
can2040_shutdown(struct can2040 *cd)
{
    // XXX
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can2040_shutdown(struct can2040 *cd)
|———Node:identifier Text: can2040_shutdown
|———Node:parameter_list Text: (struct can2040 *cd)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can2040 *cd
|—————Node:struct_specifier Text: struct can2040
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can2040
|—————Node:pointer_declarator Text: *cd
|——————Node:* Text: *
|——————Node:identifier Text: cd
|————Node:) Text: )
|——Node:compound_statement Text: {
    // XXX
}
|———Node:{ Text: {
|———Node:comment Text: // XXX
|———Node:} Text: }
