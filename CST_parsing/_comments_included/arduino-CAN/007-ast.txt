arduino-CAN-src\MCP2515.cpp

|Node:translation_unit
|—Node:comment Text: // Copyright (c) Sandeep Mistry. All rights reserved.
|—Node:comment Text: // Licensed under the MIT license. See LICENSE file in the project root for full license information.
|—Node:preproc_ifdef Text: #ifndef ARDUINO_ARCH_ESP32

#include "MCP2515.h"

#define REG_BFPCTRL                0x0c
#define REG_TXRTSCTRL              0x0d

#define REG_CANCTRL                0x0f

#define REG_CNF3                   0x28
#define REG_CNF2                   0x29
#define REG_CNF1                   0x2a

#define REG_CANINTE                0x2b
#define REG_CANINTF                0x2c

#define FLAG_RXnIE(n)              (0x01 << n)
#define FLAG_RXnIF(n)              (0x01 << n)
#define FLAG_TXnIF(n)              (0x04 << n)

#define REG_RXFnSIDH(n)            (0x00 + (n * 4))
#define REG_RXFnSIDL(n)            (0x01 + (n * 4))
#define REG_RXFnEID8(n)            (0x02 + (n * 4))
#define REG_RXFnEID0(n)            (0x03 + (n * 4))

#define REG_RXMnSIDH(n)            (0x20 + (n * 0x04))
#define REG_RXMnSIDL(n)            (0x21 + (n * 0x04))
#define REG_RXMnEID8(n)            (0x22 + (n * 0x04))
#define REG_RXMnEID0(n)            (0x23 + (n * 0x04))

#define REG_TXBnCTRL(n)            (0x30 + (n * 0x10))
#define REG_TXBnSIDH(n)            (0x31 + (n * 0x10))
#define REG_TXBnSIDL(n)            (0x32 + (n * 0x10))
#define REG_TXBnEID8(n)            (0x33 + (n * 0x10))
#define REG_TXBnEID0(n)            (0x34 + (n * 0x10))
#define REG_TXBnDLC(n)             (0x35 + (n * 0x10))
#define REG_TXBnD0(n)              (0x36 + (n * 0x10))

#define REG_RXBnCTRL(n)            (0x60 + (n * 0x10))
#define REG_RXBnSIDH(n)            (0x61 + (n * 0x10))
#define REG_RXBnSIDL(n)            (0x62 + (n * 0x10))
#define REG_RXBnEID8(n)            (0x63 + (n * 0x10))
#define REG_RXBnEID0(n)            (0x64 + (n * 0x10))
#define REG_RXBnDLC(n)             (0x65 + (n * 0x10))
#define REG_RXBnD0(n)              (0x66 + (n * 0x10))

#define FLAG_IDE                   0x08
#define FLAG_SRR                   0x10
#define FLAG_RTR                   0x40
#define FLAG_EXIDE                 0x08

#define FLAG_RXM0                  0x20
#define FLAG_RXM1                  0x40


MCP2515Class::MCP2515Class() :
  CANControllerClass(),
  _spiSettings(10E6, MSBFIRST, SPI_MODE0),
  _csPin(MCP2515_DEFAULT_CS_PIN),
  _intPin(MCP2515_DEFAULT_INT_PIN),
  _clockFrequency(MCP2515_DEFAULT_CLOCK_FREQUENCY)
{
}

MCP2515Class::~MCP2515Class()
{
}

int MCP2515Class::begin(long baudRate)
{
  CANControllerClass::begin(baudRate);

  pinMode(_csPin, OUTPUT);

  // start SPI
  SPI.begin();

  reset();

  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  const struct {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  } CNF_MAPPER[] = {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  };

  const uint8_t* cnf = NULL;

  for (unsigned int i = 0; i < (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0])); i++) {
    if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
  }

  if (cnf == NULL) {
    return 0;
  }

  writeRegister(REG_CNF1, cnf[0]);
  writeRegister(REG_CNF2, cnf[1]);
  writeRegister(REG_CNF3, cnf[2]);

  writeRegister(REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0));
  writeRegister(REG_BFPCTRL, 0x00);
  writeRegister(REG_TXRTSCTRL, 0x00);
  writeRegister(REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0);
  writeRegister(REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0);

  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}

void MCP2515Class::end()
{
  SPI.end();

  CANControllerClass::end();
}

int MCP2515Class::endPacket()
{
  if (!CANControllerClass::endPacket()) {
    return 0;
  }

  int n = 0;

  if (_txExtended) {
    writeRegister(REG_TXBnSIDH(n), _txId >> 21);
    writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
    writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
    writeRegister(REG_TXBnEID0(n), _txId & 0xff);
  } else {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }

  if (_txRtr) {
    writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
  } else {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }

  writeRegister(REG_TXBnCTRL(n), 0x08);

  bool aborted = false;

  while (readRegister(REG_TXBnCTRL(n)) & 0x08) {
    if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }

    yield();
  }

  if (aborted) {
    // clear abort command
    modifyRegister(REG_CANCTRL, 0x10, 0x00);
  }

  modifyRegister(REG_CANINTF, FLAG_TXnIF(n), 0x00);

  return (readRegister(REG_TXBnCTRL(n)) & 0x70) ? 0 : 1;
}

int MCP2515Class::parsePacket()
{
  int n;

  uint8_t intf = readRegister(REG_CANINTF);

  if (intf & FLAG_RXnIF(0)) {
    n = 0;
  } else if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }

  _rxExtended = (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false;

  uint32_t idA = ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07);
  if (_rxExtended) {
    uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));

    _rxId = (idA << 18) | idB;
    _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
  } else {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
  _rxDlc = readRegister(REG_RXBnDLC(n)) & 0x0f;
  _rxIndex = 0;

  if (_rxRtr) {
    _rxLength = 0;
  } else {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }

  modifyRegister(REG_CANINTF, FLAG_RXnIF(n), 0x00);

  return _rxDlc;
}

void MCP2515Class::onReceive(void(*callback)(int))
{
  CANControllerClass::onReceive(callback);

  pinMode(_intPin, INPUT);

  if (callback) {
    SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
    attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
  } else {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
}

int MCP2515Class::filter(int id, int mask)
{
  id &= 0x7ff;
  mask &= 0x7ff;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // standard only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);

    writeRegister(REG_RXMnSIDH(n), mask >> 3);
    writeRegister(REG_RXMnSIDL(n), mask << 5);
    writeRegister(REG_RXMnEID8(n), 0);
    writeRegister(REG_RXMnEID0(n), 0);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 3);
    writeRegister(REG_RXFnSIDL(n), id << 5);
    writeRegister(REG_RXFnEID8(n), 0);
    writeRegister(REG_RXFnEID0(n), 0);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}

int MCP2515Class::filterExtended(long id, long mask)
{
  id &= 0x1FFFFFFF;
  mask &= 0x1FFFFFFF;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // extended only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);

    writeRegister(REG_RXMnSIDH(n), mask >> 21);
    writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
    writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
    writeRegister(REG_RXMnEID0(n), mask & 0xff);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 21);
    writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
    writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
    writeRegister(REG_RXFnEID0(n), id & 0xff);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}

int MCP2515Class::observe()
{
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  return 1;
}

int MCP2515Class::loopback()
{
  writeRegister(REG_CANCTRL, 0x40);
  if (readRegister(REG_CANCTRL) != 0x40) {
    return 0;
  }

  return 1;
}

int MCP2515Class::sleep()
{
  writeRegister(REG_CANCTRL, 0x01);
  if (readRegister(REG_CANCTRL) != 0x01) {
    return 0;
  }

  return 1;
}

int MCP2515Class::wakeup()
{
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}

void MCP2515Class::setPins(int cs, int irq)
{
  _csPin = cs;
  _intPin = irq;
}

void MCP2515Class::setSPIFrequency(uint32_t frequency)
{
  _spiSettings = SPISettings(frequency, MSBFIRST, SPI_MODE0);
}

void MCP2515Class::setClockFrequency(long clockFrequency)
{
  _clockFrequency = clockFrequency;
}

void MCP2515Class::dumpRegisters(Stream& out)
{
  for (int i = 0; i < 128; i++) {
    byte b = readRegister(i);

    out.print("0x");
    if (i < 16) {
      out.print('0');
    }
    out.print(i, HEX);
    out.print(": 0x");
    if (b < 16) {
      out.print('0');
    }
    out.println(b, HEX);
  }
}

void MCP2515Class::reset()
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0xc0);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  delayMicroseconds(10);
}

void MCP2515Class::handleInterrupt()
{
  if (readRegister(REG_CANINTF) == 0) {
    return;
  }

  while (parsePacket() || _rxId != -1) {
    _onReceive(available());
  }
}

uint8_t MCP2515Class::readRegister(uint8_t address)
{
  uint8_t value;

  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x03);
  SPI.transfer(address);
  value = SPI.transfer(0x00);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  return value;
}

void MCP2515Class::modifyRegister(uint8_t address, uint8_t mask, uint8_t value)
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x05);
  SPI.transfer(address);
  SPI.transfer(mask);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}

void MCP2515Class::writeRegister(uint8_t address, uint8_t value)
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x02);
  SPI.transfer(address);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}

void MCP2515Class::onInterrupt()
{
  CAN.handleInterrupt();
}

MCP2515Class CAN;

#endif
|——Node:#ifndef Text: #ifndef
|——Node:identifier Text: ARDUINO_ARCH_ESP32
|——Node:preproc_include Text: #include "MCP2515.h"

|———Node:#include Text: #include
|———Node:string_literal Text: "MCP2515.h"
|————Node:" Text: "
|————Node:string_content Text: MCP2515.h
|————Node:" Text: "
|——Node:preproc_def Text: #define REG_BFPCTRL                0x0c

|———Node:#define Text: #define
|———Node:identifier Text: REG_BFPCTRL
|———Node:preproc_arg Text: 0x0c
|——Node:preproc_def Text: #define REG_TXRTSCTRL              0x0d

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXRTSCTRL
|———Node:preproc_arg Text: 0x0d
|——Node:preproc_def Text: #define REG_CANCTRL                0x0f

|———Node:#define Text: #define
|———Node:identifier Text: REG_CANCTRL
|———Node:preproc_arg Text: 0x0f
|——Node:preproc_def Text: #define REG_CNF3                   0x28

|———Node:#define Text: #define
|———Node:identifier Text: REG_CNF3
|———Node:preproc_arg Text: 0x28
|——Node:preproc_def Text: #define REG_CNF2                   0x29

|———Node:#define Text: #define
|———Node:identifier Text: REG_CNF2
|———Node:preproc_arg Text: 0x29
|——Node:preproc_def Text: #define REG_CNF1                   0x2a

|———Node:#define Text: #define
|———Node:identifier Text: REG_CNF1
|———Node:preproc_arg Text: 0x2a
|——Node:preproc_def Text: #define REG_CANINTE                0x2b

|———Node:#define Text: #define
|———Node:identifier Text: REG_CANINTE
|———Node:preproc_arg Text: 0x2b
|——Node:preproc_def Text: #define REG_CANINTF                0x2c

|———Node:#define Text: #define
|———Node:identifier Text: REG_CANINTF
|———Node:preproc_arg Text: 0x2c
|——Node:preproc_function_def Text: #define FLAG_RXnIE(n)              (0x01 << n)

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_RXnIE
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x01 << n)
|——Node:preproc_function_def Text: #define FLAG_RXnIF(n)              (0x01 << n)

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_RXnIF
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x01 << n)
|——Node:preproc_function_def Text: #define FLAG_TXnIF(n)              (0x04 << n)

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_TXnIF
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x04 << n)
|——Node:preproc_function_def Text: #define REG_RXFnSIDH(n)            (0x00 + (n * 4))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXFnSIDH
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x00 + (n * 4))
|——Node:preproc_function_def Text: #define REG_RXFnSIDL(n)            (0x01 + (n * 4))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXFnSIDL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x01 + (n * 4))
|——Node:preproc_function_def Text: #define REG_RXFnEID8(n)            (0x02 + (n * 4))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXFnEID8
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x02 + (n * 4))
|——Node:preproc_function_def Text: #define REG_RXFnEID0(n)            (0x03 + (n * 4))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXFnEID0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x03 + (n * 4))
|——Node:preproc_function_def Text: #define REG_RXMnSIDH(n)            (0x20 + (n * 0x04))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXMnSIDH
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x20 + (n * 0x04))
|——Node:preproc_function_def Text: #define REG_RXMnSIDL(n)            (0x21 + (n * 0x04))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXMnSIDL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x21 + (n * 0x04))
|——Node:preproc_function_def Text: #define REG_RXMnEID8(n)            (0x22 + (n * 0x04))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXMnEID8
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x22 + (n * 0x04))
|——Node:preproc_function_def Text: #define REG_RXMnEID0(n)            (0x23 + (n * 0x04))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXMnEID0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x23 + (n * 0x04))
|——Node:preproc_function_def Text: #define REG_TXBnCTRL(n)            (0x30 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnCTRL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x30 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnSIDH(n)            (0x31 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnSIDH
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x31 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnSIDL(n)            (0x32 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnSIDL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x32 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnEID8(n)            (0x33 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnEID8
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x33 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnEID0(n)            (0x34 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnEID0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x34 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnDLC(n)             (0x35 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnDLC
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x35 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_TXBnD0(n)              (0x36 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_TXBnD0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x36 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnCTRL(n)            (0x60 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnCTRL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x60 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnSIDH(n)            (0x61 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnSIDH
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x61 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnSIDL(n)            (0x62 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnSIDL
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x62 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnEID8(n)            (0x63 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnEID8
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x63 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnEID0(n)            (0x64 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnEID0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x64 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnDLC(n)             (0x65 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnDLC
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x65 + (n * 0x10))
|——Node:preproc_function_def Text: #define REG_RXBnD0(n)              (0x66 + (n * 0x10))

|———Node:#define Text: #define
|———Node:identifier Text: REG_RXBnD0
|———Node:preproc_params Text: (n)
|————Node:( Text: (
|————Node:identifier Text: n
|————Node:) Text: )
|———Node:preproc_arg Text: (0x66 + (n * 0x10))
|——Node:preproc_def Text: #define FLAG_IDE                   0x08

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_IDE
|———Node:preproc_arg Text: 0x08
|——Node:preproc_def Text: #define FLAG_SRR                   0x10

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_SRR
|———Node:preproc_arg Text: 0x10
|——Node:preproc_def Text: #define FLAG_RTR                   0x40

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_RTR
|———Node:preproc_arg Text: 0x40
|——Node:preproc_def Text: #define FLAG_EXIDE                 0x08

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_EXIDE
|———Node:preproc_arg Text: 0x08
|——Node:preproc_def Text: #define FLAG_RXM0                  0x20

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_RXM0
|———Node:preproc_arg Text: 0x20
|——Node:preproc_def Text: #define FLAG_RXM1                  0x40

|———Node:#define Text: #define
|———Node:identifier Text: FLAG_RXM1
|———Node:preproc_arg Text: 0x40
|——Node:function_definition Text: MCP2515Class::MCP2515Class() :
  CANControllerClass(),
  _spiSettings(10E6, MSBFIRST, SPI_MODE0),
  _csPin(MCP2515_DEFAULT_CS_PIN),
  _intPin(MCP2515_DEFAULT_INT_PIN),
  _clockFrequency(MCP2515_DEFAULT_CLOCK_FREQUENCY)
{
}
|———Node:function_declarator Text: MCP2515Class::MCP2515Class()
|————Node:qualified_identifier Text: MCP2515Class::MCP2515Class
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: MCP2515Class
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:field_initializer_list Text: :
  CANControllerClass(),
  _spiSettings(10E6, MSBFIRST, SPI_MODE0),
  _csPin(MCP2515_DEFAULT_CS_PIN),
  _intPin(MCP2515_DEFAULT_INT_PIN),
  _clockFrequency(MCP2515_DEFAULT_CLOCK_FREQUENCY)
|————Node:: Text: :
|————Node:field_initializer Text: CANControllerClass()
|—————Node:field_identifier Text: CANControllerClass
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:, Text: ,
|————Node:field_initializer Text: _spiSettings(10E6, MSBFIRST, SPI_MODE0)
|—————Node:field_identifier Text: _spiSettings
|—————Node:argument_list Text: (10E6, MSBFIRST, SPI_MODE0)
|——————Node:( Text: (
|——————Node:number_literal Text: 10E6
|——————Node:, Text: ,
|——————Node:identifier Text: MSBFIRST
|——————Node:, Text: ,
|——————Node:identifier Text: SPI_MODE0
|——————Node:) Text: )
|————Node:, Text: ,
|————Node:field_initializer Text: _csPin(MCP2515_DEFAULT_CS_PIN)
|—————Node:field_identifier Text: _csPin
|—————Node:argument_list Text: (MCP2515_DEFAULT_CS_PIN)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_DEFAULT_CS_PIN
|——————Node:) Text: )
|————Node:, Text: ,
|————Node:field_initializer Text: _intPin(MCP2515_DEFAULT_INT_PIN)
|—————Node:field_identifier Text: _intPin
|—————Node:argument_list Text: (MCP2515_DEFAULT_INT_PIN)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_DEFAULT_INT_PIN
|——————Node:) Text: )
|————Node:, Text: ,
|————Node:field_initializer Text: _clockFrequency(MCP2515_DEFAULT_CLOCK_FREQUENCY)
|—————Node:field_identifier Text: _clockFrequency
|—————Node:argument_list Text: (MCP2515_DEFAULT_CLOCK_FREQUENCY)
|——————Node:( Text: (
|——————Node:identifier Text: MCP2515_DEFAULT_CLOCK_FREQUENCY
|——————Node:) Text: )
|———Node:compound_statement Text: {
}
|————Node:{ Text: {
|————Node:} Text: }
|——Node:function_definition Text: MCP2515Class::~MCP2515Class()
{
}
|———Node:function_declarator Text: MCP2515Class::~MCP2515Class()
|————Node:qualified_identifier Text: MCP2515Class::~MCP2515Class
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:destructor_name Text: ~MCP2515Class
|——————Node:~ Text: ~
|——————Node:identifier Text: MCP2515Class
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
}
|————Node:{ Text: {
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::begin(long baudRate)
{
  CANControllerClass::begin(baudRate);

  pinMode(_csPin, OUTPUT);

  // start SPI
  SPI.begin();

  reset();

  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  const struct {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  } CNF_MAPPER[] = {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  };

  const uint8_t* cnf = NULL;

  for (unsigned int i = 0; i < (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0])); i++) {
    if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
  }

  if (cnf == NULL) {
    return 0;
  }

  writeRegister(REG_CNF1, cnf[0]);
  writeRegister(REG_CNF2, cnf[1]);
  writeRegister(REG_CNF3, cnf[2]);

  writeRegister(REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0));
  writeRegister(REG_BFPCTRL, 0x00);
  writeRegister(REG_TXRTSCTRL, 0x00);
  writeRegister(REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0);
  writeRegister(REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0);

  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::begin(long baudRate)
|————Node:qualified_identifier Text: MCP2515Class::begin
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: begin
|————Node:parameter_list Text: (long baudRate)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: long baudRate
|——————Node:sized_type_specifier Text: long
|———————Node:long Text: long
|——————Node:identifier Text: baudRate
|—————Node:) Text: )
|———Node:compound_statement Text: {
  CANControllerClass::begin(baudRate);

  pinMode(_csPin, OUTPUT);

  // start SPI
  SPI.begin();

  reset();

  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  const struct {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  } CNF_MAPPER[] = {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  };

  const uint8_t* cnf = NULL;

  for (unsigned int i = 0; i < (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0])); i++) {
    if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
  }

  if (cnf == NULL) {
    return 0;
  }

  writeRegister(REG_CNF1, cnf[0]);
  writeRegister(REG_CNF2, cnf[1]);
  writeRegister(REG_CNF3, cnf[2]);

  writeRegister(REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0));
  writeRegister(REG_BFPCTRL, 0x00);
  writeRegister(REG_TXRTSCTRL, 0x00);
  writeRegister(REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0);
  writeRegister(REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0);

  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: CANControllerClass::begin(baudRate);
|—————Node:call_expression Text: CANControllerClass::begin(baudRate)
|——————Node:qualified_identifier Text: CANControllerClass::begin
|———————Node:namespace_identifier Text: CANControllerClass
|———————Node::: Text: ::
|———————Node:identifier Text: begin
|——————Node:argument_list Text: (baudRate)
|———————Node:( Text: (
|———————Node:identifier Text: baudRate
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: pinMode(_csPin, OUTPUT);
|—————Node:call_expression Text: pinMode(_csPin, OUTPUT)
|——————Node:identifier Text: pinMode
|——————Node:argument_list Text: (_csPin, OUTPUT)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: OUTPUT
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:comment Text: // start SPI
|————Node:expression_statement Text: SPI.begin();
|—————Node:call_expression Text: SPI.begin()
|——————Node:field_expression Text: SPI.begin
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: begin
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: reset();
|—————Node:call_expression Text: reset()
|——————Node:identifier Text: reset
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x80);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x80)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x80)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x80
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x80)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x80
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x80
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:declaration Text: const struct {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  } CNF_MAPPER[] = {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  };
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:struct_specifier Text: struct {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  }
|——————Node:struct Text: struct
|——————Node:field_declaration_list Text: {
    long clockFrequency;
    long baudRate;
    uint8_t cnf[3];
  }
|———————Node:{ Text: {
|———————Node:field_declaration Text: long clockFrequency;
|————————Node:sized_type_specifier Text: long
|—————————Node:long Text: long
|————————Node:field_identifier Text: clockFrequency
|————————Node:; Text: ;
|———————Node:field_declaration Text: long baudRate;
|————————Node:sized_type_specifier Text: long
|—————————Node:long Text: long
|————————Node:field_identifier Text: baudRate
|————————Node:; Text: ;
|———————Node:field_declaration Text: uint8_t cnf[3];
|————————Node:primitive_type Text: uint8_t
|————————Node:array_declarator Text: cnf[3]
|—————————Node:field_identifier Text: cnf
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 3
|—————————Node:] Text: ]
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:init_declarator Text: CNF_MAPPER[] = {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  }
|——————Node:array_declarator Text: CNF_MAPPER[]
|———————Node:identifier Text: CNF_MAPPER
|———————Node:[ Text: [
|———————Node:] Text: ]
|——————Node:= Text: =
|——————Node:initializer_list Text: {
    {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } },
    {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } },
    {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } },
    {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } },
    {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } },
    {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } },
    {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } },
    {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } },
    {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } },
    {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } },
    {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } },
    {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } },

    { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } },
    { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } },
    { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } },
    { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } },
    { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } },
    { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } },
    { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } },
    { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } },
    { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } },
    { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } },
    { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } },
    { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } },
  }
|———————Node:{ Text: {
|———————Node:initializer_list Text: {  (long)8E6, (long)1000E3, { 0x00, 0x80, 0x00 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)1000E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 1000E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0x80, 0x00 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x80
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x00
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,  (long)500E3, { 0x00, 0x90, 0x02 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)500E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 500E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0x90, 0x02 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x90
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x02
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,  (long)250E3, { 0x00, 0xb1, 0x05 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)250E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 250E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0xb1, 0x05 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xb1
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x05
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,  (long)200E3, { 0x00, 0xb4, 0x06 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)200E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 200E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0xb4, 0x06 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xb4
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x06
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,  (long)125E3, { 0x01, 0xb1, 0x05 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)125E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 125E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x01, 0xb1, 0x05 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xb1
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x05
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,  (long)100E3, { 0x01, 0xb4, 0x06 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)100E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 100E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x01, 0xb4, 0x06 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xb4
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x06
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,   (long)80E3, { 0x01, 0xbf, 0x07 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)80E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 80E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x01, 0xbf, 0x07 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xbf
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x07
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,   (long)50E3, { 0x03, 0xb4, 0x06 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)50E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 50E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x03, 0xb4, 0x06 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x03
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xb4
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x06
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,   (long)40E3, { 0x03, 0xbf, 0x07 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)40E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 40E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x03, 0xbf, 0x07 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x03
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xbf
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x07
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,   (long)20E3, { 0x07, 0xbf, 0x07 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)20E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 20E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x07, 0xbf, 0x07 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x07
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xbf
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x07
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,   (long)10E3, { 0x0f, 0xbf, 0x07 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)10E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 10E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x0f, 0xbf, 0x07 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x0f
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xbf
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x07
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: {  (long)8E6,    (long)5E3, { 0x1f, 0xbf, 0x07 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)8E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 8E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)5E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 5E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x1f, 0xbf, 0x07 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x1f
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xbf
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x07
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6, (long)1000E3, { 0x00, 0xd0, 0x82 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)1000E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 1000E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0xd0, 0x82 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xd0
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x82
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,  (long)500E3, { 0x00, 0xf0, 0x86 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)500E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 500E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x00, 0xf0, 0x86 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x00
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xf0
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x86
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,  (long)250E3, { 0x41, 0xf1, 0x85 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)250E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 250E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x41, 0xf1, 0x85 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x41
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xf1
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x85
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,  (long)200E3, { 0x01, 0xfa, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)200E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 200E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x01, 0xfa, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x01
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xfa
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,  (long)125E3, { 0x03, 0xf0, 0x86 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)125E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 125E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x03, 0xf0, 0x86 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x03
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xf0
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x86
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,  (long)100E3, { 0x03, 0xfa, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)100E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 100E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x03, 0xfa, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x03
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xfa
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,   (long)80E3, { 0x03, 0xff, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)80E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 80E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x03, 0xff, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x03
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xff
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,   (long)50E3, { 0x07, 0xfa, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)50E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 50E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x07, 0xfa, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x07
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xfa
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,   (long)40E3, { 0x07, 0xff, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)40E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 40E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x07, 0xff, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x07
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xff
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,   (long)20E3, { 0x0f, 0xff, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)20E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 20E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x0f, 0xff, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x0f
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xff
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,   (long)10E3, { 0x1f, 0xff, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)10E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 10E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x1f, 0xff, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x1f
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xff
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:initializer_list Text: { (long)16E6,    (long)5E3, { 0x3f, 0xff, 0x87 } }
|————————Node:{ Text: {
|————————Node:cast_expression Text: (long)16E6
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 16E6
|————————Node:, Text: ,
|————————Node:cast_expression Text: (long)5E3
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: long
|——————————Node:sized_type_specifier Text: long
|———————————Node:long Text: long
|—————————Node:) Text: )
|—————————Node:number_literal Text: 5E3
|————————Node:, Text: ,
|————————Node:initializer_list Text: { 0x3f, 0xff, 0x87 }
|—————————Node:{ Text: {
|—————————Node:number_literal Text: 0x3f
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0xff
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x87
|—————————Node:} Text: }
|————————Node:} Text: }
|———————Node:, Text: ,
|———————Node:} Text: }
|—————Node:; Text: ;
|————Node:declaration Text: const uint8_t* cnf = NULL;
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:primitive_type Text: uint8_t
|—————Node:init_declarator Text: * cnf = NULL
|——————Node:pointer_declarator Text: * cnf
|———————Node:* Text: *
|———————Node:identifier Text: cnf
|——————Node:= Text: =
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:; Text: ;
|————Node:for_statement Text: for (unsigned int i = 0; i < (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0])); i++) {
    if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: unsigned int i = 0;
|——————Node:sized_type_specifier Text: unsigned int
|———————Node:unsigned Text: unsigned
|———————Node:primitive_type Text: int
|——————Node:init_declarator Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: i < (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0]))
|——————Node:identifier Text: i
|——————Node:< Text: <
|——————Node:parenthesized_expression Text: (sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0]))
|———————Node:( Text: (
|———————Node:binary_expression Text: sizeof(CNF_MAPPER) / sizeof(CNF_MAPPER[0])
|————————Node:sizeof_expression Text: sizeof(CNF_MAPPER)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (CNF_MAPPER)
|——————————Node:( Text: (
|——————————Node:identifier Text: CNF_MAPPER
|——————————Node:) Text: )
|————————Node:/ Text: /
|————————Node:sizeof_expression Text: sizeof(CNF_MAPPER[0])
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (CNF_MAPPER[0])
|——————————Node:( Text: (
|——————————Node:subscript_expression Text: CNF_MAPPER[0]
|———————————Node:identifier Text: CNF_MAPPER
|———————————Node:subscript_argument_list Text: [0]
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 0
|————————————Node:] Text: ]
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|—————Node:update_expression Text: i++
|——————Node:identifier Text: i
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate) {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: (CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate)
|————————Node:( Text: (
|————————Node:binary_expression Text: CNF_MAPPER[i].clockFrequency == _clockFrequency && CNF_MAPPER[i].baudRate == baudRate
|—————————Node:binary_expression Text: CNF_MAPPER[i].clockFrequency == _clockFrequency
|——————————Node:field_expression Text: CNF_MAPPER[i].clockFrequency
|———————————Node:subscript_expression Text: CNF_MAPPER[i]
|————————————Node:identifier Text: CNF_MAPPER
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: clockFrequency
|——————————Node:== Text: ==
|——————————Node:identifier Text: _clockFrequency
|—————————Node:&& Text: &&
|—————————Node:binary_expression Text: CNF_MAPPER[i].baudRate == baudRate
|——————————Node:field_expression Text: CNF_MAPPER[i].baudRate
|———————————Node:subscript_expression Text: CNF_MAPPER[i]
|————————————Node:identifier Text: CNF_MAPPER
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: baudRate
|——————————Node:== Text: ==
|——————————Node:identifier Text: baudRate
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      cnf = CNF_MAPPER[i].cnf;
      break;
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: cnf = CNF_MAPPER[i].cnf;
|—————————Node:assignment_expression Text: cnf = CNF_MAPPER[i].cnf
|——————————Node:identifier Text: cnf
|——————————Node:= Text: =
|——————————Node:field_expression Text: CNF_MAPPER[i].cnf
|———————————Node:subscript_expression Text: CNF_MAPPER[i]
|————————————Node:identifier Text: CNF_MAPPER
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: cnf
|—————————Node:; Text: ;
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:if_statement Text: if (cnf == NULL) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (cnf == NULL)
|——————Node:( Text: (
|——————Node:binary_expression Text: cnf == NULL
|———————Node:identifier Text: cnf
|———————Node:== Text: ==
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:expression_statement Text: writeRegister(REG_CNF1, cnf[0]);
|—————Node:call_expression Text: writeRegister(REG_CNF1, cnf[0])
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CNF1, cnf[0])
|———————Node:( Text: (
|———————Node:identifier Text: REG_CNF1
|———————Node:, Text: ,
|———————Node:subscript_expression Text: cnf[0]
|————————Node:identifier Text: cnf
|————————Node:subscript_argument_list Text: [0]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 0
|—————————Node:] Text: ]
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_CNF2, cnf[1]);
|—————Node:call_expression Text: writeRegister(REG_CNF2, cnf[1])
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CNF2, cnf[1])
|———————Node:( Text: (
|———————Node:identifier Text: REG_CNF2
|———————Node:, Text: ,
|———————Node:subscript_expression Text: cnf[1]
|————————Node:identifier Text: cnf
|————————Node:subscript_argument_list Text: [1]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 1
|—————————Node:] Text: ]
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_CNF3, cnf[2]);
|—————Node:call_expression Text: writeRegister(REG_CNF3, cnf[2])
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CNF3, cnf[2])
|———————Node:( Text: (
|———————Node:identifier Text: REG_CNF3
|———————Node:, Text: ,
|———————Node:subscript_expression Text: cnf[2]
|————————Node:identifier Text: cnf
|————————Node:subscript_argument_list Text: [2]
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 2
|—————————Node:] Text: ]
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0));
|—————Node:call_expression Text: writeRegister(REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0))
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANINTE, FLAG_RXnIE(1) | FLAG_RXnIE(0))
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANINTE
|———————Node:, Text: ,
|———————Node:binary_expression Text: FLAG_RXnIE(1) | FLAG_RXnIE(0)
|————————Node:call_expression Text: FLAG_RXnIE(1)
|—————————Node:identifier Text: FLAG_RXnIE
|—————————Node:argument_list Text: (1)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 1
|——————————Node:) Text: )
|————————Node:| Text: |
|————————Node:call_expression Text: FLAG_RXnIE(0)
|—————————Node:identifier Text: FLAG_RXnIE
|—————————Node:argument_list Text: (0)
|——————————Node:( Text: (
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_BFPCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_BFPCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_BFPCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_BFPCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_TXRTSCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_TXRTSCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_TXRTSCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_TXRTSCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0);
|—————Node:call_expression Text: writeRegister(REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_RXBnCTRL(0), FLAG_RXM1 | FLAG_RXM0)
|———————Node:( Text: (
|———————Node:call_expression Text: REG_RXBnCTRL(0)
|————————Node:identifier Text: REG_RXBnCTRL
|————————Node:argument_list Text: (0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:binary_expression Text: FLAG_RXM1 | FLAG_RXM0
|————————Node:identifier Text: FLAG_RXM1
|————————Node:| Text: |
|————————Node:identifier Text: FLAG_RXM0
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0);
|—————Node:call_expression Text: writeRegister(REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_RXBnCTRL(1), FLAG_RXM1 | FLAG_RXM0)
|———————Node:( Text: (
|———————Node:call_expression Text: REG_RXBnCTRL(1)
|————————Node:identifier Text: REG_RXBnCTRL
|————————Node:argument_list Text: (1)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 1
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:binary_expression Text: FLAG_RXM1 | FLAG_RXM0
|————————Node:identifier Text: FLAG_RXM1
|————————Node:| Text: |
|————————Node:identifier Text: FLAG_RXM0
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x00)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x00
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x00
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::end()
{
  SPI.end();

  CANControllerClass::end();
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::end()
|————Node:qualified_identifier Text: MCP2515Class::end
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: end
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  SPI.end();

  CANControllerClass::end();
}
|————Node:{ Text: {
|————Node:expression_statement Text: SPI.end();
|—————Node:call_expression Text: SPI.end()
|——————Node:field_expression Text: SPI.end
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: end
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: CANControllerClass::end();
|—————Node:call_expression Text: CANControllerClass::end()
|——————Node:qualified_identifier Text: CANControllerClass::end
|———————Node:namespace_identifier Text: CANControllerClass
|———————Node::: Text: ::
|———————Node:identifier Text: end
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::endPacket()
{
  if (!CANControllerClass::endPacket()) {
    return 0;
  }

  int n = 0;

  if (_txExtended) {
    writeRegister(REG_TXBnSIDH(n), _txId >> 21);
    writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
    writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
    writeRegister(REG_TXBnEID0(n), _txId & 0xff);
  } else {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }

  if (_txRtr) {
    writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
  } else {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }

  writeRegister(REG_TXBnCTRL(n), 0x08);

  bool aborted = false;

  while (readRegister(REG_TXBnCTRL(n)) & 0x08) {
    if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }

    yield();
  }

  if (aborted) {
    // clear abort command
    modifyRegister(REG_CANCTRL, 0x10, 0x00);
  }

  modifyRegister(REG_CANINTF, FLAG_TXnIF(n), 0x00);

  return (readRegister(REG_TXBnCTRL(n)) & 0x70) ? 0 : 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::endPacket()
|————Node:qualified_identifier Text: MCP2515Class::endPacket
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: endPacket
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  if (!CANControllerClass::endPacket()) {
    return 0;
  }

  int n = 0;

  if (_txExtended) {
    writeRegister(REG_TXBnSIDH(n), _txId >> 21);
    writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
    writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
    writeRegister(REG_TXBnEID0(n), _txId & 0xff);
  } else {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }

  if (_txRtr) {
    writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
  } else {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }

  writeRegister(REG_TXBnCTRL(n), 0x08);

  bool aborted = false;

  while (readRegister(REG_TXBnCTRL(n)) & 0x08) {
    if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }

    yield();
  }

  if (aborted) {
    // clear abort command
    modifyRegister(REG_CANCTRL, 0x10, 0x00);
  }

  modifyRegister(REG_CANINTF, FLAG_TXnIF(n), 0x00);

  return (readRegister(REG_TXBnCTRL(n)) & 0x70) ? 0 : 1;
}
|————Node:{ Text: {
|————Node:if_statement Text: if (!CANControllerClass::endPacket()) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (!CANControllerClass::endPacket())
|——————Node:( Text: (
|——————Node:unary_expression Text: !CANControllerClass::endPacket()
|———————Node:! Text: !
|———————Node:call_expression Text: CANControllerClass::endPacket()
|————————Node:qualified_identifier Text: CANControllerClass::endPacket
|—————————Node:namespace_identifier Text: CANControllerClass
|—————————Node::: Text: ::
|—————————Node:identifier Text: endPacket
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:declaration Text: int n = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: n = 0
|——————Node:identifier Text: n
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:if_statement Text: if (_txExtended) {
    writeRegister(REG_TXBnSIDH(n), _txId >> 21);
    writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
    writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
    writeRegister(REG_TXBnEID0(n), _txId & 0xff);
  } else {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (_txExtended)
|——————Node:( Text: (
|——————Node:identifier Text: _txExtended
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    writeRegister(REG_TXBnSIDH(n), _txId >> 21);
    writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
    writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
    writeRegister(REG_TXBnEID0(n), _txId & 0xff);
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: writeRegister(REG_TXBnSIDH(n), _txId >> 21);
|———————Node:call_expression Text: writeRegister(REG_TXBnSIDH(n), _txId >> 21)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_TXBnSIDH(n), _txId >> 21)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnSIDH(n)
|——————————Node:identifier Text: REG_TXBnSIDH
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: _txId >> 21
|——————————Node:identifier Text: _txId
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 21
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03));
|———————Node:call_expression Text: writeRegister(REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03))
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_TXBnSIDL(n), (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03))
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnSIDL(n)
|——————————Node:identifier Text: REG_TXBnSIDL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE | ((_txId >> 16) & 0x03)
|——————————Node:binary_expression Text: (((_txId >> 18) & 0x07) << 5) | FLAG_EXIDE
|———————————Node:parenthesized_expression Text: (((_txId >> 18) & 0x07) << 5)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ((_txId >> 18) & 0x07) << 5
|—————————————Node:parenthesized_expression Text: ((_txId >> 18) & 0x07)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (_txId >> 18) & 0x07
|———————————————Node:parenthesized_expression Text: (_txId >> 18)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: _txId >> 18
|—————————————————Node:identifier Text: _txId
|—————————————————Node:>> Text: >>
|—————————————————Node:number_literal Text: 18
|————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0x07
|——————————————Node:) Text: )
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 5
|————————————Node:) Text: )
|———————————Node:| Text: |
|———————————Node:identifier Text: FLAG_EXIDE
|——————————Node:| Text: |
|——————————Node:parenthesized_expression Text: ((_txId >> 16) & 0x03)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (_txId >> 16) & 0x03
|————————————Node:parenthesized_expression Text: (_txId >> 16)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: _txId >> 16
|——————————————Node:identifier Text: _txId
|——————————————Node:>> Text: >>
|——————————————Node:number_literal Text: 16
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x03
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff);
|———————Node:call_expression Text: writeRegister(REG_TXBnEID8(n), (_txId >> 8) & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_TXBnEID8(n), (_txId >> 8) & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnEID8(n)
|——————————Node:identifier Text: REG_TXBnEID8
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (_txId >> 8) & 0xff
|——————————Node:parenthesized_expression Text: (_txId >> 8)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: _txId >> 8
|————————————Node:identifier Text: _txId
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 8
|———————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_TXBnEID0(n), _txId & 0xff);
|———————Node:call_expression Text: writeRegister(REG_TXBnEID0(n), _txId & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_TXBnEID0(n), _txId & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnEID0(n)
|——————————Node:identifier Text: REG_TXBnEID0
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: _txId & 0xff
|——————————Node:identifier Text: _txId
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
    writeRegister(REG_TXBnSIDH(n), _txId >> 3);
    writeRegister(REG_TXBnSIDL(n), _txId << 5);
    writeRegister(REG_TXBnEID8(n), 0x00);
    writeRegister(REG_TXBnEID0(n), 0x00);
  }
|———————Node:{ Text: {
|———————Node:expression_statement Text: writeRegister(REG_TXBnSIDH(n), _txId >> 3);
|————————Node:call_expression Text: writeRegister(REG_TXBnSIDH(n), _txId >> 3)
|—————————Node:identifier Text: writeRegister
|—————————Node:argument_list Text: (REG_TXBnSIDH(n), _txId >> 3)
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnSIDH(n)
|———————————Node:identifier Text: REG_TXBnSIDH
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: _txId >> 3
|———————————Node:identifier Text: _txId
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 3
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: writeRegister(REG_TXBnSIDL(n), _txId << 5);
|————————Node:call_expression Text: writeRegister(REG_TXBnSIDL(n), _txId << 5)
|—————————Node:identifier Text: writeRegister
|—————————Node:argument_list Text: (REG_TXBnSIDL(n), _txId << 5)
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnSIDL(n)
|———————————Node:identifier Text: REG_TXBnSIDL
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: _txId << 5
|———————————Node:identifier Text: _txId
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 5
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: writeRegister(REG_TXBnEID8(n), 0x00);
|————————Node:call_expression Text: writeRegister(REG_TXBnEID8(n), 0x00)
|—————————Node:identifier Text: writeRegister
|—————————Node:argument_list Text: (REG_TXBnEID8(n), 0x00)
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnEID8(n)
|———————————Node:identifier Text: REG_TXBnEID8
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0x00
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: writeRegister(REG_TXBnEID0(n), 0x00);
|————————Node:call_expression Text: writeRegister(REG_TXBnEID0(n), 0x00)
|—————————Node:identifier Text: writeRegister
|—————————Node:argument_list Text: (REG_TXBnEID0(n), 0x00)
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnEID0(n)
|———————————Node:identifier Text: REG_TXBnEID0
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0x00
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|————Node:if_statement Text: if (_txRtr) {
    writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
  } else {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (_txRtr)
|——————Node:( Text: (
|——————Node:identifier Text: _txRtr
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: writeRegister(REG_TXBnDLC(n), 0x40 | _txLength);
|———————Node:call_expression Text: writeRegister(REG_TXBnDLC(n), 0x40 | _txLength)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_TXBnDLC(n), 0x40 | _txLength)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnDLC(n)
|——————————Node:identifier Text: REG_TXBnDLC
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: 0x40 | _txLength
|——————————Node:number_literal Text: 0x40
|——————————Node:| Text: |
|——————————Node:identifier Text: _txLength
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
    writeRegister(REG_TXBnDLC(n), _txLength);

    for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
  }
|———————Node:{ Text: {
|———————Node:expression_statement Text: writeRegister(REG_TXBnDLC(n), _txLength);
|————————Node:call_expression Text: writeRegister(REG_TXBnDLC(n), _txLength)
|—————————Node:identifier Text: writeRegister
|—————————Node:argument_list Text: (REG_TXBnDLC(n), _txLength)
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnDLC(n)
|———————————Node:identifier Text: REG_TXBnDLC
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: _txLength
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:for_statement Text: for (int i = 0; i < _txLength; i++) {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: int i = 0;
|—————————Node:primitive_type Text: int
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < _txLength
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:identifier Text: _txLength
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
      writeRegister(REG_TXBnD0(n) + i, _txData[i]);
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: writeRegister(REG_TXBnD0(n) + i, _txData[i]);
|——————————Node:call_expression Text: writeRegister(REG_TXBnD0(n) + i, _txData[i])
|———————————Node:identifier Text: writeRegister
|———————————Node:argument_list Text: (REG_TXBnD0(n) + i, _txData[i])
|————————————Node:( Text: (
|————————————Node:binary_expression Text: REG_TXBnD0(n) + i
|—————————————Node:call_expression Text: REG_TXBnD0(n)
|——————————————Node:identifier Text: REG_TXBnD0
|——————————————Node:argument_list Text: (n)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: n
|———————————————Node:) Text: )
|—————————————Node:+ Text: +
|—————————————Node:identifier Text: i
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: _txData[i]
|—————————————Node:identifier Text: _txData
|—————————————Node:subscript_argument_list Text: [i]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: i
|——————————————Node:] Text: ]
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|————Node:expression_statement Text: writeRegister(REG_TXBnCTRL(n), 0x08);
|—————Node:call_expression Text: writeRegister(REG_TXBnCTRL(n), 0x08)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_TXBnCTRL(n), 0x08)
|———————Node:( Text: (
|———————Node:call_expression Text: REG_TXBnCTRL(n)
|————————Node:identifier Text: REG_TXBnCTRL
|————————Node:argument_list Text: (n)
|—————————Node:( Text: (
|—————————Node:identifier Text: n
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x08
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:declaration Text: bool aborted = false;
|—————Node:primitive_type Text: bool
|—————Node:init_declarator Text: aborted = false
|——————Node:identifier Text: aborted
|——————Node:= Text: =
|——————Node:false Text: false
|—————Node:; Text: ;
|————Node:while_statement Text: while (readRegister(REG_TXBnCTRL(n)) & 0x08) {
    if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }

    yield();
  }
|—————Node:while Text: while
|—————Node:condition_clause Text: (readRegister(REG_TXBnCTRL(n)) & 0x08)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_TXBnCTRL(n)) & 0x08
|———————Node:call_expression Text: readRegister(REG_TXBnCTRL(n))
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_TXBnCTRL(n))
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_TXBnCTRL(n)
|——————————Node:identifier Text: REG_TXBnCTRL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:& Text: &
|———————Node:number_literal Text: 0x08
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }

    yield();
  }
|——————Node:{ Text: {
|——————Node:if_statement Text: if (readRegister(REG_TXBnCTRL(n)) & 0x10) {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: (readRegister(REG_TXBnCTRL(n)) & 0x10)
|————————Node:( Text: (
|————————Node:binary_expression Text: readRegister(REG_TXBnCTRL(n)) & 0x10
|—————————Node:call_expression Text: readRegister(REG_TXBnCTRL(n))
|——————————Node:identifier Text: readRegister
|——————————Node:argument_list Text: (REG_TXBnCTRL(n))
|———————————Node:( Text: (
|———————————Node:call_expression Text: REG_TXBnCTRL(n)
|————————————Node:identifier Text: REG_TXBnCTRL
|————————————Node:argument_list Text: (n)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: n
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:number_literal Text: 0x10
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      // abort
      aborted = true;

      modifyRegister(REG_CANCTRL, 0x10, 0x10);
    }
|————————Node:{ Text: {
|————————Node:comment Text: // abort
|————————Node:expression_statement Text: aborted = true;
|—————————Node:assignment_expression Text: aborted = true
|——————————Node:identifier Text: aborted
|——————————Node:= Text: =
|——————————Node:true Text: true
|—————————Node:; Text: ;
|————————Node:expression_statement Text: modifyRegister(REG_CANCTRL, 0x10, 0x10);
|—————————Node:call_expression Text: modifyRegister(REG_CANCTRL, 0x10, 0x10)
|——————————Node:identifier Text: modifyRegister
|——————————Node:argument_list Text: (REG_CANCTRL, 0x10, 0x10)
|———————————Node:( Text: (
|———————————Node:identifier Text: REG_CANCTRL
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 0x10
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 0x10
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: yield();
|———————Node:call_expression Text: yield()
|————————Node:identifier Text: yield
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:if_statement Text: if (aborted) {
    // clear abort command
    modifyRegister(REG_CANCTRL, 0x10, 0x00);
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (aborted)
|——————Node:( Text: (
|——————Node:identifier Text: aborted
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    // clear abort command
    modifyRegister(REG_CANCTRL, 0x10, 0x00);
  }
|——————Node:{ Text: {
|——————Node:comment Text: // clear abort command
|——————Node:expression_statement Text: modifyRegister(REG_CANCTRL, 0x10, 0x00);
|———————Node:call_expression Text: modifyRegister(REG_CANCTRL, 0x10, 0x00)
|————————Node:identifier Text: modifyRegister
|————————Node:argument_list Text: (REG_CANCTRL, 0x10, 0x00)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x10
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0x00
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:expression_statement Text: modifyRegister(REG_CANINTF, FLAG_TXnIF(n), 0x00);
|—————Node:call_expression Text: modifyRegister(REG_CANINTF, FLAG_TXnIF(n), 0x00)
|——————Node:identifier Text: modifyRegister
|——————Node:argument_list Text: (REG_CANINTF, FLAG_TXnIF(n), 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANINTF
|———————Node:, Text: ,
|———————Node:call_expression Text: FLAG_TXnIF(n)
|————————Node:identifier Text: FLAG_TXnIF
|————————Node:argument_list Text: (n)
|—————————Node:( Text: (
|—————————Node:identifier Text: n
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:return_statement Text: return (readRegister(REG_TXBnCTRL(n)) & 0x70) ? 0 : 1;
|—————Node:return Text: return
|—————Node:conditional_expression Text: (readRegister(REG_TXBnCTRL(n)) & 0x70) ? 0 : 1
|——————Node:parenthesized_expression Text: (readRegister(REG_TXBnCTRL(n)) & 0x70)
|———————Node:( Text: (
|———————Node:binary_expression Text: readRegister(REG_TXBnCTRL(n)) & 0x70
|————————Node:call_expression Text: readRegister(REG_TXBnCTRL(n))
|—————————Node:identifier Text: readRegister
|—————————Node:argument_list Text: (REG_TXBnCTRL(n))
|——————————Node:( Text: (
|——————————Node:call_expression Text: REG_TXBnCTRL(n)
|———————————Node:identifier Text: REG_TXBnCTRL
|———————————Node:argument_list Text: (n)
|————————————Node:( Text: (
|————————————Node:identifier Text: n
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0x70
|———————Node:) Text: )
|——————Node:? Text: ?
|——————Node:number_literal Text: 0
|——————Node:: Text: :
|——————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::parsePacket()
{
  int n;

  uint8_t intf = readRegister(REG_CANINTF);

  if (intf & FLAG_RXnIF(0)) {
    n = 0;
  } else if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }

  _rxExtended = (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false;

  uint32_t idA = ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07);
  if (_rxExtended) {
    uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));

    _rxId = (idA << 18) | idB;
    _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
  } else {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
  _rxDlc = readRegister(REG_RXBnDLC(n)) & 0x0f;
  _rxIndex = 0;

  if (_rxRtr) {
    _rxLength = 0;
  } else {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }

  modifyRegister(REG_CANINTF, FLAG_RXnIF(n), 0x00);

  return _rxDlc;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::parsePacket()
|————Node:qualified_identifier Text: MCP2515Class::parsePacket
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: parsePacket
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  int n;

  uint8_t intf = readRegister(REG_CANINTF);

  if (intf & FLAG_RXnIF(0)) {
    n = 0;
  } else if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }

  _rxExtended = (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false;

  uint32_t idA = ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07);
  if (_rxExtended) {
    uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));

    _rxId = (idA << 18) | idB;
    _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
  } else {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
  _rxDlc = readRegister(REG_RXBnDLC(n)) & 0x0f;
  _rxIndex = 0;

  if (_rxRtr) {
    _rxLength = 0;
  } else {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }

  modifyRegister(REG_CANINTF, FLAG_RXnIF(n), 0x00);

  return _rxDlc;
}
|————Node:{ Text: {
|————Node:declaration Text: int n;
|—————Node:primitive_type Text: int
|—————Node:identifier Text: n
|—————Node:; Text: ;
|————Node:declaration Text: uint8_t intf = readRegister(REG_CANINTF);
|—————Node:primitive_type Text: uint8_t
|—————Node:init_declarator Text: intf = readRegister(REG_CANINTF)
|——————Node:identifier Text: intf
|——————Node:= Text: =
|——————Node:call_expression Text: readRegister(REG_CANINTF)
|———————Node:identifier Text: readRegister
|———————Node:argument_list Text: (REG_CANINTF)
|————————Node:( Text: (
|————————Node:identifier Text: REG_CANINTF
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (intf & FLAG_RXnIF(0)) {
    n = 0;
  } else if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (intf & FLAG_RXnIF(0))
|——————Node:( Text: (
|——————Node:binary_expression Text: intf & FLAG_RXnIF(0)
|———————Node:identifier Text: intf
|———————Node:& Text: &
|———————Node:call_expression Text: FLAG_RXnIF(0)
|————————Node:identifier Text: FLAG_RXnIF
|————————Node:argument_list Text: (0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    n = 0;
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: n = 0;
|———————Node:assignment_expression Text: n = 0
|————————Node:identifier Text: n
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }
|——————Node:else Text: else
|——————Node:if_statement Text: if (intf & FLAG_RXnIF(1)) {
    n = 1;
  } else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }
|———————Node:if Text: if
|———————Node:condition_clause Text: (intf & FLAG_RXnIF(1))
|————————Node:( Text: (
|————————Node:binary_expression Text: intf & FLAG_RXnIF(1)
|—————————Node:identifier Text: intf
|—————————Node:& Text: &
|—————————Node:call_expression Text: FLAG_RXnIF(1)
|——————————Node:identifier Text: FLAG_RXnIF
|——————————Node:argument_list Text: (1)
|———————————Node:( Text: (
|———————————Node:number_literal Text: 1
|———————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
    n = 1;
  }
|————————Node:{ Text: {
|————————Node:expression_statement Text: n = 1;
|—————————Node:assignment_expression Text: n = 1
|——————————Node:identifier Text: n
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
    _rxId = -1;
    _rxExtended = false;
    _rxRtr = false;
    _rxLength = 0;
    return 0;
  }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: _rxId = -1;
|——————————Node:assignment_expression Text: _rxId = -1
|———————————Node:identifier Text: _rxId
|———————————Node:= Text: =
|———————————Node:number_literal Text: -1
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: _rxExtended = false;
|——————————Node:assignment_expression Text: _rxExtended = false
|———————————Node:identifier Text: _rxExtended
|———————————Node:= Text: =
|———————————Node:false Text: false
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: _rxRtr = false;
|——————————Node:assignment_expression Text: _rxRtr = false
|———————————Node:identifier Text: _rxRtr
|———————————Node:= Text: =
|———————————Node:false Text: false
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: _rxLength = 0;
|——————————Node:assignment_expression Text: _rxLength = 0
|———————————Node:identifier Text: _rxLength
|———————————Node:= Text: =
|———————————Node:number_literal Text: 0
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return 0;
|——————————Node:return Text: return
|——————————Node:number_literal Text: 0
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————Node:expression_statement Text: _rxExtended = (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false;
|—————Node:assignment_expression Text: _rxExtended = (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false
|——————Node:identifier Text: _rxExtended
|——————Node:= Text: =
|——————Node:conditional_expression Text: (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE) ? true : false
|———————Node:parenthesized_expression Text: (readRegister(REG_RXBnSIDL(n)) & FLAG_IDE)
|————————Node:( Text: (
|————————Node:binary_expression Text: readRegister(REG_RXBnSIDL(n)) & FLAG_IDE
|—————————Node:call_expression Text: readRegister(REG_RXBnSIDL(n))
|——————————Node:identifier Text: readRegister
|——————————Node:argument_list Text: (REG_RXBnSIDL(n))
|———————————Node:( Text: (
|———————————Node:call_expression Text: REG_RXBnSIDL(n)
|————————————Node:identifier Text: REG_RXBnSIDL
|————————————Node:argument_list Text: (n)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: n
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:identifier Text: FLAG_IDE
|————————Node:) Text: )
|———————Node:? Text: ?
|———————Node:true Text: true
|———————Node:: Text: :
|———————Node:false Text: false
|—————Node:; Text: ;
|————Node:declaration Text: uint32_t idA = ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07);
|—————Node:primitive_type Text: uint32_t
|—————Node:init_declarator Text: idA = ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07)
|——————Node:identifier Text: idA
|——————Node:= Text: =
|——————Node:binary_expression Text: ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8) | ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07)
|———————Node:parenthesized_expression Text: ((readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8)
|————————Node:( Text: (
|————————Node:binary_expression Text: (readRegister(REG_RXBnSIDH(n)) << 3) & 0x07f8
|—————————Node:parenthesized_expression Text: (readRegister(REG_RXBnSIDH(n)) << 3)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: readRegister(REG_RXBnSIDH(n)) << 3
|———————————Node:call_expression Text: readRegister(REG_RXBnSIDH(n))
|————————————Node:identifier Text: readRegister
|————————————Node:argument_list Text: (REG_RXBnSIDH(n))
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: REG_RXBnSIDH(n)
|——————————————Node:identifier Text: REG_RXBnSIDH
|——————————————Node:argument_list Text: (n)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: n
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 3
|——————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:number_literal Text: 0x07f8
|————————Node:) Text: )
|———————Node:| Text: |
|———————Node:parenthesized_expression Text: ((readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07)
|————————Node:( Text: (
|————————Node:binary_expression Text: (readRegister(REG_RXBnSIDL(n)) >> 5) & 0x07
|—————————Node:parenthesized_expression Text: (readRegister(REG_RXBnSIDL(n)) >> 5)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: readRegister(REG_RXBnSIDL(n)) >> 5
|———————————Node:call_expression Text: readRegister(REG_RXBnSIDL(n))
|————————————Node:identifier Text: readRegister
|————————————Node:argument_list Text: (REG_RXBnSIDL(n))
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: REG_RXBnSIDL(n)
|——————————————Node:identifier Text: REG_RXBnSIDL
|——————————————Node:argument_list Text: (n)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: n
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 5
|——————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:number_literal Text: 0x07
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (_rxExtended) {
    uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));

    _rxId = (idA << 18) | idB;
    _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
  } else {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (_rxExtended)
|——————Node:( Text: (
|——————Node:identifier Text: _rxExtended
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));

    _rxId = (idA << 18) | idB;
    _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
  }
|——————Node:{ Text: {
|——————Node:declaration Text: uint32_t idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n));
|———————Node:primitive_type Text: uint32_t
|———————Node:init_declarator Text: idB = (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n))
|————————Node:identifier Text: idB
|————————Node:= Text: =
|————————Node:binary_expression Text: (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00) | readRegister(REG_RXBnEID0(n))
|—————————Node:binary_expression Text: (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000) | ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00)
|——————————Node:parenthesized_expression Text: (((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16) & 0x30000
|————————————Node:parenthesized_expression Text: ((uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: (uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03) << 16
|——————————————Node:cast_expression Text: (uint32_t)(readRegister(REG_RXBnSIDL(n)) & 0x03)
|———————————————Node:( Text: (
|———————————————Node:type_descriptor Text: uint32_t
|————————————————Node:primitive_type Text: uint32_t
|———————————————Node:) Text: )
|———————————————Node:parenthesized_expression Text: (readRegister(REG_RXBnSIDL(n)) & 0x03)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: readRegister(REG_RXBnSIDL(n)) & 0x03
|—————————————————Node:call_expression Text: readRegister(REG_RXBnSIDL(n))
|——————————————————Node:identifier Text: readRegister
|——————————————————Node:argument_list Text: (REG_RXBnSIDL(n))
|———————————————————Node:( Text: (
|———————————————————Node:call_expression Text: REG_RXBnSIDL(n)
|————————————————————Node:identifier Text: REG_RXBnSIDL
|————————————————————Node:argument_list Text: (n)
|—————————————————————Node:( Text: (
|—————————————————————Node:identifier Text: n
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|—————————————————Node:& Text: &
|—————————————————Node:number_literal Text: 0x03
|————————————————Node:) Text: )
|——————————————Node:<< Text: <<
|——————————————Node:number_literal Text: 16
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x30000
|———————————Node:) Text: )
|——————————Node:| Text: |
|——————————Node:parenthesized_expression Text: ((readRegister(REG_RXBnEID8(n)) << 8) & 0xff00)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (readRegister(REG_RXBnEID8(n)) << 8) & 0xff00
|————————————Node:parenthesized_expression Text: (readRegister(REG_RXBnEID8(n)) << 8)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: readRegister(REG_RXBnEID8(n)) << 8
|——————————————Node:call_expression Text: readRegister(REG_RXBnEID8(n))
|———————————————Node:identifier Text: readRegister
|———————————————Node:argument_list Text: (REG_RXBnEID8(n))
|————————————————Node:( Text: (
|————————————————Node:call_expression Text: REG_RXBnEID8(n)
|—————————————————Node:identifier Text: REG_RXBnEID8
|—————————————————Node:argument_list Text: (n)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: n
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:<< Text: <<
|——————————————Node:number_literal Text: 8
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0xff00
|———————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:call_expression Text: readRegister(REG_RXBnEID0(n))
|——————————Node:identifier Text: readRegister
|——————————Node:argument_list Text: (REG_RXBnEID0(n))
|———————————Node:( Text: (
|———————————Node:call_expression Text: REG_RXBnEID0(n)
|————————————Node:identifier Text: REG_RXBnEID0
|————————————Node:argument_list Text: (n)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: n
|—————————————Node:) Text: )
|———————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: _rxId = (idA << 18) | idB;
|———————Node:assignment_expression Text: _rxId = (idA << 18) | idB
|————————Node:identifier Text: _rxId
|————————Node:= Text: =
|————————Node:binary_expression Text: (idA << 18) | idB
|—————————Node:parenthesized_expression Text: (idA << 18)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: idA << 18
|———————————Node:identifier Text: idA
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 18
|——————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:identifier Text: idB
|———————Node:; Text: ;
|——————Node:expression_statement Text: _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false;
|———————Node:assignment_expression Text: _rxRtr = (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false
|————————Node:identifier Text: _rxRtr
|————————Node:= Text: =
|————————Node:conditional_expression Text: (readRegister(REG_RXBnDLC(n)) & FLAG_RTR) ? true : false
|—————————Node:parenthesized_expression Text: (readRegister(REG_RXBnDLC(n)) & FLAG_RTR)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: readRegister(REG_RXBnDLC(n)) & FLAG_RTR
|———————————Node:call_expression Text: readRegister(REG_RXBnDLC(n))
|————————————Node:identifier Text: readRegister
|————————————Node:argument_list Text: (REG_RXBnDLC(n))
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: REG_RXBnDLC(n)
|——————————————Node:identifier Text: REG_RXBnDLC
|——————————————Node:argument_list Text: (n)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: n
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:& Text: &
|———————————Node:identifier Text: FLAG_RTR
|——————————Node:) Text: )
|—————————Node:? Text: ?
|—————————Node:true Text: true
|—————————Node:: Text: :
|—————————Node:false Text: false
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
    _rxId = idA;
    _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
  }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _rxId = idA;
|————————Node:assignment_expression Text: _rxId = idA
|—————————Node:identifier Text: _rxId
|—————————Node:= Text: =
|—————————Node:identifier Text: idA
|————————Node:; Text: ;
|———————Node:expression_statement Text: _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false;
|————————Node:assignment_expression Text: _rxRtr = (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false
|—————————Node:identifier Text: _rxRtr
|—————————Node:= Text: =
|—————————Node:conditional_expression Text: (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR) ? true : false
|——————————Node:parenthesized_expression Text: (readRegister(REG_RXBnSIDL(n)) & FLAG_SRR)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: readRegister(REG_RXBnSIDL(n)) & FLAG_SRR
|————————————Node:call_expression Text: readRegister(REG_RXBnSIDL(n))
|—————————————Node:identifier Text: readRegister
|—————————————Node:argument_list Text: (REG_RXBnSIDL(n))
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: REG_RXBnSIDL(n)
|———————————————Node:identifier Text: REG_RXBnSIDL
|———————————————Node:argument_list Text: (n)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: n
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:identifier Text: FLAG_SRR
|———————————Node:) Text: )
|——————————Node:? Text: ?
|——————————Node:true Text: true
|——————————Node:: Text: :
|——————————Node:false Text: false
|————————Node:; Text: ;
|———————Node:} Text: }
|————Node:expression_statement Text: _rxDlc = readRegister(REG_RXBnDLC(n)) & 0x0f;
|—————Node:assignment_expression Text: _rxDlc = readRegister(REG_RXBnDLC(n)) & 0x0f
|——————Node:identifier Text: _rxDlc
|——————Node:= Text: =
|——————Node:binary_expression Text: readRegister(REG_RXBnDLC(n)) & 0x0f
|———————Node:call_expression Text: readRegister(REG_RXBnDLC(n))
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_RXBnDLC(n))
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXBnDLC(n)
|——————————Node:identifier Text: REG_RXBnDLC
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:& Text: &
|———————Node:number_literal Text: 0x0f
|—————Node:; Text: ;
|————Node:expression_statement Text: _rxIndex = 0;
|—————Node:assignment_expression Text: _rxIndex = 0
|——————Node:identifier Text: _rxIndex
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:if_statement Text: if (_rxRtr) {
    _rxLength = 0;
  } else {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (_rxRtr)
|——————Node:( Text: (
|——————Node:identifier Text: _rxRtr
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    _rxLength = 0;
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: _rxLength = 0;
|———————Node:assignment_expression Text: _rxLength = 0
|————————Node:identifier Text: _rxLength
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
    _rxLength = _rxDlc;

    for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
  }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _rxLength = _rxDlc;
|————————Node:assignment_expression Text: _rxLength = _rxDlc
|—————————Node:identifier Text: _rxLength
|—————————Node:= Text: =
|—————————Node:identifier Text: _rxDlc
|————————Node:; Text: ;
|———————Node:for_statement Text: for (int i = 0; i < _rxLength; i++) {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: int i = 0;
|—————————Node:primitive_type Text: int
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < _rxLength
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:identifier Text: _rxLength
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
      _rxData[i] = readRegister(REG_RXBnD0(n) + i);
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: _rxData[i] = readRegister(REG_RXBnD0(n) + i);
|——————————Node:assignment_expression Text: _rxData[i] = readRegister(REG_RXBnD0(n) + i)
|———————————Node:subscript_expression Text: _rxData[i]
|————————————Node:identifier Text: _rxData
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:= Text: =
|———————————Node:call_expression Text: readRegister(REG_RXBnD0(n) + i)
|————————————Node:identifier Text: readRegister
|————————————Node:argument_list Text: (REG_RXBnD0(n) + i)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: REG_RXBnD0(n) + i
|——————————————Node:call_expression Text: REG_RXBnD0(n)
|———————————————Node:identifier Text: REG_RXBnD0
|———————————————Node:argument_list Text: (n)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: n
|————————————————Node:) Text: )
|——————————————Node:+ Text: +
|——————————————Node:identifier Text: i
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|————Node:expression_statement Text: modifyRegister(REG_CANINTF, FLAG_RXnIF(n), 0x00);
|—————Node:call_expression Text: modifyRegister(REG_CANINTF, FLAG_RXnIF(n), 0x00)
|——————Node:identifier Text: modifyRegister
|——————Node:argument_list Text: (REG_CANINTF, FLAG_RXnIF(n), 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANINTF
|———————Node:, Text: ,
|———————Node:call_expression Text: FLAG_RXnIF(n)
|————————Node:identifier Text: FLAG_RXnIF
|————————Node:argument_list Text: (n)
|—————————Node:( Text: (
|—————————Node:identifier Text: n
|—————————Node:) Text: )
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:return_statement Text: return _rxDlc;
|—————Node:return Text: return
|—————Node:identifier Text: _rxDlc
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::onReceive(void(*callback)(int))
{
  CANControllerClass::onReceive(callback);

  pinMode(_intPin, INPUT);

  if (callback) {
    SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
    attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
  } else {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::onReceive(void(*callback)(int))
|————Node:qualified_identifier Text: MCP2515Class::onReceive
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: onReceive
|————Node:parameter_list Text: (void(*callback)(int))
|—————Node:( Text: (
|—————Node:parameter_declaration Text: void(*callback)(int)
|——————Node:primitive_type Text: void
|——————Node:function_declarator Text: (*callback)(int)
|———————Node:parenthesized_declarator Text: (*callback)
|————————Node:( Text: (
|————————Node:pointer_declarator Text: *callback
|—————————Node:* Text: *
|—————————Node:identifier Text: callback
|————————Node:) Text: )
|———————Node:parameter_list Text: (int)
|————————Node:( Text: (
|————————Node:parameter_declaration Text: int
|—————————Node:primitive_type Text: int
|————————Node:) Text: )
|—————Node:) Text: )
|———Node:compound_statement Text: {
  CANControllerClass::onReceive(callback);

  pinMode(_intPin, INPUT);

  if (callback) {
    SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
    attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
  } else {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
}
|————Node:{ Text: {
|————Node:expression_statement Text: CANControllerClass::onReceive(callback);
|—————Node:call_expression Text: CANControllerClass::onReceive(callback)
|——————Node:qualified_identifier Text: CANControllerClass::onReceive
|———————Node:namespace_identifier Text: CANControllerClass
|———————Node::: Text: ::
|———————Node:identifier Text: onReceive
|——————Node:argument_list Text: (callback)
|———————Node:( Text: (
|———————Node:identifier Text: callback
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: pinMode(_intPin, INPUT);
|—————Node:call_expression Text: pinMode(_intPin, INPUT)
|——————Node:identifier Text: pinMode
|——————Node:argument_list Text: (_intPin, INPUT)
|———————Node:( Text: (
|———————Node:identifier Text: _intPin
|———————Node:, Text: ,
|———————Node:identifier Text: INPUT
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (callback) {
    SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
    attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
  } else {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (callback)
|——————Node:( Text: (
|——————Node:identifier Text: callback
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
    attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: SPI.usingInterrupt(digitalPinToInterrupt(_intPin));
|———————Node:call_expression Text: SPI.usingInterrupt(digitalPinToInterrupt(_intPin))
|————————Node:field_expression Text: SPI.usingInterrupt
|—————————Node:identifier Text: SPI
|—————————Node:. Text: .
|—————————Node:field_identifier Text: usingInterrupt
|————————Node:argument_list Text: (digitalPinToInterrupt(_intPin))
|—————————Node:( Text: (
|—————————Node:call_expression Text: digitalPinToInterrupt(_intPin)
|——————————Node:identifier Text: digitalPinToInterrupt
|——————————Node:argument_list Text: (_intPin)
|———————————Node:( Text: (
|———————————Node:identifier Text: _intPin
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW);
|———————Node:call_expression Text: attachInterrupt(digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW)
|————————Node:identifier Text: attachInterrupt
|————————Node:argument_list Text: (digitalPinToInterrupt(_intPin), MCP2515Class::onInterrupt, LOW)
|—————————Node:( Text: (
|—————————Node:call_expression Text: digitalPinToInterrupt(_intPin)
|——————————Node:identifier Text: digitalPinToInterrupt
|——————————Node:argument_list Text: (_intPin)
|———————————Node:( Text: (
|———————————Node:identifier Text: _intPin
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:qualified_identifier Text: MCP2515Class::onInterrupt
|——————————Node:namespace_identifier Text: MCP2515Class
|——————————Node::: Text: ::
|——————————Node:identifier Text: onInterrupt
|—————————Node:, Text: ,
|—————————Node:identifier Text: LOW
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|—————Node:else_clause Text: else {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
|——————Node:else Text: else
|——————Node:compound_statement Text: {
    detachInterrupt(digitalPinToInterrupt(_intPin));
#ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
  }
|———————Node:{ Text: {
|———————Node:expression_statement Text: detachInterrupt(digitalPinToInterrupt(_intPin));
|————————Node:call_expression Text: detachInterrupt(digitalPinToInterrupt(_intPin))
|—————————Node:identifier Text: detachInterrupt
|—————————Node:argument_list Text: (digitalPinToInterrupt(_intPin))
|——————————Node:( Text: (
|——————————Node:call_expression Text: digitalPinToInterrupt(_intPin)
|———————————Node:identifier Text: digitalPinToInterrupt
|———————————Node:argument_list Text: (_intPin)
|————————————Node:( Text: (
|————————————Node:identifier Text: _intPin
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:preproc_ifdef Text: #ifdef SPI_HAS_NOTUSINGINTERRUPT
    SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
#endif
|————————Node:#ifdef Text: #ifdef
|————————Node:identifier Text: SPI_HAS_NOTUSINGINTERRUPT
|————————Node:expression_statement Text: SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin));
|—————————Node:call_expression Text: SPI.notUsingInterrupt(digitalPinToInterrupt(_intPin))
|——————————Node:field_expression Text: SPI.notUsingInterrupt
|———————————Node:identifier Text: SPI
|———————————Node:. Text: .
|———————————Node:field_identifier Text: notUsingInterrupt
|——————————Node:argument_list Text: (digitalPinToInterrupt(_intPin))
|———————————Node:( Text: (
|———————————Node:call_expression Text: digitalPinToInterrupt(_intPin)
|————————————Node:identifier Text: digitalPinToInterrupt
|————————————Node:argument_list Text: (_intPin)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: _intPin
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:} Text: }
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::filter(int id, int mask)
{
  id &= 0x7ff;
  mask &= 0x7ff;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // standard only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);

    writeRegister(REG_RXMnSIDH(n), mask >> 3);
    writeRegister(REG_RXMnSIDL(n), mask << 5);
    writeRegister(REG_RXMnEID8(n), 0);
    writeRegister(REG_RXMnEID0(n), 0);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 3);
    writeRegister(REG_RXFnSIDL(n), id << 5);
    writeRegister(REG_RXFnEID8(n), 0);
    writeRegister(REG_RXFnEID0(n), 0);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::filter(int id, int mask)
|————Node:qualified_identifier Text: MCP2515Class::filter
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: filter
|————Node:parameter_list Text: (int id, int mask)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: int id
|——————Node:primitive_type Text: int
|——————Node:identifier Text: id
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: int mask
|——————Node:primitive_type Text: int
|——————Node:identifier Text: mask
|—————Node:) Text: )
|———Node:compound_statement Text: {
  id &= 0x7ff;
  mask &= 0x7ff;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // standard only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);

    writeRegister(REG_RXMnSIDH(n), mask >> 3);
    writeRegister(REG_RXMnSIDL(n), mask << 5);
    writeRegister(REG_RXMnEID8(n), 0);
    writeRegister(REG_RXMnEID0(n), 0);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 3);
    writeRegister(REG_RXFnSIDL(n), id << 5);
    writeRegister(REG_RXFnEID8(n), 0);
    writeRegister(REG_RXFnEID0(n), 0);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: id &= 0x7ff;
|—————Node:assignment_expression Text: id &= 0x7ff
|——————Node:identifier Text: id
|——————Node:&= Text: &=
|——————Node:number_literal Text: 0x7ff
|—————Node:; Text: ;
|————Node:expression_statement Text: mask &= 0x7ff;
|—————Node:assignment_expression Text: mask &= 0x7ff
|——————Node:identifier Text: mask
|——————Node:&= Text: &=
|——————Node:number_literal Text: 0x7ff
|—————Node:; Text: ;
|————Node:comment Text: // config mode
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x80);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x80)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x80)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x80
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x80)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x80
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x80
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:for_statement Text: for (int n = 0; n < 2; n++) {
    // standard only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);

    writeRegister(REG_RXMnSIDH(n), mask >> 3);
    writeRegister(REG_RXMnSIDL(n), mask << 5);
    writeRegister(REG_RXMnEID8(n), 0);
    writeRegister(REG_RXMnEID0(n), 0);
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: int n = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: n = 0
|———————Node:identifier Text: n
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: n < 2
|——————Node:identifier Text: n
|——————Node:< Text: <
|——————Node:number_literal Text: 2
|—————Node:; Text: ;
|—————Node:update_expression Text: n++
|——————Node:identifier Text: n
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    // standard only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);

    writeRegister(REG_RXMnSIDH(n), mask >> 3);
    writeRegister(REG_RXMnSIDL(n), mask << 5);
    writeRegister(REG_RXMnEID8(n), 0);
    writeRegister(REG_RXMnEID0(n), 0);
  }
|——————Node:{ Text: {
|——————Node:comment Text: // standard only
|——————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
|———————Node:call_expression Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXBnCTRL(n), FLAG_RXM0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXBnCTRL(n)
|——————————Node:identifier Text: REG_RXBnCTRL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: FLAG_RXM0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM0);
|———————Node:call_expression Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXBnCTRL(n), FLAG_RXM0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXBnCTRL(n)
|——————————Node:identifier Text: REG_RXBnCTRL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: FLAG_RXM0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnSIDH(n), mask >> 3);
|———————Node:call_expression Text: writeRegister(REG_RXMnSIDH(n), mask >> 3)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnSIDH(n), mask >> 3)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnSIDH(n)
|——————————Node:identifier Text: REG_RXMnSIDH
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: mask >> 3
|——————————Node:identifier Text: mask
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 3
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnSIDL(n), mask << 5);
|———————Node:call_expression Text: writeRegister(REG_RXMnSIDL(n), mask << 5)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnSIDL(n), mask << 5)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnSIDL(n)
|——————————Node:identifier Text: REG_RXMnSIDL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: mask << 5
|——————————Node:identifier Text: mask
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 5
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnEID8(n), 0);
|———————Node:call_expression Text: writeRegister(REG_RXMnEID8(n), 0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnEID8(n), 0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnEID8(n)
|——————————Node:identifier Text: REG_RXMnEID8
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnEID0(n), 0);
|———————Node:call_expression Text: writeRegister(REG_RXMnEID0(n), 0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnEID0(n), 0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnEID0(n)
|——————————Node:identifier Text: REG_RXMnEID0
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:for_statement Text: for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 3);
    writeRegister(REG_RXFnSIDL(n), id << 5);
    writeRegister(REG_RXFnEID8(n), 0);
    writeRegister(REG_RXFnEID0(n), 0);
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: int n = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: n = 0
|———————Node:identifier Text: n
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: n < 6
|——————Node:identifier Text: n
|——————Node:< Text: <
|——————Node:number_literal Text: 6
|—————Node:; Text: ;
|—————Node:update_expression Text: n++
|——————Node:identifier Text: n
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    writeRegister(REG_RXFnSIDH(n), id >> 3);
    writeRegister(REG_RXFnSIDL(n), id << 5);
    writeRegister(REG_RXFnEID8(n), 0);
    writeRegister(REG_RXFnEID0(n), 0);
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: writeRegister(REG_RXFnSIDH(n), id >> 3);
|———————Node:call_expression Text: writeRegister(REG_RXFnSIDH(n), id >> 3)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnSIDH(n), id >> 3)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnSIDH(n)
|——————————Node:identifier Text: REG_RXFnSIDH
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: id >> 3
|——————————Node:identifier Text: id
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 3
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnSIDL(n), id << 5);
|———————Node:call_expression Text: writeRegister(REG_RXFnSIDL(n), id << 5)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnSIDL(n), id << 5)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnSIDL(n)
|——————————Node:identifier Text: REG_RXFnSIDL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: id << 5
|——————————Node:identifier Text: id
|——————————Node:<< Text: <<
|——————————Node:number_literal Text: 5
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnEID8(n), 0);
|———————Node:call_expression Text: writeRegister(REG_RXFnEID8(n), 0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnEID8(n), 0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnEID8(n)
|——————————Node:identifier Text: REG_RXFnEID8
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnEID0(n), 0);
|———————Node:call_expression Text: writeRegister(REG_RXFnEID0(n), 0)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnEID0(n), 0)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnEID0(n)
|——————————Node:identifier Text: REG_RXFnEID0
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment Text: // normal mode
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x00)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x00
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x00
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::filterExtended(long id, long mask)
{
  id &= 0x1FFFFFFF;
  mask &= 0x1FFFFFFF;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // extended only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);

    writeRegister(REG_RXMnSIDH(n), mask >> 21);
    writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
    writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
    writeRegister(REG_RXMnEID0(n), mask & 0xff);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 21);
    writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
    writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
    writeRegister(REG_RXFnEID0(n), id & 0xff);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::filterExtended(long id, long mask)
|————Node:qualified_identifier Text: MCP2515Class::filterExtended
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: filterExtended
|————Node:parameter_list Text: (long id, long mask)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: long id
|——————Node:sized_type_specifier Text: long
|———————Node:long Text: long
|——————Node:identifier Text: id
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: long mask
|——————Node:sized_type_specifier Text: long
|———————Node:long Text: long
|——————Node:identifier Text: mask
|—————Node:) Text: )
|———Node:compound_statement Text: {
  id &= 0x1FFFFFFF;
  mask &= 0x1FFFFFFF;

  // config mode
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  for (int n = 0; n < 2; n++) {
    // extended only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);

    writeRegister(REG_RXMnSIDH(n), mask >> 21);
    writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
    writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
    writeRegister(REG_RXMnEID0(n), mask & 0xff);
  }

  for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 21);
    writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
    writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
    writeRegister(REG_RXFnEID0(n), id & 0xff);
  }

  // normal mode
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: id &= 0x1FFFFFFF;
|—————Node:assignment_expression Text: id &= 0x1FFFFFFF
|——————Node:identifier Text: id
|——————Node:&= Text: &=
|——————Node:number_literal Text: 0x1FFFFFFF
|—————Node:; Text: ;
|————Node:expression_statement Text: mask &= 0x1FFFFFFF;
|—————Node:assignment_expression Text: mask &= 0x1FFFFFFF
|——————Node:identifier Text: mask
|——————Node:&= Text: &=
|——————Node:number_literal Text: 0x1FFFFFFF
|—————Node:; Text: ;
|————Node:comment Text: // config mode
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x80);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x80)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x80)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x80
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x80)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x80
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x80
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:for_statement Text: for (int n = 0; n < 2; n++) {
    // extended only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);

    writeRegister(REG_RXMnSIDH(n), mask >> 21);
    writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
    writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
    writeRegister(REG_RXMnEID0(n), mask & 0xff);
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: int n = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: n = 0
|———————Node:identifier Text: n
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: n < 2
|——————Node:identifier Text: n
|——————Node:< Text: <
|——————Node:number_literal Text: 2
|—————Node:; Text: ;
|—————Node:update_expression Text: n++
|——————Node:identifier Text: n
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    // extended only
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
    writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);

    writeRegister(REG_RXMnSIDH(n), mask >> 21);
    writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
    writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
    writeRegister(REG_RXMnEID0(n), mask & 0xff);
  }
|——————Node:{ Text: {
|——————Node:comment Text: // extended only
|——————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
|———————Node:call_expression Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM1)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXBnCTRL(n), FLAG_RXM1)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXBnCTRL(n)
|——————————Node:identifier Text: REG_RXBnCTRL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: FLAG_RXM1
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM1);
|———————Node:call_expression Text: writeRegister(REG_RXBnCTRL(n), FLAG_RXM1)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXBnCTRL(n), FLAG_RXM1)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXBnCTRL(n)
|——————————Node:identifier Text: REG_RXBnCTRL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: FLAG_RXM1
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnSIDH(n), mask >> 21);
|———————Node:call_expression Text: writeRegister(REG_RXMnSIDH(n), mask >> 21)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnSIDH(n), mask >> 21)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnSIDH(n)
|——————————Node:identifier Text: REG_RXMnSIDH
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: mask >> 21
|——————————Node:identifier Text: mask
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 21
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03));
|———————Node:call_expression Text: writeRegister(REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03))
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnSIDL(n), (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03))
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnSIDL(n)
|——————————Node:identifier Text: REG_RXMnSIDL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE | ((mask >> 16) & 0x03)
|——————————Node:binary_expression Text: (((mask >> 18) & 0x03) << 5) | FLAG_EXIDE
|———————————Node:parenthesized_expression Text: (((mask >> 18) & 0x03) << 5)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ((mask >> 18) & 0x03) << 5
|—————————————Node:parenthesized_expression Text: ((mask >> 18) & 0x03)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (mask >> 18) & 0x03
|———————————————Node:parenthesized_expression Text: (mask >> 18)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: mask >> 18
|—————————————————Node:identifier Text: mask
|—————————————————Node:>> Text: >>
|—————————————————Node:number_literal Text: 18
|————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0x03
|——————————————Node:) Text: )
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 5
|————————————Node:) Text: )
|———————————Node:| Text: |
|———————————Node:identifier Text: FLAG_EXIDE
|——————————Node:| Text: |
|——————————Node:parenthesized_expression Text: ((mask >> 16) & 0x03)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (mask >> 16) & 0x03
|————————————Node:parenthesized_expression Text: (mask >> 16)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: mask >> 16
|——————————————Node:identifier Text: mask
|——————————————Node:>> Text: >>
|——————————————Node:number_literal Text: 16
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x03
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff);
|———————Node:call_expression Text: writeRegister(REG_RXMnEID8(n), (mask >> 8) & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnEID8(n), (mask >> 8) & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnEID8(n)
|——————————Node:identifier Text: REG_RXMnEID8
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (mask >> 8) & 0xff
|——————————Node:parenthesized_expression Text: (mask >> 8)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: mask >> 8
|————————————Node:identifier Text: mask
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 8
|———————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXMnEID0(n), mask & 0xff);
|———————Node:call_expression Text: writeRegister(REG_RXMnEID0(n), mask & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXMnEID0(n), mask & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXMnEID0(n)
|——————————Node:identifier Text: REG_RXMnEID0
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: mask & 0xff
|——————————Node:identifier Text: mask
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:for_statement Text: for (int n = 0; n < 6; n++) {
    writeRegister(REG_RXFnSIDH(n), id >> 21);
    writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
    writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
    writeRegister(REG_RXFnEID0(n), id & 0xff);
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: int n = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: n = 0
|———————Node:identifier Text: n
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: n < 6
|——————Node:identifier Text: n
|——————Node:< Text: <
|——————Node:number_literal Text: 6
|—————Node:; Text: ;
|—————Node:update_expression Text: n++
|——————Node:identifier Text: n
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    writeRegister(REG_RXFnSIDH(n), id >> 21);
    writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
    writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
    writeRegister(REG_RXFnEID0(n), id & 0xff);
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: writeRegister(REG_RXFnSIDH(n), id >> 21);
|———————Node:call_expression Text: writeRegister(REG_RXFnSIDH(n), id >> 21)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnSIDH(n), id >> 21)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnSIDH(n)
|——————————Node:identifier Text: REG_RXFnSIDH
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: id >> 21
|——————————Node:identifier Text: id
|——————————Node:>> Text: >>
|——————————Node:number_literal Text: 21
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03));
|———————Node:call_expression Text: writeRegister(REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03))
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnSIDL(n), (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03))
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnSIDL(n)
|——————————Node:identifier Text: REG_RXFnSIDL
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (((id >> 18) & 0x03) << 5) | FLAG_EXIDE | ((id >> 16) & 0x03)
|——————————Node:binary_expression Text: (((id >> 18) & 0x03) << 5) | FLAG_EXIDE
|———————————Node:parenthesized_expression Text: (((id >> 18) & 0x03) << 5)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: ((id >> 18) & 0x03) << 5
|—————————————Node:parenthesized_expression Text: ((id >> 18) & 0x03)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (id >> 18) & 0x03
|———————————————Node:parenthesized_expression Text: (id >> 18)
|————————————————Node:( Text: (
|————————————————Node:binary_expression Text: id >> 18
|—————————————————Node:identifier Text: id
|—————————————————Node:>> Text: >>
|—————————————————Node:number_literal Text: 18
|————————————————Node:) Text: )
|———————————————Node:& Text: &
|———————————————Node:number_literal Text: 0x03
|——————————————Node:) Text: )
|—————————————Node:<< Text: <<
|—————————————Node:number_literal Text: 5
|————————————Node:) Text: )
|———————————Node:| Text: |
|———————————Node:identifier Text: FLAG_EXIDE
|——————————Node:| Text: |
|——————————Node:parenthesized_expression Text: ((id >> 16) & 0x03)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: (id >> 16) & 0x03
|————————————Node:parenthesized_expression Text: (id >> 16)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: id >> 16
|——————————————Node:identifier Text: id
|——————————————Node:>> Text: >>
|——————————————Node:number_literal Text: 16
|—————————————Node:) Text: )
|————————————Node:& Text: &
|————————————Node:number_literal Text: 0x03
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff);
|———————Node:call_expression Text: writeRegister(REG_RXFnEID8(n), (id >> 8) & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnEID8(n), (id >> 8) & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnEID8(n)
|——————————Node:identifier Text: REG_RXFnEID8
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: (id >> 8) & 0xff
|——————————Node:parenthesized_expression Text: (id >> 8)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: id >> 8
|————————————Node:identifier Text: id
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 8
|———————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: writeRegister(REG_RXFnEID0(n), id & 0xff);
|———————Node:call_expression Text: writeRegister(REG_RXFnEID0(n), id & 0xff)
|————————Node:identifier Text: writeRegister
|————————Node:argument_list Text: (REG_RXFnEID0(n), id & 0xff)
|—————————Node:( Text: (
|—————————Node:call_expression Text: REG_RXFnEID0(n)
|——————————Node:identifier Text: REG_RXFnEID0
|——————————Node:argument_list Text: (n)
|———————————Node:( Text: (
|———————————Node:identifier Text: n
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:binary_expression Text: id & 0xff
|——————————Node:identifier Text: id
|——————————Node:& Text: &
|——————————Node:number_literal Text: 0xff
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:comment Text: // normal mode
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x00)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x00
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x00
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::observe()
{
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::observe()
|————Node:qualified_identifier Text: MCP2515Class::observe
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: observe
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  writeRegister(REG_CANCTRL, 0x80);
  if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x80);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x80)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x80)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x80
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x80) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x80)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x80
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x80
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::loopback()
{
  writeRegister(REG_CANCTRL, 0x40);
  if (readRegister(REG_CANCTRL) != 0x40) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::loopback()
|————Node:qualified_identifier Text: MCP2515Class::loopback
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: loopback
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  writeRegister(REG_CANCTRL, 0x40);
  if (readRegister(REG_CANCTRL) != 0x40) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x40);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x40)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x40)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x40
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x40) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x40)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x40
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x40
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::sleep()
{
  writeRegister(REG_CANCTRL, 0x01);
  if (readRegister(REG_CANCTRL) != 0x01) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::sleep()
|————Node:qualified_identifier Text: MCP2515Class::sleep
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: sleep
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  writeRegister(REG_CANCTRL, 0x01);
  if (readRegister(REG_CANCTRL) != 0x01) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x01);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x01)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x01)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x01
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x01) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x01)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x01
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x01
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: int MCP2515Class::wakeup()
{
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|———Node:primitive_type Text: int
|———Node:function_declarator Text: MCP2515Class::wakeup()
|————Node:qualified_identifier Text: MCP2515Class::wakeup
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: wakeup
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  writeRegister(REG_CANCTRL, 0x00);
  if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }

  return 1;
}
|————Node:{ Text: {
|————Node:expression_statement Text: writeRegister(REG_CANCTRL, 0x00);
|—————Node:call_expression Text: writeRegister(REG_CANCTRL, 0x00)
|——————Node:identifier Text: writeRegister
|——————Node:argument_list Text: (REG_CANCTRL, 0x00)
|———————Node:( Text: (
|———————Node:identifier Text: REG_CANCTRL
|———————Node:, Text: ,
|———————Node:number_literal Text: 0x00
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:if_statement Text: if (readRegister(REG_CANCTRL) != 0x00) {
    return 0;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANCTRL) != 0x00)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANCTRL) != 0x00
|———————Node:call_expression Text: readRegister(REG_CANCTRL)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANCTRL)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANCTRL
|—————————Node:) Text: )
|———————Node:!= Text: !=
|———————Node:number_literal Text: 0x00
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return 0;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return 0;
|———————Node:return Text: return
|———————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return 1;
|—————Node:return Text: return
|—————Node:number_literal Text: 1
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::setPins(int cs, int irq)
{
  _csPin = cs;
  _intPin = irq;
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::setPins(int cs, int irq)
|————Node:qualified_identifier Text: MCP2515Class::setPins
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: setPins
|————Node:parameter_list Text: (int cs, int irq)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: int cs
|——————Node:primitive_type Text: int
|——————Node:identifier Text: cs
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: int irq
|——————Node:primitive_type Text: int
|——————Node:identifier Text: irq
|—————Node:) Text: )
|———Node:compound_statement Text: {
  _csPin = cs;
  _intPin = irq;
}
|————Node:{ Text: {
|————Node:expression_statement Text: _csPin = cs;
|—————Node:assignment_expression Text: _csPin = cs
|——————Node:identifier Text: _csPin
|——————Node:= Text: =
|——————Node:identifier Text: cs
|—————Node:; Text: ;
|————Node:expression_statement Text: _intPin = irq;
|—————Node:assignment_expression Text: _intPin = irq
|——————Node:identifier Text: _intPin
|——————Node:= Text: =
|——————Node:identifier Text: irq
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::setSPIFrequency(uint32_t frequency)
{
  _spiSettings = SPISettings(frequency, MSBFIRST, SPI_MODE0);
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::setSPIFrequency(uint32_t frequency)
|————Node:qualified_identifier Text: MCP2515Class::setSPIFrequency
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: setSPIFrequency
|————Node:parameter_list Text: (uint32_t frequency)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: uint32_t frequency
|——————Node:primitive_type Text: uint32_t
|——————Node:identifier Text: frequency
|—————Node:) Text: )
|———Node:compound_statement Text: {
  _spiSettings = SPISettings(frequency, MSBFIRST, SPI_MODE0);
}
|————Node:{ Text: {
|————Node:expression_statement Text: _spiSettings = SPISettings(frequency, MSBFIRST, SPI_MODE0);
|—————Node:assignment_expression Text: _spiSettings = SPISettings(frequency, MSBFIRST, SPI_MODE0)
|——————Node:identifier Text: _spiSettings
|——————Node:= Text: =
|——————Node:call_expression Text: SPISettings(frequency, MSBFIRST, SPI_MODE0)
|———————Node:identifier Text: SPISettings
|———————Node:argument_list Text: (frequency, MSBFIRST, SPI_MODE0)
|————————Node:( Text: (
|————————Node:identifier Text: frequency
|————————Node:, Text: ,
|————————Node:identifier Text: MSBFIRST
|————————Node:, Text: ,
|————————Node:identifier Text: SPI_MODE0
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::setClockFrequency(long clockFrequency)
{
  _clockFrequency = clockFrequency;
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::setClockFrequency(long clockFrequency)
|————Node:qualified_identifier Text: MCP2515Class::setClockFrequency
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: setClockFrequency
|————Node:parameter_list Text: (long clockFrequency)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: long clockFrequency
|——————Node:sized_type_specifier Text: long
|———————Node:long Text: long
|——————Node:identifier Text: clockFrequency
|—————Node:) Text: )
|———Node:compound_statement Text: {
  _clockFrequency = clockFrequency;
}
|————Node:{ Text: {
|————Node:expression_statement Text: _clockFrequency = clockFrequency;
|—————Node:assignment_expression Text: _clockFrequency = clockFrequency
|——————Node:identifier Text: _clockFrequency
|——————Node:= Text: =
|——————Node:identifier Text: clockFrequency
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::dumpRegisters(Stream& out)
{
  for (int i = 0; i < 128; i++) {
    byte b = readRegister(i);

    out.print("0x");
    if (i < 16) {
      out.print('0');
    }
    out.print(i, HEX);
    out.print(": 0x");
    if (b < 16) {
      out.print('0');
    }
    out.println(b, HEX);
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::dumpRegisters(Stream& out)
|————Node:qualified_identifier Text: MCP2515Class::dumpRegisters
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: dumpRegisters
|————Node:parameter_list Text: (Stream& out)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: Stream& out
|——————Node:type_identifier Text: Stream
|——————Node:reference_declarator Text: & out
|———————Node:& Text: &
|———————Node:identifier Text: out
|—————Node:) Text: )
|———Node:compound_statement Text: {
  for (int i = 0; i < 128; i++) {
    byte b = readRegister(i);

    out.print("0x");
    if (i < 16) {
      out.print('0');
    }
    out.print(i, HEX);
    out.print(": 0x");
    if (b < 16) {
      out.print('0');
    }
    out.println(b, HEX);
  }
}
|————Node:{ Text: {
|————Node:for_statement Text: for (int i = 0; i < 128; i++) {
    byte b = readRegister(i);

    out.print("0x");
    if (i < 16) {
      out.print('0');
    }
    out.print(i, HEX);
    out.print(": 0x");
    if (b < 16) {
      out.print('0');
    }
    out.println(b, HEX);
  }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:declaration Text: int i = 0;
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:binary_expression Text: i < 128
|——————Node:identifier Text: i
|——————Node:< Text: <
|——————Node:number_literal Text: 128
|—————Node:; Text: ;
|—————Node:update_expression Text: i++
|——————Node:identifier Text: i
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
    byte b = readRegister(i);

    out.print("0x");
    if (i < 16) {
      out.print('0');
    }
    out.print(i, HEX);
    out.print(": 0x");
    if (b < 16) {
      out.print('0');
    }
    out.println(b, HEX);
  }
|——————Node:{ Text: {
|——————Node:declaration Text: byte b = readRegister(i);
|———————Node:type_identifier Text: byte
|———————Node:init_declarator Text: b = readRegister(i)
|————————Node:identifier Text: b
|————————Node:= Text: =
|————————Node:call_expression Text: readRegister(i)
|—————————Node:identifier Text: readRegister
|—————————Node:argument_list Text: (i)
|——————————Node:( Text: (
|——————————Node:identifier Text: i
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: out.print("0x");
|———————Node:call_expression Text: out.print("0x")
|————————Node:field_expression Text: out.print
|—————————Node:identifier Text: out
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: ("0x")
|—————————Node:( Text: (
|—————————Node:string_literal Text: "0x"
|——————————Node:" Text: "
|——————————Node:string_content Text: 0x
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (i < 16) {
      out.print('0');
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: (i < 16)
|————————Node:( Text: (
|————————Node:binary_expression Text: i < 16
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:number_literal Text: 16
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      out.print('0');
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: out.print('0');
|—————————Node:call_expression Text: out.print('0')
|——————————Node:field_expression Text: out.print
|———————————Node:identifier Text: out
|———————————Node:. Text: .
|———————————Node:field_identifier Text: print
|——————————Node:argument_list Text: ('0')
|———————————Node:( Text: (
|———————————Node:char_literal Text: '0'
|————————————Node:' Text: '
|————————————Node:character Text: 0
|————————————Node:' Text: '
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: out.print(i, HEX);
|———————Node:call_expression Text: out.print(i, HEX)
|————————Node:field_expression Text: out.print
|—————————Node:identifier Text: out
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: (i, HEX)
|—————————Node:( Text: (
|—————————Node:identifier Text: i
|—————————Node:, Text: ,
|—————————Node:identifier Text: HEX
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: out.print(": 0x");
|———————Node:call_expression Text: out.print(": 0x")
|————————Node:field_expression Text: out.print
|—————————Node:identifier Text: out
|—————————Node:. Text: .
|—————————Node:field_identifier Text: print
|————————Node:argument_list Text: (": 0x")
|—————————Node:( Text: (
|—————————Node:string_literal Text: ": 0x"
|——————————Node:" Text: "
|——————————Node:string_content Text: : 0x
|——————————Node:" Text: "
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:if_statement Text: if (b < 16) {
      out.print('0');
    }
|———————Node:if Text: if
|———————Node:condition_clause Text: (b < 16)
|————————Node:( Text: (
|————————Node:binary_expression Text: b < 16
|—————————Node:identifier Text: b
|—————————Node:< Text: <
|—————————Node:number_literal Text: 16
|————————Node:) Text: )
|———————Node:compound_statement Text: {
      out.print('0');
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: out.print('0');
|—————————Node:call_expression Text: out.print('0')
|——————————Node:field_expression Text: out.print
|———————————Node:identifier Text: out
|———————————Node:. Text: .
|———————————Node:field_identifier Text: print
|——————————Node:argument_list Text: ('0')
|———————————Node:( Text: (
|———————————Node:char_literal Text: '0'
|————————————Node:' Text: '
|————————————Node:character Text: 0
|————————————Node:' Text: '
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: out.println(b, HEX);
|———————Node:call_expression Text: out.println(b, HEX)
|————————Node:field_expression Text: out.println
|—————————Node:identifier Text: out
|—————————Node:. Text: .
|—————————Node:field_identifier Text: println
|————————Node:argument_list Text: (b, HEX)
|—————————Node:( Text: (
|—————————Node:identifier Text: b
|—————————Node:, Text: ,
|—————————Node:identifier Text: HEX
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::reset()
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0xc0);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  delayMicroseconds(10);
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::reset()
|————Node:qualified_identifier Text: MCP2515Class::reset
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: reset
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0xc0);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  delayMicroseconds(10);
}
|————Node:{ Text: {
|————Node:expression_statement Text: SPI.beginTransaction(_spiSettings);
|—————Node:call_expression Text: SPI.beginTransaction(_spiSettings)
|——————Node:field_expression Text: SPI.beginTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: beginTransaction
|——————Node:argument_list Text: (_spiSettings)
|———————Node:( Text: (
|———————Node:identifier Text: _spiSettings
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, LOW);
|—————Node:call_expression Text: digitalWrite(_csPin, LOW)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, LOW)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: LOW
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(0xc0);
|—————Node:call_expression Text: SPI.transfer(0xc0)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (0xc0)
|———————Node:( Text: (
|———————Node:number_literal Text: 0xc0
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, HIGH);
|—————Node:call_expression Text: digitalWrite(_csPin, HIGH)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: HIGH
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.endTransaction();
|—————Node:call_expression Text: SPI.endTransaction()
|——————Node:field_expression Text: SPI.endTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: endTransaction
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: delayMicroseconds(10);
|—————Node:call_expression Text: delayMicroseconds(10)
|——————Node:identifier Text: delayMicroseconds
|——————Node:argument_list Text: (10)
|———————Node:( Text: (
|———————Node:number_literal Text: 10
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::handleInterrupt()
{
  if (readRegister(REG_CANINTF) == 0) {
    return;
  }

  while (parsePacket() || _rxId != -1) {
    _onReceive(available());
  }
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::handleInterrupt()
|————Node:qualified_identifier Text: MCP2515Class::handleInterrupt
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: handleInterrupt
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  if (readRegister(REG_CANINTF) == 0) {
    return;
  }

  while (parsePacket() || _rxId != -1) {
    _onReceive(available());
  }
}
|————Node:{ Text: {
|————Node:if_statement Text: if (readRegister(REG_CANINTF) == 0) {
    return;
  }
|—————Node:if Text: if
|—————Node:condition_clause Text: (readRegister(REG_CANINTF) == 0)
|——————Node:( Text: (
|——————Node:binary_expression Text: readRegister(REG_CANINTF) == 0
|———————Node:call_expression Text: readRegister(REG_CANINTF)
|————————Node:identifier Text: readRegister
|————————Node:argument_list Text: (REG_CANINTF)
|—————————Node:( Text: (
|—————————Node:identifier Text: REG_CANINTF
|—————————Node:) Text: )
|———————Node:== Text: ==
|———————Node:number_literal Text: 0
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    return;
  }
|——————Node:{ Text: {
|——————Node:return_statement Text: return;
|———————Node:return Text: return
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:while_statement Text: while (parsePacket() || _rxId != -1) {
    _onReceive(available());
  }
|—————Node:while Text: while
|—————Node:condition_clause Text: (parsePacket() || _rxId != -1)
|——————Node:( Text: (
|——————Node:binary_expression Text: parsePacket() || _rxId != -1
|———————Node:call_expression Text: parsePacket()
|————————Node:identifier Text: parsePacket
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:|| Text: ||
|———————Node:binary_expression Text: _rxId != -1
|————————Node:identifier Text: _rxId
|————————Node:!= Text: !=
|————————Node:number_literal Text: -1
|——————Node:) Text: )
|—————Node:compound_statement Text: {
    _onReceive(available());
  }
|——————Node:{ Text: {
|——————Node:expression_statement Text: _onReceive(available());
|———————Node:call_expression Text: _onReceive(available())
|————————Node:identifier Text: _onReceive
|————————Node:argument_list Text: (available())
|—————————Node:( Text: (
|—————————Node:call_expression Text: available()
|——————————Node:identifier Text: available
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:} Text: }
|——Node:function_definition Text: uint8_t MCP2515Class::readRegister(uint8_t address)
{
  uint8_t value;

  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x03);
  SPI.transfer(address);
  value = SPI.transfer(0x00);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  return value;
}
|———Node:primitive_type Text: uint8_t
|———Node:function_declarator Text: MCP2515Class::readRegister(uint8_t address)
|————Node:qualified_identifier Text: MCP2515Class::readRegister
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: readRegister
|————Node:parameter_list Text: (uint8_t address)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: uint8_t address
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: address
|—————Node:) Text: )
|———Node:compound_statement Text: {
  uint8_t value;

  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x03);
  SPI.transfer(address);
  value = SPI.transfer(0x00);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();

  return value;
}
|————Node:{ Text: {
|————Node:declaration Text: uint8_t value;
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: value
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.beginTransaction(_spiSettings);
|—————Node:call_expression Text: SPI.beginTransaction(_spiSettings)
|——————Node:field_expression Text: SPI.beginTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: beginTransaction
|——————Node:argument_list Text: (_spiSettings)
|———————Node:( Text: (
|———————Node:identifier Text: _spiSettings
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, LOW);
|—————Node:call_expression Text: digitalWrite(_csPin, LOW)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, LOW)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: LOW
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(0x03);
|—————Node:call_expression Text: SPI.transfer(0x03)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (0x03)
|———————Node:( Text: (
|———————Node:number_literal Text: 0x03
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(address);
|—————Node:call_expression Text: SPI.transfer(address)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (address)
|———————Node:( Text: (
|———————Node:identifier Text: address
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: value = SPI.transfer(0x00);
|—————Node:assignment_expression Text: value = SPI.transfer(0x00)
|——————Node:identifier Text: value
|——————Node:= Text: =
|——————Node:call_expression Text: SPI.transfer(0x00)
|———————Node:field_expression Text: SPI.transfer
|————————Node:identifier Text: SPI
|————————Node:. Text: .
|————————Node:field_identifier Text: transfer
|———————Node:argument_list Text: (0x00)
|————————Node:( Text: (
|————————Node:number_literal Text: 0x00
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, HIGH);
|—————Node:call_expression Text: digitalWrite(_csPin, HIGH)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: HIGH
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.endTransaction();
|—————Node:call_expression Text: SPI.endTransaction()
|——————Node:field_expression Text: SPI.endTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: endTransaction
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:return_statement Text: return value;
|—————Node:return Text: return
|—————Node:identifier Text: value
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::modifyRegister(uint8_t address, uint8_t mask, uint8_t value)
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x05);
  SPI.transfer(address);
  SPI.transfer(mask);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::modifyRegister(uint8_t address, uint8_t mask, uint8_t value)
|————Node:qualified_identifier Text: MCP2515Class::modifyRegister
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: modifyRegister
|————Node:parameter_list Text: (uint8_t address, uint8_t mask, uint8_t value)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: uint8_t address
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: address
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: uint8_t mask
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: mask
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: uint8_t value
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: value
|—————Node:) Text: )
|———Node:compound_statement Text: {
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x05);
  SPI.transfer(address);
  SPI.transfer(mask);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}
|————Node:{ Text: {
|————Node:expression_statement Text: SPI.beginTransaction(_spiSettings);
|—————Node:call_expression Text: SPI.beginTransaction(_spiSettings)
|——————Node:field_expression Text: SPI.beginTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: beginTransaction
|——————Node:argument_list Text: (_spiSettings)
|———————Node:( Text: (
|———————Node:identifier Text: _spiSettings
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, LOW);
|—————Node:call_expression Text: digitalWrite(_csPin, LOW)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, LOW)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: LOW
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(0x05);
|—————Node:call_expression Text: SPI.transfer(0x05)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (0x05)
|———————Node:( Text: (
|———————Node:number_literal Text: 0x05
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(address);
|—————Node:call_expression Text: SPI.transfer(address)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (address)
|———————Node:( Text: (
|———————Node:identifier Text: address
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(mask);
|—————Node:call_expression Text: SPI.transfer(mask)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (mask)
|———————Node:( Text: (
|———————Node:identifier Text: mask
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(value);
|—————Node:call_expression Text: SPI.transfer(value)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (value)
|———————Node:( Text: (
|———————Node:identifier Text: value
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, HIGH);
|—————Node:call_expression Text: digitalWrite(_csPin, HIGH)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: HIGH
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.endTransaction();
|—————Node:call_expression Text: SPI.endTransaction()
|——————Node:field_expression Text: SPI.endTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: endTransaction
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::writeRegister(uint8_t address, uint8_t value)
{
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x02);
  SPI.transfer(address);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::writeRegister(uint8_t address, uint8_t value)
|————Node:qualified_identifier Text: MCP2515Class::writeRegister
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: writeRegister
|————Node:parameter_list Text: (uint8_t address, uint8_t value)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: uint8_t address
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: address
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: uint8_t value
|——————Node:primitive_type Text: uint8_t
|——————Node:identifier Text: value
|—————Node:) Text: )
|———Node:compound_statement Text: {
  SPI.beginTransaction(_spiSettings);
  digitalWrite(_csPin, LOW);
  SPI.transfer(0x02);
  SPI.transfer(address);
  SPI.transfer(value);
  digitalWrite(_csPin, HIGH);
  SPI.endTransaction();
}
|————Node:{ Text: {
|————Node:expression_statement Text: SPI.beginTransaction(_spiSettings);
|—————Node:call_expression Text: SPI.beginTransaction(_spiSettings)
|——————Node:field_expression Text: SPI.beginTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: beginTransaction
|——————Node:argument_list Text: (_spiSettings)
|———————Node:( Text: (
|———————Node:identifier Text: _spiSettings
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, LOW);
|—————Node:call_expression Text: digitalWrite(_csPin, LOW)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, LOW)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: LOW
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(0x02);
|—————Node:call_expression Text: SPI.transfer(0x02)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (0x02)
|———————Node:( Text: (
|———————Node:number_literal Text: 0x02
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(address);
|—————Node:call_expression Text: SPI.transfer(address)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (address)
|———————Node:( Text: (
|———————Node:identifier Text: address
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.transfer(value);
|—————Node:call_expression Text: SPI.transfer(value)
|——————Node:field_expression Text: SPI.transfer
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: transfer
|——————Node:argument_list Text: (value)
|———————Node:( Text: (
|———————Node:identifier Text: value
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: digitalWrite(_csPin, HIGH);
|—————Node:call_expression Text: digitalWrite(_csPin, HIGH)
|——————Node:identifier Text: digitalWrite
|——————Node:argument_list Text: (_csPin, HIGH)
|———————Node:( Text: (
|———————Node:identifier Text: _csPin
|———————Node:, Text: ,
|———————Node:identifier Text: HIGH
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: SPI.endTransaction();
|—————Node:call_expression Text: SPI.endTransaction()
|——————Node:field_expression Text: SPI.endTransaction
|———————Node:identifier Text: SPI
|———————Node:. Text: .
|———————Node:field_identifier Text: endTransaction
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:function_definition Text: void MCP2515Class::onInterrupt()
{
  CAN.handleInterrupt();
}
|———Node:primitive_type Text: void
|———Node:function_declarator Text: MCP2515Class::onInterrupt()
|————Node:qualified_identifier Text: MCP2515Class::onInterrupt
|—————Node:namespace_identifier Text: MCP2515Class
|—————Node::: Text: ::
|—————Node:identifier Text: onInterrupt
|————Node:parameter_list Text: ()
|—————Node:( Text: (
|—————Node:) Text: )
|———Node:compound_statement Text: {
  CAN.handleInterrupt();
}
|————Node:{ Text: {
|————Node:expression_statement Text: CAN.handleInterrupt();
|—————Node:call_expression Text: CAN.handleInterrupt()
|——————Node:field_expression Text: CAN.handleInterrupt
|———————Node:identifier Text: CAN
|———————Node:. Text: .
|———————Node:field_identifier Text: handleInterrupt
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:declaration Text: MCP2515Class CAN;
|———Node:type_identifier Text: MCP2515Class
|———Node:identifier Text: CAN
|———Node:; Text: ;
|——Node:#endif Text: #endif
