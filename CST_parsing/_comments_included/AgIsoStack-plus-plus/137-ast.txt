AgIsoStack-plus-plus-socket_can\src\socket_can_interface.cpp

|Node:translation_unit
|—Node:comment Text: //================================================================================================
|—Node:comment Text: /// @file socket_can_interface.cpp
|—Node:comment Text: ///
|—Node:comment Text: /// @brief An interface for using socket CAN on linux. Mostly for testing, but it could be
|—Node:comment Text: /// used in any application to get the stack hooked up to the bus.
|—Node:comment Text: /// @author Adrian Del Grosso
|—Node:comment Text: ///
|—Node:comment Text: /// @copyright 2022 Adrian Del Grosso
|—Node:comment Text: //================================================================================================
|—Node:preproc_include Text: #include "socket_can_interface.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "socket_can_interface.hpp"
|———Node:" Text: "
|———Node:string_content Text: socket_can_interface.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include "system_timing.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "system_timing.hpp"
|———Node:" Text: "
|———Node:string_content Text: system_timing.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include <linux/can.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/can.h>
|—Node:preproc_include Text: #include <linux/can/raw.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <linux/can/raw.h>
|—Node:preproc_include Text: #include <net/if.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <net/if.h>
|—Node:preproc_include Text: #include <poll.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <poll.h>
|—Node:preproc_include Text: #include <sys/ioctl.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <sys/ioctl.h>
|—Node:preproc_include Text: #include <unistd.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <unistd.h>
|—Node:preproc_include Text: #include <algorithm>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <algorithm>
|—Node:preproc_include Text: #include <chrono>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <chrono>
|—Node:preproc_include Text: #include <cstdint>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <cstdint>
|—Node:preproc_include Text: #include <limits>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <limits>
|—Node:declaration Text: std::thread *CANHardwareInterface::can_thread = nullptr;
|——Node:qualified_identifier Text: std::thread
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: thread
|——Node:init_declarator Text: *CANHardwareInterface::can_thread = nullptr
|———Node:pointer_declarator Text: *CANHardwareInterface::can_thread
|————Node:* Text: *
|————Node:qualified_identifier Text: CANHardwareInterface::can_thread
|—————Node:namespace_identifier Text: CANHardwareInterface
|—————Node::: Text: ::
|—————Node:identifier Text: can_thread
|———Node:= Text: =
|———Node:null Text: nullptr
|————Node:nullptr Text: nullptr
|——Node:; Text: ;
|—Node:declaration Text: std::thread *CANHardwareInterface::updateCANLibPeriodicThread = nullptr;
|——Node:qualified_identifier Text: std::thread
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: thread
|——Node:init_declarator Text: *CANHardwareInterface::updateCANLibPeriodicThread = nullptr
|———Node:pointer_declarator Text: *CANHardwareInterface::updateCANLibPeriodicThread
|————Node:* Text: *
|————Node:qualified_identifier Text: CANHardwareInterface::updateCANLibPeriodicThread
|—————Node:namespace_identifier Text: CANHardwareInterface
|—————Node::: Text: ::
|—————Node:identifier Text: updateCANLibPeriodicThread
|———Node:= Text: =
|———Node:null Text: nullptr
|————Node:nullptr Text: nullptr
|——Node:; Text: ;
|—Node:declaration Text: std::condition_variable CANHardwareInterface::threadConditionVariable;
|——Node:qualified_identifier Text: std::condition_variable
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: condition_variable
|——Node:qualified_identifier Text: CANHardwareInterface::threadConditionVariable
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: threadConditionVariable
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::CanHardware *> CANHardwareInterface::hardwareChannels;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::CanHardware *>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::CanHardware *>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::CanHardware *>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::CanHardware *
|——————Node:qualified_identifier Text: CANHardwareInterface::CanHardware
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: CanHardware
|——————Node:abstract_pointer_declarator Text: *
|———————Node:* Text: *
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::hardwareChannels
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: hardwareChannels
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::RawCanMessageCallbackInfo> CANHardwareInterface::rxCallbacks;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::RawCanMessageCallbackInfo>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::RawCanMessageCallbackInfo>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::RawCanMessageCallbackInfo>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::RawCanMessageCallbackInfo
|——————Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: RawCanMessageCallbackInfo
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::rxCallbacks
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: rxCallbacks
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::CanLibUpdateCallbackInfo> CANHardwareInterface::canLibUpdateCallbacks;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::CanLibUpdateCallbackInfo>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::CanLibUpdateCallbackInfo>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::CanLibUpdateCallbackInfo>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::CanLibUpdateCallbackInfo
|——————Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: CanLibUpdateCallbackInfo
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::canLibUpdateCallbacks
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibUpdateCallbacks
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::hardwareChannelsMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::hardwareChannelsMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: hardwareChannelsMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::threadMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::threadMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: threadMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::rxCallbackMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::rxCallbackMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: rxCallbackMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::canLibNeedsUpdateMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::canLibNeedsUpdateMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibNeedsUpdateMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::canLibUpdateCallbacksMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::canLibUpdateCallbacksMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibUpdateCallbacksMutex
|——Node:; Text: ;
|—Node:declaration Text: bool CANHardwareInterface::threadsStarted = false;
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: CANHardwareInterface::threadsStarted = false
|———Node:qualified_identifier Text: CANHardwareInterface::threadsStarted
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: threadsStarted
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: bool CANHardwareInterface::canLibNeedsUpdate = false;
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: CANHardwareInterface::canLibNeedsUpdate = false
|———Node:qualified_identifier Text: CANHardwareInterface::canLibNeedsUpdate
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: canLibNeedsUpdate
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: CANHardwareInterface CANHardwareInterface::CAN_HARDWARE_INTERFACE;
|——Node:type_identifier Text: CANHardwareInterface
|——Node:qualified_identifier Text: CANHardwareInterface::CAN_HARDWARE_INTERFACE
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: CAN_HARDWARE_INTERFACE
|——Node:; Text: ;
|—Node:function_definition Text: bool isobus::send_can_message_to_hardware(HardwareInterfaceCANFrame frame)
{
	return CANHardwareInterface::transmit_can_message(frame);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: isobus::send_can_message_to_hardware(HardwareInterfaceCANFrame frame)
|———Node:qualified_identifier Text: isobus::send_can_message_to_hardware
|————Node:namespace_identifier Text: isobus
|————Node::: Text: ::
|————Node:identifier Text: send_can_message_to_hardware
|———Node:parameter_list Text: (HardwareInterfaceCANFrame frame)
|————Node:( Text: (
|————Node:parameter_declaration Text: HardwareInterfaceCANFrame frame
|—————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:identifier Text: frame
|————Node:) Text: )
|——Node:compound_statement Text: {
	return CANHardwareInterface::transmit_can_message(frame);
}
|———Node:{ Text: {
|———Node:return_statement Text: return CANHardwareInterface::transmit_can_message(frame);
|————Node:return Text: return
|————Node:call_expression Text: CANHardwareInterface::transmit_can_message(frame)
|—————Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message
|——————Node:namespace_identifier Text: CANHardwareInterface
|——————Node::: Text: ::
|——————Node:identifier Text: transmit_can_message
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::SocketCANFrameHandler::SocketCANFrameHandler(const std::string deviceName) :
  pCANDevice(new sockaddr_can),
  name(deviceName),
  fileDescriptor(-1)
{
	if (nullptr != pCANDevice)
	{
		memset(pCANDevice, 0, sizeof(struct sockaddr_can));
	}
}
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::SocketCANFrameHandler(const std::string deviceName)
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::SocketCANFrameHandler
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::SocketCANFrameHandler
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: SocketCANFrameHandler
|———Node:parameter_list Text: (const std::string deviceName)
|————Node:( Text: (
|————Node:parameter_declaration Text: const std::string deviceName
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:qualified_identifier Text: std::string
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:type_identifier Text: string
|—————Node:identifier Text: deviceName
|————Node:) Text: )
|——Node:field_initializer_list Text: :
  pCANDevice(new sockaddr_can),
  name(deviceName),
  fileDescriptor(-1)
|———Node:: Text: :
|———Node:field_initializer Text: pCANDevice(new sockaddr_can)
|————Node:field_identifier Text: pCANDevice
|————Node:argument_list Text: (new sockaddr_can)
|—————Node:( Text: (
|—————Node:new_expression Text: new sockaddr_can
|——————Node:new Text: new
|——————Node:type_identifier Text: sockaddr_can
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: name(deviceName)
|————Node:field_identifier Text: name
|————Node:argument_list Text: (deviceName)
|—————Node:( Text: (
|—————Node:identifier Text: deviceName
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: fileDescriptor(-1)
|————Node:field_identifier Text: fileDescriptor
|————Node:argument_list Text: (-1)
|—————Node:( Text: (
|—————Node:number_literal Text: -1
|—————Node:) Text: )
|——Node:compound_statement Text: {
	if (nullptr != pCANDevice)
	{
		memset(pCANDevice, 0, sizeof(struct sockaddr_can));
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (nullptr != pCANDevice)
	{
		memset(pCANDevice, 0, sizeof(struct sockaddr_can));
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != pCANDevice)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != pCANDevice
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: pCANDevice
|—————Node:) Text: )
|————Node:compound_statement Text: {
		memset(pCANDevice, 0, sizeof(struct sockaddr_can));
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: memset(pCANDevice, 0, sizeof(struct sockaddr_can));
|——————Node:call_expression Text: memset(pCANDevice, 0, sizeof(struct sockaddr_can))
|———————Node:identifier Text: memset
|———————Node:argument_list Text: (pCANDevice, 0, sizeof(struct sockaddr_can))
|————————Node:( Text: (
|————————Node:identifier Text: pCANDevice
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(struct sockaddr_can)
|—————————Node:sizeof Text: sizeof
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: struct sockaddr_can
|——————————Node:struct_specifier Text: struct sockaddr_can
|———————————Node:struct Text: struct
|———————————Node:type_identifier Text: sockaddr_can
|—————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::SocketCANFrameHandler::~SocketCANFrameHandler()
{
	close();

	if (nullptr != pCANDevice)
	{
		delete pCANDevice;
		pCANDevice = nullptr;
	}
}
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::~SocketCANFrameHandler()
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::~SocketCANFrameHandler
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::~SocketCANFrameHandler
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:destructor_name Text: ~SocketCANFrameHandler
|——————Node:~ Text: ~
|——————Node:identifier Text: SocketCANFrameHandler
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	close();

	if (nullptr != pCANDevice)
	{
		delete pCANDevice;
		pCANDevice = nullptr;
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: close();
|————Node:call_expression Text: close()
|—————Node:identifier Text: close
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nullptr != pCANDevice)
	{
		delete pCANDevice;
		pCANDevice = nullptr;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != pCANDevice)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != pCANDevice
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: pCANDevice
|—————Node:) Text: )
|————Node:compound_statement Text: {
		delete pCANDevice;
		pCANDevice = nullptr;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: delete pCANDevice;
|——————Node:delete_expression Text: delete pCANDevice
|———————Node:delete Text: delete
|———————Node:identifier Text: pCANDevice
|——————Node:; Text: ;
|—————Node:expression_statement Text: pCANDevice = nullptr;
|——————Node:assignment_expression Text: pCANDevice = nullptr
|———————Node:identifier Text: pCANDevice
|———————Node:= Text: =
|———————Node:null Text: nullptr
|————————Node:nullptr Text: nullptr
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::SocketCANFrameHandler::get_is_valid() const
{
	return (-1 != fileDescriptor);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::get_is_valid() const
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::get_is_valid
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::get_is_valid
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: get_is_valid
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return (-1 != fileDescriptor);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (-1 != fileDescriptor);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (-1 != fileDescriptor)
|—————Node:( Text: (
|—————Node:binary_expression Text: -1 != fileDescriptor
|——————Node:number_literal Text: -1
|——————Node:!= Text: !=
|——————Node:identifier Text: fileDescriptor
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: std::string CANHardwareInterface::SocketCANFrameHandler::get_device_name() const
{
	return name;
}
|——Node:qualified_identifier Text: std::string
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: string
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::get_device_name() const
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::get_device_name
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::get_device_name
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: get_device_name
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|———Node:type_qualifier Text: const
|————Node:const Text: const
|——Node:compound_statement Text: {
	return name;
}
|———Node:{ Text: {
|———Node:return_statement Text: return name;
|————Node:return Text: return
|————Node:identifier Text: name
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::SocketCANFrameHandler::close()
{
	::close(fileDescriptor);
	fileDescriptor = -1;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::close()
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::close
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::close
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: close
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	::close(fileDescriptor);
	fileDescriptor = -1;
}
|———Node:{ Text: {
|———Node:expression_statement Text: ::close(fileDescriptor);
|————Node:call_expression Text: ::close(fileDescriptor)
|—————Node:qualified_identifier Text: ::close
|——————Node::: Text: ::
|——————Node:identifier Text: close
|—————Node:argument_list Text: (fileDescriptor)
|——————Node:( Text: (
|——————Node:identifier Text: fileDescriptor
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: fileDescriptor = -1;
|————Node:assignment_expression Text: fileDescriptor = -1
|—————Node:identifier Text: fileDescriptor
|—————Node:= Text: =
|—————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::SocketCANFrameHandler::open()
{
	fileDescriptor = socket(PF_CAN, SOCK_RAW, CAN_RAW);

	if (fileDescriptor >= 0)
	{
		struct ifreq interfaceRequestStructure;
		const int RECEIVE_OWN_MESSAGES = 0;
		const int DROP_MONITOR = 1;
		const int TIMESTAMPING = 0x58;
		const int TIMESTAMP = 1;
		memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure));
		strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name));
		setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES));
		setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR));

		if (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
		{
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}

		if (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
		{
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
		else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
	}
	else
	{
		::close(fileDescriptor);
		fileDescriptor = -1;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::open()
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::open
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::open
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: open
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	fileDescriptor = socket(PF_CAN, SOCK_RAW, CAN_RAW);

	if (fileDescriptor >= 0)
	{
		struct ifreq interfaceRequestStructure;
		const int RECEIVE_OWN_MESSAGES = 0;
		const int DROP_MONITOR = 1;
		const int TIMESTAMPING = 0x58;
		const int TIMESTAMP = 1;
		memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure));
		strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name));
		setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES));
		setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR));

		if (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
		{
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}

		if (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
		{
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
		else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
	}
	else
	{
		::close(fileDescriptor);
		fileDescriptor = -1;
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: fileDescriptor = socket(PF_CAN, SOCK_RAW, CAN_RAW);
|————Node:assignment_expression Text: fileDescriptor = socket(PF_CAN, SOCK_RAW, CAN_RAW)
|—————Node:identifier Text: fileDescriptor
|—————Node:= Text: =
|—————Node:call_expression Text: socket(PF_CAN, SOCK_RAW, CAN_RAW)
|——————Node:identifier Text: socket
|——————Node:argument_list Text: (PF_CAN, SOCK_RAW, CAN_RAW)
|———————Node:( Text: (
|———————Node:identifier Text: PF_CAN
|———————Node:, Text: ,
|———————Node:identifier Text: SOCK_RAW
|———————Node:, Text: ,
|———————Node:identifier Text: CAN_RAW
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (fileDescriptor >= 0)
	{
		struct ifreq interfaceRequestStructure;
		const int RECEIVE_OWN_MESSAGES = 0;
		const int DROP_MONITOR = 1;
		const int TIMESTAMPING = 0x58;
		const int TIMESTAMP = 1;
		memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure));
		strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name));
		setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES));
		setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR));

		if (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
		{
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}

		if (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
		{
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
		else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
	}
	else
	{
		::close(fileDescriptor);
		fileDescriptor = -1;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (fileDescriptor >= 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: fileDescriptor >= 0
|——————Node:identifier Text: fileDescriptor
|——————Node:>= Text: >=
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		struct ifreq interfaceRequestStructure;
		const int RECEIVE_OWN_MESSAGES = 0;
		const int DROP_MONITOR = 1;
		const int TIMESTAMPING = 0x58;
		const int TIMESTAMP = 1;
		memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure));
		strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name));
		setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES));
		setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR));

		if (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
		{
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}

		if (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
		{
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
		else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: struct ifreq interfaceRequestStructure;
|——————Node:struct_specifier Text: struct ifreq
|———————Node:struct Text: struct
|———————Node:type_identifier Text: ifreq
|——————Node:identifier Text: interfaceRequestStructure
|——————Node:; Text: ;
|—————Node:declaration Text: const int RECEIVE_OWN_MESSAGES = 0;
|——————Node:type_qualifier Text: const
|———————Node:const Text: const
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: RECEIVE_OWN_MESSAGES = 0
|———————Node:identifier Text: RECEIVE_OWN_MESSAGES
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:declaration Text: const int DROP_MONITOR = 1;
|——————Node:type_qualifier Text: const
|———————Node:const Text: const
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: DROP_MONITOR = 1
|———————Node:identifier Text: DROP_MONITOR
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:declaration Text: const int TIMESTAMPING = 0x58;
|——————Node:type_qualifier Text: const
|———————Node:const Text: const
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: TIMESTAMPING = 0x58
|———————Node:identifier Text: TIMESTAMPING
|———————Node:= Text: =
|———————Node:number_literal Text: 0x58
|——————Node:; Text: ;
|—————Node:declaration Text: const int TIMESTAMP = 1;
|——————Node:type_qualifier Text: const
|———————Node:const Text: const
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: TIMESTAMP = 1
|———————Node:identifier Text: TIMESTAMP
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure));
|——————Node:call_expression Text: memset(&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure))
|———————Node:identifier Text: memset
|———————Node:argument_list Text: (&interfaceRequestStructure, 0, sizeof(interfaceRequestStructure))
|————————Node:( Text: (
|————————Node:pointer_expression Text: &interfaceRequestStructure
|—————————Node:& Text: &
|—————————Node:identifier Text: interfaceRequestStructure
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(interfaceRequestStructure)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (interfaceRequestStructure)
|——————————Node:( Text: (
|——————————Node:identifier Text: interfaceRequestStructure
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name));
|——————Node:call_expression Text: strncpy(interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name))
|———————Node:identifier Text: strncpy
|———————Node:argument_list Text: (interfaceRequestStructure.ifr_name, name.c_str(), sizeof(interfaceRequestStructure.ifr_name))
|————————Node:( Text: (
|————————Node:field_expression Text: interfaceRequestStructure.ifr_name
|—————————Node:identifier Text: interfaceRequestStructure
|—————————Node:. Text: .
|—————————Node:field_identifier Text: ifr_name
|————————Node:, Text: ,
|————————Node:call_expression Text: name.c_str()
|—————————Node:field_expression Text: name.c_str
|——————————Node:identifier Text: name
|——————————Node:. Text: .
|——————————Node:field_identifier Text: c_str
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(interfaceRequestStructure.ifr_name)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (interfaceRequestStructure.ifr_name)
|——————————Node:( Text: (
|——————————Node:field_expression Text: interfaceRequestStructure.ifr_name
|———————————Node:identifier Text: interfaceRequestStructure
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ifr_name
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES));
|——————Node:call_expression Text: setsockopt(fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES))
|———————Node:identifier Text: setsockopt
|———————Node:argument_list Text: (fileDescriptor, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &RECEIVE_OWN_MESSAGES, sizeof(RECEIVE_OWN_MESSAGES))
|————————Node:( Text: (
|————————Node:identifier Text: fileDescriptor
|————————Node:, Text: ,
|————————Node:identifier Text: SOL_CAN_RAW
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_RAW_RECV_OWN_MSGS
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &RECEIVE_OWN_MESSAGES
|—————————Node:& Text: &
|—————————Node:identifier Text: RECEIVE_OWN_MESSAGES
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(RECEIVE_OWN_MESSAGES)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (RECEIVE_OWN_MESSAGES)
|——————————Node:( Text: (
|——————————Node:identifier Text: RECEIVE_OWN_MESSAGES
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR));
|——————Node:call_expression Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR))
|———————Node:identifier Text: setsockopt
|———————Node:argument_list Text: (fileDescriptor, SOL_SOCKET, SO_RXQ_OVFL, &DROP_MONITOR, sizeof(DROP_MONITOR))
|————————Node:( Text: (
|————————Node:identifier Text: fileDescriptor
|————————Node:, Text: ,
|————————Node:identifier Text: SOL_SOCKET
|————————Node:, Text: ,
|————————Node:identifier Text: SO_RXQ_OVFL
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &DROP_MONITOR
|—————————Node:& Text: &
|—————————Node:identifier Text: DROP_MONITOR
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(DROP_MONITOR)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (DROP_MONITOR)
|——————————Node:( Text: (
|——————————Node:identifier Text: DROP_MONITOR
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
		{
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING)) < 0
|————————Node:call_expression Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING))
|—————————Node:identifier Text: setsockopt
|—————————Node:argument_list Text: (fileDescriptor, SOL_SOCKET, SO_TIMESTAMPING, &TIMESTAMPING, sizeof(TIMESTAMPING))
|——————————Node:( Text: (
|——————————Node:identifier Text: fileDescriptor
|——————————Node:, Text: ,
|——————————Node:identifier Text: SOL_SOCKET
|——————————Node:, Text: ,
|——————————Node:identifier Text: SO_TIMESTAMPING
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TIMESTAMPING
|———————————Node:& Text: &
|———————————Node:identifier Text: TIMESTAMPING
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(TIMESTAMPING)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (TIMESTAMPING)
|————————————Node:( Text: (
|————————————Node:identifier Text: TIMESTAMPING
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:< Text: <
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP));
|————————Node:call_expression Text: setsockopt(fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP))
|—————————Node:identifier Text: setsockopt
|—————————Node:argument_list Text: (fileDescriptor, SOL_SOCKET, SO_TIMESTAMP, &TIMESTAMP, sizeof(TIMESTAMP))
|——————————Node:( Text: (
|——————————Node:identifier Text: fileDescriptor
|——————————Node:, Text: ,
|——————————Node:identifier Text: SOL_SOCKET
|——————————Node:, Text: ,
|——————————Node:identifier Text: SO_TIMESTAMP
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &TIMESTAMP
|———————————Node:& Text: &
|———————————Node:identifier Text: TIMESTAMP
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(TIMESTAMP)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (TIMESTAMP)
|————————————Node:( Text: (
|————————————Node:identifier Text: TIMESTAMP
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
		{
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
		else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure) >= 0
|————————Node:call_expression Text: ioctl(fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure)
|—————————Node:identifier Text: ioctl
|—————————Node:argument_list Text: (fileDescriptor, SIOCGIFINDEX, &interfaceRequestStructure)
|——————————Node:( Text: (
|——————————Node:identifier Text: fileDescriptor
|——————————Node:, Text: ,
|——————————Node:identifier Text: SIOCGIFINDEX
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &interfaceRequestStructure
|———————————Node:& Text: &
|———————————Node:identifier Text: interfaceRequestStructure
|——————————Node:) Text: )
|————————Node:>= Text: >=
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			memset(pCANDevice, 0, sizeof(sockaddr_can));
			pCANDevice->can_family = AF_CAN;
			pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;

			if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: memset(pCANDevice, 0, sizeof(sockaddr_can));
|————————Node:call_expression Text: memset(pCANDevice, 0, sizeof(sockaddr_can))
|—————————Node:identifier Text: memset
|—————————Node:argument_list Text: (pCANDevice, 0, sizeof(sockaddr_can))
|——————————Node:( Text: (
|——————————Node:identifier Text: pCANDevice
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(sockaddr_can)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (sockaddr_can)
|————————————Node:( Text: (
|————————————Node:identifier Text: sockaddr_can
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: pCANDevice->can_family = AF_CAN;
|————————Node:assignment_expression Text: pCANDevice->can_family = AF_CAN
|—————————Node:field_expression Text: pCANDevice->can_family
|——————————Node:identifier Text: pCANDevice
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_family
|—————————Node:= Text: =
|—————————Node:identifier Text: AF_CAN
|————————Node:; Text: ;
|———————Node:expression_statement Text: pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex;
|————————Node:assignment_expression Text: pCANDevice->can_ifindex = interfaceRequestStructure.ifr_ifindex
|—————————Node:field_expression Text: pCANDevice->can_ifindex
|——————————Node:identifier Text: pCANDevice
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: can_ifindex
|—————————Node:= Text: =
|—————————Node:field_expression Text: interfaceRequestStructure.ifr_ifindex
|——————————Node:identifier Text: interfaceRequestStructure
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ifr_ifindex
|————————Node:; Text: ;
|———————Node:if_statement Text: if (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
			{
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr)) < 0
|——————————Node:call_expression Text: bind(fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr))
|———————————Node:identifier Text: bind
|———————————Node:argument_list Text: (fileDescriptor, (struct sockaddr *)pCANDevice, sizeof(struct sockaddr))
|————————————Node:( Text: (
|————————————Node:identifier Text: fileDescriptor
|————————————Node:, Text: ,
|————————————Node:cast_expression Text: (struct sockaddr *)pCANDevice
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: struct sockaddr *
|——————————————Node:struct_specifier Text: struct sockaddr
|———————————————Node:struct Text: struct
|———————————————Node:type_identifier Text: sockaddr
|——————————————Node:abstract_pointer_declarator Text: *
|———————————————Node:* Text: *
|—————————————Node:) Text: )
|—————————————Node:identifier Text: pCANDevice
|————————————Node:, Text: ,
|————————————Node:sizeof_expression Text: sizeof(struct sockaddr)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: struct sockaddr
|——————————————Node:struct_specifier Text: struct sockaddr
|———————————————Node:struct Text: struct
|———————————————Node:type_identifier Text: sockaddr
|—————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:< Text: <
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				::close(fileDescriptor);
				fileDescriptor = -1;
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ::close(fileDescriptor);
|——————————Node:call_expression Text: ::close(fileDescriptor)
|———————————Node:qualified_identifier Text: ::close
|————————————Node::: Text: ::
|————————————Node:identifier Text: close
|———————————Node:argument_list Text: (fileDescriptor)
|————————————Node:( Text: (
|————————————Node:identifier Text: fileDescriptor
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: fileDescriptor = -1;
|——————————Node:assignment_expression Text: fileDescriptor = -1
|———————————Node:identifier Text: fileDescriptor
|———————————Node:= Text: =
|———————————Node:number_literal Text: -1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|——————Node:else_clause Text: else
		{
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
|———————Node:else Text: else
|———————Node:compound_statement Text: {
			::close(fileDescriptor);
			fileDescriptor = -1;
		}
|————————Node:{ Text: {
|————————Node:expression_statement Text: ::close(fileDescriptor);
|—————————Node:call_expression Text: ::close(fileDescriptor)
|——————————Node:qualified_identifier Text: ::close
|———————————Node::: Text: ::
|———————————Node:identifier Text: close
|——————————Node:argument_list Text: (fileDescriptor)
|———————————Node:( Text: (
|———————————Node:identifier Text: fileDescriptor
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: fileDescriptor = -1;
|—————————Node:assignment_expression Text: fileDescriptor = -1
|——————————Node:identifier Text: fileDescriptor
|——————————Node:= Text: =
|——————————Node:number_literal Text: -1
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else
	{
		::close(fileDescriptor);
		fileDescriptor = -1;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		::close(fileDescriptor);
		fileDescriptor = -1;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: ::close(fileDescriptor);
|———————Node:call_expression Text: ::close(fileDescriptor)
|————————Node:qualified_identifier Text: ::close
|—————————Node::: Text: ::
|—————————Node:identifier Text: close
|————————Node:argument_list Text: (fileDescriptor)
|—————————Node:( Text: (
|—————————Node:identifier Text: fileDescriptor
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: fileDescriptor = -1;
|———————Node:assignment_expression Text: fileDescriptor = -1
|————————Node:identifier Text: fileDescriptor
|————————Node:= Text: =
|————————Node:number_literal Text: -1
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::SocketCANFrameHandler::read_frame(isobus::HardwareInterfaceCANFrame &canFrame)
{
	struct pollfd pollingFileDescriptor;
	bool retVal = false;

	pollingFileDescriptor.fd = fileDescriptor;
	pollingFileDescriptor.events = POLLIN;
	pollingFileDescriptor.revents = 0;

	if (1 == poll(&pollingFileDescriptor, 1, 100))
	{
		canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max();
		struct can_frame txFrame;
		struct msghdr message;
		struct iovec segment;

		char lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))];

		segment.iov_base = &txFrame;
		segment.iov_len = sizeof(struct can_frame);
		message.msg_iov = &segment;
		message.msg_iovlen = 1;
		message.msg_control = &lControlMessage;
		message.msg_controllen = sizeof(lControlMessage);
		message.msg_name = pCANDevice;
		message.msg_namelen = sizeof(struct sockaddr_can);
		message.msg_flags = 0;

		if (recvmsg(fileDescriptor, &message, 0) > 0)
		{
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
	}
	else if (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
	{
		close();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::read_frame(isobus::HardwareInterfaceCANFrame &canFrame)
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::read_frame
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::read_frame
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: read_frame
|———Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &canFrame)
|————Node:( Text: (
|————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &canFrame
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &canFrame
|——————Node:& Text: &
|——————Node:identifier Text: canFrame
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct pollfd pollingFileDescriptor;
	bool retVal = false;

	pollingFileDescriptor.fd = fileDescriptor;
	pollingFileDescriptor.events = POLLIN;
	pollingFileDescriptor.revents = 0;

	if (1 == poll(&pollingFileDescriptor, 1, 100))
	{
		canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max();
		struct can_frame txFrame;
		struct msghdr message;
		struct iovec segment;

		char lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))];

		segment.iov_base = &txFrame;
		segment.iov_len = sizeof(struct can_frame);
		message.msg_iov = &segment;
		message.msg_iovlen = 1;
		message.msg_control = &lControlMessage;
		message.msg_controllen = sizeof(lControlMessage);
		message.msg_name = pCANDevice;
		message.msg_namelen = sizeof(struct sockaddr_can);
		message.msg_flags = 0;

		if (recvmsg(fileDescriptor, &message, 0) > 0)
		{
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
	}
	else if (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
	{
		close();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: struct pollfd pollingFileDescriptor;
|————Node:struct_specifier Text: struct pollfd
|—————Node:struct Text: struct
|—————Node:type_identifier Text: pollfd
|————Node:identifier Text: pollingFileDescriptor
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: pollingFileDescriptor.fd = fileDescriptor;
|————Node:assignment_expression Text: pollingFileDescriptor.fd = fileDescriptor
|—————Node:field_expression Text: pollingFileDescriptor.fd
|——————Node:identifier Text: pollingFileDescriptor
|——————Node:. Text: .
|——————Node:field_identifier Text: fd
|—————Node:= Text: =
|—————Node:identifier Text: fileDescriptor
|————Node:; Text: ;
|———Node:expression_statement Text: pollingFileDescriptor.events = POLLIN;
|————Node:assignment_expression Text: pollingFileDescriptor.events = POLLIN
|—————Node:field_expression Text: pollingFileDescriptor.events
|——————Node:identifier Text: pollingFileDescriptor
|——————Node:. Text: .
|——————Node:field_identifier Text: events
|—————Node:= Text: =
|—————Node:identifier Text: POLLIN
|————Node:; Text: ;
|———Node:expression_statement Text: pollingFileDescriptor.revents = 0;
|————Node:assignment_expression Text: pollingFileDescriptor.revents = 0
|—————Node:field_expression Text: pollingFileDescriptor.revents
|——————Node:identifier Text: pollingFileDescriptor
|——————Node:. Text: .
|——————Node:field_identifier Text: revents
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (1 == poll(&pollingFileDescriptor, 1, 100))
	{
		canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max();
		struct can_frame txFrame;
		struct msghdr message;
		struct iovec segment;

		char lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))];

		segment.iov_base = &txFrame;
		segment.iov_len = sizeof(struct can_frame);
		message.msg_iov = &segment;
		message.msg_iovlen = 1;
		message.msg_control = &lControlMessage;
		message.msg_controllen = sizeof(lControlMessage);
		message.msg_name = pCANDevice;
		message.msg_namelen = sizeof(struct sockaddr_can);
		message.msg_flags = 0;

		if (recvmsg(fileDescriptor, &message, 0) > 0)
		{
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
	}
	else if (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
	{
		close();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (1 == poll(&pollingFileDescriptor, 1, 100))
|—————Node:( Text: (
|—————Node:binary_expression Text: 1 == poll(&pollingFileDescriptor, 1, 100)
|——————Node:number_literal Text: 1
|——————Node:== Text: ==
|——————Node:call_expression Text: poll(&pollingFileDescriptor, 1, 100)
|———————Node:identifier Text: poll
|———————Node:argument_list Text: (&pollingFileDescriptor, 1, 100)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &pollingFileDescriptor
|—————————Node:& Text: &
|—————————Node:identifier Text: pollingFileDescriptor
|————————Node:, Text: ,
|————————Node:number_literal Text: 1
|————————Node:, Text: ,
|————————Node:number_literal Text: 100
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max();
		struct can_frame txFrame;
		struct msghdr message;
		struct iovec segment;

		char lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))];

		segment.iov_base = &txFrame;
		segment.iov_len = sizeof(struct can_frame);
		message.msg_iov = &segment;
		message.msg_iovlen = 1;
		message.msg_control = &lControlMessage;
		message.msg_controllen = sizeof(lControlMessage);
		message.msg_name = pCANDevice;
		message.msg_namelen = sizeof(struct sockaddr_can);
		message.msg_flags = 0;

		if (recvmsg(fileDescriptor, &message, 0) > 0)
		{
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max();
|——————Node:assignment_expression Text: canFrame.timestamp_us = std::numeric_limits<std::uint64_t>::max()
|———————Node:field_expression Text: canFrame.timestamp_us
|————————Node:identifier Text: canFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: timestamp_us
|———————Node:= Text: =
|———————Node:call_expression Text: std::numeric_limits<std::uint64_t>::max()
|————————Node:qualified_identifier Text: std::numeric_limits<std::uint64_t>::max
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:qualified_identifier Text: numeric_limits<std::uint64_t>::max
|——————————Node:template_type Text: numeric_limits<std::uint64_t>
|———————————Node:type_identifier Text: numeric_limits
|———————————Node:template_argument_list Text: <std::uint64_t>
|————————————Node:< Text: <
|————————————Node:type_descriptor Text: std::uint64_t
|—————————————Node:qualified_identifier Text: std::uint64_t
|——————————————Node:namespace_identifier Text: std
|——————————————Node::: Text: ::
|——————————————Node:type_identifier Text: uint64_t
|————————————Node:> Text: >
|——————————Node::: Text: ::
|——————————Node:identifier Text: max
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: struct can_frame txFrame;
|——————Node:struct_specifier Text: struct can_frame
|———————Node:struct Text: struct
|———————Node:type_identifier Text: can_frame
|——————Node:identifier Text: txFrame
|——————Node:; Text: ;
|—————Node:declaration Text: struct msghdr message;
|——————Node:struct_specifier Text: struct msghdr
|———————Node:struct Text: struct
|———————Node:type_identifier Text: msghdr
|——————Node:identifier Text: message
|——————Node:; Text: ;
|—————Node:declaration Text: struct iovec segment;
|——————Node:struct_specifier Text: struct iovec
|———————Node:struct Text: struct
|———————Node:type_identifier Text: iovec
|——————Node:identifier Text: segment
|——————Node:; Text: ;
|—————Node:declaration Text: char lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))];
|——————Node:primitive_type Text: char
|——————Node:array_declarator Text: lControlMessage[CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))]
|———————Node:identifier Text: lControlMessage
|———————Node:[ Text: [
|———————Node:call_expression Text: CMSG_SPACE(sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))
|————————Node:identifier Text: CMSG_SPACE
|————————Node:argument_list Text: (sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: sizeof(struct timeval) + (3 * sizeof(struct timespec)) + sizeof(std::uint32_t)
|——————————Node:binary_expression Text: sizeof(struct timeval) + (3 * sizeof(struct timespec))
|———————————Node:sizeof_expression Text: sizeof(struct timeval)
|————————————Node:sizeof Text: sizeof
|————————————Node:( Text: (
|————————————Node:type_descriptor Text: struct timeval
|—————————————Node:struct_specifier Text: struct timeval
|——————————————Node:struct Text: struct
|——————————————Node:type_identifier Text: timeval
|————————————Node:) Text: )
|———————————Node:+ Text: +
|———————————Node:parenthesized_expression Text: (3 * sizeof(struct timespec))
|————————————Node:( Text: (
|————————————Node:binary_expression Text: 3 * sizeof(struct timespec)
|—————————————Node:number_literal Text: 3
|—————————————Node:* Text: *
|—————————————Node:sizeof_expression Text: sizeof(struct timespec)
|——————————————Node:sizeof Text: sizeof
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: struct timespec
|———————————————Node:struct_specifier Text: struct timespec
|————————————————Node:struct Text: struct
|————————————————Node:type_identifier Text: timespec
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:+ Text: +
|——————————Node:sizeof_expression Text: sizeof(std::uint32_t)
|———————————Node:sizeof Text: sizeof
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: std::uint32_t
|————————————Node:qualified_identifier Text: std::uint32_t
|—————————————Node:namespace_identifier Text: std
|—————————————Node::: Text: ::
|—————————————Node:type_identifier Text: uint32_t
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: segment.iov_base = &txFrame;
|——————Node:assignment_expression Text: segment.iov_base = &txFrame
|———————Node:field_expression Text: segment.iov_base
|————————Node:identifier Text: segment
|————————Node:. Text: .
|————————Node:field_identifier Text: iov_base
|———————Node:= Text: =
|———————Node:pointer_expression Text: &txFrame
|————————Node:& Text: &
|————————Node:identifier Text: txFrame
|——————Node:; Text: ;
|—————Node:expression_statement Text: segment.iov_len = sizeof(struct can_frame);
|——————Node:assignment_expression Text: segment.iov_len = sizeof(struct can_frame)
|———————Node:field_expression Text: segment.iov_len
|————————Node:identifier Text: segment
|————————Node:. Text: .
|————————Node:field_identifier Text: iov_len
|———————Node:= Text: =
|———————Node:sizeof_expression Text: sizeof(struct can_frame)
|————————Node:sizeof Text: sizeof
|————————Node:( Text: (
|————————Node:type_descriptor Text: struct can_frame
|—————————Node:struct_specifier Text: struct can_frame
|——————————Node:struct Text: struct
|——————————Node:type_identifier Text: can_frame
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_iov = &segment;
|——————Node:assignment_expression Text: message.msg_iov = &segment
|———————Node:field_expression Text: message.msg_iov
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_iov
|———————Node:= Text: =
|———————Node:pointer_expression Text: &segment
|————————Node:& Text: &
|————————Node:identifier Text: segment
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_iovlen = 1;
|——————Node:assignment_expression Text: message.msg_iovlen = 1
|———————Node:field_expression Text: message.msg_iovlen
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_iovlen
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_control = &lControlMessage;
|——————Node:assignment_expression Text: message.msg_control = &lControlMessage
|———————Node:field_expression Text: message.msg_control
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_control
|———————Node:= Text: =
|———————Node:pointer_expression Text: &lControlMessage
|————————Node:& Text: &
|————————Node:identifier Text: lControlMessage
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_controllen = sizeof(lControlMessage);
|——————Node:assignment_expression Text: message.msg_controllen = sizeof(lControlMessage)
|———————Node:field_expression Text: message.msg_controllen
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_controllen
|———————Node:= Text: =
|———————Node:sizeof_expression Text: sizeof(lControlMessage)
|————————Node:sizeof Text: sizeof
|————————Node:parenthesized_expression Text: (lControlMessage)
|—————————Node:( Text: (
|—————————Node:identifier Text: lControlMessage
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_name = pCANDevice;
|——————Node:assignment_expression Text: message.msg_name = pCANDevice
|———————Node:field_expression Text: message.msg_name
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_name
|———————Node:= Text: =
|———————Node:identifier Text: pCANDevice
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_namelen = sizeof(struct sockaddr_can);
|——————Node:assignment_expression Text: message.msg_namelen = sizeof(struct sockaddr_can)
|———————Node:field_expression Text: message.msg_namelen
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_namelen
|———————Node:= Text: =
|———————Node:sizeof_expression Text: sizeof(struct sockaddr_can)
|————————Node:sizeof Text: sizeof
|————————Node:( Text: (
|————————Node:type_descriptor Text: struct sockaddr_can
|—————————Node:struct_specifier Text: struct sockaddr_can
|——————————Node:struct Text: struct
|——————————Node:type_identifier Text: sockaddr_can
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: message.msg_flags = 0;
|——————Node:assignment_expression Text: message.msg_flags = 0
|———————Node:field_expression Text: message.msg_flags
|————————Node:identifier Text: message
|————————Node:. Text: .
|————————Node:field_identifier Text: msg_flags
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:if_statement Text: if (recvmsg(fileDescriptor, &message, 0) > 0)
		{
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (recvmsg(fileDescriptor, &message, 0) > 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: recvmsg(fileDescriptor, &message, 0) > 0
|————————Node:call_expression Text: recvmsg(fileDescriptor, &message, 0)
|—————————Node:identifier Text: recvmsg
|—————————Node:argument_list Text: (fileDescriptor, &message, 0)
|——————————Node:( Text: (
|——————————Node:identifier Text: fileDescriptor
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &message
|———————————Node:& Text: &
|———————————Node:identifier Text: message
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:> Text: >
|————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if (0 == (txFrame.can_id & CAN_ERR_FLAG))
			{
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (0 == (txFrame.can_id & CAN_ERR_FLAG))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: 0 == (txFrame.can_id & CAN_ERR_FLAG)
|——————————Node:number_literal Text: 0
|——————————Node:== Text: ==
|——————————Node:parenthesized_expression Text: (txFrame.can_id & CAN_ERR_FLAG)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: txFrame.can_id & CAN_ERR_FLAG
|————————————Node:field_expression Text: txFrame.can_id
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: can_id
|————————————Node:& Text: &
|————————————Node:identifier Text: CAN_ERR_FLAG
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
				canFrame.dataLength = txFrame.can_dlc;
				memset(canFrame.data, 0, sizeof(canFrame.data));
				memcpy(canFrame.data, txFrame.data, canFrame.dataLength);

				for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
				retVal = true;
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (0 != (txFrame.can_id & CAN_EFF_FLAG))
				{
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
				else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (0 != (txFrame.can_id & CAN_EFF_FLAG))
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 0 != (txFrame.can_id & CAN_EFF_FLAG)
|————————————Node:number_literal Text: 0
|————————————Node:!= Text: !=
|————————————Node:parenthesized_expression Text: (txFrame.can_id & CAN_EFF_FLAG)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: txFrame.can_id & CAN_EFF_FLAG
|——————————————Node:field_expression Text: txFrame.can_id
|———————————————Node:identifier Text: txFrame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: can_id
|——————————————Node:& Text: &
|——————————————Node:identifier Text: CAN_EFF_FLAG
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
					canFrame.isExtendedFrame = true;
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK);
|————————————Node:assignment_expression Text: canFrame.identifier = (txFrame.can_id & CAN_EFF_MASK)
|—————————————Node:field_expression Text: canFrame.identifier
|——————————————Node:identifier Text: canFrame
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: identifier
|—————————————Node:= Text: =
|—————————————Node:parenthesized_expression Text: (txFrame.can_id & CAN_EFF_MASK)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: txFrame.can_id & CAN_EFF_MASK
|———————————————Node:field_expression Text: txFrame.can_id
|————————————————Node:identifier Text: txFrame
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: can_id
|———————————————Node:& Text: &
|———————————————Node:identifier Text: CAN_EFF_MASK
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: canFrame.isExtendedFrame = true;
|————————————Node:assignment_expression Text: canFrame.isExtendedFrame = true
|—————————————Node:field_expression Text: canFrame.isExtendedFrame
|——————————————Node:identifier Text: canFrame
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: isExtendedFrame
|—————————————Node:= Text: =
|—————————————Node:true Text: true
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else
				{
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
					canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
					canFrame.isExtendedFrame = false;
				}
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK);
|—————————————Node:assignment_expression Text: canFrame.identifier = (txFrame.can_id & CAN_SFF_MASK)
|——————————————Node:field_expression Text: canFrame.identifier
|———————————————Node:identifier Text: canFrame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: identifier
|——————————————Node:= Text: =
|——————————————Node:parenthesized_expression Text: (txFrame.can_id & CAN_SFF_MASK)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: txFrame.can_id & CAN_SFF_MASK
|————————————————Node:field_expression Text: txFrame.can_id
|—————————————————Node:identifier Text: txFrame
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: can_id
|————————————————Node:& Text: &
|————————————————Node:identifier Text: CAN_SFF_MASK
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: canFrame.isExtendedFrame = false;
|—————————————Node:assignment_expression Text: canFrame.isExtendedFrame = false
|——————————————Node:field_expression Text: canFrame.isExtendedFrame
|———————————————Node:identifier Text: canFrame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: isExtendedFrame
|——————————————Node:= Text: =
|——————————————Node:false Text: false
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————————Node:expression_statement Text: canFrame.dataLength = txFrame.can_dlc;
|——————————Node:assignment_expression Text: canFrame.dataLength = txFrame.can_dlc
|———————————Node:field_expression Text: canFrame.dataLength
|————————————Node:identifier Text: canFrame
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dataLength
|———————————Node:= Text: =
|———————————Node:field_expression Text: txFrame.can_dlc
|————————————Node:identifier Text: txFrame
|————————————Node:. Text: .
|————————————Node:field_identifier Text: can_dlc
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: memset(canFrame.data, 0, sizeof(canFrame.data));
|——————————Node:call_expression Text: memset(canFrame.data, 0, sizeof(canFrame.data))
|———————————Node:identifier Text: memset
|———————————Node:argument_list Text: (canFrame.data, 0, sizeof(canFrame.data))
|————————————Node:( Text: (
|————————————Node:field_expression Text: canFrame.data
|—————————————Node:identifier Text: canFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: data
|————————————Node:, Text: ,
|————————————Node:number_literal Text: 0
|————————————Node:, Text: ,
|————————————Node:sizeof_expression Text: sizeof(canFrame.data)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:parenthesized_expression Text: (canFrame.data)
|——————————————Node:( Text: (
|——————————————Node:field_expression Text: canFrame.data
|———————————————Node:identifier Text: canFrame
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: data
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: memcpy(canFrame.data, txFrame.data, canFrame.dataLength);
|——————————Node:call_expression Text: memcpy(canFrame.data, txFrame.data, canFrame.dataLength)
|———————————Node:identifier Text: memcpy
|———————————Node:argument_list Text: (canFrame.data, txFrame.data, canFrame.dataLength)
|————————————Node:( Text: (
|————————————Node:field_expression Text: canFrame.data
|—————————————Node:identifier Text: canFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: data
|————————————Node:, Text: ,
|————————————Node:field_expression Text: txFrame.data
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: data
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canFrame.dataLength
|—————————————Node:identifier Text: canFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dataLength
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:for_statement Text: for (struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message); (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level); pControlMessage = CMSG_NXTHDR(&message, pControlMessage))
				{
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:declaration Text: struct cmsghdr *pControlMessage = CMSG_FIRSTHDR(&message);
|———————————Node:struct_specifier Text: struct cmsghdr
|————————————Node:struct Text: struct
|————————————Node:type_identifier Text: cmsghdr
|———————————Node:init_declarator Text: *pControlMessage = CMSG_FIRSTHDR(&message)
|————————————Node:pointer_declarator Text: *pControlMessage
|—————————————Node:* Text: *
|—————————————Node:identifier Text: pControlMessage
|————————————Node:= Text: =
|————————————Node:call_expression Text: CMSG_FIRSTHDR(&message)
|—————————————Node:identifier Text: CMSG_FIRSTHDR
|—————————————Node:argument_list Text: (&message)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &message
|———————————————Node:& Text: &
|———————————————Node:identifier Text: message
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:binary_expression Text: (nullptr != pControlMessage) && (SOL_SOCKET == pControlMessage->cmsg_level)
|———————————Node:parenthesized_expression Text: (nullptr != pControlMessage)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: nullptr != pControlMessage
|—————————————Node:null Text: nullptr
|——————————————Node:nullptr Text: nullptr
|—————————————Node:!= Text: !=
|—————————————Node:identifier Text: pControlMessage
|————————————Node:) Text: )
|———————————Node:&& Text: &&
|———————————Node:parenthesized_expression Text: (SOL_SOCKET == pControlMessage->cmsg_level)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: SOL_SOCKET == pControlMessage->cmsg_level
|—————————————Node:identifier Text: SOL_SOCKET
|—————————————Node:== Text: ==
|—————————————Node:field_expression Text: pControlMessage->cmsg_level
|——————————————Node:identifier Text: pControlMessage
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: cmsg_level
|————————————Node:) Text: )
|——————————Node:; Text: ;
|——————————Node:assignment_expression Text: pControlMessage = CMSG_NXTHDR(&message, pControlMessage)
|———————————Node:identifier Text: pControlMessage
|———————————Node:= Text: =
|———————————Node:call_expression Text: CMSG_NXTHDR(&message, pControlMessage)
|————————————Node:identifier Text: CMSG_NXTHDR
|————————————Node:argument_list Text: (&message, pControlMessage)
|—————————————Node:( Text: (
|—————————————Node:pointer_expression Text: &message
|——————————————Node:& Text: &
|——————————————Node:identifier Text: message
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: pControlMessage
|—————————————Node:) Text: )
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
					switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
				}
|———————————Node:{ Text: {
|———————————Node:switch_statement Text: switch (pControlMessage->cmsg_type)
					{
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
|————————————Node:switch Text: switch
|————————————Node:condition_clause Text: (pControlMessage->cmsg_type)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: pControlMessage->cmsg_type
|——————————————Node:identifier Text: pControlMessage
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: cmsg_type
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;

						case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
					}
|—————————————Node:{ Text: {
|—————————————Node:case_statement Text: case SO_TIMESTAMP:
						{
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
						break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: SO_TIMESTAMP
|——————————————Node:: Text: :
|——————————————Node:compound_statement Text: {
							struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);

							if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
						}
|———————————————Node:{ Text: {
|———————————————Node:declaration Text: struct timeval *time = (struct timeval *)CMSG_DATA(pControlMessage);
|————————————————Node:struct_specifier Text: struct timeval
|—————————————————Node:struct Text: struct
|—————————————————Node:type_identifier Text: timeval
|————————————————Node:init_declarator Text: *time = (struct timeval *)CMSG_DATA(pControlMessage)
|—————————————————Node:pointer_declarator Text: *time
|——————————————————Node:* Text: *
|——————————————————Node:identifier Text: time
|—————————————————Node:= Text: =
|—————————————————Node:cast_expression Text: (struct timeval *)CMSG_DATA(pControlMessage)
|——————————————————Node:( Text: (
|——————————————————Node:type_descriptor Text: struct timeval *
|———————————————————Node:struct_specifier Text: struct timeval
|————————————————————Node:struct Text: struct
|————————————————————Node:type_identifier Text: timeval
|———————————————————Node:abstract_pointer_declarator Text: *
|————————————————————Node:* Text: *
|——————————————————Node:) Text: )
|——————————————————Node:call_expression Text: CMSG_DATA(pControlMessage)
|———————————————————Node:identifier Text: CMSG_DATA
|———————————————————Node:argument_list Text: (pControlMessage)
|————————————————————Node:( Text: (
|————————————————————Node:identifier Text: pControlMessage
|————————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:if_statement Text: if (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
							{
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: std::numeric_limits<std::uint64_t>::max() == canFrame.timestamp_us
|——————————————————Node:call_expression Text: std::numeric_limits<std::uint64_t>::max()
|———————————————————Node:qualified_identifier Text: std::numeric_limits<std::uint64_t>::max
|————————————————————Node:namespace_identifier Text: std
|————————————————————Node::: Text: ::
|————————————————————Node:qualified_identifier Text: numeric_limits<std::uint64_t>::max
|—————————————————————Node:template_type Text: numeric_limits<std::uint64_t>
|——————————————————————Node:type_identifier Text: numeric_limits
|——————————————————————Node:template_argument_list Text: <std::uint64_t>
|———————————————————————Node:< Text: <
|———————————————————————Node:type_descriptor Text: std::uint64_t
|————————————————————————Node:qualified_identifier Text: std::uint64_t
|—————————————————————————Node:namespace_identifier Text: std
|—————————————————————————Node::: Text: ::
|—————————————————————————Node:type_identifier Text: uint64_t
|———————————————————————Node:> Text: >
|—————————————————————Node::: Text: ::
|—————————————————————Node:identifier Text: max
|———————————————————Node:argument_list Text: ()
|————————————————————Node:( Text: (
|————————————————————Node:) Text: )
|——————————————————Node:== Text: ==
|——————————————————Node:field_expression Text: canFrame.timestamp_us
|———————————————————Node:identifier Text: canFrame
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: timestamp_us
|—————————————————Node:) Text: )
|————————————————Node:compound_statement Text: {
								canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
							}
|—————————————————Node:{ Text: {
|—————————————————Node:expression_statement Text: canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000);
|——————————————————Node:assignment_expression Text: canFrame.timestamp_us = static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000)
|———————————————————Node:field_expression Text: canFrame.timestamp_us
|————————————————————Node:identifier Text: canFrame
|————————————————————Node:. Text: .
|————————————————————Node:field_identifier Text: timestamp_us
|———————————————————Node:= Text: =
|———————————————————Node:binary_expression Text: static_cast<std::uint64_t>(time->tv_usec) + (static_cast<std::uint64_t>(time->tv_sec) * 1000000)
|————————————————————Node:call_expression Text: static_cast<std::uint64_t>(time->tv_usec)
|—————————————————————Node:template_function Text: static_cast<std::uint64_t>
|——————————————————————Node:identifier Text: static_cast
|——————————————————————Node:template_argument_list Text: <std::uint64_t>
|———————————————————————Node:< Text: <
|———————————————————————Node:type_descriptor Text: std::uint64_t
|————————————————————————Node:qualified_identifier Text: std::uint64_t
|—————————————————————————Node:namespace_identifier Text: std
|—————————————————————————Node::: Text: ::
|—————————————————————————Node:type_identifier Text: uint64_t
|———————————————————————Node:> Text: >
|—————————————————————Node:argument_list Text: (time->tv_usec)
|——————————————————————Node:( Text: (
|——————————————————————Node:field_expression Text: time->tv_usec
|———————————————————————Node:identifier Text: time
|———————————————————————Node:-> Text: ->
|———————————————————————Node:field_identifier Text: tv_usec
|——————————————————————Node:) Text: )
|————————————————————Node:+ Text: +
|————————————————————Node:parenthesized_expression Text: (static_cast<std::uint64_t>(time->tv_sec) * 1000000)
|—————————————————————Node:( Text: (
|—————————————————————Node:binary_expression Text: static_cast<std::uint64_t>(time->tv_sec) * 1000000
|——————————————————————Node:call_expression Text: static_cast<std::uint64_t>(time->tv_sec)
|———————————————————————Node:template_function Text: static_cast<std::uint64_t>
|————————————————————————Node:identifier Text: static_cast
|————————————————————————Node:template_argument_list Text: <std::uint64_t>
|—————————————————————————Node:< Text: <
|—————————————————————————Node:type_descriptor Text: std::uint64_t
|——————————————————————————Node:qualified_identifier Text: std::uint64_t
|———————————————————————————Node:namespace_identifier Text: std
|———————————————————————————Node::: Text: ::
|———————————————————————————Node:type_identifier Text: uint64_t
|—————————————————————————Node:> Text: >
|———————————————————————Node:argument_list Text: (time->tv_sec)
|————————————————————————Node:( Text: (
|————————————————————————Node:field_expression Text: time->tv_sec
|—————————————————————————Node:identifier Text: time
|—————————————————————————Node:-> Text: ->
|—————————————————————————Node:field_identifier Text: tv_sec
|————————————————————————Node:) Text: )
|——————————————————————Node:* Text: *
|——————————————————————Node:number_literal Text: 1000000
|—————————————————————Node:) Text: )
|——————————————————Node:; Text: ;
|—————————————————Node:} Text: }
|———————————————Node:} Text: }
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:case_statement Text: case SO_TIMESTAMPING:
						{
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
						break;
|——————————————Node:case Text: case
|——————————————Node:identifier Text: SO_TIMESTAMPING
|——————————————Node:: Text: :
|——————————————Node:compound_statement Text: {
							struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
							canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
						}
|———————————————Node:{ Text: {
|———————————————Node:declaration Text: struct timespec *time = (struct timespec *)(CMSG_DATA(pControlMessage));
|————————————————Node:struct_specifier Text: struct timespec
|—————————————————Node:struct Text: struct
|—————————————————Node:type_identifier Text: timespec
|————————————————Node:init_declarator Text: *time = (struct timespec *)(CMSG_DATA(pControlMessage))
|—————————————————Node:pointer_declarator Text: *time
|——————————————————Node:* Text: *
|——————————————————Node:identifier Text: time
|—————————————————Node:= Text: =
|—————————————————Node:cast_expression Text: (struct timespec *)(CMSG_DATA(pControlMessage))
|——————————————————Node:( Text: (
|——————————————————Node:type_descriptor Text: struct timespec *
|———————————————————Node:struct_specifier Text: struct timespec
|————————————————————Node:struct Text: struct
|————————————————————Node:type_identifier Text: timespec
|———————————————————Node:abstract_pointer_declarator Text: *
|————————————————————Node:* Text: *
|——————————————————Node:) Text: )
|——————————————————Node:parenthesized_expression Text: (CMSG_DATA(pControlMessage))
|———————————————————Node:( Text: (
|———————————————————Node:call_expression Text: CMSG_DATA(pControlMessage)
|————————————————————Node:identifier Text: CMSG_DATA
|————————————————————Node:argument_list Text: (pControlMessage)
|—————————————————————Node:( Text: (
|—————————————————————Node:identifier Text: pControlMessage
|—————————————————————Node:) Text: )
|———————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:expression_statement Text: canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000);
|————————————————Node:assignment_expression Text: canFrame.timestamp_us = (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000)
|—————————————————Node:field_expression Text: canFrame.timestamp_us
|——————————————————Node:identifier Text: canFrame
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: timestamp_us
|—————————————————Node:= Text: =
|—————————————————Node:binary_expression Text: (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000) + (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000)
|——————————————————Node:parenthesized_expression Text: (static_cast<std::uint64_t>(time[2].tv_nsec) / 1000)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: static_cast<std::uint64_t>(time[2].tv_nsec) / 1000
|————————————————————Node:call_expression Text: static_cast<std::uint64_t>(time[2].tv_nsec)
|—————————————————————Node:template_function Text: static_cast<std::uint64_t>
|——————————————————————Node:identifier Text: static_cast
|——————————————————————Node:template_argument_list Text: <std::uint64_t>
|———————————————————————Node:< Text: <
|———————————————————————Node:type_descriptor Text: std::uint64_t
|————————————————————————Node:qualified_identifier Text: std::uint64_t
|—————————————————————————Node:namespace_identifier Text: std
|—————————————————————————Node::: Text: ::
|—————————————————————————Node:type_identifier Text: uint64_t
|———————————————————————Node:> Text: >
|—————————————————————Node:argument_list Text: (time[2].tv_nsec)
|——————————————————————Node:( Text: (
|——————————————————————Node:field_expression Text: time[2].tv_nsec
|———————————————————————Node:subscript_expression Text: time[2]
|————————————————————————Node:identifier Text: time
|————————————————————————Node:subscript_argument_list Text: [2]
|—————————————————————————Node:[ Text: [
|—————————————————————————Node:number_literal Text: 2
|—————————————————————————Node:] Text: ]
|———————————————————————Node:. Text: .
|———————————————————————Node:field_identifier Text: tv_nsec
|——————————————————————Node:) Text: )
|————————————————————Node:/ Text: /
|————————————————————Node:number_literal Text: 1000
|———————————————————Node:) Text: )
|——————————————————Node:+ Text: +
|——————————————————Node:parenthesized_expression Text: (static_cast<std::uint64_t>(time[2].tv_sec) * 1000000)
|———————————————————Node:( Text: (
|———————————————————Node:binary_expression Text: static_cast<std::uint64_t>(time[2].tv_sec) * 1000000
|————————————————————Node:call_expression Text: static_cast<std::uint64_t>(time[2].tv_sec)
|—————————————————————Node:template_function Text: static_cast<std::uint64_t>
|——————————————————————Node:identifier Text: static_cast
|——————————————————————Node:template_argument_list Text: <std::uint64_t>
|———————————————————————Node:< Text: <
|———————————————————————Node:type_descriptor Text: std::uint64_t
|————————————————————————Node:qualified_identifier Text: std::uint64_t
|—————————————————————————Node:namespace_identifier Text: std
|—————————————————————————Node::: Text: ::
|—————————————————————————Node:type_identifier Text: uint64_t
|———————————————————————Node:> Text: >
|—————————————————————Node:argument_list Text: (time[2].tv_sec)
|——————————————————————Node:( Text: (
|——————————————————————Node:field_expression Text: time[2].tv_sec
|———————————————————————Node:subscript_expression Text: time[2]
|————————————————————————Node:identifier Text: time
|————————————————————————Node:subscript_argument_list Text: [2]
|—————————————————————————Node:[ Text: [
|—————————————————————————Node:number_literal Text: 2
|—————————————————————————Node:] Text: ]
|———————————————————————Node:. Text: .
|———————————————————————Node:field_identifier Text: tv_sec
|——————————————————————Node:) Text: )
|————————————————————Node:* Text: *
|————————————————————Node:number_literal Text: 1000000
|———————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|——————————————Node:break_statement Text: break;
|———————————————Node:break Text: break
|———————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:expression_statement Text: retVal = true;
|——————————Node:assignment_expression Text: retVal = true
|———————————Node:identifier Text: retVal
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else if (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
	{
		close();
	}
|—————Node:else Text: else
|—————Node:if_statement Text: if (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
	{
		close();
	}
|——————Node:if Text: if
|——————Node:condition_clause Text: (pollingFileDescriptor.revents & (POLLERR | POLLHUP))
|———————Node:( Text: (
|———————Node:binary_expression Text: pollingFileDescriptor.revents & (POLLERR | POLLHUP)
|————————Node:field_expression Text: pollingFileDescriptor.revents
|—————————Node:identifier Text: pollingFileDescriptor
|—————————Node:. Text: .
|—————————Node:field_identifier Text: revents
|————————Node:& Text: &
|————————Node:parenthesized_expression Text: (POLLERR | POLLHUP)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: POLLERR | POLLHUP
|——————————Node:identifier Text: POLLERR
|——————————Node:| Text: |
|——————————Node:identifier Text: POLLHUP
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
		close();
	}
|———————Node:{ Text: {
|———————Node:expression_statement Text: close();
|————————Node:call_expression Text: close()
|—————————Node:identifier Text: close
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::SocketCANFrameHandler::write_frame(const isobus::HardwareInterfaceCANFrame &canFrame)
{
	struct can_frame txFrame;
	bool retVal = false;

	txFrame.can_id = canFrame.identifier;
	txFrame.can_dlc = canFrame.dataLength;
	memcpy(txFrame.data, canFrame.data, canFrame.dataLength);

	if (canFrame.isExtendedFrame)
	{
		txFrame.can_id |= CAN_EFF_FLAG;
	}

	if (write(fileDescriptor, &txFrame, sizeof(struct can_frame)) > 0)
	{
		retVal = true;
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::SocketCANFrameHandler::write_frame(const isobus::HardwareInterfaceCANFrame &canFrame)
|———Node:qualified_identifier Text: CANHardwareInterface::SocketCANFrameHandler::write_frame
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: SocketCANFrameHandler::write_frame
|—————Node:namespace_identifier Text: SocketCANFrameHandler
|—————Node::: Text: ::
|—————Node:identifier Text: write_frame
|———Node:parameter_list Text: (const isobus::HardwareInterfaceCANFrame &canFrame)
|————Node:( Text: (
|————Node:parameter_declaration Text: const isobus::HardwareInterfaceCANFrame &canFrame
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &canFrame
|——————Node:& Text: &
|——————Node:identifier Text: canFrame
|————Node:) Text: )
|——Node:compound_statement Text: {
	struct can_frame txFrame;
	bool retVal = false;

	txFrame.can_id = canFrame.identifier;
	txFrame.can_dlc = canFrame.dataLength;
	memcpy(txFrame.data, canFrame.data, canFrame.dataLength);

	if (canFrame.isExtendedFrame)
	{
		txFrame.can_id |= CAN_EFF_FLAG;
	}

	if (write(fileDescriptor, &txFrame, sizeof(struct can_frame)) > 0)
	{
		retVal = true;
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: struct can_frame txFrame;
|————Node:struct_specifier Text: struct can_frame
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_frame
|————Node:identifier Text: txFrame
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: txFrame.can_id = canFrame.identifier;
|————Node:assignment_expression Text: txFrame.can_id = canFrame.identifier
|—————Node:field_expression Text: txFrame.can_id
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: can_id
|—————Node:= Text: =
|—————Node:field_expression Text: canFrame.identifier
|——————Node:identifier Text: canFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: identifier
|————Node:; Text: ;
|———Node:expression_statement Text: txFrame.can_dlc = canFrame.dataLength;
|————Node:assignment_expression Text: txFrame.can_dlc = canFrame.dataLength
|—————Node:field_expression Text: txFrame.can_dlc
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: can_dlc
|—————Node:= Text: =
|—————Node:field_expression Text: canFrame.dataLength
|——————Node:identifier Text: canFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: dataLength
|————Node:; Text: ;
|———Node:expression_statement Text: memcpy(txFrame.data, canFrame.data, canFrame.dataLength);
|————Node:call_expression Text: memcpy(txFrame.data, canFrame.data, canFrame.dataLength)
|—————Node:identifier Text: memcpy
|—————Node:argument_list Text: (txFrame.data, canFrame.data, canFrame.dataLength)
|——————Node:( Text: (
|——————Node:field_expression Text: txFrame.data
|———————Node:identifier Text: txFrame
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:, Text: ,
|——————Node:field_expression Text: canFrame.data
|———————Node:identifier Text: canFrame
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:, Text: ,
|——————Node:field_expression Text: canFrame.dataLength
|———————Node:identifier Text: canFrame
|———————Node:. Text: .
|———————Node:field_identifier Text: dataLength
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (canFrame.isExtendedFrame)
	{
		txFrame.can_id |= CAN_EFF_FLAG;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (canFrame.isExtendedFrame)
|—————Node:( Text: (
|—————Node:field_expression Text: canFrame.isExtendedFrame
|——————Node:identifier Text: canFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: isExtendedFrame
|—————Node:) Text: )
|————Node:compound_statement Text: {
		txFrame.can_id |= CAN_EFF_FLAG;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: txFrame.can_id |= CAN_EFF_FLAG;
|——————Node:assignment_expression Text: txFrame.can_id |= CAN_EFF_FLAG
|———————Node:field_expression Text: txFrame.can_id
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: can_id
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN_EFF_FLAG
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (write(fileDescriptor, &txFrame, sizeof(struct can_frame)) > 0)
	{
		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (write(fileDescriptor, &txFrame, sizeof(struct can_frame)) > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: write(fileDescriptor, &txFrame, sizeof(struct can_frame)) > 0
|——————Node:call_expression Text: write(fileDescriptor, &txFrame, sizeof(struct can_frame))
|———————Node:identifier Text: write
|———————Node:argument_list Text: (fileDescriptor, &txFrame, sizeof(struct can_frame))
|————————Node:( Text: (
|————————Node:identifier Text: fileDescriptor
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &txFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: txFrame
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(struct can_frame)
|—————————Node:sizeof Text: sizeof
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: struct can_frame
|——————————Node:struct_specifier Text: struct can_frame
|———————————Node:struct Text: struct
|———————————Node:type_identifier Text: can_frame
|—————————Node:) Text: )
|————————Node:) Text: )
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo() :
  callback(nullptr),
  parent(nullptr)
{
}
|——Node:function_declarator Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo()
|———Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: RawCanMessageCallbackInfo::RawCanMessageCallbackInfo
|—————Node:namespace_identifier Text: RawCanMessageCallbackInfo
|—————Node::: Text: ::
|—————Node:identifier Text: RawCanMessageCallbackInfo
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:field_initializer_list Text: :
  callback(nullptr),
  parent(nullptr)
|———Node:: Text: :
|———Node:field_initializer Text: callback(nullptr)
|————Node:field_identifier Text: callback
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: parent(nullptr)
|————Node:field_identifier Text: parent
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::RawCanMessageCallbackInfo::operator==(const RawCanMessageCallbackInfo &obj)
{
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::RawCanMessageCallbackInfo::operator==(const RawCanMessageCallbackInfo &obj)
|———Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo::operator==
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: RawCanMessageCallbackInfo::operator==
|—————Node:namespace_identifier Text: RawCanMessageCallbackInfo
|—————Node::: Text: ::
|—————Node:operator_name Text: operator==
|——————Node:operator Text: operator
|——————Node:== Text: ==
|———Node:parameter_list Text: (const RawCanMessageCallbackInfo &obj)
|————Node:( Text: (
|————Node:parameter_declaration Text: const RawCanMessageCallbackInfo &obj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: RawCanMessageCallbackInfo
|—————Node:reference_declarator Text: &obj
|——————Node:& Text: &
|——————Node:identifier Text: obj
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|———Node:{ Text: {
|———Node:return_statement Text: return ((obj.callback == this->callback) && (obj.parent == this->parent));
|————Node:return Text: return
|————Node:parenthesized_expression Text: ((obj.callback == this->callback) && (obj.parent == this->parent))
|—————Node:( Text: (
|—————Node:binary_expression Text: (obj.callback == this->callback) && (obj.parent == this->parent)
|——————Node:parenthesized_expression Text: (obj.callback == this->callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.callback == this->callback
|————————Node:field_expression Text: obj.callback
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: callback
|————————Node:== Text: ==
|————————Node:field_expression Text: this->callback
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (obj.parent == this->parent)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.parent == this->parent
|————————Node:field_expression Text: obj.parent
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: parent
|————————Node:== Text: ==
|————————Node:field_expression Text: this->parent
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parent
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo() :
  callback(nullptr),
  parent(nullptr)
{
}
|——Node:function_declarator Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo()
|———Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo
|—————Node:namespace_identifier Text: CanLibUpdateCallbackInfo
|—————Node::: Text: ::
|—————Node:identifier Text: CanLibUpdateCallbackInfo
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:field_initializer_list Text: :
  callback(nullptr),
  parent(nullptr)
|———Node:: Text: :
|———Node:field_initializer Text: callback(nullptr)
|————Node:field_identifier Text: callback
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: parent(nullptr)
|————Node:field_identifier Text: parent
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::CanLibUpdateCallbackInfo::operator==(const CanLibUpdateCallbackInfo &obj)
{
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::CanLibUpdateCallbackInfo::operator==(const CanLibUpdateCallbackInfo &obj)
|———Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo::operator==
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: CanLibUpdateCallbackInfo::operator==
|—————Node:namespace_identifier Text: CanLibUpdateCallbackInfo
|—————Node::: Text: ::
|—————Node:operator_name Text: operator==
|——————Node:operator Text: operator
|——————Node:== Text: ==
|———Node:parameter_list Text: (const CanLibUpdateCallbackInfo &obj)
|————Node:( Text: (
|————Node:parameter_declaration Text: const CanLibUpdateCallbackInfo &obj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CanLibUpdateCallbackInfo
|—————Node:reference_declarator Text: &obj
|——————Node:& Text: &
|——————Node:identifier Text: obj
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|———Node:{ Text: {
|———Node:return_statement Text: return ((obj.callback == this->callback) && (obj.parent == this->parent));
|————Node:return Text: return
|————Node:parenthesized_expression Text: ((obj.callback == this->callback) && (obj.parent == this->parent))
|—————Node:( Text: (
|—————Node:binary_expression Text: (obj.callback == this->callback) && (obj.parent == this->parent)
|——————Node:parenthesized_expression Text: (obj.callback == this->callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.callback == this->callback
|————————Node:field_expression Text: obj.callback
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: callback
|————————Node:== Text: ==
|————————Node:field_expression Text: this->callback
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (obj.parent == this->parent)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.parent == this->parent
|————————Node:field_expression Text: obj.parent
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: parent
|————————Node:== Text: ==
|————————Node:field_expression Text: this->parent
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parent
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::CANHardwareInterface()
{
}
|——Node:function_declarator Text: CANHardwareInterface::CANHardwareInterface()
|———Node:qualified_identifier Text: CANHardwareInterface::CANHardwareInterface
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: CANHardwareInterface
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::~CANHardwareInterface()
{
}
|——Node:function_declarator Text: CANHardwareInterface::~CANHardwareInterface()
|———Node:qualified_identifier Text: CANHardwareInterface::~CANHardwareInterface
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:destructor_name Text: ~CANHardwareInterface
|—————Node:~ Text: ~
|—————Node:identifier Text: CANHardwareInterface
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::assign_can_channel_frame_handler(std::uint8_t aCANChannel, std::string deviceName)
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::assign_can_channel_frame_handler(std::uint8_t aCANChannel, std::string deviceName)
|———Node:qualified_identifier Text: CANHardwareInterface::assign_can_channel_frame_handler
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: assign_can_channel_frame_handler
|———Node:parameter_list Text: (std::uint8_t aCANChannel, std::string deviceName)
|————Node:( Text: (
|————Node:parameter_declaration Text: std::uint8_t aCANChannel
|—————Node:qualified_identifier Text: std::uint8_t
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:type_identifier Text: uint8_t
|—————Node:identifier Text: aCANChannel
|————Node:, Text: ,
|————Node:parameter_declaration Text: std::string deviceName
|—————Node:qualified_identifier Text: std::string
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:type_identifier Text: string
|—————Node:identifier Text: deviceName
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
|———————Node:( Text: (
|———————Node:binary_expression Text: (!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size())
|————————Node:parenthesized_expression Text: (!threadsStarted)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !threadsStarted
|——————————Node:! Text: !
|——————————Node:identifier Text: threadsStarted
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (aCANChannel < hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aCANChannel < hardwareChannels.size()
|——————————Node:identifier Text: aCANChannel
|——————————Node:< Text: <
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if (nullptr == hardwareChannels[aCANChannel]->frameHandler)
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
			else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (nullptr == hardwareChannels[aCANChannel]->frameHandler)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr == hardwareChannels[aCANChannel]->frameHandler
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:== Text: ==
|——————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|———————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|————————————Node:identifier Text: hardwareChannels
|————————————Node:subscript_argument_list Text: [aCANChannel]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: aCANChannel
|—————————————Node:] Text: ]
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: frameHandler
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: retVal = true;
|——————————Node:assignment_expression Text: retVal = true
|———————————Node:identifier Text: retVal
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
|——————————Node:assignment_expression Text: hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName)
|———————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:subscript_argument_list Text: [aCANChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: aCANChannel
|——————————————Node:] Text: ]
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:= Text: =
|———————————Node:new_expression Text: new SocketCANFrameHandler(deviceName)
|————————————Node:new Text: new
|————————————Node:type_identifier Text: SocketCANFrameHandler
|————————————Node:argument_list Text: (deviceName)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: deviceName
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else
			{
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
				retVal = true;

				if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: retVal = true;
|———————————Node:assignment_expression Text: retVal = true
|————————————Node:identifier Text: retVal
|————————————Node:= Text: =
|————————————Node:true Text: true
|———————————Node:; Text: ;
|——————————Node:if_statement Text: if (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
				{
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
|———————————Node:if Text: if
|———————————Node:condition_clause Text: (hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: hardwareChannels[aCANChannel]->frameHandler->get_device_name() != deviceName
|—————————————Node:call_expression Text: hardwareChannels[aCANChannel]->frameHandler->get_device_name()
|——————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler->get_device_name
|———————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|————————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [aCANChannel]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: aCANChannel
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: frameHandler
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: get_device_name
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:!= Text: !=
|—————————————Node:identifier Text: deviceName
|————————————Node:) Text: )
|———————————Node:compound_statement Text: {
					hardwareChannels[aCANChannel]->frameHandler->close();
					delete hardwareChannels[aCANChannel]->frameHandler;
					hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
				}
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: hardwareChannels[aCANChannel]->frameHandler->close();
|—————————————Node:call_expression Text: hardwareChannels[aCANChannel]->frameHandler->close()
|——————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler->close
|———————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|————————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [aCANChannel]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: aCANChannel
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: frameHandler
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: close
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: delete hardwareChannels[aCANChannel]->frameHandler;
|—————————————Node:delete_expression Text: delete hardwareChannels[aCANChannel]->frameHandler
|——————————————Node:delete Text: delete
|——————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [aCANChannel]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: aCANChannel
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|—————————————Node:; Text: ;
|————————————Node:expression_statement Text: hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName);
|—————————————Node:assignment_expression Text: hardwareChannels[aCANChannel]->frameHandler = new SocketCANFrameHandler(deviceName)
|——————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [aCANChannel]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: aCANChannel
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|——————————————Node:= Text: =
|——————————————Node:new_expression Text: new SocketCANFrameHandler(deviceName)
|———————————————Node:new Text: new
|———————————————Node:type_identifier Text: SocketCANFrameHandler
|———————————————Node:argument_list Text: (deviceName)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: deviceName
|————————————————Node:) Text: )
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|——————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t CANHardwareInterface::get_number_of_can_channels()
{
	return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANHardwareInterface::get_number_of_can_channels()
|———Node:qualified_identifier Text: CANHardwareInterface::get_number_of_can_channels
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: get_number_of_can_channels
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
}
|———Node:{ Text: {
|———Node:return_statement Text: return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
|————Node:return Text: return
|————Node:call_expression Text: static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max())
|—————Node:template_function Text: static_cast<uint8_t>
|——————Node:identifier Text: static_cast
|——————Node:template_argument_list Text: <uint8_t>
|———————Node:< Text: <
|———————Node:type_descriptor Text: uint8_t
|————————Node:primitive_type Text: uint8_t
|———————Node:> Text: >
|—————Node:argument_list Text: (hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max())
|——————Node:( Text: (
|——————Node:binary_expression Text: hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max()
|———————Node:call_expression Text: hardwareChannels.size()
|————————Node:field_expression Text: hardwareChannels.size
|—————————Node:identifier Text: hardwareChannels
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:& Text: &
|———————Node:call_expression Text: std::numeric_limits<std::uint8_t>::max()
|————————Node:qualified_identifier Text: std::numeric_limits<std::uint8_t>::max
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:qualified_identifier Text: numeric_limits<std::uint8_t>::max
|——————————Node:template_type Text: numeric_limits<std::uint8_t>
|———————————Node:type_identifier Text: numeric_limits
|———————————Node:template_argument_list Text: <std::uint8_t>
|————————————Node:< Text: <
|————————————Node:type_descriptor Text: std::uint8_t
|—————————————Node:qualified_identifier Text: std::uint8_t
|——————————————Node:namespace_identifier Text: std
|——————————————Node::: Text: ::
|——————————————Node:type_identifier Text: uint8_t
|————————————Node:> Text: >
|——————————Node::: Text: ::
|——————————Node:identifier Text: max
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::set_number_of_can_channels(uint8_t aValue)
{
	CanHardware *pCANHardware;
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::set_number_of_can_channels(uint8_t aValue)
|———Node:qualified_identifier Text: CANHardwareInterface::set_number_of_can_channels
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: set_number_of_can_channels
|———Node:parameter_list Text: (uint8_t aValue)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t aValue
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: aValue
|————Node:) Text: )
|——Node:compound_statement Text: {
	CanHardware *pCANHardware;
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: CanHardware *pCANHardware;
|————Node:type_identifier Text: CanHardware
|————Node:pointer_declarator Text: *pCANHardware
|—————Node:* Text: *
|—————Node:identifier Text: pCANHardware
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (!threadsStarted)
|———————Node:( Text: (
|———————Node:unary_expression Text: !threadsStarted
|————————Node:! Text: !
|————————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:while_statement Text: while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}
|————————Node:while Text: while
|————————Node:condition_clause Text: (aValue > hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aValue > hardwareChannels.size()
|——————————Node:identifier Text: aValue
|——————————Node:> Text: >
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = new CanHardware();
|——————————Node:assignment_expression Text: pCANHardware = new CanHardware()
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:new_expression Text: new CanHardware()
|————————————Node:new Text: new
|————————————Node:type_identifier Text: CanHardware
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->receiveMessageThread = nullptr;
|——————————Node:assignment_expression Text: pCANHardware->receiveMessageThread = nullptr
|———————————Node:field_expression Text: pCANHardware->receiveMessageThread
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: receiveMessageThread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->frameHandler = nullptr;
|——————————Node:assignment_expression Text: pCANHardware->frameHandler = nullptr
|———————————Node:field_expression Text: pCANHardware->frameHandler
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels.push_back(pCANHardware);
|——————————Node:call_expression Text: hardwareChannels.push_back(pCANHardware)
|———————————Node:field_expression Text: hardwareChannels.push_back
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: push_back
|———————————Node:argument_list Text: (pCANHardware)
|————————————Node:( Text: (
|————————————Node:identifier Text: pCANHardware
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:while_statement Text: while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
|————————Node:while Text: while
|————————Node:condition_clause Text: (aValue < hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aValue < hardwareChannels.size()
|——————————Node:identifier Text: aValue
|——————————Node:< Text: <
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();

				delete pCANHardware;
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels.back();
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels.back()
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:call_expression Text: hardwareChannels.back()
|————————————Node:field_expression Text: hardwareChannels.back
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: back
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels.pop_back();
|——————————Node:call_expression Text: hardwareChannels.pop_back()
|———————————Node:field_expression Text: hardwareChannels.pop_back
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: pop_back
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: delete pCANHardware;
|——————————Node:delete_expression Text: delete pCANHardware
|———————————Node:delete Text: delete
|———————————Node:identifier Text: pCANHardware
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::start()
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::start()
|———Node:qualified_identifier Text: CANHardwareInterface::start
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: start
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (!threadsStarted)
|———————Node:( Text: (
|———————Node:unary_expression Text: !threadsStarted
|————————Node:! Text: !
|————————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: threadsStarted = true;
|————————Node:assignment_expression Text: threadsStarted = true
|—————————Node:identifier Text: threadsStarted
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:expression_statement Text: can_thread = new std::thread(can_thread_function);
|————————Node:assignment_expression Text: can_thread = new std::thread(can_thread_function)
|—————————Node:identifier Text: can_thread
|—————————Node:= Text: =
|—————————Node:new_expression Text: new std::thread(can_thread_function)
|——————————Node:new Text: new
|——————————Node:qualified_identifier Text: std::thread
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: thread
|——————————Node:argument_list Text: (can_thread_function)
|———————————Node:( Text: (
|———————————Node:identifier Text: can_thread_function
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);
|————————Node:assignment_expression Text: updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function)
|—————————Node:identifier Text: updateCANLibPeriodicThread
|—————————Node:= Text: =
|—————————Node:new_expression Text: new std::thread(update_can_lib_periodic_function)
|——————————Node:new Text: new
|——————————Node:qualified_identifier Text: std::thread
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: thread
|——————————Node:argument_list Text: (update_can_lib_periodic_function)
|———————————Node:( Text: (
|———————————Node:identifier Text: update_can_lib_periodic_function
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->frameHandler
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->frameHandler->open();
|————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->open()
|—————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->open
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: open
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (hardwareChannels[i]->frameHandler->get_is_valid())
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->get_is_valid()
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->get_is_valid
|———————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: frameHandler
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: get_is_valid
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
|——————————————Node:assignment_expression Text: hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i)
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receiveMessageThread
|———————————————Node:= Text: =
|———————————————Node:new_expression Text: new std::thread(receive_message_thread_function, i)
|————————————————Node:new Text: new
|————————————————Node:qualified_identifier Text: std::thread
|—————————————————Node:namespace_identifier Text: std
|—————————————————Node::: Text: ::
|—————————————————Node:type_identifier Text: thread
|————————————————Node:argument_list Text: (receive_message_thread_function, i)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: receive_message_thread_function
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: i
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::stop()
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}

	if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}

	if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::stop()
|———Node:qualified_identifier Text: CANHardwareInterface::stop
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: stop
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}

	if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}

	if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (threadsStarted)
|———————Node:( Text: (
|———————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: threadsStarted = false;
|————————Node:assignment_expression Text: threadsStarted = false
|—————————Node:identifier Text: threadsStarted
|—————————Node:= Text: =
|—————————Node:false Text: false
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:if_statement Text: if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (nullptr != can_thread)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != can_thread
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:identifier Text: can_thread
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (can_thread->joinable())
|———————————Node:( Text: (
|———————————Node:call_expression Text: can_thread->joinable()
|————————————Node:field_expression Text: can_thread->joinable
|—————————————Node:identifier Text: can_thread
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: joinable
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————————————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————————————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————————————Node:identifier Text: hardwareChannelsMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: threadConditionVariable.notify_all();
|————————————Node:call_expression Text: threadConditionVariable.notify_all()
|—————————————Node:field_expression Text: threadConditionVariable.notify_all
|——————————————Node:identifier Text: threadConditionVariable
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: notify_all
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: can_thread->join();
|————————————Node:call_expression Text: can_thread->join()
|—————————————Node:field_expression Text: can_thread->join
|——————————————Node:identifier Text: can_thread
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: join
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: hardwareChannelsMutex.lock();
|————————————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————————————Node:field_expression Text: hardwareChannelsMutex.lock
|——————————————Node:identifier Text: hardwareChannelsMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: delete can_thread;
|——————————Node:delete_expression Text: delete can_thread
|———————————Node:delete Text: delete
|———————————Node:identifier Text: can_thread
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: can_thread = nullptr;
|——————————Node:assignment_expression Text: can_thread = nullptr
|———————————Node:identifier Text: can_thread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:if_statement Text: if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (nullptr != updateCANLibPeriodicThread)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != updateCANLibPeriodicThread
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:identifier Text: updateCANLibPeriodicThread
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (updateCANLibPeriodicThread->joinable())
|———————————Node:( Text: (
|———————————Node:call_expression Text: updateCANLibPeriodicThread->joinable()
|————————————Node:field_expression Text: updateCANLibPeriodicThread->joinable
|—————————————Node:identifier Text: updateCANLibPeriodicThread
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: joinable
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					updateCANLibPeriodicThread->join();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: updateCANLibPeriodicThread->join();
|————————————Node:call_expression Text: updateCANLibPeriodicThread->join()
|—————————————Node:field_expression Text: updateCANLibPeriodicThread->join
|——————————————Node:identifier Text: updateCANLibPeriodicThread
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: join
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: delete updateCANLibPeriodicThread;
|——————————Node:delete_expression Text: delete updateCANLibPeriodicThread
|———————————Node:delete Text: delete
|———————————Node:identifier Text: updateCANLibPeriodicThread
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: updateCANLibPeriodicThread = nullptr;
|——————————Node:assignment_expression Text: updateCANLibPeriodicThread = nullptr
|———————————Node:identifier Text: updateCANLibPeriodicThread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->frameHandler
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->frameHandler->close();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->frameHandler->close();
|————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->close()
|—————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->close
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: close
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->receiveMessageThread)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->receiveMessageThread
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receiveMessageThread
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (hardwareChannels[i]->receiveMessageThread->joinable())
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: hardwareChannels[i]->receiveMessageThread->joinable()
|——————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread->joinable
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receiveMessageThread
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: joinable
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						hardwareChannels[i]->receiveMessageThread->join();
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread->join();
|——————————————Node:call_expression Text: hardwareChannels[i]->receiveMessageThread->join()
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread->join
|————————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|—————————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————————Node:identifier Text: hardwareChannels
|——————————————————Node:subscript_argument_list Text: [i]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: i
|———————————————————Node:] Text: ]
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: receiveMessageThread
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: join
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: delete hardwareChannels[i]->receiveMessageThread;
|————————————Node:delete_expression Text: delete hardwareChannels[i]->receiveMessageThread
|—————————————Node:delete Text: delete
|—————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|——————————————Node:subscript_expression Text: hardwareChannels[i]
|———————————————Node:identifier Text: hardwareChannels
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: receiveMessageThread
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread = nullptr;
|————————————Node:assignment_expression Text: hardwareChannels[i]->receiveMessageThread = nullptr
|—————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|——————————————Node:subscript_expression Text: hardwareChannels[i]
|———————————————Node:identifier Text: hardwareChannels
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: receiveMessageThread
|—————————————Node:= Text: =
|—————————————Node:null Text: nullptr
|——————————————Node:nullptr Text: nullptr
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock();
|——————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock()
|———————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock
|————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:while_statement Text: while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
|——————————Node:while Text: while
|——————————Node:condition_clause Text: (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 0 != hardwareChannels[i]->messagesToBeTransmitted.size()
|————————————Node:number_literal Text: 0
|————————————Node:!= Text: !=
|————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.size()
|—————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.size
|——————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: size
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
|————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin())
|—————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.erase
|——————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: erase
|—————————————Node:argument_list Text: (hardwareChannels[i]->messagesToBeTransmitted.begin())
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.begin()
|———————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.begin
|————————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|—————————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————————Node:identifier Text: hardwareChannels
|——————————————————Node:subscript_argument_list Text: [i]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: i
|———————————————————Node:] Text: ]
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: messagesToBeTransmitted
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: begin
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();
|——————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock()
|———————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock
|————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessagesMutex.lock();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessagesMutex.lock()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex.lock
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessages.clear();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessages.clear()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessages.clear
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessages
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessages
|————————————Node:. Text: .
|————————————Node:field_identifier Text: clear
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessagesMutex.unlock();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessagesMutex.unlock()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex.unlock
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (rxCallbackMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: rxCallbackMutex.try_lock()
|——————Node:field_expression Text: rxCallbackMutex.try_lock
|———————Node:identifier Text: rxCallbackMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:for_statement Text: for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: std::uint32_t i = 0;
|———————Node:qualified_identifier Text: std::uint32_t
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:type_identifier Text: uint32_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < rxCallbacks.size()
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:call_expression Text: rxCallbacks.size()
|————————Node:field_expression Text: rxCallbacks.size
|—————————Node:identifier Text: rxCallbacks
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
			rxCallbacks.pop_back();
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: rxCallbacks.pop_back();
|————————Node:call_expression Text: rxCallbacks.pop_back()
|—————————Node:field_expression Text: rxCallbacks.pop_back
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pop_back
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: rxCallbackMutex.unlock();
|——————Node:call_expression Text: rxCallbackMutex.unlock()
|———————Node:field_expression Text: rxCallbackMutex.unlock
|————————Node:identifier Text: rxCallbackMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (canLibUpdateCallbacksMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: canLibUpdateCallbacksMutex.try_lock()
|——————Node:field_expression Text: canLibUpdateCallbacksMutex.try_lock
|———————Node:identifier Text: canLibUpdateCallbacksMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:for_statement Text: for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: std::uint32_t i = 0;
|———————Node:qualified_identifier Text: std::uint32_t
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:type_identifier Text: uint32_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < canLibUpdateCallbacks.size()
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:call_expression Text: canLibUpdateCallbacks.size()
|————————Node:field_expression Text: canLibUpdateCallbacks.size
|—————————Node:identifier Text: canLibUpdateCallbacks
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
			canLibUpdateCallbacks.pop_back();
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: canLibUpdateCallbacks.pop_back();
|————————Node:call_expression Text: canLibUpdateCallbacks.pop_back()
|—————————Node:field_expression Text: canLibUpdateCallbacks.pop_back
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pop_back
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|——————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|———————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::transmit_can_message(isobus::HardwareInterfaceCANFrame &packet)
{
	std::uint8_t lChannel = packet.channel;
	bool retVal = false;

	if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::transmit_can_message(isobus::HardwareInterfaceCANFrame &packet)
|———Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: transmit_can_message
|———Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &packet)
|————Node:( Text: (
|————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &packet
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &packet
|——————Node:& Text: &
|——————Node:identifier Text: packet
|————Node:) Text: )
|——Node:compound_statement Text: {
	std::uint8_t lChannel = packet.channel;
	bool retVal = false;

	if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: std::uint8_t lChannel = packet.channel;
|————Node:qualified_identifier Text: std::uint8_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint8_t
|————Node:init_declarator Text: lChannel = packet.channel
|—————Node:identifier Text: lChannel
|—————Node:= Text: =
|—————Node:field_expression Text: packet.channel
|——————Node:identifier Text: packet
|——————Node:. Text: .
|——————Node:field_identifier Text: channel
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted))
|—————Node:( Text: (
|—————Node:binary_expression Text: (lChannel < hardwareChannels.size()) &&
	    (threadsStarted)
|——————Node:parenthesized_expression Text: (lChannel < hardwareChannels.size())
|———————Node:( Text: (
|———————Node:binary_expression Text: lChannel < hardwareChannels.size()
|————————Node:identifier Text: lChannel
|————————Node:< Text: <
|————————Node:call_expression Text: hardwareChannels.size()
|—————————Node:field_expression Text: hardwareChannels.size
|——————————Node:identifier Text: hardwareChannels
|——————————Node:. Text: .
|——————————Node:field_identifier Text: size
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (threadsStarted)
|———————Node:( Text: (
|———————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock()
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: lock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet)
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmitted
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (packet)
|————————Node:( Text: (
|————————Node:identifier Text: packet
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock()
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: threadConditionVariable.notify_all();
|——————Node:call_expression Text: threadConditionVariable.notify_all()
|———————Node:field_expression Text: threadConditionVariable.notify_all
|————————Node:identifier Text: threadConditionVariable
|————————Node:. Text: .
|————————Node:field_identifier Text: notify_all
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::add_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
{
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::add_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|———Node:qualified_identifier Text: CANHardwareInterface::add_raw_can_message_rx_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: add_raw_can_message_rx_callback
|———Node:parameter_list Text: (void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &rxFrame
|————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————Node:namespace_identifier Text: isobus
|—————————Node::: Text: ::
|—————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————Node:reference_declarator Text: &rxFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: rxFrame
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: void *parentPointer
|————————Node:primitive_type Text: void
|————————Node:pointer_declarator Text: *parentPointer
|—————————Node:* Text: *
|—————————Node:identifier Text: parentPointer
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parent
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parent
|——————Node:* Text: *
|——————Node:identifier Text: parent
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: RawCanMessageCallbackInfo callbackInfo;
|————Node:type_identifier Text: RawCanMessageCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parent;
|————Node:assignment_expression Text: callbackInfo.parent = parent
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parent
|————Node:; Text: ;
|———Node:expression_statement Text: rxCallbackMutex.lock();
|————Node:call_expression Text: rxCallbackMutex.lock()
|—————Node:field_expression Text: rxCallbackMutex.lock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
|—————Node:( Text: (
|—————Node:binary_expression Text: (nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo))
|——————Node:parenthesized_expression Text: (nullptr != callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: nullptr != callback
|————————Node:null Text: nullptr
|—————————Node:nullptr Text: nullptr
|————————Node:!= Text: !=
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo))
|———————Node:( Text: (
|———————Node:binary_expression Text: rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|————————Node:call_expression Text: rxCallbacks.end()
|—————————Node:field_expression Text: rxCallbacks.end
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:call_expression Text: find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|—————————Node:identifier Text: find
|—————————Node:argument_list Text: (rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|——————————Node:( Text: (
|——————————Node:call_expression Text: rxCallbacks.begin()
|———————————Node:field_expression Text: rxCallbacks.begin
|————————————Node:identifier Text: rxCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: begin
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: rxCallbacks.end()
|———————————Node:field_expression Text: rxCallbacks.end
|————————————Node:identifier Text: rxCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: end
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: callbackInfo
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: rxCallbacks.push_back(callbackInfo);
|——————Node:call_expression Text: rxCallbacks.push_back(callbackInfo)
|———————Node:field_expression Text: rxCallbacks.push_back
|————————Node:identifier Text: rxCallbacks
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (callbackInfo)
|————————Node:( Text: (
|————————Node:identifier Text: callbackInfo
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: rxCallbackMutex.unlock();
|————Node:call_expression Text: rxCallbackMutex.unlock()
|—————Node:field_expression Text: rxCallbackMutex.unlock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::remove_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
{
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::remove_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|———Node:qualified_identifier Text: CANHardwareInterface::remove_raw_can_message_rx_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: remove_raw_can_message_rx_callback
|———Node:parameter_list Text: (void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &rxFrame
|————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————Node:namespace_identifier Text: isobus
|—————————Node::: Text: ::
|—————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————Node:reference_declarator Text: &rxFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: rxFrame
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: void *parentPointer
|————————Node:primitive_type Text: void
|————————Node:pointer_declarator Text: *parentPointer
|—————————Node:* Text: *
|—————————Node:identifier Text: parentPointer
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parent
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parent
|——————Node:* Text: *
|——————Node:identifier Text: parent
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: RawCanMessageCallbackInfo callbackInfo;
|————Node:type_identifier Text: RawCanMessageCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parent;
|————Node:assignment_expression Text: callbackInfo.parent = parent
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parent
|————Node:; Text: ;
|———Node:expression_statement Text: rxCallbackMutex.lock();
|————Node:call_expression Text: rxCallbackMutex.lock()
|—————Node:field_expression Text: rxCallbackMutex.lock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != callback)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != callback
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: callback
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
|——————Node:qualified_identifier Text: std::vector<RawCanMessageCallbackInfo>::iterator
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:qualified_identifier Text: vector<RawCanMessageCallbackInfo>::iterator
|————————Node:template_type Text: vector<RawCanMessageCallbackInfo>
|—————————Node:type_identifier Text: vector
|—————————Node:template_argument_list Text: <RawCanMessageCallbackInfo>
|——————————Node:< Text: <
|——————————Node:type_descriptor Text: RawCanMessageCallbackInfo
|———————————Node:type_identifier Text: RawCanMessageCallbackInfo
|——————————Node:> Text: >
|————————Node::: Text: ::
|————————Node:type_identifier Text: iterator
|——————Node:identifier Text: callbackLocation
|——————Node:; Text: ;
|—————Node:expression_statement Text: callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);
|——————Node:assignment_expression Text: callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|———————Node:identifier Text: callbackLocation
|———————Node:= Text: =
|———————Node:call_expression Text: std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|————————Node:qualified_identifier Text: std::find
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:identifier Text: find
|————————Node:argument_list Text: (rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|—————————Node:( Text: (
|—————————Node:call_expression Text: rxCallbacks.begin()
|——————————Node:field_expression Text: rxCallbacks.begin
|———————————Node:identifier Text: rxCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: begin
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: rxCallbacks.end()
|——————————Node:field_expression Text: rxCallbacks.end
|———————————Node:identifier Text: rxCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: end
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: callbackInfo
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (rxCallbacks.end() != callbackLocation)
|———————Node:( Text: (
|———————Node:binary_expression Text: rxCallbacks.end() != callbackLocation
|————————Node:call_expression Text: rxCallbacks.end()
|—————————Node:field_expression Text: rxCallbacks.end
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: callbackLocation
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: rxCallbacks.erase(callbackLocation);
|————————Node:call_expression Text: rxCallbacks.erase(callbackLocation)
|—————————Node:field_expression Text: rxCallbacks.erase
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: erase
|—————————Node:argument_list Text: (callbackLocation)
|——————————Node:( Text: (
|——————————Node:identifier Text: callbackLocation
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: rxCallbackMutex.unlock();
|————Node:call_expression Text: rxCallbackMutex.unlock()
|—————Node:field_expression Text: rxCallbackMutex.unlock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::add_can_lib_update_callback(void (*callback)(), void *parentPointer)
{
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::add_can_lib_update_callback(void (*callback)(), void *parentPointer)
|———Node:qualified_identifier Text: CANHardwareInterface::add_can_lib_update_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: add_can_lib_update_callback
|———Node:parameter_list Text: (void (*callback)(), void *parentPointer)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)()
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)()
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parentPointer
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parentPointer
|——————Node:* Text: *
|——————Node:identifier Text: parentPointer
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: CanLibUpdateCallbackInfo callbackInfo;
|————Node:type_identifier Text: CanLibUpdateCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parentPointer;
|————Node:assignment_expression Text: callbackInfo.parent = parentPointer
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parentPointer
|————Node:; Text: ;
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
|—————Node:( Text: (
|—————Node:binary_expression Text: (nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo))
|——————Node:parenthesized_expression Text: (nullptr != callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: nullptr != callback
|————————Node:null Text: nullptr
|—————————Node:nullptr Text: nullptr
|————————Node:!= Text: !=
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo))
|———————Node:( Text: (
|———————Node:binary_expression Text: canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|————————Node:call_expression Text: canLibUpdateCallbacks.end()
|—————————Node:field_expression Text: canLibUpdateCallbacks.end
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:call_expression Text: find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|—————————Node:identifier Text: find
|—————————Node:argument_list Text: (canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|——————————Node:( Text: (
|——————————Node:call_expression Text: canLibUpdateCallbacks.begin()
|———————————Node:field_expression Text: canLibUpdateCallbacks.begin
|————————————Node:identifier Text: canLibUpdateCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: begin
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: canLibUpdateCallbacks.end()
|———————————Node:field_expression Text: canLibUpdateCallbacks.end
|————————————Node:identifier Text: canLibUpdateCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: end
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: callbackInfo
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: canLibUpdateCallbacks.push_back(callbackInfo);
|——————Node:call_expression Text: canLibUpdateCallbacks.push_back(callbackInfo)
|———————Node:field_expression Text: canLibUpdateCallbacks.push_back
|————————Node:identifier Text: canLibUpdateCallbacks
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (callbackInfo)
|————————Node:( Text: (
|————————Node:identifier Text: callbackInfo
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::remove_can_lib_update_callback(void (*callback)(), void *parentPointer)
{
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::remove_can_lib_update_callback(void (*callback)(), void *parentPointer)
|———Node:qualified_identifier Text: CANHardwareInterface::remove_can_lib_update_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: remove_can_lib_update_callback
|———Node:parameter_list Text: (void (*callback)(), void *parentPointer)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)()
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)()
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parentPointer
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parentPointer
|——————Node:* Text: *
|——————Node:identifier Text: parentPointer
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: CanLibUpdateCallbackInfo callbackInfo;
|————Node:type_identifier Text: CanLibUpdateCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parentPointer;
|————Node:assignment_expression Text: callbackInfo.parent = parentPointer
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parentPointer
|————Node:; Text: ;
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != callback)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != callback
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: callback
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
|——————Node:qualified_identifier Text: std::vector<CanLibUpdateCallbackInfo>::iterator
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:qualified_identifier Text: vector<CanLibUpdateCallbackInfo>::iterator
|————————Node:template_type Text: vector<CanLibUpdateCallbackInfo>
|—————————Node:type_identifier Text: vector
|—————————Node:template_argument_list Text: <CanLibUpdateCallbackInfo>
|——————————Node:< Text: <
|——————————Node:type_descriptor Text: CanLibUpdateCallbackInfo
|———————————Node:type_identifier Text: CanLibUpdateCallbackInfo
|——————————Node:> Text: >
|————————Node::: Text: ::
|————————Node:type_identifier Text: iterator
|——————Node:identifier Text: callbackLocation
|——————Node:; Text: ;
|—————Node:expression_statement Text: callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);
|——————Node:assignment_expression Text: callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|———————Node:identifier Text: callbackLocation
|———————Node:= Text: =
|———————Node:call_expression Text: std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|————————Node:qualified_identifier Text: std::find
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:identifier Text: find
|————————Node:argument_list Text: (canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|—————————Node:( Text: (
|—————————Node:call_expression Text: canLibUpdateCallbacks.begin()
|——————————Node:field_expression Text: canLibUpdateCallbacks.begin
|———————————Node:identifier Text: canLibUpdateCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: begin
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: canLibUpdateCallbacks.end()
|——————————Node:field_expression Text: canLibUpdateCallbacks.end
|———————————Node:identifier Text: canLibUpdateCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: end
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: callbackInfo
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (canLibUpdateCallbacks.end() != callbackLocation)
|———————Node:( Text: (
|———————Node:binary_expression Text: canLibUpdateCallbacks.end() != callbackLocation
|————————Node:call_expression Text: canLibUpdateCallbacks.end()
|—————————Node:field_expression Text: canLibUpdateCallbacks.end
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: callbackLocation
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: canLibUpdateCallbacks.erase(callbackLocation);
|————————Node:call_expression Text: canLibUpdateCallbacks.erase(callbackLocation)
|—————————Node:field_expression Text: canLibUpdateCallbacks.erase
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: erase
|—————————Node:argument_list Text: (callbackLocation)
|——————————Node:( Text: (
|——————————Node:identifier Text: callbackLocation
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::can_thread_function()
{
	hardwareChannelsMutex.lock();
	// Wait until everything is running
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::can_thread_function()
|———Node:qualified_identifier Text: CANHardwareInterface::can_thread_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: can_thread_function
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	hardwareChannelsMutex.lock();
	// Wait until everything is running
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Wait until everything is running
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:while_statement Text: while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
	}
|————Node:while Text: while
|————Node:condition_clause Text: (threadsStarted)
|—————Node:( Text: (
|—————Node:identifier Text: threadsStarted
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::unique_lock<std::mutex> lMutex(threadMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::unique_lock<std::mutex> lMutex(threadMutex);
|——————Node:qualified_identifier Text: std::unique_lock<std::mutex>
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:template_type Text: unique_lock<std::mutex>
|————————Node:type_identifier Text: unique_lock
|————————Node:template_argument_list Text: <std::mutex>
|—————————Node:< Text: <
|—————————Node:type_descriptor Text: std::mutex
|——————————Node:qualified_identifier Text: std::mutex
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: mutex
|—————————Node:> Text: >
|——————Node:function_declarator Text: lMutex(threadMutex)
|———————Node:identifier Text: lMutex
|———————Node:parameter_list Text: (threadMutex)
|————————Node:( Text: (
|————————Node:parameter_declaration Text: threadMutex
|—————————Node:type_identifier Text: threadMutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: CanHardware *pCANHardware;
|——————Node:type_identifier Text: CanHardware
|——————Node:pointer_declarator Text: *pCANHardware
|———————Node:* Text: *
|———————Node:identifier Text: pCANHardware
|——————Node:; Text: ;
|—————Node:if_statement Text: if (threadsStarted)
		{
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (threadsStarted)
|———————Node:( Text: (
|———————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			threadConditionVariable.wait(lMutex);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: threadConditionVariable.wait(lMutex);
|————————Node:call_expression Text: threadConditionVariable.wait(lMutex)
|—————————Node:field_expression Text: threadConditionVariable.wait
|——————————Node:identifier Text: threadConditionVariable
|——————————Node:. Text: .
|——————————Node:field_identifier Text: wait
|—————————Node:argument_list Text: (lMutex)
|——————————Node:( Text: (
|——————————Node:identifier Text: lMutex
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels[i];

				pCANHardware->receivedMessagesMutex.lock();
				bool processNextMessage = (!pCANHardware->receivedMessages.empty());
				pCANHardware->receivedMessagesMutex.unlock();

				while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels[i];
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels[i]
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:subscript_expression Text: hardwareChannels[i]
|————————————Node:identifier Text: hardwareChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|——————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|———————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|—————————————Node:identifier Text: pCANHardware
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:declaration Text: bool processNextMessage = (!pCANHardware->receivedMessages.empty());
|——————————Node:primitive_type Text: bool
|——————————Node:init_declarator Text: processNextMessage = (!pCANHardware->receivedMessages.empty())
|———————————Node:identifier Text: processNextMessage
|———————————Node:= Text: =
|———————————Node:parenthesized_expression Text: (!pCANHardware->receivedMessages.empty())
|————————————Node:( Text: (
|————————————Node:unary_expression Text: !pCANHardware->receivedMessages.empty()
|—————————————Node:! Text: !
|—————————————Node:call_expression Text: pCANHardware->receivedMessages.empty()
|——————————————Node:field_expression Text: pCANHardware->receivedMessages.empty
|———————————————Node:field_expression Text: pCANHardware->receivedMessages
|————————————————Node:identifier Text: pCANHardware
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receivedMessages
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: empty
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|——————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|———————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|—————————————Node:identifier Text: pCANHardware
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:while_statement Text: while (processNextMessage)
				{
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
|——————————Node:while Text: while
|——————————Node:condition_clause Text: (processNextMessage)
|———————————Node:( Text: (
|———————————Node:identifier Text: processNextMessage
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					isobus::HardwareInterfaceCANFrame tempCanFrame;

					pCANHardware->receivedMessagesMutex.lock();
					tempCanFrame = pCANHardware->receivedMessages.front();
					pCANHardware->receivedMessages.pop_front();
					processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					rxCallbackMutex.lock();
					for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
					rxCallbackMutex.unlock();
				}
|———————————Node:{ Text: {
|———————————Node:declaration Text: isobus::HardwareInterfaceCANFrame tempCanFrame;
|————————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————————Node:namespace_identifier Text: isobus
|—————————————Node::: Text: ::
|—————————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————————Node:identifier Text: tempCanFrame
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: tempCanFrame = pCANHardware->receivedMessages.front();
|————————————Node:assignment_expression Text: tempCanFrame = pCANHardware->receivedMessages.front()
|—————————————Node:identifier Text: tempCanFrame
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: pCANHardware->receivedMessages.front()
|——————————————Node:field_expression Text: pCANHardware->receivedMessages.front
|———————————————Node:field_expression Text: pCANHardware->receivedMessages
|————————————————Node:identifier Text: pCANHardware
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receivedMessages
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: front
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessages.pop_front();
|————————————Node:call_expression Text: pCANHardware->receivedMessages.pop_front()
|—————————————Node:field_expression Text: pCANHardware->receivedMessages.pop_front
|——————————————Node:field_expression Text: pCANHardware->receivedMessages
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessages
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: pop_front
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: processNextMessage = (!pCANHardware->receivedMessages.empty());
|————————————Node:assignment_expression Text: processNextMessage = (!pCANHardware->receivedMessages.empty())
|—————————————Node:identifier Text: processNextMessage
|—————————————Node:= Text: =
|—————————————Node:parenthesized_expression Text: (!pCANHardware->receivedMessages.empty())
|——————————————Node:( Text: (
|——————————————Node:unary_expression Text: !pCANHardware->receivedMessages.empty()
|———————————————Node:! Text: !
|———————————————Node:call_expression Text: pCANHardware->receivedMessages.empty()
|————————————————Node:field_expression Text: pCANHardware->receivedMessages.empty
|—————————————————Node:field_expression Text: pCANHardware->receivedMessages
|——————————————————Node:identifier Text: pCANHardware
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: receivedMessages
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: empty
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: rxCallbackMutex.lock();
|————————————Node:call_expression Text: rxCallbackMutex.lock()
|—————————————Node:field_expression Text: rxCallbackMutex.lock
|——————————————Node:identifier Text: rxCallbackMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:for_statement Text: for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
					{
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: std::uint32_t j = 0;
|—————————————Node:qualified_identifier Text: std::uint32_t
|——————————————Node:namespace_identifier Text: std
|——————————————Node::: Text: ::
|——————————————Node:type_identifier Text: uint32_t
|—————————————Node:init_declarator Text: j = 0
|——————————————Node:identifier Text: j
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: j < rxCallbacks.size()
|—————————————Node:identifier Text: j
|—————————————Node:< Text: <
|—————————————Node:call_expression Text: rxCallbacks.size()
|——————————————Node:field_expression Text: rxCallbacks.size
|———————————————Node:identifier Text: rxCallbacks
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: size
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|————————————Node:update_expression Text: j++
|—————————————Node:identifier Text: j
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
					}
|—————————————Node:{ Text: {
|—————————————Node:if_statement Text: if (nullptr != rxCallbacks[j].callback)
						{
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (nullptr != rxCallbacks[j].callback)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: nullptr != rxCallbacks[j].callback
|————————————————Node:null Text: nullptr
|—————————————————Node:nullptr Text: nullptr
|————————————————Node:!= Text: !=
|————————————————Node:field_expression Text: rxCallbacks[j].callback
|—————————————————Node:subscript_expression Text: rxCallbacks[j]
|——————————————————Node:identifier Text: rxCallbacks
|——————————————————Node:subscript_argument_list Text: [j]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: j
|———————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: callback
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
							rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
						}
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
|————————————————Node:call_expression Text: rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent)
|—————————————————Node:field_expression Text: rxCallbacks[j].callback
|——————————————————Node:subscript_expression Text: rxCallbacks[j]
|———————————————————Node:identifier Text: rxCallbacks
|———————————————————Node:subscript_argument_list Text: [j]
|————————————————————Node:[ Text: [
|————————————————————Node:identifier Text: j
|————————————————————Node:] Text: ]
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: callback
|—————————————————Node:argument_list Text: (tempCanFrame, rxCallbacks[j].parent)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: tempCanFrame
|——————————————————Node:, Text: ,
|——————————————————Node:field_expression Text: rxCallbacks[j].parent
|———————————————————Node:subscript_expression Text: rxCallbacks[j]
|————————————————————Node:identifier Text: rxCallbacks
|————————————————————Node:subscript_argument_list Text: [j]
|—————————————————————Node:[ Text: [
|—————————————————————Node:identifier Text: j
|—————————————————————Node:] Text: ]
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: parent
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: rxCallbackMutex.unlock();
|————————————Node:call_expression Text: rxCallbackMutex.unlock()
|—————————————Node:field_expression Text: rxCallbackMutex.unlock
|——————————————Node:identifier Text: rxCallbackMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:if_statement Text: if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (get_clear_can_lib_needs_update())
|—————————Node:( Text: (
|—————————Node:call_expression Text: get_clear_can_lib_needs_update()
|——————————Node:identifier Text: get_clear_can_lib_needs_update
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|——————————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|———————————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|————————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:for_statement Text: for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:declaration Text: std::uint32_t j = 0;
|———————————Node:qualified_identifier Text: std::uint32_t
|————————————Node:namespace_identifier Text: std
|————————————Node::: Text: ::
|————————————Node:type_identifier Text: uint32_t
|———————————Node:init_declarator Text: j = 0
|————————————Node:identifier Text: j
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:binary_expression Text: j < canLibUpdateCallbacks.size()
|———————————Node:identifier Text: j
|———————————Node:< Text: <
|———————————Node:call_expression Text: canLibUpdateCallbacks.size()
|————————————Node:field_expression Text: canLibUpdateCallbacks.size
|—————————————Node:identifier Text: canLibUpdateCallbacks
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: size
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|——————————Node:update_expression Text: j++
|———————————Node:identifier Text: j
|———————————Node:++ Text: ++
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (nullptr != canLibUpdateCallbacks[j].callback)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: nullptr != canLibUpdateCallbacks[j].callback
|——————————————Node:null Text: nullptr
|———————————————Node:nullptr Text: nullptr
|——————————————Node:!= Text: !=
|——————————————Node:field_expression Text: canLibUpdateCallbacks[j].callback
|———————————————Node:subscript_expression Text: canLibUpdateCallbacks[j]
|————————————————Node:identifier Text: canLibUpdateCallbacks
|————————————————Node:subscript_argument_list Text: [j]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: j
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: callback
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						canLibUpdateCallbacks[j].callback();
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: canLibUpdateCallbacks[j].callback();
|——————————————Node:call_expression Text: canLibUpdateCallbacks[j].callback()
|———————————————Node:field_expression Text: canLibUpdateCallbacks[j].callback
|————————————————Node:subscript_expression Text: canLibUpdateCallbacks[j]
|—————————————————Node:identifier Text: canLibUpdateCallbacks
|—————————————————Node:subscript_argument_list Text: [j]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: j
|——————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: callback
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|——————————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|———————————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|————————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels[i];
				pCANHardware->messagesToBeTransmittedMutex.lock();
				isobus::HardwareInterfaceCANFrame packet;
				bool sendPacket = false;

				for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
				pCANHardware->messagesToBeTransmittedMutex.unlock();
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels[i];
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels[i]
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:subscript_expression Text: hardwareChannels[i]
|————————————Node:identifier Text: hardwareChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->messagesToBeTransmittedMutex.lock();
|——————————Node:call_expression Text: pCANHardware->messagesToBeTransmittedMutex.lock()
|———————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex.lock
|————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex
|—————————————Node:identifier Text: pCANHardware
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:declaration Text: isobus::HardwareInterfaceCANFrame packet;
|——————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|———————————Node:namespace_identifier Text: isobus
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: HardwareInterfaceCANFrame
|——————————Node:identifier Text: packet
|——————————Node:; Text: ;
|—————————Node:declaration Text: bool sendPacket = false;
|——————————Node:primitive_type Text: bool
|——————————Node:init_declarator Text: sendPacket = false
|———————————Node:identifier Text: sendPacket
|———————————Node:= Text: =
|———————————Node:false Text: false
|——————————Node:; Text: ;
|—————————Node:for_statement Text: for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
				{
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:declaration Text: std::uint32_t j = 0;
|———————————Node:qualified_identifier Text: std::uint32_t
|————————————Node:namespace_identifier Text: std
|————————————Node::: Text: ::
|————————————Node:type_identifier Text: uint32_t
|———————————Node:init_declarator Text: j = 0
|————————————Node:identifier Text: j
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:binary_expression Text: j < pCANHardware->messagesToBeTransmitted.size()
|———————————Node:identifier Text: j
|———————————Node:< Text: <
|———————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.size()
|————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.size
|—————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|——————————————Node:identifier Text: pCANHardware
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: messagesToBeTransmitted
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: size
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|——————————Node:update_expression Text: j++
|———————————Node:identifier Text: j
|———————————Node:++ Text: ++
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
					sendPacket = false;

					if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}

					if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: sendPacket = false;
|————————————Node:assignment_expression Text: sendPacket = false
|—————————————Node:identifier Text: sendPacket
|—————————————Node:= Text: =
|—————————————Node:false Text: false
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if (0 != pCANHardware->messagesToBeTransmitted.size())
					{
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (0 != pCANHardware->messagesToBeTransmitted.size())
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 0 != pCANHardware->messagesToBeTransmitted.size()
|——————————————Node:number_literal Text: 0
|——————————————Node:!= Text: !=
|——————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.size()
|———————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.size
|————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|—————————————————Node:identifier Text: pCANHardware
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: messagesToBeTransmitted
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: size
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						packet = pCANHardware->messagesToBeTransmitted.front();
						sendPacket = true;
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: packet = pCANHardware->messagesToBeTransmitted.front();
|——————————————Node:assignment_expression Text: packet = pCANHardware->messagesToBeTransmitted.front()
|———————————————Node:identifier Text: packet
|———————————————Node:= Text: =
|———————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.front()
|————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.front
|—————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|——————————————————Node:identifier Text: pCANHardware
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: messagesToBeTransmitted
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: front
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: sendPacket = true;
|——————————————Node:assignment_expression Text: sendPacket = true
|———————————————Node:identifier Text: sendPacket
|———————————————Node:= Text: =
|———————————————Node:true Text: true
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:if_statement Text: if (sendPacket)
					{
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (sendPacket)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: sendPacket
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
						// Todo, notify CAN lib that we sent, or did not send, each packet
					}
|—————————————Node:{ Text: {
|—————————————Node:if_statement Text: if (transmit_can_message_from_buffer(packet))
						{
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
						else
						{
							break;
						}
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (transmit_can_message_from_buffer(packet))
|———————————————Node:( Text: (
|———————————————Node:call_expression Text: transmit_can_message_from_buffer(packet)
|————————————————Node:identifier Text: transmit_can_message_from_buffer
|————————————————Node:argument_list Text: (packet)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: packet
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
							pCANHardware->messagesToBeTransmitted.pop_front();
						}
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: pCANHardware->messagesToBeTransmitted.pop_front();
|————————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.pop_front()
|—————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.pop_front
|——————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|———————————————————Node:identifier Text: pCANHardware
|———————————————————Node:-> Text: ->
|———————————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: pop_front
|—————————————————Node:argument_list Text: ()
|——————————————————Node:( Text: (
|——————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|——————————————Node:else_clause Text: else
						{
							break;
						}
|———————————————Node:else Text: else
|———————————————Node:compound_statement Text: {
							break;
						}
|————————————————Node:{ Text: {
|————————————————Node:break_statement Text: break;
|—————————————————Node:break Text: break
|—————————————————Node:; Text: ;
|————————————————Node:} Text: }
|—————————————Node:comment Text: // Todo, notify CAN lib that we sent, or did not send, each packet
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:expression_statement Text: pCANHardware->messagesToBeTransmittedMutex.unlock();
|——————————Node:call_expression Text: pCANHardware->messagesToBeTransmittedMutex.unlock()
|———————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex.unlock
|————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex
|—————————————Node:identifier Text: pCANHardware
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::receive_message_thread_function(uint8_t aCANChannel)
{
	CanHardware *pCANHardware;
	isobus::HardwareInterfaceCANFrame tempCanFrame;

	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::receive_message_thread_function(uint8_t aCANChannel)
|———Node:qualified_identifier Text: CANHardwareInterface::receive_message_thread_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: receive_message_thread_function
|———Node:parameter_list Text: (uint8_t aCANChannel)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t aCANChannel
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: aCANChannel
|————Node:) Text: )
|——Node:compound_statement Text: {
	CanHardware *pCANHardware;
	isobus::HardwareInterfaceCANFrame tempCanFrame;

	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
	}
}
|———Node:{ Text: {
|———Node:declaration Text: CanHardware *pCANHardware;
|————Node:type_identifier Text: CanHardware
|————Node:pointer_declarator Text: *pCANHardware
|—————Node:* Text: *
|—————Node:identifier Text: pCANHardware
|————Node:; Text: ;
|———Node:declaration Text: isobus::HardwareInterfaceCANFrame tempCanFrame;
|————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————Node:namespace_identifier Text: isobus
|—————Node::: Text: ::
|—————Node:type_identifier Text: HardwareInterfaceCANFrame
|————Node:identifier Text: tempCanFrame
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (aCANChannel < hardwareChannels.size())
|—————Node:( Text: (
|—————Node:binary_expression Text: aCANChannel < hardwareChannels.size()
|——————Node:identifier Text: aCANChannel
|——————Node:< Text: <
|——————Node:call_expression Text: hardwareChannels.size()
|———————Node:field_expression Text: hardwareChannels.size
|————————Node:identifier Text: hardwareChannels
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: pCANHardware = hardwareChannels[aCANChannel];
|——————Node:assignment_expression Text: pCANHardware = hardwareChannels[aCANChannel]
|———————Node:identifier Text: pCANHardware
|———————Node:= Text: =
|———————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|————————Node:identifier Text: hardwareChannels
|————————Node:subscript_argument_list Text: [aCANChannel]
|—————————Node:[ Text: [
|—————————Node:identifier Text: aCANChannel
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:while_statement Text: while ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
|——————Node:while Text: while
|——————Node:condition_clause Text: ((threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler))
|———————Node:( Text: (
|———————Node:binary_expression Text: (threadsStarted) &&
		       (nullptr != pCANHardware->frameHandler)
|————————Node:parenthesized_expression Text: (threadsStarted)
|—————————Node:( Text: (
|—————————Node:identifier Text: threadsStarted
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (nullptr != pCANHardware->frameHandler)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != pCANHardware->frameHandler
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:field_expression Text: pCANHardware->frameHandler
|———————————Node:identifier Text: pCANHardware
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: frameHandler
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				pCANHardware->frameHandler->open();
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (pCANHardware->frameHandler->get_is_valid())
|—————————Node:( Text: (
|—————————Node:call_expression Text: pCANHardware->frameHandler->get_is_valid()
|——————————Node:field_expression Text: pCANHardware->frameHandler->get_is_valid
|———————————Node:field_expression Text: pCANHardware->frameHandler
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: get_is_valid
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				// Socker or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
|—————————Node:{ Text: {
|—————————Node:comment Text: // Socker or other hardware still open
|—————————Node:if_statement Text: if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (pCANHardware->frameHandler->read_frame(tempCanFrame))
|———————————Node:( Text: (
|———————————Node:call_expression Text: pCANHardware->frameHandler->read_frame(tempCanFrame)
|————————————Node:field_expression Text: pCANHardware->frameHandler->read_frame
|—————————————Node:field_expression Text: pCANHardware->frameHandler
|——————————————Node:identifier Text: pCANHardware
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: frameHandler
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: read_frame
|————————————Node:argument_list Text: (tempCanFrame)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: tempCanFrame
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: tempCanFrame.channel = aCANChannel;
|————————————Node:assignment_expression Text: tempCanFrame.channel = aCANChannel
|—————————————Node:field_expression Text: tempCanFrame.channel
|——————————————Node:identifier Text: tempCanFrame
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: channel
|—————————————Node:= Text: =
|—————————————Node:identifier Text: aCANChannel
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessages.push_back(tempCanFrame);
|————————————Node:call_expression Text: pCANHardware->receivedMessages.push_back(tempCanFrame)
|—————————————Node:field_expression Text: pCANHardware->receivedMessages.push_back
|——————————————Node:field_expression Text: pCANHardware->receivedMessages
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessages
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: push_back
|—————————————Node:argument_list Text: (tempCanFrame)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: tempCanFrame
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: threadConditionVariable.notify_all();
|————————————Node:call_expression Text: threadConditionVariable.notify_all()
|—————————————Node:field_expression Text: threadConditionVariable.notify_all
|——————————————Node:identifier Text: threadConditionVariable
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: notify_all
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:else_clause Text: else
			{
				pCANHardware->frameHandler->open();
			}
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
				pCANHardware->frameHandler->open();
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: pCANHardware->frameHandler->open();
|———————————Node:call_expression Text: pCANHardware->frameHandler->open()
|————————————Node:field_expression Text: pCANHardware->frameHandler->open
|—————————————Node:field_expression Text: pCANHardware->frameHandler
|——————————————Node:identifier Text: pCANHardware
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: frameHandler
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: open
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::transmit_can_message_from_buffer(isobus::HardwareInterfaceCANFrame &packet)
{
	bool retVal = false;
	std::uint8_t lChannel = packet.channel;

	if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::transmit_can_message_from_buffer(isobus::HardwareInterfaceCANFrame &packet)
|———Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message_from_buffer
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: transmit_can_message_from_buffer
|———Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &packet)
|————Node:( Text: (
|————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &packet
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &packet
|——————Node:& Text: &
|——————Node:identifier Text: packet
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	std::uint8_t lChannel = packet.channel;

	if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: std::uint8_t lChannel = packet.channel;
|————Node:qualified_identifier Text: std::uint8_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint8_t
|————Node:init_declarator Text: lChannel = packet.channel
|—————Node:identifier Text: lChannel
|—————Node:= Text: =
|—————Node:field_expression Text: packet.channel
|——————Node:identifier Text: packet
|——————Node:. Text: .
|——————Node:field_identifier Text: channel
|————Node:; Text: ;
|———Node:if_statement Text: if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
|————Node:if Text: if
|————Node:condition_clause Text: (lChannel < hardwareChannels.size())
|—————Node:( Text: (
|—————Node:binary_expression Text: lChannel < hardwareChannels.size()
|——————Node:identifier Text: lChannel
|——————Node:< Text: <
|——————Node:call_expression Text: hardwareChannels.size()
|———————Node:field_expression Text: hardwareChannels.size
|————————Node:identifier Text: hardwareChannels
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
|——————Node:assignment_expression Text: retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)))
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)))
|————————Node:( Text: (
|————————Node:binary_expression Text: (nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet))
|—————————Node:parenthesized_expression Text: (nullptr != hardwareChannels[lChannel]->frameHandler)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: nullptr != hardwareChannels[lChannel]->frameHandler
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|———————————Node:!= Text: !=
|———————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|————————————Node:subscript_expression Text: hardwareChannels[lChannel]
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:subscript_argument_list Text: [lChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: lChannel
|——————————————Node:] Text: ]
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|——————————Node:) Text: )
|—————————Node:&& Text: &&
|—————————Node:parenthesized_expression Text: (hardwareChannels[lChannel]->frameHandler->write_frame(packet))
|——————————Node:( Text: (
|——————————Node:call_expression Text: hardwareChannels[lChannel]->frameHandler->write_frame(packet)
|———————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler->write_frame
|————————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [lChannel]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: lChannel
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: write_frame
|———————————Node:argument_list Text: (packet)
|————————————Node:( Text: (
|————————————Node:identifier Text: packet
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::update_can_lib_periodic_function()
{
	const std::uint32_t UPDATE_RATE = CANLIB_UPDATE_RATE;
	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::update_can_lib_periodic_function()
|———Node:qualified_identifier Text: CANHardwareInterface::update_can_lib_periodic_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: update_can_lib_periodic_function
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	const std::uint32_t UPDATE_RATE = CANLIB_UPDATE_RATE;
	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
}
|———Node:{ Text: {
|———Node:declaration Text: const std::uint32_t UPDATE_RATE = CANLIB_UPDATE_RATE;
|————Node:type_qualifier Text: const
|—————Node:const Text: const
|————Node:qualified_identifier Text: std::uint32_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint32_t
|————Node:init_declarator Text: UPDATE_RATE = CANLIB_UPDATE_RATE
|—————Node:identifier Text: UPDATE_RATE
|—————Node:= Text: =
|—————Node:identifier Text: CANLIB_UPDATE_RATE
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:while_statement Text: while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
|————Node:while Text: while
|————Node:condition_clause Text: (threadsStarted)
|—————Node:( Text: (
|—————Node:identifier Text: threadsStarted
|—————Node:) Text: )
|————Node:compound_statement Text: {
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: set_can_lib_needs_update();
|——————Node:call_expression Text: set_can_lib_needs_update()
|———————Node:identifier Text: set_can_lib_needs_update
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: threadConditionVariable.notify_all();
|——————Node:call_expression Text: threadConditionVariable.notify_all()
|———————Node:field_expression Text: threadConditionVariable.notify_all
|————————Node:identifier Text: threadConditionVariable
|————————Node:. Text: .
|————————Node:field_identifier Text: notify_all
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
|——————Node:call_expression Text: std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE))
|———————Node:qualified_identifier Text: std::this_thread::sleep_for
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:qualified_identifier Text: this_thread::sleep_for
|—————————Node:namespace_identifier Text: this_thread
|—————————Node::: Text: ::
|—————————Node:identifier Text: sleep_for
|———————Node:argument_list Text: (std::chrono::milliseconds(UPDATE_RATE))
|————————Node:( Text: (
|————————Node:call_expression Text: std::chrono::milliseconds(UPDATE_RATE)
|—————————Node:qualified_identifier Text: std::chrono::milliseconds
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:qualified_identifier Text: chrono::milliseconds
|———————————Node:namespace_identifier Text: chrono
|———————————Node::: Text: ::
|———————————Node:identifier Text: milliseconds
|—————————Node:argument_list Text: (UPDATE_RATE)
|——————————Node:( Text: (
|——————————Node:identifier Text: UPDATE_RATE
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::set_can_lib_needs_update()
{
	canLibNeedsUpdateMutex.lock();
	canLibNeedsUpdate = true;
	canLibNeedsUpdateMutex.unlock();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::set_can_lib_needs_update()
|———Node:qualified_identifier Text: CANHardwareInterface::set_can_lib_needs_update
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: set_can_lib_needs_update
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	canLibNeedsUpdateMutex.lock();
	canLibNeedsUpdate = true;
	canLibNeedsUpdateMutex.unlock();
}
|———Node:{ Text: {
|———Node:expression_statement Text: canLibNeedsUpdateMutex.lock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.lock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.lock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdate = true;
|————Node:assignment_expression Text: canLibNeedsUpdate = true
|—————Node:identifier Text: canLibNeedsUpdate
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.unlock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.unlock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.unlock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::get_clear_can_lib_needs_update()
{
	bool retVal = false;

	canLibNeedsUpdateMutex.lock();
	retVal = canLibNeedsUpdate;
	canLibNeedsUpdate = false;
	canLibNeedsUpdateMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::get_clear_can_lib_needs_update()
|———Node:qualified_identifier Text: CANHardwareInterface::get_clear_can_lib_needs_update
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: get_clear_can_lib_needs_update
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	canLibNeedsUpdateMutex.lock();
	retVal = canLibNeedsUpdate;
	canLibNeedsUpdate = false;
	canLibNeedsUpdateMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.lock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.lock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.lock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: retVal = canLibNeedsUpdate;
|————Node:assignment_expression Text: retVal = canLibNeedsUpdate
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:identifier Text: canLibNeedsUpdate
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdate = false;
|————Node:assignment_expression Text: canLibNeedsUpdate = false
|—————Node:identifier Text: canLibNeedsUpdate
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.unlock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.unlock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.unlock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
