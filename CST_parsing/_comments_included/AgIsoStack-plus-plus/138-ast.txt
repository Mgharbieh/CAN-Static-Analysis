AgIsoStack-plus-plus-hardware_integration\src\can_hardware_interface.cpp

|Node:translation_unit
|—Node:comment Text: //================================================================================================
|—Node:comment Text: /// @file can_hardware_interface.cpp
|—Node:comment Text: ///
|—Node:comment Text: /// @brief An interface for using socket CAN on linux. Mostly for testing, but it could be
|—Node:comment Text: /// used in any application to get the stack hooked up to the bus.
|—Node:comment Text: /// @author Adrian Del Grosso
|—Node:comment Text: ///
|—Node:comment Text: /// @copyright 2022 Adrian Del Grosso
|—Node:comment Text: //================================================================================================
|—Node:preproc_include Text: #include "isobus/hardware_integration/can_hardware_interface.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "isobus/hardware_integration/can_hardware_interface.hpp"
|———Node:" Text: "
|———Node:string_content Text: isobus/hardware_integration/can_hardware_interface.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include "isobus/isobus/can_stack_logger.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "isobus/isobus/can_stack_logger.hpp"
|———Node:" Text: "
|———Node:string_content Text: isobus/isobus/can_stack_logger.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include "isobus/utility/system_timing.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "isobus/utility/system_timing.hpp"
|———Node:" Text: "
|———Node:string_content Text: isobus/utility/system_timing.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include "isobus/utility/to_string.hpp"

|——Node:#include Text: #include
|——Node:string_literal Text: "isobus/utility/to_string.hpp"
|———Node:" Text: "
|———Node:string_content Text: isobus/utility/to_string.hpp
|———Node:" Text: "
|—Node:preproc_include Text: #include <algorithm>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <algorithm>
|—Node:declaration Text: std::thread *CANHardwareInterface::can_thread = nullptr;
|——Node:qualified_identifier Text: std::thread
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: thread
|——Node:init_declarator Text: *CANHardwareInterface::can_thread = nullptr
|———Node:pointer_declarator Text: *CANHardwareInterface::can_thread
|————Node:* Text: *
|————Node:qualified_identifier Text: CANHardwareInterface::can_thread
|—————Node:namespace_identifier Text: CANHardwareInterface
|—————Node::: Text: ::
|—————Node:identifier Text: can_thread
|———Node:= Text: =
|———Node:null Text: nullptr
|————Node:nullptr Text: nullptr
|——Node:; Text: ;
|—Node:declaration Text: std::thread *CANHardwareInterface::updateCANLibPeriodicThread = nullptr;
|——Node:qualified_identifier Text: std::thread
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: thread
|——Node:init_declarator Text: *CANHardwareInterface::updateCANLibPeriodicThread = nullptr
|———Node:pointer_declarator Text: *CANHardwareInterface::updateCANLibPeriodicThread
|————Node:* Text: *
|————Node:qualified_identifier Text: CANHardwareInterface::updateCANLibPeriodicThread
|—————Node:namespace_identifier Text: CANHardwareInterface
|—————Node::: Text: ::
|—————Node:identifier Text: updateCANLibPeriodicThread
|———Node:= Text: =
|———Node:null Text: nullptr
|————Node:nullptr Text: nullptr
|——Node:; Text: ;
|—Node:declaration Text: std::condition_variable CANHardwareInterface::threadConditionVariable;
|——Node:qualified_identifier Text: std::condition_variable
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: condition_variable
|——Node:qualified_identifier Text: CANHardwareInterface::threadConditionVariable
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: threadConditionVariable
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::CanHardware *> CANHardwareInterface::hardwareChannels;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::CanHardware *>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::CanHardware *>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::CanHardware *>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::CanHardware *
|——————Node:qualified_identifier Text: CANHardwareInterface::CanHardware
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: CanHardware
|——————Node:abstract_pointer_declarator Text: *
|———————Node:* Text: *
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::hardwareChannels
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: hardwareChannels
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::RawCanMessageCallbackInfo> CANHardwareInterface::rxCallbacks;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::RawCanMessageCallbackInfo>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::RawCanMessageCallbackInfo>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::RawCanMessageCallbackInfo>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::RawCanMessageCallbackInfo
|——————Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: RawCanMessageCallbackInfo
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::rxCallbacks
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: rxCallbacks
|——Node:; Text: ;
|—Node:declaration Text: std::vector<CANHardwareInterface::CanLibUpdateCallbackInfo> CANHardwareInterface::canLibUpdateCallbacks;
|——Node:qualified_identifier Text: std::vector<CANHardwareInterface::CanLibUpdateCallbackInfo>
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:template_type Text: vector<CANHardwareInterface::CanLibUpdateCallbackInfo>
|————Node:type_identifier Text: vector
|————Node:template_argument_list Text: <CANHardwareInterface::CanLibUpdateCallbackInfo>
|—————Node:< Text: <
|—————Node:type_descriptor Text: CANHardwareInterface::CanLibUpdateCallbackInfo
|——————Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo
|———————Node:namespace_identifier Text: CANHardwareInterface
|———————Node::: Text: ::
|———————Node:type_identifier Text: CanLibUpdateCallbackInfo
|—————Node:> Text: >
|——Node:qualified_identifier Text: CANHardwareInterface::canLibUpdateCallbacks
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibUpdateCallbacks
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::hardwareChannelsMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::hardwareChannelsMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: hardwareChannelsMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::threadMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::threadMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: threadMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::rxCallbackMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::rxCallbackMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: rxCallbackMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::canLibNeedsUpdateMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::canLibNeedsUpdateMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibNeedsUpdateMutex
|——Node:; Text: ;
|—Node:declaration Text: std::mutex CANHardwareInterface::canLibUpdateCallbacksMutex;
|——Node:qualified_identifier Text: std::mutex
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: mutex
|——Node:qualified_identifier Text: CANHardwareInterface::canLibUpdateCallbacksMutex
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: canLibUpdateCallbacksMutex
|——Node:; Text: ;
|—Node:declaration Text: bool CANHardwareInterface::threadsStarted = false;
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: CANHardwareInterface::threadsStarted = false
|———Node:qualified_identifier Text: CANHardwareInterface::threadsStarted
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: threadsStarted
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: bool CANHardwareInterface::canLibNeedsUpdate = false;
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: CANHardwareInterface::canLibNeedsUpdate = false
|———Node:qualified_identifier Text: CANHardwareInterface::canLibNeedsUpdate
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: canLibNeedsUpdate
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: std::uint32_t CANHardwareInterface::canLibUpdatePeriod = CANLIB_UPDATE_RATE;
|——Node:qualified_identifier Text: std::uint32_t
|———Node:namespace_identifier Text: std
|———Node::: Text: ::
|———Node:type_identifier Text: uint32_t
|——Node:init_declarator Text: CANHardwareInterface::canLibUpdatePeriod = CANLIB_UPDATE_RATE
|———Node:qualified_identifier Text: CANHardwareInterface::canLibUpdatePeriod
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: canLibUpdatePeriod
|———Node:= Text: =
|———Node:identifier Text: CANLIB_UPDATE_RATE
|——Node:; Text: ;
|—Node:declaration Text: CANHardwareInterface CANHardwareInterface::CAN_HARDWARE_INTERFACE;
|——Node:type_identifier Text: CANHardwareInterface
|——Node:qualified_identifier Text: CANHardwareInterface::CAN_HARDWARE_INTERFACE
|———Node:namespace_identifier Text: CANHardwareInterface
|———Node::: Text: ::
|———Node:identifier Text: CAN_HARDWARE_INTERFACE
|——Node:; Text: ;
|—Node:function_definition Text: bool isobus::send_can_message_to_hardware(HardwareInterfaceCANFrame frame)
{
	return CANHardwareInterface::transmit_can_message(frame);
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: isobus::send_can_message_to_hardware(HardwareInterfaceCANFrame frame)
|———Node:qualified_identifier Text: isobus::send_can_message_to_hardware
|————Node:namespace_identifier Text: isobus
|————Node::: Text: ::
|————Node:identifier Text: send_can_message_to_hardware
|———Node:parameter_list Text: (HardwareInterfaceCANFrame frame)
|————Node:( Text: (
|————Node:parameter_declaration Text: HardwareInterfaceCANFrame frame
|—————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:identifier Text: frame
|————Node:) Text: )
|——Node:compound_statement Text: {
	return CANHardwareInterface::transmit_can_message(frame);
}
|———Node:{ Text: {
|———Node:return_statement Text: return CANHardwareInterface::transmit_can_message(frame);
|————Node:return Text: return
|————Node:call_expression Text: CANHardwareInterface::transmit_can_message(frame)
|—————Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message
|——————Node:namespace_identifier Text: CANHardwareInterface
|——————Node::: Text: ::
|——————Node:identifier Text: transmit_can_message
|—————Node:argument_list Text: (frame)
|——————Node:( Text: (
|——————Node:identifier Text: frame
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo() :
  callback(nullptr),
  parent(nullptr)
{
}
|——Node:function_declarator Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo()
|———Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo::RawCanMessageCallbackInfo
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: RawCanMessageCallbackInfo::RawCanMessageCallbackInfo
|—————Node:namespace_identifier Text: RawCanMessageCallbackInfo
|—————Node::: Text: ::
|—————Node:identifier Text: RawCanMessageCallbackInfo
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:field_initializer_list Text: :
  callback(nullptr),
  parent(nullptr)
|———Node:: Text: :
|———Node:field_initializer Text: callback(nullptr)
|————Node:field_identifier Text: callback
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: parent(nullptr)
|————Node:field_identifier Text: parent
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::RawCanMessageCallbackInfo::operator==(const RawCanMessageCallbackInfo &obj)
{
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::RawCanMessageCallbackInfo::operator==(const RawCanMessageCallbackInfo &obj)
|———Node:qualified_identifier Text: CANHardwareInterface::RawCanMessageCallbackInfo::operator==
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: RawCanMessageCallbackInfo::operator==
|—————Node:namespace_identifier Text: RawCanMessageCallbackInfo
|—————Node::: Text: ::
|—————Node:operator_name Text: operator==
|——————Node:operator Text: operator
|——————Node:== Text: ==
|———Node:parameter_list Text: (const RawCanMessageCallbackInfo &obj)
|————Node:( Text: (
|————Node:parameter_declaration Text: const RawCanMessageCallbackInfo &obj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: RawCanMessageCallbackInfo
|—————Node:reference_declarator Text: &obj
|——————Node:& Text: &
|——————Node:identifier Text: obj
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|———Node:{ Text: {
|———Node:return_statement Text: return ((obj.callback == this->callback) && (obj.parent == this->parent));
|————Node:return Text: return
|————Node:parenthesized_expression Text: ((obj.callback == this->callback) && (obj.parent == this->parent))
|—————Node:( Text: (
|—————Node:binary_expression Text: (obj.callback == this->callback) && (obj.parent == this->parent)
|——————Node:parenthesized_expression Text: (obj.callback == this->callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.callback == this->callback
|————————Node:field_expression Text: obj.callback
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: callback
|————————Node:== Text: ==
|————————Node:field_expression Text: this->callback
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (obj.parent == this->parent)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.parent == this->parent
|————————Node:field_expression Text: obj.parent
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: parent
|————————Node:== Text: ==
|————————Node:field_expression Text: this->parent
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parent
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo() :
  callback(nullptr),
  parent(nullptr)
{
}
|——Node:function_declarator Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo()
|———Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: CanLibUpdateCallbackInfo::CanLibUpdateCallbackInfo
|—————Node:namespace_identifier Text: CanLibUpdateCallbackInfo
|—————Node::: Text: ::
|—————Node:identifier Text: CanLibUpdateCallbackInfo
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:field_initializer_list Text: :
  callback(nullptr),
  parent(nullptr)
|———Node:: Text: :
|———Node:field_initializer Text: callback(nullptr)
|————Node:field_identifier Text: callback
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|———Node:, Text: ,
|———Node:field_initializer Text: parent(nullptr)
|————Node:field_identifier Text: parent
|————Node:argument_list Text: (nullptr)
|—————Node:( Text: (
|—————Node:null Text: nullptr
|——————Node:nullptr Text: nullptr
|—————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::CanLibUpdateCallbackInfo::operator==(const CanLibUpdateCallbackInfo &obj)
{
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::CanLibUpdateCallbackInfo::operator==(const CanLibUpdateCallbackInfo &obj)
|———Node:qualified_identifier Text: CANHardwareInterface::CanLibUpdateCallbackInfo::operator==
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:qualified_identifier Text: CanLibUpdateCallbackInfo::operator==
|—————Node:namespace_identifier Text: CanLibUpdateCallbackInfo
|—————Node::: Text: ::
|—————Node:operator_name Text: operator==
|——————Node:operator Text: operator
|——————Node:== Text: ==
|———Node:parameter_list Text: (const CanLibUpdateCallbackInfo &obj)
|————Node:( Text: (
|————Node:parameter_declaration Text: const CanLibUpdateCallbackInfo &obj
|—————Node:type_qualifier Text: const
|——————Node:const Text: const
|—————Node:type_identifier Text: CanLibUpdateCallbackInfo
|—————Node:reference_declarator Text: &obj
|——————Node:& Text: &
|——————Node:identifier Text: obj
|————Node:) Text: )
|——Node:compound_statement Text: {
	return ((obj.callback == this->callback) && (obj.parent == this->parent));
}
|———Node:{ Text: {
|———Node:return_statement Text: return ((obj.callback == this->callback) && (obj.parent == this->parent));
|————Node:return Text: return
|————Node:parenthesized_expression Text: ((obj.callback == this->callback) && (obj.parent == this->parent))
|—————Node:( Text: (
|—————Node:binary_expression Text: (obj.callback == this->callback) && (obj.parent == this->parent)
|——————Node:parenthesized_expression Text: (obj.callback == this->callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.callback == this->callback
|————————Node:field_expression Text: obj.callback
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: callback
|————————Node:== Text: ==
|————————Node:field_expression Text: this->callback
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (obj.parent == this->parent)
|———————Node:( Text: (
|———————Node:binary_expression Text: obj.parent == this->parent
|————————Node:field_expression Text: obj.parent
|—————————Node:identifier Text: obj
|—————————Node:. Text: .
|—————————Node:field_identifier Text: parent
|————————Node:== Text: ==
|————————Node:field_expression Text: this->parent
|—————————Node:this Text: this
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: parent
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::CANHardwareInterface()
{
}
|——Node:function_declarator Text: CANHardwareInterface::CANHardwareInterface()
|———Node:qualified_identifier Text: CANHardwareInterface::CANHardwareInterface
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: CANHardwareInterface
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
}
|———Node:{ Text: {
|———Node:} Text: }
|—Node:function_definition Text: CANHardwareInterface::~CANHardwareInterface()
{
	set_number_of_can_channels(0);
}
|——Node:function_declarator Text: CANHardwareInterface::~CANHardwareInterface()
|———Node:qualified_identifier Text: CANHardwareInterface::~CANHardwareInterface
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:destructor_name Text: ~CANHardwareInterface
|—————Node:~ Text: ~
|—————Node:identifier Text: CANHardwareInterface
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	set_number_of_can_channels(0);
}
|———Node:{ Text: {
|———Node:expression_statement Text: set_number_of_can_channels(0);
|————Node:call_expression Text: set_number_of_can_channels(0)
|—————Node:identifier Text: set_number_of_can_channels
|—————Node:argument_list Text: (0)
|——————Node:( Text: (
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::assign_can_channel_frame_handler(std::uint8_t aCANChannel, std::shared_ptr<CANHardwarePlugin> driver)
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::assign_can_channel_frame_handler(std::uint8_t aCANChannel, std::shared_ptr<CANHardwarePlugin> driver)
|———Node:qualified_identifier Text: CANHardwareInterface::assign_can_channel_frame_handler
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: assign_can_channel_frame_handler
|———Node:parameter_list Text: (std::uint8_t aCANChannel, std::shared_ptr<CANHardwarePlugin> driver)
|————Node:( Text: (
|————Node:parameter_declaration Text: std::uint8_t aCANChannel
|—————Node:qualified_identifier Text: std::uint8_t
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:type_identifier Text: uint8_t
|—————Node:identifier Text: aCANChannel
|————Node:, Text: ,
|————Node:parameter_declaration Text: std::shared_ptr<CANHardwarePlugin> driver
|—————Node:qualified_identifier Text: std::shared_ptr<CANHardwarePlugin>
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:template_type Text: shared_ptr<CANHardwarePlugin>
|———————Node:type_identifier Text: shared_ptr
|———————Node:template_argument_list Text: <CANHardwarePlugin>
|————————Node:< Text: <
|————————Node:type_descriptor Text: CANHardwarePlugin
|—————————Node:type_identifier Text: CANHardwarePlugin
|————————Node:> Text: >
|—————Node:identifier Text: driver
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
		{
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: ((!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size()))
|———————Node:( Text: (
|———————Node:binary_expression Text: (!threadsStarted) &&
		    (aCANChannel < hardwareChannels.size())
|————————Node:parenthesized_expression Text: (!threadsStarted)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !threadsStarted
|——————————Node:! Text: !
|——————————Node:identifier Text: threadsStarted
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (aCANChannel < hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aCANChannel < hardwareChannels.size()
|——————————Node:identifier Text: aCANChannel
|——————————Node:< Text: <
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
			{
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: ((nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (nullptr == hardwareChannels[aCANChannel]->frameHandler) ||
			    (driver == hardwareChannels[aCANChannel]->frameHandler)
|——————————Node:parenthesized_expression Text: (nullptr == hardwareChannels[aCANChannel]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr == hardwareChannels[aCANChannel]->frameHandler
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:== Text: ==
|————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [aCANChannel]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: aCANChannel
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|——————————Node:|| Text: ||
|——————————Node:parenthesized_expression Text: (driver == hardwareChannels[aCANChannel]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: driver == hardwareChannels[aCANChannel]->frameHandler
|————————————Node:identifier Text: driver
|————————————Node:== Text: ==
|————————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [aCANChannel]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: aCANChannel
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				retVal = true;
				hardwareChannels[aCANChannel]->frameHandler = driver;
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: retVal = true;
|——————————Node:assignment_expression Text: retVal = true
|———————————Node:identifier Text: retVal
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[aCANChannel]->frameHandler = driver;
|——————————Node:assignment_expression Text: hardwareChannels[aCANChannel]->frameHandler = driver
|———————————Node:field_expression Text: hardwareChannels[aCANChannel]->frameHandler
|————————————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:subscript_argument_list Text: [aCANChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: aCANChannel
|——————————————Node:] Text: ]
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:= Text: =
|———————————Node:identifier Text: driver
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t CANHardwareInterface::get_number_of_can_channels()
{
	return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANHardwareInterface::get_number_of_can_channels()
|———Node:qualified_identifier Text: CANHardwareInterface::get_number_of_can_channels
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: get_number_of_can_channels
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
}
|———Node:{ Text: {
|———Node:return_statement Text: return static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max());
|————Node:return Text: return
|————Node:call_expression Text: static_cast<uint8_t>(hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max())
|—————Node:template_function Text: static_cast<uint8_t>
|——————Node:identifier Text: static_cast
|——————Node:template_argument_list Text: <uint8_t>
|———————Node:< Text: <
|———————Node:type_descriptor Text: uint8_t
|————————Node:primitive_type Text: uint8_t
|———————Node:> Text: >
|—————Node:argument_list Text: (hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max())
|——————Node:( Text: (
|——————Node:binary_expression Text: hardwareChannels.size() & std::numeric_limits<std::uint8_t>::max()
|———————Node:call_expression Text: hardwareChannels.size()
|————————Node:field_expression Text: hardwareChannels.size
|—————————Node:identifier Text: hardwareChannels
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:& Text: &
|———————Node:call_expression Text: std::numeric_limits<std::uint8_t>::max()
|————————Node:qualified_identifier Text: std::numeric_limits<std::uint8_t>::max
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:qualified_identifier Text: numeric_limits<std::uint8_t>::max
|——————————Node:template_type Text: numeric_limits<std::uint8_t>
|———————————Node:type_identifier Text: numeric_limits
|———————————Node:template_argument_list Text: <std::uint8_t>
|————————————Node:< Text: <
|————————————Node:type_descriptor Text: std::uint8_t
|—————————————Node:qualified_identifier Text: std::uint8_t
|——————————————Node:namespace_identifier Text: std
|——————————————Node::: Text: ::
|——————————————Node:type_identifier Text: uint8_t
|————————————Node:> Text: >
|——————————Node::: Text: ::
|——————————Node:identifier Text: max
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::set_number_of_can_channels(uint8_t aValue)
{
	CanHardware *pCANHardware;
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::set_number_of_can_channels(uint8_t aValue)
|———Node:qualified_identifier Text: CANHardwareInterface::set_number_of_can_channels
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: set_number_of_can_channels
|———Node:parameter_list Text: (uint8_t aValue)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t aValue
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: aValue
|————Node:) Text: )
|——Node:compound_statement Text: {
	CanHardware *pCANHardware;
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: CanHardware *pCANHardware;
|————Node:type_identifier Text: CanHardware
|————Node:pointer_declarator Text: *pCANHardware
|—————Node:* Text: *
|—————Node:identifier Text: pCANHardware
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!threadsStarted)
		{
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (!threadsStarted)
|———————Node:( Text: (
|———————Node:unary_expression Text: !threadsStarted
|————————Node:! Text: !
|————————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}

			while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:while_statement Text: while (aValue > hardwareChannels.size())
			{
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}
|————————Node:while Text: while
|————————Node:condition_clause Text: (aValue > hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aValue > hardwareChannels.size()
|——————————Node:identifier Text: aValue
|——————————Node:> Text: >
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = new CanHardware();
				pCANHardware->receiveMessageThread = nullptr;
				pCANHardware->frameHandler = nullptr;

				hardwareChannels.push_back(pCANHardware);
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = new CanHardware();
|——————————Node:assignment_expression Text: pCANHardware = new CanHardware()
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:new_expression Text: new CanHardware()
|————————————Node:new Text: new
|————————————Node:type_identifier Text: CanHardware
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->receiveMessageThread = nullptr;
|——————————Node:assignment_expression Text: pCANHardware->receiveMessageThread = nullptr
|———————————Node:field_expression Text: pCANHardware->receiveMessageThread
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: receiveMessageThread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pCANHardware->frameHandler = nullptr;
|——————————Node:assignment_expression Text: pCANHardware->frameHandler = nullptr
|———————————Node:field_expression Text: pCANHardware->frameHandler
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels.push_back(pCANHardware);
|——————————Node:call_expression Text: hardwareChannels.push_back(pCANHardware)
|———————————Node:field_expression Text: hardwareChannels.push_back
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: push_back
|———————————Node:argument_list Text: (pCANHardware)
|————————————Node:( Text: (
|————————————Node:identifier Text: pCANHardware
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:while_statement Text: while (aValue < hardwareChannels.size())
			{
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
|————————Node:while Text: while
|————————Node:condition_clause Text: (aValue < hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: aValue < hardwareChannels.size()
|——————————Node:identifier Text: aValue
|——————————Node:< Text: <
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels.back();
				hardwareChannels.pop_back();
				delete pCANHardware;
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels.back();
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels.back()
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:call_expression Text: hardwareChannels.back()
|————————————Node:field_expression Text: hardwareChannels.back
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: back
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels.pop_back();
|——————————Node:call_expression Text: hardwareChannels.pop_back()
|———————————Node:field_expression Text: hardwareChannels.pop_back
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: pop_back
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: delete pCANHardware;
|——————————Node:delete_expression Text: delete pCANHardware
|———————————Node:delete Text: delete
|———————————Node:identifier Text: pCANHardware
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::start()
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::start()
|———Node:qualified_identifier Text: CANHardwareInterface::start
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: start
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (!threadsStarted)
		{
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (!threadsStarted)
|———————Node:( Text: (
|———————Node:unary_expression Text: !threadsStarted
|————————Node:! Text: !
|————————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			threadsStarted = true;
			retVal = true;
			can_thread = new std::thread(can_thread_function);
			updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: threadsStarted = true;
|————————Node:assignment_expression Text: threadsStarted = true
|—————————Node:identifier Text: threadsStarted
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:expression_statement Text: can_thread = new std::thread(can_thread_function);
|————————Node:assignment_expression Text: can_thread = new std::thread(can_thread_function)
|—————————Node:identifier Text: can_thread
|—————————Node:= Text: =
|—————————Node:new_expression Text: new std::thread(can_thread_function)
|——————————Node:new Text: new
|——————————Node:qualified_identifier Text: std::thread
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: thread
|——————————Node:argument_list Text: (can_thread_function)
|———————————Node:( Text: (
|———————————Node:identifier Text: can_thread_function
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function);
|————————Node:assignment_expression Text: updateCANLibPeriodicThread = new std::thread(update_can_lib_periodic_function)
|—————————Node:identifier Text: updateCANLibPeriodicThread
|—————————Node:= Text: =
|—————————Node:new_expression Text: new std::thread(update_can_lib_periodic_function)
|——————————Node:new Text: new
|——————————Node:qualified_identifier Text: std::thread
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: thread
|——————————Node:argument_list Text: (update_can_lib_periodic_function)
|———————————Node:( Text: (
|———————————Node:identifier Text: update_can_lib_periodic_function
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->frameHandler
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->frameHandler->open();

					if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->frameHandler->open();
|————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->open()
|—————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->open
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: open
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:if_statement Text: if (hardwareChannels[i]->frameHandler->get_is_valid())
					{
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (hardwareChannels[i]->frameHandler->get_is_valid())
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->get_is_valid()
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->get_is_valid
|———————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: frameHandler
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: get_is_valid
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i);
|——————————————Node:assignment_expression Text: hardwareChannels[i]->receiveMessageThread = new std::thread(receive_message_thread_function, i)
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receiveMessageThread
|———————————————Node:= Text: =
|———————————————Node:new_expression Text: new std::thread(receive_message_thread_function, i)
|————————————————Node:new Text: new
|————————————————Node:qualified_identifier Text: std::thread
|—————————————————Node:namespace_identifier Text: std
|—————————————————Node::: Text: ::
|—————————————————Node:type_identifier Text: thread
|————————————————Node:argument_list Text: (receive_message_thread_function, i)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: receive_message_thread_function
|—————————————————Node:, Text: ,
|—————————————————Node:identifier Text: i
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::stop()
{
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}

	if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}

	if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::stop()
|———Node:qualified_identifier Text: CANHardwareInterface::stop
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: stop
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}

	if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}

	if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if (hardwareChannelsMutex.try_lock())
	{
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (hardwareChannelsMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: hardwareChannelsMutex.try_lock()
|——————Node:field_expression Text: hardwareChannelsMutex.try_lock
|———————Node:identifier Text: hardwareChannelsMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
		hardwareChannelsMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (threadsStarted)
		{
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (threadsStarted)
|———————Node:( Text: (
|———————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			threadsStarted = false;
			retVal = true;

			if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}

			if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: threadsStarted = false;
|————————Node:assignment_expression Text: threadsStarted = false
|—————————Node:identifier Text: threadsStarted
|—————————Node:= Text: =
|—————————Node:false Text: false
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:if_statement Text: if (nullptr != can_thread)
			{
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (nullptr != can_thread)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != can_thread
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:identifier Text: can_thread
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
				delete can_thread;
				can_thread = nullptr;
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (can_thread->joinable())
				{
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (can_thread->joinable())
|———————————Node:( Text: (
|———————————Node:call_expression Text: can_thread->joinable()
|————————————Node:field_expression Text: can_thread->joinable
|—————————————Node:identifier Text: can_thread
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: joinable
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannelsMutex.unlock();
					threadConditionVariable.notify_all();
					can_thread->join();
					hardwareChannelsMutex.lock();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————————————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————————————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————————————Node:identifier Text: hardwareChannelsMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: threadConditionVariable.notify_all();
|————————————Node:call_expression Text: threadConditionVariable.notify_all()
|—————————————Node:field_expression Text: threadConditionVariable.notify_all
|——————————————Node:identifier Text: threadConditionVariable
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: notify_all
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: can_thread->join();
|————————————Node:call_expression Text: can_thread->join()
|—————————————Node:field_expression Text: can_thread->join
|——————————————Node:identifier Text: can_thread
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: join
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: hardwareChannelsMutex.lock();
|————————————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————————————Node:field_expression Text: hardwareChannelsMutex.lock
|——————————————Node:identifier Text: hardwareChannelsMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: delete can_thread;
|——————————Node:delete_expression Text: delete can_thread
|———————————Node:delete Text: delete
|———————————Node:identifier Text: can_thread
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: can_thread = nullptr;
|——————————Node:assignment_expression Text: can_thread = nullptr
|———————————Node:identifier Text: can_thread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:if_statement Text: if (nullptr != updateCANLibPeriodicThread)
			{
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (nullptr != updateCANLibPeriodicThread)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != updateCANLibPeriodicThread
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:identifier Text: updateCANLibPeriodicThread
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
				delete updateCANLibPeriodicThread;
				updateCANLibPeriodicThread = nullptr;
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (updateCANLibPeriodicThread->joinable())
				{
					updateCANLibPeriodicThread->join();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (updateCANLibPeriodicThread->joinable())
|———————————Node:( Text: (
|———————————Node:call_expression Text: updateCANLibPeriodicThread->joinable()
|————————————Node:field_expression Text: updateCANLibPeriodicThread->joinable
|—————————————Node:identifier Text: updateCANLibPeriodicThread
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: joinable
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					updateCANLibPeriodicThread->join();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: updateCANLibPeriodicThread->join();
|————————————Node:call_expression Text: updateCANLibPeriodicThread->join()
|—————————————Node:field_expression Text: updateCANLibPeriodicThread->join
|——————————————Node:identifier Text: updateCANLibPeriodicThread
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: join
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: delete updateCANLibPeriodicThread;
|——————————Node:delete_expression Text: delete updateCANLibPeriodicThread
|———————————Node:delete Text: delete
|———————————Node:identifier Text: updateCANLibPeriodicThread
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: updateCANLibPeriodicThread = nullptr;
|——————————Node:assignment_expression Text: updateCANLibPeriodicThread = nullptr
|———————————Node:identifier Text: updateCANLibPeriodicThread
|———————————Node:= Text: =
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->frameHandler)
				{
					hardwareChannels[i]->frameHandler->close();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->frameHandler)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->frameHandler
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->frameHandler->close();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->frameHandler->close();
|————————————Node:call_expression Text: hardwareChannels[i]->frameHandler->close()
|—————————————Node:field_expression Text: hardwareChannels[i]->frameHandler->close
|——————————————Node:field_expression Text: hardwareChannels[i]->frameHandler
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: frameHandler
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: close
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.lock();

				while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
				hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();

				hardwareChannels[i]->receivedMessagesMutex.lock();
				hardwareChannels[i]->receivedMessages.clear();
				hardwareChannels[i]->receivedMessagesMutex.unlock();
			}
|—————————Node:{ Text: {
|—————————Node:if_statement Text: if (nullptr != hardwareChannels[i]->receiveMessageThread)
				{
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != hardwareChannels[i]->receiveMessageThread)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != hardwareChannels[i]->receiveMessageThread
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receiveMessageThread
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
					delete hardwareChannels[i]->receiveMessageThread;
					hardwareChannels[i]->receiveMessageThread = nullptr;
				}
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (hardwareChannels[i]->receiveMessageThread->joinable())
					{
						hardwareChannels[i]->receiveMessageThread->join();
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (hardwareChannels[i]->receiveMessageThread->joinable())
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: hardwareChannels[i]->receiveMessageThread->joinable()
|——————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread->joinable
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|————————————————Node:subscript_expression Text: hardwareChannels[i]
|—————————————————Node:identifier Text: hardwareChannels
|—————————————————Node:subscript_argument_list Text: [i]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: i
|——————————————————Node:] Text: ]
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: receiveMessageThread
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: joinable
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						hardwareChannels[i]->receiveMessageThread->join();
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread->join();
|——————————————Node:call_expression Text: hardwareChannels[i]->receiveMessageThread->join()
|———————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread->join
|————————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|—————————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————————Node:identifier Text: hardwareChannels
|——————————————————Node:subscript_argument_list Text: [i]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: i
|———————————————————Node:] Text: ]
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: receiveMessageThread
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: join
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: delete hardwareChannels[i]->receiveMessageThread;
|————————————Node:delete_expression Text: delete hardwareChannels[i]->receiveMessageThread
|—————————————Node:delete Text: delete
|—————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|——————————————Node:subscript_expression Text: hardwareChannels[i]
|———————————————Node:identifier Text: hardwareChannels
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: receiveMessageThread
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: hardwareChannels[i]->receiveMessageThread = nullptr;
|————————————Node:assignment_expression Text: hardwareChannels[i]->receiveMessageThread = nullptr
|—————————————Node:field_expression Text: hardwareChannels[i]->receiveMessageThread
|——————————————Node:subscript_expression Text: hardwareChannels[i]
|———————————————Node:identifier Text: hardwareChannels
|———————————————Node:subscript_argument_list Text: [i]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: i
|————————————————Node:] Text: ]
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: receiveMessageThread
|—————————————Node:= Text: =
|—————————————Node:null Text: nullptr
|——————————————Node:nullptr Text: nullptr
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock();
|——————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock()
|———————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.lock
|————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:while_statement Text: while (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
				{
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
|——————————Node:while Text: while
|——————————Node:condition_clause Text: (0 != hardwareChannels[i]->messagesToBeTransmitted.size())
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 0 != hardwareChannels[i]->messagesToBeTransmitted.size()
|————————————Node:number_literal Text: 0
|————————————Node:!= Text: !=
|————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.size()
|—————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.size
|——————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: size
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin());
|————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.erase(hardwareChannels[i]->messagesToBeTransmitted.begin())
|—————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.erase
|——————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|———————————————Node:subscript_expression Text: hardwareChannels[i]
|————————————————Node:identifier Text: hardwareChannels
|————————————————Node:subscript_argument_list Text: [i]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: i
|—————————————————Node:] Text: ]
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: erase
|—————————————Node:argument_list Text: (hardwareChannels[i]->messagesToBeTransmitted.begin())
|——————————————Node:( Text: (
|——————————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmitted.begin()
|———————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted.begin
|————————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmitted
|—————————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————————Node:identifier Text: hardwareChannels
|——————————————————Node:subscript_argument_list Text: [i]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: i
|———————————————————Node:] Text: ]
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: messagesToBeTransmitted
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: begin
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock();
|——————————Node:call_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock()
|———————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex.unlock
|————————————Node:field_expression Text: hardwareChannels[i]->messagesToBeTransmittedMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessagesMutex.lock();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessagesMutex.lock()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex.lock
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessages.clear();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessages.clear()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessages.clear
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessages
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessages
|————————————Node:. Text: .
|————————————Node:field_identifier Text: clear
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: hardwareChannels[i]->receivedMessagesMutex.unlock();
|——————————Node:call_expression Text: hardwareChannels[i]->receivedMessagesMutex.unlock()
|———————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex.unlock
|————————————Node:field_expression Text: hardwareChannels[i]->receivedMessagesMutex
|—————————————Node:subscript_expression Text: hardwareChannels[i]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: receivedMessagesMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:expression_statement Text: hardwareChannelsMutex.unlock();
|——————Node:call_expression Text: hardwareChannelsMutex.unlock()
|———————Node:field_expression Text: hardwareChannelsMutex.unlock
|————————Node:identifier Text: hardwareChannelsMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (rxCallbackMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (rxCallbackMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: rxCallbackMutex.try_lock()
|——————Node:field_expression Text: rxCallbackMutex.try_lock
|———————Node:identifier Text: rxCallbackMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
		rxCallbackMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:for_statement Text: for (std::uint32_t i = 0; i < rxCallbacks.size(); i++)
		{
			rxCallbacks.pop_back();
		}
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: std::uint32_t i = 0;
|———————Node:qualified_identifier Text: std::uint32_t
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:type_identifier Text: uint32_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < rxCallbacks.size()
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:call_expression Text: rxCallbacks.size()
|————————Node:field_expression Text: rxCallbacks.size
|—————————Node:identifier Text: rxCallbacks
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
			rxCallbacks.pop_back();
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: rxCallbacks.pop_back();
|————————Node:call_expression Text: rxCallbacks.pop_back()
|—————————Node:field_expression Text: rxCallbacks.pop_back
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pop_back
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: rxCallbackMutex.unlock();
|——————Node:call_expression Text: rxCallbackMutex.unlock()
|———————Node:field_expression Text: rxCallbackMutex.unlock
|————————Node:identifier Text: rxCallbackMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (canLibUpdateCallbacksMutex.try_lock())
	{
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
|————Node:if Text: if
|————Node:condition_clause Text: (canLibUpdateCallbacksMutex.try_lock())
|—————Node:( Text: (
|—————Node:call_expression Text: canLibUpdateCallbacksMutex.try_lock()
|——————Node:field_expression Text: canLibUpdateCallbacksMutex.try_lock
|———————Node:identifier Text: canLibUpdateCallbacksMutex
|———————Node:. Text: .
|———————Node:field_identifier Text: try_lock
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
		canLibUpdateCallbacksMutex.unlock();
	}
|—————Node:{ Text: {
|—————Node:for_statement Text: for (std::uint32_t i = 0; i < canLibUpdateCallbacks.size(); i++)
		{
			canLibUpdateCallbacks.pop_back();
		}
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:declaration Text: std::uint32_t i = 0;
|———————Node:qualified_identifier Text: std::uint32_t
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:type_identifier Text: uint32_t
|———————Node:init_declarator Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|——————Node:binary_expression Text: i < canLibUpdateCallbacks.size()
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:call_expression Text: canLibUpdateCallbacks.size()
|————————Node:field_expression Text: canLibUpdateCallbacks.size
|—————————Node:identifier Text: canLibUpdateCallbacks
|—————————Node:. Text: .
|—————————Node:field_identifier Text: size
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|——————Node:; Text: ;
|——————Node:update_expression Text: i++
|———————Node:identifier Text: i
|———————Node:++ Text: ++
|——————Node:) Text: )
|——————Node:compound_statement Text: {
			canLibUpdateCallbacks.pop_back();
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: canLibUpdateCallbacks.pop_back();
|————————Node:call_expression Text: canLibUpdateCallbacks.pop_back()
|—————————Node:field_expression Text: canLibUpdateCallbacks.pop_back
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: pop_back
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|——————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|———————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::transmit_can_message(isobus::HardwareInterfaceCANFrame &packet)
{
	std::uint8_t lChannel = packet.channel;
	bool retVal = false;

	if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler) &&
	    (hardwareChannels[lChannel]->frameHandler->get_is_valid()))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::transmit_can_message(isobus::HardwareInterfaceCANFrame &packet)
|———Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: transmit_can_message
|———Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &packet)
|————Node:( Text: (
|————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &packet
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &packet
|——————Node:& Text: &
|——————Node:identifier Text: packet
|————Node:) Text: )
|——Node:compound_statement Text: {
	std::uint8_t lChannel = packet.channel;
	bool retVal = false;

	if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler) &&
	    (hardwareChannels[lChannel]->frameHandler->get_is_valid()))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: std::uint8_t lChannel = packet.channel;
|————Node:qualified_identifier Text: std::uint8_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint8_t
|————Node:init_declarator Text: lChannel = packet.channel
|—————Node:identifier Text: lChannel
|—————Node:= Text: =
|—————Node:field_expression Text: packet.channel
|——————Node:identifier Text: packet
|——————Node:. Text: .
|——————Node:field_identifier Text: channel
|————Node:; Text: ;
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:if_statement Text: if ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler) &&
	    (hardwareChannels[lChannel]->frameHandler->get_is_valid()))
	{
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler) &&
	    (hardwareChannels[lChannel]->frameHandler->get_is_valid()))
|—————Node:( Text: (
|—————Node:binary_expression Text: (lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler) &&
	    (hardwareChannels[lChannel]->frameHandler->get_is_valid())
|——————Node:binary_expression Text: (lChannel < hardwareChannels.size()) &&
	    (threadsStarted) &&
	    (nullptr != hardwareChannels[lChannel]->frameHandler)
|———————Node:binary_expression Text: (lChannel < hardwareChannels.size()) &&
	    (threadsStarted)
|————————Node:parenthesized_expression Text: (lChannel < hardwareChannels.size())
|—————————Node:( Text: (
|—————————Node:binary_expression Text: lChannel < hardwareChannels.size()
|——————————Node:identifier Text: lChannel
|——————————Node:< Text: <
|——————————Node:call_expression Text: hardwareChannels.size()
|———————————Node:field_expression Text: hardwareChannels.size
|————————————Node:identifier Text: hardwareChannels
|————————————Node:. Text: .
|————————————Node:field_identifier Text: size
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (threadsStarted)
|—————————Node:( Text: (
|—————————Node:identifier Text: threadsStarted
|—————————Node:) Text: )
|———————Node:&& Text: &&
|———————Node:parenthesized_expression Text: (nullptr != hardwareChannels[lChannel]->frameHandler)
|————————Node:( Text: (
|————————Node:binary_expression Text: nullptr != hardwareChannels[lChannel]->frameHandler
|—————————Node:null Text: nullptr
|——————————Node:nullptr Text: nullptr
|—————————Node:!= Text: !=
|—————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|——————————Node:subscript_expression Text: hardwareChannels[lChannel]
|———————————Node:identifier Text: hardwareChannels
|———————————Node:subscript_argument_list Text: [lChannel]
|————————————Node:[ Text: [
|————————————Node:identifier Text: lChannel
|————————————Node:] Text: ]
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: frameHandler
|————————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (hardwareChannels[lChannel]->frameHandler->get_is_valid())
|———————Node:( Text: (
|———————Node:call_expression Text: hardwareChannels[lChannel]->frameHandler->get_is_valid()
|————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler->get_is_valid
|—————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|——————————Node:subscript_expression Text: hardwareChannels[lChannel]
|———————————Node:identifier Text: hardwareChannels
|———————————Node:subscript_argument_list Text: [lChannel]
|————————————Node:[ Text: [
|————————————Node:identifier Text: lChannel
|————————————Node:] Text: ]
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: frameHandler
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: get_is_valid
|————————Node:argument_list Text: ()
|—————————Node:( Text: (
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
		hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
		hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();

		threadConditionVariable.notify_all();

		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock();
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock()
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.lock
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: lock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet);
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back(packet)
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted.push_back
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmitted
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmitted
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (packet)
|————————Node:( Text: (
|————————Node:identifier Text: packet
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock();
|——————Node:call_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock()
|———————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex.unlock
|————————Node:field_expression Text: hardwareChannels[lChannel]->messagesToBeTransmittedMutex
|—————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————Node:identifier Text: hardwareChannels
|——————————Node:subscript_argument_list Text: [lChannel]
|———————————Node:[ Text: [
|———————————Node:identifier Text: lChannel
|———————————Node:] Text: ]
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: messagesToBeTransmittedMutex
|————————Node:. Text: .
|————————Node:field_identifier Text: unlock
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: threadConditionVariable.notify_all();
|——————Node:call_expression Text: threadConditionVariable.notify_all()
|———————Node:field_expression Text: threadConditionVariable.notify_all
|————————Node:identifier Text: threadConditionVariable
|————————Node:. Text: .
|————————Node:field_identifier Text: notify_all
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::add_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
{
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::add_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|———Node:qualified_identifier Text: CANHardwareInterface::add_raw_can_message_rx_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: add_raw_can_message_rx_callback
|———Node:parameter_list Text: (void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &rxFrame
|————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————Node:namespace_identifier Text: isobus
|—————————Node::: Text: ::
|—————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————Node:reference_declarator Text: &rxFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: rxFrame
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: void *parentPointer
|————————Node:primitive_type Text: void
|————————Node:pointer_declarator Text: *parentPointer
|—————————Node:* Text: *
|—————————Node:identifier Text: parentPointer
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parent
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parent
|——————Node:* Text: *
|——————Node:identifier Text: parent
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: RawCanMessageCallbackInfo callbackInfo;
|————Node:type_identifier Text: RawCanMessageCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parent;
|————Node:assignment_expression Text: callbackInfo.parent = parent
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parent
|————Node:; Text: ;
|———Node:expression_statement Text: rxCallbackMutex.lock();
|————Node:call_expression Text: rxCallbackMutex.lock()
|—————Node:field_expression Text: rxCallbackMutex.lock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
	{
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)))
|—————Node:( Text: (
|—————Node:binary_expression Text: (nullptr != callback) && (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo))
|——————Node:parenthesized_expression Text: (nullptr != callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: nullptr != callback
|————————Node:null Text: nullptr
|—————————Node:nullptr Text: nullptr
|————————Node:!= Text: !=
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo))
|———————Node:( Text: (
|———————Node:binary_expression Text: rxCallbacks.end() == find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|————————Node:call_expression Text: rxCallbacks.end()
|—————————Node:field_expression Text: rxCallbacks.end
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:call_expression Text: find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|—————————Node:identifier Text: find
|—————————Node:argument_list Text: (rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|——————————Node:( Text: (
|——————————Node:call_expression Text: rxCallbacks.begin()
|———————————Node:field_expression Text: rxCallbacks.begin
|————————————Node:identifier Text: rxCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: begin
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: rxCallbacks.end()
|———————————Node:field_expression Text: rxCallbacks.end
|————————————Node:identifier Text: rxCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: end
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: callbackInfo
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		rxCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: rxCallbacks.push_back(callbackInfo);
|——————Node:call_expression Text: rxCallbacks.push_back(callbackInfo)
|———————Node:field_expression Text: rxCallbacks.push_back
|————————Node:identifier Text: rxCallbacks
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (callbackInfo)
|————————Node:( Text: (
|————————Node:identifier Text: callbackInfo
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: rxCallbackMutex.unlock();
|————Node:call_expression Text: rxCallbackMutex.unlock()
|—————Node:field_expression Text: rxCallbackMutex.unlock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::remove_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
{
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::remove_raw_can_message_rx_callback(void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|———Node:qualified_identifier Text: CANHardwareInterface::remove_raw_can_message_rx_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: remove_raw_can_message_rx_callback
|———Node:parameter_list Text: (void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer), void *parent)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)(isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &rxFrame, void *parentPointer)
|———————Node:( Text: (
|———————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &rxFrame
|————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————Node:namespace_identifier Text: isobus
|—————————Node::: Text: ::
|—————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————Node:reference_declarator Text: &rxFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: rxFrame
|———————Node:, Text: ,
|———————Node:parameter_declaration Text: void *parentPointer
|————————Node:primitive_type Text: void
|————————Node:pointer_declarator Text: *parentPointer
|—————————Node:* Text: *
|—————————Node:identifier Text: parentPointer
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parent
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parent
|——————Node:* Text: *
|——————Node:identifier Text: parent
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	RawCanMessageCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parent;

	rxCallbackMutex.lock();

	if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	rxCallbackMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: RawCanMessageCallbackInfo callbackInfo;
|————Node:type_identifier Text: RawCanMessageCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parent;
|————Node:assignment_expression Text: callbackInfo.parent = parent
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parent
|————Node:; Text: ;
|———Node:expression_statement Text: rxCallbackMutex.lock();
|————Node:call_expression Text: rxCallbackMutex.lock()
|—————Node:field_expression Text: rxCallbackMutex.lock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nullptr != callback)
	{
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != callback)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != callback
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: callback
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);

		if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::vector<RawCanMessageCallbackInfo>::iterator callbackLocation;
|——————Node:qualified_identifier Text: std::vector<RawCanMessageCallbackInfo>::iterator
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:qualified_identifier Text: vector<RawCanMessageCallbackInfo>::iterator
|————————Node:template_type Text: vector<RawCanMessageCallbackInfo>
|—————————Node:type_identifier Text: vector
|—————————Node:template_argument_list Text: <RawCanMessageCallbackInfo>
|——————————Node:< Text: <
|——————————Node:type_descriptor Text: RawCanMessageCallbackInfo
|———————————Node:type_identifier Text: RawCanMessageCallbackInfo
|——————————Node:> Text: >
|————————Node::: Text: ::
|————————Node:type_identifier Text: iterator
|——————Node:identifier Text: callbackLocation
|——————Node:; Text: ;
|—————Node:expression_statement Text: callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo);
|——————Node:assignment_expression Text: callbackLocation = std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|———————Node:identifier Text: callbackLocation
|———————Node:= Text: =
|———————Node:call_expression Text: std::find(rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|————————Node:qualified_identifier Text: std::find
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:identifier Text: find
|————————Node:argument_list Text: (rxCallbacks.begin(), rxCallbacks.end(), callbackInfo)
|—————————Node:( Text: (
|—————————Node:call_expression Text: rxCallbacks.begin()
|——————————Node:field_expression Text: rxCallbacks.begin
|———————————Node:identifier Text: rxCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: begin
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: rxCallbacks.end()
|——————————Node:field_expression Text: rxCallbacks.end
|———————————Node:identifier Text: rxCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: end
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: callbackInfo
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (rxCallbacks.end() != callbackLocation)
		{
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (rxCallbacks.end() != callbackLocation)
|———————Node:( Text: (
|———————Node:binary_expression Text: rxCallbacks.end() != callbackLocation
|————————Node:call_expression Text: rxCallbacks.end()
|—————————Node:field_expression Text: rxCallbacks.end
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: callbackLocation
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			rxCallbacks.erase(callbackLocation);
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: rxCallbacks.erase(callbackLocation);
|————————Node:call_expression Text: rxCallbacks.erase(callbackLocation)
|—————————Node:field_expression Text: rxCallbacks.erase
|——————————Node:identifier Text: rxCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: erase
|—————————Node:argument_list Text: (callbackLocation)
|——————————Node:( Text: (
|——————————Node:identifier Text: callbackLocation
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: rxCallbackMutex.unlock();
|————Node:call_expression Text: rxCallbackMutex.unlock()
|—————Node:field_expression Text: rxCallbackMutex.unlock
|——————Node:identifier Text: rxCallbackMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::set_can_driver_update_period(std::uint32_t value)
{
	canLibUpdatePeriod = value;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::set_can_driver_update_period(std::uint32_t value)
|———Node:qualified_identifier Text: CANHardwareInterface::set_can_driver_update_period
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: set_can_driver_update_period
|———Node:parameter_list Text: (std::uint32_t value)
|————Node:( Text: (
|————Node:parameter_declaration Text: std::uint32_t value
|—————Node:qualified_identifier Text: std::uint32_t
|——————Node:namespace_identifier Text: std
|——————Node::: Text: ::
|——————Node:type_identifier Text: uint32_t
|—————Node:identifier Text: value
|————Node:) Text: )
|——Node:compound_statement Text: {
	canLibUpdatePeriod = value;
}
|———Node:{ Text: {
|———Node:expression_statement Text: canLibUpdatePeriod = value;
|————Node:assignment_expression Text: canLibUpdatePeriod = value
|—————Node:identifier Text: canLibUpdatePeriod
|—————Node:= Text: =
|—————Node:identifier Text: value
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::add_can_lib_update_callback(void (*callback)(), void *parentPointer)
{
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::add_can_lib_update_callback(void (*callback)(), void *parentPointer)
|———Node:qualified_identifier Text: CANHardwareInterface::add_can_lib_update_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: add_can_lib_update_callback
|———Node:parameter_list Text: (void (*callback)(), void *parentPointer)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)()
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)()
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parentPointer
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parentPointer
|——————Node:* Text: *
|——————Node:identifier Text: parentPointer
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: CanLibUpdateCallbackInfo callbackInfo;
|————Node:type_identifier Text: CanLibUpdateCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parentPointer;
|————Node:assignment_expression Text: callbackInfo.parent = parentPointer
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parentPointer
|————Node:; Text: ;
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
	{
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)))
|—————Node:( Text: (
|—————Node:binary_expression Text: (nullptr != callback) && (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo))
|——————Node:parenthesized_expression Text: (nullptr != callback)
|———————Node:( Text: (
|———————Node:binary_expression Text: nullptr != callback
|————————Node:null Text: nullptr
|—————————Node:nullptr Text: nullptr
|————————Node:!= Text: !=
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo))
|———————Node:( Text: (
|———————Node:binary_expression Text: canLibUpdateCallbacks.end() == find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|————————Node:call_expression Text: canLibUpdateCallbacks.end()
|—————————Node:field_expression Text: canLibUpdateCallbacks.end
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:call_expression Text: find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|—————————Node:identifier Text: find
|—————————Node:argument_list Text: (canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|——————————Node:( Text: (
|——————————Node:call_expression Text: canLibUpdateCallbacks.begin()
|———————————Node:field_expression Text: canLibUpdateCallbacks.begin
|————————————Node:identifier Text: canLibUpdateCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: begin
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:call_expression Text: canLibUpdateCallbacks.end()
|———————————Node:field_expression Text: canLibUpdateCallbacks.end
|————————————Node:identifier Text: canLibUpdateCallbacks
|————————————Node:. Text: .
|————————————Node:field_identifier Text: end
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:identifier Text: callbackInfo
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		canLibUpdateCallbacks.push_back(callbackInfo);
		retVal = true;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: canLibUpdateCallbacks.push_back(callbackInfo);
|——————Node:call_expression Text: canLibUpdateCallbacks.push_back(callbackInfo)
|———————Node:field_expression Text: canLibUpdateCallbacks.push_back
|————————Node:identifier Text: canLibUpdateCallbacks
|————————Node:. Text: .
|————————Node:field_identifier Text: push_back
|———————Node:argument_list Text: (callbackInfo)
|————————Node:( Text: (
|————————Node:identifier Text: callbackInfo
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: retVal = true;
|——————Node:assignment_expression Text: retVal = true
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::remove_can_lib_update_callback(void (*callback)(), void *parentPointer)
{
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::remove_can_lib_update_callback(void (*callback)(), void *parentPointer)
|———Node:qualified_identifier Text: CANHardwareInterface::remove_can_lib_update_callback
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: remove_can_lib_update_callback
|———Node:parameter_list Text: (void (*callback)(), void *parentPointer)
|————Node:( Text: (
|————Node:parameter_declaration Text: void (*callback)()
|—————Node:primitive_type Text: void
|—————Node:function_declarator Text: (*callback)()
|——————Node:parenthesized_declarator Text: (*callback)
|———————Node:( Text: (
|———————Node:pointer_declarator Text: *callback
|————————Node:* Text: *
|————————Node:identifier Text: callback
|———————Node:) Text: )
|——————Node:parameter_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:, Text: ,
|————Node:parameter_declaration Text: void *parentPointer
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: *parentPointer
|——————Node:* Text: *
|——————Node:identifier Text: parentPointer
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	CanLibUpdateCallbackInfo callbackInfo;

	callbackInfo.callback = callback;
	callbackInfo.parent = parentPointer;

	canLibUpdateCallbacksMutex.lock();

	if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}

	canLibUpdateCallbacksMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: CanLibUpdateCallbackInfo callbackInfo;
|————Node:type_identifier Text: CanLibUpdateCallbackInfo
|————Node:identifier Text: callbackInfo
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.callback = callback;
|————Node:assignment_expression Text: callbackInfo.callback = callback
|—————Node:field_expression Text: callbackInfo.callback
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: callback
|—————Node:= Text: =
|—————Node:identifier Text: callback
|————Node:; Text: ;
|———Node:expression_statement Text: callbackInfo.parent = parentPointer;
|————Node:assignment_expression Text: callbackInfo.parent = parentPointer
|—————Node:field_expression Text: callbackInfo.parent
|——————Node:identifier Text: callbackInfo
|——————Node:. Text: .
|——————Node:field_identifier Text: parent
|—————Node:= Text: =
|—————Node:identifier Text: parentPointer
|————Node:; Text: ;
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (nullptr != callback)
	{
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (nullptr != callback)
|—————Node:( Text: (
|—————Node:binary_expression Text: nullptr != callback
|——————Node:null Text: nullptr
|———————Node:nullptr Text: nullptr
|——————Node:!= Text: !=
|——————Node:identifier Text: callback
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
		callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);

		if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::vector<CanLibUpdateCallbackInfo>::iterator callbackLocation;
|——————Node:qualified_identifier Text: std::vector<CanLibUpdateCallbackInfo>::iterator
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:qualified_identifier Text: vector<CanLibUpdateCallbackInfo>::iterator
|————————Node:template_type Text: vector<CanLibUpdateCallbackInfo>
|—————————Node:type_identifier Text: vector
|—————————Node:template_argument_list Text: <CanLibUpdateCallbackInfo>
|——————————Node:< Text: <
|——————————Node:type_descriptor Text: CanLibUpdateCallbackInfo
|———————————Node:type_identifier Text: CanLibUpdateCallbackInfo
|——————————Node:> Text: >
|————————Node::: Text: ::
|————————Node:type_identifier Text: iterator
|——————Node:identifier Text: callbackLocation
|——————Node:; Text: ;
|—————Node:expression_statement Text: callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo);
|——————Node:assignment_expression Text: callbackLocation = std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|———————Node:identifier Text: callbackLocation
|———————Node:= Text: =
|———————Node:call_expression Text: std::find(canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|————————Node:qualified_identifier Text: std::find
|—————————Node:namespace_identifier Text: std
|—————————Node::: Text: ::
|—————————Node:identifier Text: find
|————————Node:argument_list Text: (canLibUpdateCallbacks.begin(), canLibUpdateCallbacks.end(), callbackInfo)
|—————————Node:( Text: (
|—————————Node:call_expression Text: canLibUpdateCallbacks.begin()
|——————————Node:field_expression Text: canLibUpdateCallbacks.begin
|———————————Node:identifier Text: canLibUpdateCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: begin
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:call_expression Text: canLibUpdateCallbacks.end()
|——————————Node:field_expression Text: canLibUpdateCallbacks.end
|———————————Node:identifier Text: canLibUpdateCallbacks
|———————————Node:. Text: .
|———————————Node:field_identifier Text: end
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:, Text: ,
|—————————Node:identifier Text: callbackInfo
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (canLibUpdateCallbacks.end() != callbackLocation)
		{
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (canLibUpdateCallbacks.end() != callbackLocation)
|———————Node:( Text: (
|———————Node:binary_expression Text: canLibUpdateCallbacks.end() != callbackLocation
|————————Node:call_expression Text: canLibUpdateCallbacks.end()
|—————————Node:field_expression Text: canLibUpdateCallbacks.end
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: end
|—————————Node:argument_list Text: ()
|——————————Node:( Text: (
|——————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: callbackLocation
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			canLibUpdateCallbacks.erase(callbackLocation);
			retVal = true;
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: canLibUpdateCallbacks.erase(callbackLocation);
|————————Node:call_expression Text: canLibUpdateCallbacks.erase(callbackLocation)
|—————————Node:field_expression Text: canLibUpdateCallbacks.erase
|——————————Node:identifier Text: canLibUpdateCallbacks
|——————————Node:. Text: .
|——————————Node:field_identifier Text: erase
|—————————Node:argument_list Text: (callbackLocation)
|——————————Node:( Text: (
|——————————Node:identifier Text: callbackLocation
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: retVal = true;
|————————Node:assignment_expression Text: retVal = true
|—————————Node:identifier Text: retVal
|—————————Node:= Text: =
|—————————Node:true Text: true
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|—————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|——————Node:identifier Text: canLibUpdateCallbacksMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::can_thread_function()
{
	hardwareChannelsMutex.lock();
	// Wait until everything is running
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		threadConditionVariable.wait(lMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::can_thread_function()
|———Node:qualified_identifier Text: CANHardwareInterface::can_thread_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: can_thread_function
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	hardwareChannelsMutex.lock();
	// Wait until everything is running
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		threadConditionVariable.wait(lMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
	}
}
|———Node:{ Text: {
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Wait until everything is running
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:while_statement Text: while (threadsStarted)
	{
		std::unique_lock<std::mutex> lMutex(threadMutex);
		threadConditionVariable.wait(lMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
	}
|————Node:while Text: while
|————Node:condition_clause Text: (threadsStarted)
|—————Node:( Text: (
|—————Node:identifier Text: threadsStarted
|—————Node:) Text: )
|————Node:compound_statement Text: {
		std::unique_lock<std::mutex> lMutex(threadMutex);
		threadConditionVariable.wait(lMutex);
		CanHardware *pCANHardware;

		if (threadsStarted)
		{
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
	}
|—————Node:{ Text: {
|—————Node:declaration Text: std::unique_lock<std::mutex> lMutex(threadMutex);
|——————Node:qualified_identifier Text: std::unique_lock<std::mutex>
|———————Node:namespace_identifier Text: std
|———————Node::: Text: ::
|———————Node:template_type Text: unique_lock<std::mutex>
|————————Node:type_identifier Text: unique_lock
|————————Node:template_argument_list Text: <std::mutex>
|—————————Node:< Text: <
|—————————Node:type_descriptor Text: std::mutex
|——————————Node:qualified_identifier Text: std::mutex
|———————————Node:namespace_identifier Text: std
|———————————Node::: Text: ::
|———————————Node:type_identifier Text: mutex
|—————————Node:> Text: >
|——————Node:function_declarator Text: lMutex(threadMutex)
|———————Node:identifier Text: lMutex
|———————Node:parameter_list Text: (threadMutex)
|————————Node:( Text: (
|————————Node:parameter_declaration Text: threadMutex
|—————————Node:type_identifier Text: threadMutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: threadConditionVariable.wait(lMutex);
|——————Node:call_expression Text: threadConditionVariable.wait(lMutex)
|———————Node:field_expression Text: threadConditionVariable.wait
|————————Node:identifier Text: threadConditionVariable
|————————Node:. Text: .
|————————Node:field_identifier Text: wait
|———————Node:argument_list Text: (lMutex)
|————————Node:( Text: (
|————————Node:identifier Text: lMutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: CanHardware *pCANHardware;
|——————Node:type_identifier Text: CanHardware
|——————Node:pointer_declarator Text: *pCANHardware
|———————Node:* Text: *
|———————Node:identifier Text: pCANHardware
|——————Node:; Text: ;
|—————Node:if_statement Text: if (threadsStarted)
		{
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (threadsStarted)
|———————Node:( Text: (
|———————Node:identifier Text: threadsStarted
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}

			if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}

			for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
		}
|———————Node:{ Text: {
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels[i];

				if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels[i];
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels[i]
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:subscript_expression Text: hardwareChannels[i]
|————————————Node:identifier Text: hardwareChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (nullptr != pCANHardware)
				{
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != pCANHardware)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != pCANHardware
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:identifier Text: pCANHardware
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					pCANHardware->receivedMessagesMutex.lock();
					bool processNextMessage = (!pCANHardware->receivedMessages.empty());
					pCANHardware->receivedMessagesMutex.unlock();

					while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:declaration Text: bool processNextMessage = (!pCANHardware->receivedMessages.empty());
|————————————Node:primitive_type Text: bool
|————————————Node:init_declarator Text: processNextMessage = (!pCANHardware->receivedMessages.empty())
|—————————————Node:identifier Text: processNextMessage
|—————————————Node:= Text: =
|—————————————Node:parenthesized_expression Text: (!pCANHardware->receivedMessages.empty())
|——————————————Node:( Text: (
|——————————————Node:unary_expression Text: !pCANHardware->receivedMessages.empty()
|———————————————Node:! Text: !
|———————————————Node:call_expression Text: pCANHardware->receivedMessages.empty()
|————————————————Node:field_expression Text: pCANHardware->receivedMessages.empty
|—————————————————Node:field_expression Text: pCANHardware->receivedMessages
|——————————————————Node:identifier Text: pCANHardware
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: receivedMessages
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: empty
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:while_statement Text: while (processNextMessage)
					{
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
|————————————Node:while Text: while
|————————————Node:condition_clause Text: (processNextMessage)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: processNextMessage
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						isobus::HardwareInterfaceCANFrame tempCanFrame;

						pCANHardware->receivedMessagesMutex.lock();
						tempCanFrame = pCANHardware->receivedMessages.front();
						pCANHardware->receivedMessages.pop_front();
						processNextMessage = (!pCANHardware->receivedMessages.empty());
						pCANHardware->receivedMessagesMutex.unlock();

						rxCallbackMutex.lock();
						for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
						rxCallbackMutex.unlock();
					}
|—————————————Node:{ Text: {
|—————————————Node:declaration Text: isobus::HardwareInterfaceCANFrame tempCanFrame;
|——————————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|———————————————Node:namespace_identifier Text: isobus
|———————————————Node::: Text: ::
|———————————————Node:type_identifier Text: HardwareInterfaceCANFrame
|——————————————Node:identifier Text: tempCanFrame
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|——————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|———————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|————————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|—————————————————Node:identifier Text: pCANHardware
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: receivedMessagesMutex
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: lock
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: tempCanFrame = pCANHardware->receivedMessages.front();
|——————————————Node:assignment_expression Text: tempCanFrame = pCANHardware->receivedMessages.front()
|———————————————Node:identifier Text: tempCanFrame
|———————————————Node:= Text: =
|———————————————Node:call_expression Text: pCANHardware->receivedMessages.front()
|————————————————Node:field_expression Text: pCANHardware->receivedMessages.front
|—————————————————Node:field_expression Text: pCANHardware->receivedMessages
|——————————————————Node:identifier Text: pCANHardware
|——————————————————Node:-> Text: ->
|——————————————————Node:field_identifier Text: receivedMessages
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: front
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: pCANHardware->receivedMessages.pop_front();
|——————————————Node:call_expression Text: pCANHardware->receivedMessages.pop_front()
|———————————————Node:field_expression Text: pCANHardware->receivedMessages.pop_front
|————————————————Node:field_expression Text: pCANHardware->receivedMessages
|—————————————————Node:identifier Text: pCANHardware
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: receivedMessages
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: pop_front
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: processNextMessage = (!pCANHardware->receivedMessages.empty());
|——————————————Node:assignment_expression Text: processNextMessage = (!pCANHardware->receivedMessages.empty())
|———————————————Node:identifier Text: processNextMessage
|———————————————Node:= Text: =
|———————————————Node:parenthesized_expression Text: (!pCANHardware->receivedMessages.empty())
|————————————————Node:( Text: (
|————————————————Node:unary_expression Text: !pCANHardware->receivedMessages.empty()
|—————————————————Node:! Text: !
|—————————————————Node:call_expression Text: pCANHardware->receivedMessages.empty()
|——————————————————Node:field_expression Text: pCANHardware->receivedMessages.empty
|———————————————————Node:field_expression Text: pCANHardware->receivedMessages
|————————————————————Node:identifier Text: pCANHardware
|————————————————————Node:-> Text: ->
|————————————————————Node:field_identifier Text: receivedMessages
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: empty
|——————————————————Node:argument_list Text: ()
|———————————————————Node:( Text: (
|———————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|——————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|———————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|————————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|—————————————————Node:identifier Text: pCANHardware
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: receivedMessagesMutex
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: unlock
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:expression_statement Text: rxCallbackMutex.lock();
|——————————————Node:call_expression Text: rxCallbackMutex.lock()
|———————————————Node:field_expression Text: rxCallbackMutex.lock
|————————————————Node:identifier Text: rxCallbackMutex
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: lock
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:for_statement Text: for (std::uint32_t j = 0; j < rxCallbacks.size(); j++)
						{
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
|——————————————Node:for Text: for
|——————————————Node:( Text: (
|——————————————Node:declaration Text: std::uint32_t j = 0;
|———————————————Node:qualified_identifier Text: std::uint32_t
|————————————————Node:namespace_identifier Text: std
|————————————————Node::: Text: ::
|————————————————Node:type_identifier Text: uint32_t
|———————————————Node:init_declarator Text: j = 0
|————————————————Node:identifier Text: j
|————————————————Node:= Text: =
|————————————————Node:number_literal Text: 0
|———————————————Node:; Text: ;
|——————————————Node:binary_expression Text: j < rxCallbacks.size()
|———————————————Node:identifier Text: j
|———————————————Node:< Text: <
|———————————————Node:call_expression Text: rxCallbacks.size()
|————————————————Node:field_expression Text: rxCallbacks.size
|—————————————————Node:identifier Text: rxCallbacks
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: size
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|——————————————Node:; Text: ;
|——————————————Node:update_expression Text: j++
|———————————————Node:identifier Text: j
|———————————————Node:++ Text: ++
|——————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
							if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
						}
|———————————————Node:{ Text: {
|———————————————Node:if_statement Text: if (nullptr != rxCallbacks[j].callback)
							{
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (nullptr != rxCallbacks[j].callback)
|—————————————————Node:( Text: (
|—————————————————Node:binary_expression Text: nullptr != rxCallbacks[j].callback
|——————————————————Node:null Text: nullptr
|———————————————————Node:nullptr Text: nullptr
|——————————————————Node:!= Text: !=
|——————————————————Node:field_expression Text: rxCallbacks[j].callback
|———————————————————Node:subscript_expression Text: rxCallbacks[j]
|————————————————————Node:identifier Text: rxCallbacks
|————————————————————Node:subscript_argument_list Text: [j]
|—————————————————————Node:[ Text: [
|—————————————————————Node:identifier Text: j
|—————————————————————Node:] Text: ]
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: callback
|—————————————————Node:) Text: )
|————————————————Node:compound_statement Text: {
								rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
							}
|—————————————————Node:{ Text: {
|—————————————————Node:expression_statement Text: rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent);
|——————————————————Node:call_expression Text: rxCallbacks[j].callback(tempCanFrame, rxCallbacks[j].parent)
|———————————————————Node:field_expression Text: rxCallbacks[j].callback
|————————————————————Node:subscript_expression Text: rxCallbacks[j]
|—————————————————————Node:identifier Text: rxCallbacks
|—————————————————————Node:subscript_argument_list Text: [j]
|——————————————————————Node:[ Text: [
|——————————————————————Node:identifier Text: j
|——————————————————————Node:] Text: ]
|————————————————————Node:. Text: .
|————————————————————Node:field_identifier Text: callback
|———————————————————Node:argument_list Text: (tempCanFrame, rxCallbacks[j].parent)
|————————————————————Node:( Text: (
|————————————————————Node:identifier Text: tempCanFrame
|————————————————————Node:, Text: ,
|————————————————————Node:field_expression Text: rxCallbacks[j].parent
|—————————————————————Node:subscript_expression Text: rxCallbacks[j]
|——————————————————————Node:identifier Text: rxCallbacks
|——————————————————————Node:subscript_argument_list Text: [j]
|———————————————————————Node:[ Text: [
|———————————————————————Node:identifier Text: j
|———————————————————————Node:] Text: ]
|—————————————————————Node:. Text: .
|—————————————————————Node:field_identifier Text: parent
|————————————————————Node:) Text: )
|——————————————————Node:; Text: ;
|—————————————————Node:} Text: }
|———————————————Node:} Text: }
|—————————————Node:expression_statement Text: rxCallbackMutex.unlock();
|——————————————Node:call_expression Text: rxCallbackMutex.unlock()
|———————————————Node:field_expression Text: rxCallbackMutex.unlock
|————————————————Node:identifier Text: rxCallbackMutex
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: unlock
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:if_statement Text: if (get_clear_can_lib_needs_update())
			{
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (get_clear_can_lib_needs_update())
|—————————Node:( Text: (
|—————————Node:call_expression Text: get_clear_can_lib_needs_update()
|——————————Node:identifier Text: get_clear_can_lib_needs_update
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				canLibUpdateCallbacksMutex.lock();
				for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
				canLibUpdateCallbacksMutex.unlock();
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: canLibUpdateCallbacksMutex.lock();
|——————————Node:call_expression Text: canLibUpdateCallbacksMutex.lock()
|———————————Node:field_expression Text: canLibUpdateCallbacksMutex.lock
|————————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: lock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:for_statement Text: for (std::uint32_t j = 0; j < canLibUpdateCallbacks.size(); j++)
				{
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:declaration Text: std::uint32_t j = 0;
|———————————Node:qualified_identifier Text: std::uint32_t
|————————————Node:namespace_identifier Text: std
|————————————Node::: Text: ::
|————————————Node:type_identifier Text: uint32_t
|———————————Node:init_declarator Text: j = 0
|————————————Node:identifier Text: j
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:binary_expression Text: j < canLibUpdateCallbacks.size()
|———————————Node:identifier Text: j
|———————————Node:< Text: <
|———————————Node:call_expression Text: canLibUpdateCallbacks.size()
|————————————Node:field_expression Text: canLibUpdateCallbacks.size
|—————————————Node:identifier Text: canLibUpdateCallbacks
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: size
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|——————————Node:update_expression Text: j++
|———————————Node:identifier Text: j
|———————————Node:++ Text: ++
|——————————Node:) Text: )
|——————————Node:compound_statement Text: {
					if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
				}
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (nullptr != canLibUpdateCallbacks[j].callback)
					{
						canLibUpdateCallbacks[j].callback();
					}
|————————————Node:if Text: if
|————————————Node:condition_clause Text: (nullptr != canLibUpdateCallbacks[j].callback)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: nullptr != canLibUpdateCallbacks[j].callback
|——————————————Node:null Text: nullptr
|———————————————Node:nullptr Text: nullptr
|——————————————Node:!= Text: !=
|——————————————Node:field_expression Text: canLibUpdateCallbacks[j].callback
|———————————————Node:subscript_expression Text: canLibUpdateCallbacks[j]
|————————————————Node:identifier Text: canLibUpdateCallbacks
|————————————————Node:subscript_argument_list Text: [j]
|—————————————————Node:[ Text: [
|—————————————————Node:identifier Text: j
|—————————————————Node:] Text: ]
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: callback
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						canLibUpdateCallbacks[j].callback();
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: canLibUpdateCallbacks[j].callback();
|——————————————Node:call_expression Text: canLibUpdateCallbacks[j].callback()
|———————————————Node:field_expression Text: canLibUpdateCallbacks[j].callback
|————————————————Node:subscript_expression Text: canLibUpdateCallbacks[j]
|—————————————————Node:identifier Text: canLibUpdateCallbacks
|—————————————————Node:subscript_argument_list Text: [j]
|——————————————————Node:[ Text: [
|——————————————————Node:identifier Text: j
|——————————————————Node:] Text: ]
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: callback
|———————————————Node:argument_list Text: ()
|————————————————Node:( Text: (
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:expression_statement Text: canLibUpdateCallbacksMutex.unlock();
|——————————Node:call_expression Text: canLibUpdateCallbacksMutex.unlock()
|———————————Node:field_expression Text: canLibUpdateCallbacksMutex.unlock
|————————————Node:identifier Text: canLibUpdateCallbacksMutex
|————————————Node:. Text: .
|————————————Node:field_identifier Text: unlock
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:for_statement Text: for (std::uint32_t i = 0; i < hardwareChannels.size(); i++)
			{
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
|————————Node:for Text: for
|————————Node:( Text: (
|————————Node:declaration Text: std::uint32_t i = 0;
|—————————Node:qualified_identifier Text: std::uint32_t
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:type_identifier Text: uint32_t
|—————————Node:init_declarator Text: i = 0
|——————————Node:identifier Text: i
|——————————Node:= Text: =
|——————————Node:number_literal Text: 0
|—————————Node:; Text: ;
|————————Node:binary_expression Text: i < hardwareChannels.size()
|—————————Node:identifier Text: i
|—————————Node:< Text: <
|—————————Node:call_expression Text: hardwareChannels.size()
|——————————Node:field_expression Text: hardwareChannels.size
|———————————Node:identifier Text: hardwareChannels
|———————————Node:. Text: .
|———————————Node:field_identifier Text: size
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|————————Node:; Text: ;
|————————Node:update_expression Text: i++
|—————————Node:identifier Text: i
|—————————Node:++ Text: ++
|————————Node:) Text: )
|————————Node:compound_statement Text: {
				pCANHardware = hardwareChannels[i];
				if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pCANHardware = hardwareChannels[i];
|——————————Node:assignment_expression Text: pCANHardware = hardwareChannels[i]
|———————————Node:identifier Text: pCANHardware
|———————————Node:= Text: =
|———————————Node:subscript_expression Text: hardwareChannels[i]
|————————————Node:identifier Text: hardwareChannels
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (nullptr != pCANHardware)
				{
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (nullptr != pCANHardware)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: nullptr != pCANHardware
|————————————Node:null Text: nullptr
|—————————————Node:nullptr Text: nullptr
|————————————Node:!= Text: !=
|————————————Node:identifier Text: pCANHardware
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					pCANHardware->messagesToBeTransmittedMutex.lock();
					isobus::HardwareInterfaceCANFrame packet;
					bool sendPacket = false;

					for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
					pCANHardware->messagesToBeTransmittedMutex.unlock();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: pCANHardware->messagesToBeTransmittedMutex.lock();
|————————————Node:call_expression Text: pCANHardware->messagesToBeTransmittedMutex.lock()
|—————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex.lock
|——————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:declaration Text: isobus::HardwareInterfaceCANFrame packet;
|————————————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————————————Node:namespace_identifier Text: isobus
|—————————————Node::: Text: ::
|—————————————Node:type_identifier Text: HardwareInterfaceCANFrame
|————————————Node:identifier Text: packet
|————————————Node:; Text: ;
|———————————Node:declaration Text: bool sendPacket = false;
|————————————Node:primitive_type Text: bool
|————————————Node:init_declarator Text: sendPacket = false
|—————————————Node:identifier Text: sendPacket
|—————————————Node:= Text: =
|—————————————Node:false Text: false
|————————————Node:; Text: ;
|———————————Node:for_statement Text: for (std::uint32_t j = 0; j < pCANHardware->messagesToBeTransmitted.size(); j++)
					{
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
|————————————Node:for Text: for
|————————————Node:( Text: (
|————————————Node:declaration Text: std::uint32_t j = 0;
|—————————————Node:qualified_identifier Text: std::uint32_t
|——————————————Node:namespace_identifier Text: std
|——————————————Node::: Text: ::
|——————————————Node:type_identifier Text: uint32_t
|—————————————Node:init_declarator Text: j = 0
|——————————————Node:identifier Text: j
|——————————————Node:= Text: =
|——————————————Node:number_literal Text: 0
|—————————————Node:; Text: ;
|————————————Node:binary_expression Text: j < pCANHardware->messagesToBeTransmitted.size()
|—————————————Node:identifier Text: j
|—————————————Node:< Text: <
|—————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.size()
|——————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.size
|———————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|————————————————Node:identifier Text: pCANHardware
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: messagesToBeTransmitted
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: size
|——————————————Node:argument_list Text: ()
|———————————————Node:( Text: (
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|————————————Node:update_expression Text: j++
|—————————————Node:identifier Text: j
|—————————————Node:++ Text: ++
|————————————Node:) Text: )
|————————————Node:compound_statement Text: {
						sendPacket = false;

						if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}

						if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
					}
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: sendPacket = false;
|——————————————Node:assignment_expression Text: sendPacket = false
|———————————————Node:identifier Text: sendPacket
|———————————————Node:= Text: =
|———————————————Node:false Text: false
|——————————————Node:; Text: ;
|—————————————Node:if_statement Text: if (0 != pCANHardware->messagesToBeTransmitted.size())
						{
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (0 != pCANHardware->messagesToBeTransmitted.size())
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: 0 != pCANHardware->messagesToBeTransmitted.size()
|————————————————Node:number_literal Text: 0
|————————————————Node:!= Text: !=
|————————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.size()
|—————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.size
|——————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|———————————————————Node:identifier Text: pCANHardware
|———————————————————Node:-> Text: ->
|———————————————————Node:field_identifier Text: messagesToBeTransmitted
|——————————————————Node:. Text: .
|——————————————————Node:field_identifier Text: size
|—————————————————Node:argument_list Text: ()
|——————————————————Node:( Text: (
|——————————————————Node:) Text: )
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
							packet = pCANHardware->messagesToBeTransmitted.front();
							sendPacket = true;
						}
|———————————————Node:{ Text: {
|———————————————Node:expression_statement Text: packet = pCANHardware->messagesToBeTransmitted.front();
|————————————————Node:assignment_expression Text: packet = pCANHardware->messagesToBeTransmitted.front()
|—————————————————Node:identifier Text: packet
|—————————————————Node:= Text: =
|—————————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.front()
|——————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.front
|———————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|————————————————————Node:identifier Text: pCANHardware
|————————————————————Node:-> Text: ->
|————————————————————Node:field_identifier Text: messagesToBeTransmitted
|———————————————————Node:. Text: .
|———————————————————Node:field_identifier Text: front
|——————————————————Node:argument_list Text: ()
|———————————————————Node:( Text: (
|———————————————————Node:) Text: )
|————————————————Node:; Text: ;
|———————————————Node:expression_statement Text: sendPacket = true;
|————————————————Node:assignment_expression Text: sendPacket = true
|—————————————————Node:identifier Text: sendPacket
|—————————————————Node:= Text: =
|—————————————————Node:true Text: true
|————————————————Node:; Text: ;
|———————————————Node:} Text: }
|—————————————Node:if_statement Text: if (sendPacket)
						{
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
|——————————————Node:if Text: if
|——————————————Node:condition_clause Text: (sendPacket)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: sendPacket
|———————————————Node:) Text: )
|——————————————Node:compound_statement Text: {
							if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
							// Todo, notify CAN lib that we sent, or did not send, each packet
						}
|———————————————Node:{ Text: {
|———————————————Node:if_statement Text: if (transmit_can_message_from_buffer(packet))
							{
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
							else
							{
								break;
							}
|————————————————Node:if Text: if
|————————————————Node:condition_clause Text: (transmit_can_message_from_buffer(packet))
|—————————————————Node:( Text: (
|—————————————————Node:call_expression Text: transmit_can_message_from_buffer(packet)
|——————————————————Node:identifier Text: transmit_can_message_from_buffer
|——————————————————Node:argument_list Text: (packet)
|———————————————————Node:( Text: (
|———————————————————Node:identifier Text: packet
|———————————————————Node:) Text: )
|—————————————————Node:) Text: )
|————————————————Node:compound_statement Text: {
								pCANHardware->messagesToBeTransmitted.pop_front();
							}
|—————————————————Node:{ Text: {
|—————————————————Node:expression_statement Text: pCANHardware->messagesToBeTransmitted.pop_front();
|——————————————————Node:call_expression Text: pCANHardware->messagesToBeTransmitted.pop_front()
|———————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted.pop_front
|————————————————————Node:field_expression Text: pCANHardware->messagesToBeTransmitted
|—————————————————————Node:identifier Text: pCANHardware
|—————————————————————Node:-> Text: ->
|—————————————————————Node:field_identifier Text: messagesToBeTransmitted
|————————————————————Node:. Text: .
|————————————————————Node:field_identifier Text: pop_front
|———————————————————Node:argument_list Text: ()
|————————————————————Node:( Text: (
|————————————————————Node:) Text: )
|——————————————————Node:; Text: ;
|—————————————————Node:} Text: }
|————————————————Node:else_clause Text: else
							{
								break;
							}
|—————————————————Node:else Text: else
|—————————————————Node:compound_statement Text: {
								break;
							}
|——————————————————Node:{ Text: {
|——————————————————Node:break_statement Text: break;
|———————————————————Node:break Text: break
|———————————————————Node:; Text: ;
|——————————————————Node:} Text: }
|———————————————Node:comment Text: // Todo, notify CAN lib that we sent, or did not send, each packet
|———————————————Node:} Text: }
|—————————————Node:} Text: }
|———————————Node:expression_statement Text: pCANHardware->messagesToBeTransmittedMutex.unlock();
|————————————Node:call_expression Text: pCANHardware->messagesToBeTransmittedMutex.unlock()
|—————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex.unlock
|——————————————Node:field_expression Text: pCANHardware->messagesToBeTransmittedMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: messagesToBeTransmittedMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::receive_message_thread_function(uint8_t aCANChannel)
{
	CanHardware *pCANHardware;
	isobus::HardwareInterfaceCANFrame tempCanFrame;

	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::receive_message_thread_function(uint8_t aCANChannel)
|———Node:qualified_identifier Text: CANHardwareInterface::receive_message_thread_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: receive_message_thread_function
|———Node:parameter_list Text: (uint8_t aCANChannel)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t aCANChannel
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: aCANChannel
|————Node:) Text: )
|——Node:compound_statement Text: {
	CanHardware *pCANHardware;
	isobus::HardwareInterfaceCANFrame tempCanFrame;

	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
	}
}
|———Node:{ Text: {
|———Node:declaration Text: CanHardware *pCANHardware;
|————Node:type_identifier Text: CanHardware
|————Node:pointer_declarator Text: *pCANHardware
|—————Node:* Text: *
|—————Node:identifier Text: pCANHardware
|————Node:; Text: ;
|———Node:declaration Text: isobus::HardwareInterfaceCANFrame tempCanFrame;
|————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|—————Node:namespace_identifier Text: isobus
|—————Node::: Text: ::
|—————Node:type_identifier Text: HardwareInterfaceCANFrame
|————Node:identifier Text: tempCanFrame
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (aCANChannel < hardwareChannels.size())
	{
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (aCANChannel < hardwareChannels.size())
|—————Node:( Text: (
|—————Node:binary_expression Text: aCANChannel < hardwareChannels.size()
|——————Node:identifier Text: aCANChannel
|——————Node:< Text: <
|——————Node:call_expression Text: hardwareChannels.size()
|———————Node:field_expression Text: hardwareChannels.size
|————————Node:identifier Text: hardwareChannels
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		pCANHardware = hardwareChannels[aCANChannel];

		while ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: pCANHardware = hardwareChannels[aCANChannel];
|——————Node:assignment_expression Text: pCANHardware = hardwareChannels[aCANChannel]
|———————Node:identifier Text: pCANHardware
|———————Node:= Text: =
|———————Node:subscript_expression Text: hardwareChannels[aCANChannel]
|————————Node:identifier Text: hardwareChannels
|————————Node:subscript_argument_list Text: [aCANChannel]
|—————————Node:[ Text: [
|—————————Node:identifier Text: aCANChannel
|—————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:while_statement Text: while ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
		{
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
|——————Node:while Text: while
|——————Node:condition_clause Text: ((threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler))
|———————Node:( Text: (
|———————Node:binary_expression Text: (threadsStarted) &&
		       (nullptr != pCANHardware) &&
		       (nullptr != pCANHardware->frameHandler)
|————————Node:binary_expression Text: (threadsStarted) &&
		       (nullptr != pCANHardware)
|—————————Node:parenthesized_expression Text: (threadsStarted)
|——————————Node:( Text: (
|——————————Node:identifier Text: threadsStarted
|——————————Node:) Text: )
|—————————Node:&& Text: &&
|—————————Node:parenthesized_expression Text: (nullptr != pCANHardware)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: nullptr != pCANHardware
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|———————————Node:!= Text: !=
|———————————Node:identifier Text: pCANHardware
|——————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (nullptr != pCANHardware->frameHandler)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: nullptr != pCANHardware->frameHandler
|——————————Node:null Text: nullptr
|———————————Node:nullptr Text: nullptr
|——————————Node:!= Text: !=
|——————————Node:field_expression Text: pCANHardware->frameHandler
|———————————Node:identifier Text: pCANHardware
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: frameHandler
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if (pCANHardware->frameHandler->get_is_valid())
			{
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
			else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (pCANHardware->frameHandler->get_is_valid())
|—————————Node:( Text: (
|—————————Node:call_expression Text: pCANHardware->frameHandler->get_is_valid()
|——————————Node:field_expression Text: pCANHardware->frameHandler->get_is_valid
|———————————Node:field_expression Text: pCANHardware->frameHandler
|————————————Node:identifier Text: pCANHardware
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: get_is_valid
|——————————Node:argument_list Text: ()
|———————————Node:( Text: (
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				// Socket or other hardware still open
				if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
			}
|—————————Node:{ Text: {
|—————————Node:comment Text: // Socket or other hardware still open
|—————————Node:if_statement Text: if (pCANHardware->frameHandler->read_frame(tempCanFrame))
				{
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (pCANHardware->frameHandler->read_frame(tempCanFrame))
|———————————Node:( Text: (
|———————————Node:call_expression Text: pCANHardware->frameHandler->read_frame(tempCanFrame)
|————————————Node:field_expression Text: pCANHardware->frameHandler->read_frame
|—————————————Node:field_expression Text: pCANHardware->frameHandler
|——————————————Node:identifier Text: pCANHardware
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: frameHandler
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: read_frame
|————————————Node:argument_list Text: (tempCanFrame)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: tempCanFrame
|—————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					tempCanFrame.channel = aCANChannel;
					pCANHardware->receivedMessagesMutex.lock();
					pCANHardware->receivedMessages.push_back(tempCanFrame);
					pCANHardware->receivedMessagesMutex.unlock();
					threadConditionVariable.notify_all();
				}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: tempCanFrame.channel = aCANChannel;
|————————————Node:assignment_expression Text: tempCanFrame.channel = aCANChannel
|—————————————Node:field_expression Text: tempCanFrame.channel
|——————————————Node:identifier Text: tempCanFrame
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: channel
|—————————————Node:= Text: =
|—————————————Node:identifier Text: aCANChannel
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.lock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.lock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.lock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: lock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessages.push_back(tempCanFrame);
|————————————Node:call_expression Text: pCANHardware->receivedMessages.push_back(tempCanFrame)
|—————————————Node:field_expression Text: pCANHardware->receivedMessages.push_back
|——————————————Node:field_expression Text: pCANHardware->receivedMessages
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessages
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: push_back
|—————————————Node:argument_list Text: (tempCanFrame)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: tempCanFrame
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pCANHardware->receivedMessagesMutex.unlock();
|————————————Node:call_expression Text: pCANHardware->receivedMessagesMutex.unlock()
|—————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex.unlock
|——————————————Node:field_expression Text: pCANHardware->receivedMessagesMutex
|———————————————Node:identifier Text: pCANHardware
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: receivedMessagesMutex
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: unlock
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: threadConditionVariable.notify_all();
|————————————Node:call_expression Text: threadConditionVariable.notify_all()
|—————————————Node:field_expression Text: threadConditionVariable.notify_all
|——————————————Node:identifier Text: threadConditionVariable
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: notify_all
|—————————————Node:argument_list Text: ()
|——————————————Node:( Text: (
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|————————Node:else_clause Text: else
			{
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
				isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
				std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Arbitrary, but don't want to infinite loop on the validity check.
			}
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.");
|———————————Node:call_expression Text: isobus::CANStackLogger::CAN_stack_log(isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.")
|————————————Node:qualified_identifier Text: isobus::CANStackLogger::CAN_stack_log
|—————————————Node:namespace_identifier Text: isobus
|—————————————Node::: Text: ::
|—————————————Node:qualified_identifier Text: CANStackLogger::CAN_stack_log
|——————————————Node:namespace_identifier Text: CANStackLogger
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: CAN_stack_log
|————————————Node:argument_list Text: (isobus::CANStackLogger::LoggingLevel::Critical, "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid.")
|—————————————Node:( Text: (
|—————————————Node:qualified_identifier Text: isobus::CANStackLogger::LoggingLevel::Critical
|——————————————Node:namespace_identifier Text: isobus
|——————————————Node::: Text: ::
|——————————————Node:qualified_identifier Text: CANStackLogger::LoggingLevel::Critical
|———————————————Node:namespace_identifier Text: CANStackLogger
|———————————————Node::: Text: ::
|———————————————Node:qualified_identifier Text: LoggingLevel::Critical
|————————————————Node:namespace_identifier Text: LoggingLevel
|————————————————Node::: Text: ::
|————————————————Node:identifier Text: Critical
|—————————————Node:, Text: ,
|—————————————Node:binary_expression Text: "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel) + " appears to be invalid."
|——————————————Node:binary_expression Text: "[CAN Rx Thread]: CAN Channel " + isobus::to_string(aCANChannel)
|———————————————Node:string_literal Text: "[CAN Rx Thread]: CAN Channel "
|————————————————Node:" Text: "
|————————————————Node:string_content Text: [CAN Rx Thread]: CAN Channel 
|————————————————Node:" Text: "
|———————————————Node:+ Text: +
|———————————————Node:call_expression Text: isobus::to_string(aCANChannel)
|————————————————Node:qualified_identifier Text: isobus::to_string
|—————————————————Node:namespace_identifier Text: isobus
|—————————————————Node::: Text: ::
|—————————————————Node:identifier Text: to_string
|————————————————Node:argument_list Text: (aCANChannel)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: aCANChannel
|—————————————————Node:) Text: )
|——————————————Node:+ Text: +
|——————————————Node:string_literal Text: " appears to be invalid."
|———————————————Node:" Text: "
|———————————————Node:string_content Text:  appears to be invalid.
|———————————————Node:" Text: "
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: std::this_thread::sleep_for(std::chrono::milliseconds(1000));
|———————————Node:call_expression Text: std::this_thread::sleep_for(std::chrono::milliseconds(1000))
|————————————Node:qualified_identifier Text: std::this_thread::sleep_for
|—————————————Node:namespace_identifier Text: std
|—————————————Node::: Text: ::
|—————————————Node:qualified_identifier Text: this_thread::sleep_for
|——————————————Node:namespace_identifier Text: this_thread
|——————————————Node::: Text: ::
|——————————————Node:identifier Text: sleep_for
|————————————Node:argument_list Text: (std::chrono::milliseconds(1000))
|—————————————Node:( Text: (
|—————————————Node:call_expression Text: std::chrono::milliseconds(1000)
|——————————————Node:qualified_identifier Text: std::chrono::milliseconds
|———————————————Node:namespace_identifier Text: std
|———————————————Node::: Text: ::
|———————————————Node:qualified_identifier Text: chrono::milliseconds
|————————————————Node:namespace_identifier Text: chrono
|————————————————Node::: Text: ::
|————————————————Node:identifier Text: milliseconds
|——————————————Node:argument_list Text: (1000)
|———————————————Node:( Text: (
|———————————————Node:number_literal Text: 1000
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:comment Text: // Arbitrary, but don't want to infinite loop on the validity check.
|——————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::transmit_can_message_from_buffer(isobus::HardwareInterfaceCANFrame &packet)
{
	bool retVal = false;
	std::uint8_t lChannel = packet.channel;

	if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::transmit_can_message_from_buffer(isobus::HardwareInterfaceCANFrame &packet)
|———Node:qualified_identifier Text: CANHardwareInterface::transmit_can_message_from_buffer
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: transmit_can_message_from_buffer
|———Node:parameter_list Text: (isobus::HardwareInterfaceCANFrame &packet)
|————Node:( Text: (
|————Node:parameter_declaration Text: isobus::HardwareInterfaceCANFrame &packet
|—————Node:qualified_identifier Text: isobus::HardwareInterfaceCANFrame
|——————Node:namespace_identifier Text: isobus
|——————Node::: Text: ::
|——————Node:type_identifier Text: HardwareInterfaceCANFrame
|—————Node:reference_declarator Text: &packet
|——————Node:& Text: &
|——————Node:identifier Text: packet
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;
	std::uint8_t lChannel = packet.channel;

	if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:declaration Text: std::uint8_t lChannel = packet.channel;
|————Node:qualified_identifier Text: std::uint8_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint8_t
|————Node:init_declarator Text: lChannel = packet.channel
|—————Node:identifier Text: lChannel
|—————Node:= Text: =
|—————Node:field_expression Text: packet.channel
|——————Node:identifier Text: packet
|——————Node:. Text: .
|——————Node:field_identifier Text: channel
|————Node:; Text: ;
|———Node:if_statement Text: if (lChannel < hardwareChannels.size())
	{
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
|————Node:if Text: if
|————Node:condition_clause Text: (lChannel < hardwareChannels.size())
|—————Node:( Text: (
|—————Node:binary_expression Text: lChannel < hardwareChannels.size()
|——————Node:identifier Text: lChannel
|——————Node:< Text: <
|——————Node:call_expression Text: hardwareChannels.size()
|———————Node:field_expression Text: hardwareChannels.size
|————————Node:identifier Text: hardwareChannels
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)));
|——————Node:assignment_expression Text: retVal = ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)))
|———————Node:identifier Text: retVal
|———————Node:= Text: =
|———————Node:parenthesized_expression Text: ((nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet)))
|————————Node:( Text: (
|————————Node:binary_expression Text: (nullptr != hardwareChannels[lChannel]->frameHandler) &&
		          (hardwareChannels[lChannel]->frameHandler->write_frame(packet))
|—————————Node:parenthesized_expression Text: (nullptr != hardwareChannels[lChannel]->frameHandler)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: nullptr != hardwareChannels[lChannel]->frameHandler
|———————————Node:null Text: nullptr
|————————————Node:nullptr Text: nullptr
|———————————Node:!= Text: !=
|———————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|————————————Node:subscript_expression Text: hardwareChannels[lChannel]
|—————————————Node:identifier Text: hardwareChannels
|—————————————Node:subscript_argument_list Text: [lChannel]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: lChannel
|——————————————Node:] Text: ]
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: frameHandler
|——————————Node:) Text: )
|—————————Node:&& Text: &&
|—————————Node:parenthesized_expression Text: (hardwareChannels[lChannel]->frameHandler->write_frame(packet))
|——————————Node:( Text: (
|——————————Node:call_expression Text: hardwareChannels[lChannel]->frameHandler->write_frame(packet)
|———————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler->write_frame
|————————————Node:field_expression Text: hardwareChannels[lChannel]->frameHandler
|—————————————Node:subscript_expression Text: hardwareChannels[lChannel]
|——————————————Node:identifier Text: hardwareChannels
|——————————————Node:subscript_argument_list Text: [lChannel]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: lChannel
|———————————————Node:] Text: ]
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: frameHandler
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: write_frame
|———————————Node:argument_list Text: (packet)
|————————————Node:( Text: (
|————————————Node:identifier Text: packet
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::update_can_lib_periodic_function()
{
	const std::uint32_t UPDATE_RATE = canLibUpdatePeriod;
	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::update_can_lib_periodic_function()
|———Node:qualified_identifier Text: CANHardwareInterface::update_can_lib_periodic_function
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: update_can_lib_periodic_function
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	const std::uint32_t UPDATE_RATE = canLibUpdatePeriod;
	hardwareChannelsMutex.lock();
	hardwareChannelsMutex.unlock();

	while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
}
|———Node:{ Text: {
|———Node:declaration Text: const std::uint32_t UPDATE_RATE = canLibUpdatePeriod;
|————Node:type_qualifier Text: const
|—————Node:const Text: const
|————Node:qualified_identifier Text: std::uint32_t
|—————Node:namespace_identifier Text: std
|—————Node::: Text: ::
|—————Node:type_identifier Text: uint32_t
|————Node:init_declarator Text: UPDATE_RATE = canLibUpdatePeriod
|—————Node:identifier Text: UPDATE_RATE
|—————Node:= Text: =
|—————Node:identifier Text: canLibUpdatePeriod
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.lock();
|————Node:call_expression Text: hardwareChannelsMutex.lock()
|—————Node:field_expression Text: hardwareChannelsMutex.lock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: hardwareChannelsMutex.unlock();
|————Node:call_expression Text: hardwareChannelsMutex.unlock()
|—————Node:field_expression Text: hardwareChannelsMutex.unlock
|——————Node:identifier Text: hardwareChannelsMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:while_statement Text: while (threadsStarted)
	{
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
|————Node:while Text: while
|————Node:condition_clause Text: (threadsStarted)
|—————Node:( Text: (
|—————Node:identifier Text: threadsStarted
|—————Node:) Text: )
|————Node:compound_statement Text: {
		set_can_lib_needs_update();
		threadConditionVariable.notify_all();
		std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: set_can_lib_needs_update();
|——————Node:call_expression Text: set_can_lib_needs_update()
|———————Node:identifier Text: set_can_lib_needs_update
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: threadConditionVariable.notify_all();
|——————Node:call_expression Text: threadConditionVariable.notify_all()
|———————Node:field_expression Text: threadConditionVariable.notify_all
|————————Node:identifier Text: threadConditionVariable
|————————Node:. Text: .
|————————Node:field_identifier Text: notify_all
|———————Node:argument_list Text: ()
|————————Node:( Text: (
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE));
|——————Node:call_expression Text: std::this_thread::sleep_for(std::chrono::milliseconds(UPDATE_RATE))
|———————Node:qualified_identifier Text: std::this_thread::sleep_for
|————————Node:namespace_identifier Text: std
|————————Node::: Text: ::
|————————Node:qualified_identifier Text: this_thread::sleep_for
|—————————Node:namespace_identifier Text: this_thread
|—————————Node::: Text: ::
|—————————Node:identifier Text: sleep_for
|———————Node:argument_list Text: (std::chrono::milliseconds(UPDATE_RATE))
|————————Node:( Text: (
|————————Node:call_expression Text: std::chrono::milliseconds(UPDATE_RATE)
|—————————Node:qualified_identifier Text: std::chrono::milliseconds
|——————————Node:namespace_identifier Text: std
|——————————Node::: Text: ::
|——————————Node:qualified_identifier Text: chrono::milliseconds
|———————————Node:namespace_identifier Text: chrono
|———————————Node::: Text: ::
|———————————Node:identifier Text: milliseconds
|—————————Node:argument_list Text: (UPDATE_RATE)
|——————————Node:( Text: (
|——————————Node:identifier Text: UPDATE_RATE
|——————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANHardwareInterface::set_can_lib_needs_update()
{
	canLibNeedsUpdateMutex.lock();
	canLibNeedsUpdate = true;
	canLibNeedsUpdateMutex.unlock();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANHardwareInterface::set_can_lib_needs_update()
|———Node:qualified_identifier Text: CANHardwareInterface::set_can_lib_needs_update
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: set_can_lib_needs_update
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	canLibNeedsUpdateMutex.lock();
	canLibNeedsUpdate = true;
	canLibNeedsUpdateMutex.unlock();
}
|———Node:{ Text: {
|———Node:expression_statement Text: canLibNeedsUpdateMutex.lock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.lock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.lock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdate = true;
|————Node:assignment_expression Text: canLibNeedsUpdate = true
|—————Node:identifier Text: canLibNeedsUpdate
|—————Node:= Text: =
|—————Node:true Text: true
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.unlock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.unlock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.unlock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: bool CANHardwareInterface::get_clear_can_lib_needs_update()
{
	bool retVal = false;

	canLibNeedsUpdateMutex.lock();
	retVal = canLibNeedsUpdate;
	canLibNeedsUpdate = false;
	canLibNeedsUpdateMutex.unlock();

	return retVal;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANHardwareInterface::get_clear_can_lib_needs_update()
|———Node:qualified_identifier Text: CANHardwareInterface::get_clear_can_lib_needs_update
|————Node:namespace_identifier Text: CANHardwareInterface
|————Node::: Text: ::
|————Node:identifier Text: get_clear_can_lib_needs_update
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool retVal = false;

	canLibNeedsUpdateMutex.lock();
	retVal = canLibNeedsUpdate;
	canLibNeedsUpdate = false;
	canLibNeedsUpdateMutex.unlock();

	return retVal;
}
|———Node:{ Text: {
|———Node:declaration Text: bool retVal = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: retVal = false
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.lock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.lock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.lock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: lock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: retVal = canLibNeedsUpdate;
|————Node:assignment_expression Text: retVal = canLibNeedsUpdate
|—————Node:identifier Text: retVal
|—————Node:= Text: =
|—————Node:identifier Text: canLibNeedsUpdate
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdate = false;
|————Node:assignment_expression Text: canLibNeedsUpdate = false
|—————Node:identifier Text: canLibNeedsUpdate
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:expression_statement Text: canLibNeedsUpdateMutex.unlock();
|————Node:call_expression Text: canLibNeedsUpdateMutex.unlock()
|—————Node:field_expression Text: canLibNeedsUpdateMutex.unlock
|——————Node:identifier Text: canLibNeedsUpdateMutex
|——————Node:. Text: .
|——————Node:field_identifier Text: unlock
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return retVal;
|————Node:return Text: return
|————Node:identifier Text: retVal
|————Node:; Text: ;
|———Node:} Text: }
