avr_can-due_can.cpp

|Node:translation_unit
|—Node:comment Text: /*
  Copyright (c) 2013 Arduino.  All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
|—Node:preproc_include Text: #include "due_can.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "due_can.h"
|———Node:" Text: "
|———Node:string_content Text: due_can.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "sn65hvd234.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "sn65hvd234.h"
|———Node:" Text: "
|———Node:string_content Text: sn65hvd234.h
|———Node:" Text: "
|—Node:comment Text: /** Define the timemark mask. */
|—Node:preproc_def Text: #define TIMEMARK_MASK              0x0000ffff

|——Node:#define Text: #define
|——Node:identifier Text: TIMEMARK_MASK
|——Node:preproc_arg Text: 0x0000ffff
|—Node:comment Text: /* CAN timeout for synchronization. */
|—Node:preproc_def Text: #define CAN_TIMEOUT                100000

|——Node:#define Text: #define
|——Node:identifier Text: CAN_TIMEOUT
|——Node:preproc_arg Text: 100000
|—Node:comment Text: /** The max value for CAN baudrate prescale. */
|—Node:preproc_def Text: #define CAN_BAUDRATE_MAX_DIV       128

|——Node:#define Text: #define
|——Node:identifier Text: CAN_BAUDRATE_MAX_DIV
|——Node:preproc_arg Text: 128
|—Node:comment Text: /** Define the scope for TQ. */
|—Node:preproc_def Text: #define CAN_MIN_TQ_NUM             8

|——Node:#define Text: #define
|——Node:identifier Text: CAN_MIN_TQ_NUM
|——Node:preproc_arg Text: 8
|—Node:preproc_def Text: #define CAN_MAX_TQ_NUM             25

|——Node:#define Text: #define
|——Node:identifier Text: CAN_MAX_TQ_NUM
|——Node:preproc_arg Text: 25
|—Node:comment Text: /** Define the fixed bit time value. */
|—Node:preproc_def Text: #define CAN_BIT_SYNC               1

|——Node:#define Text: #define
|——Node:identifier Text: CAN_BIT_SYNC
|——Node:preproc_arg Text: 1
|—Node:preproc_def Text: #define CAN_BIT_IPT                2

|——Node:#define Text: #define
|——Node:identifier Text: CAN_BIT_IPT
|——Node:preproc_arg Text: 2
|—Node:type_definition Text: typedef struct {
	uint8_t uc_tq;      //! CAN_BIT_SYNC + uc_prog + uc_phase1 + uc_phase2 = uc_tq, 8 <= uc_tq <= 25.
	uint8_t uc_prog;    //! Propagation segment, (3-bits + 1), 1~8;
	uint8_t uc_phase1;  //! Phase segment 1, (3-bits + 1), 1~8;
	uint8_t uc_phase2;  //! Phase segment 2, (3-bits + 1), 1~8, CAN_BIT_IPT <= uc_phase2;
	uint8_t uc_sjw;     //! Resynchronization jump width, (2-bits + 1), min(uc_phase1, 4);
	uint8_t uc_sp;      //! Sample point value, 0~100 in percent.
} can_bit_timing_t;
|——Node:typedef Text: typedef
|——Node:struct_specifier Text: struct {
	uint8_t uc_tq;      //! CAN_BIT_SYNC + uc_prog + uc_phase1 + uc_phase2 = uc_tq, 8 <= uc_tq <= 25.
	uint8_t uc_prog;    //! Propagation segment, (3-bits + 1), 1~8;
	uint8_t uc_phase1;  //! Phase segment 1, (3-bits + 1), 1~8;
	uint8_t uc_phase2;  //! Phase segment 2, (3-bits + 1), 1~8, CAN_BIT_IPT <= uc_phase2;
	uint8_t uc_sjw;     //! Resynchronization jump width, (2-bits + 1), min(uc_phase1, 4);
	uint8_t uc_sp;      //! Sample point value, 0~100 in percent.
}
|———Node:struct Text: struct
|———Node:field_declaration_list Text: {
	uint8_t uc_tq;      //! CAN_BIT_SYNC + uc_prog + uc_phase1 + uc_phase2 = uc_tq, 8 <= uc_tq <= 25.
	uint8_t uc_prog;    //! Propagation segment, (3-bits + 1), 1~8;
	uint8_t uc_phase1;  //! Phase segment 1, (3-bits + 1), 1~8;
	uint8_t uc_phase2;  //! Phase segment 2, (3-bits + 1), 1~8, CAN_BIT_IPT <= uc_phase2;
	uint8_t uc_sjw;     //! Resynchronization jump width, (2-bits + 1), min(uc_phase1, 4);
	uint8_t uc_sp;      //! Sample point value, 0~100 in percent.
}
|————Node:{ Text: {
|————Node:field_declaration Text: uint8_t uc_tq;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_tq
|—————Node:; Text: ;
|————Node:comment Text: //! CAN_BIT_SYNC + uc_prog + uc_phase1 + uc_phase2 = uc_tq, 8 <= uc_tq <= 25.
|————Node:field_declaration Text: uint8_t uc_prog;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_prog
|—————Node:; Text: ;
|————Node:comment Text: //! Propagation segment, (3-bits + 1), 1~8;
|————Node:field_declaration Text: uint8_t uc_phase1;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_phase1
|—————Node:; Text: ;
|————Node:comment Text: //! Phase segment 1, (3-bits + 1), 1~8;
|————Node:field_declaration Text: uint8_t uc_phase2;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_phase2
|—————Node:; Text: ;
|————Node:comment Text: //! Phase segment 2, (3-bits + 1), 1~8, CAN_BIT_IPT <= uc_phase2;
|————Node:field_declaration Text: uint8_t uc_sjw;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_sjw
|—————Node:; Text: ;
|————Node:comment Text: //! Resynchronization jump width, (2-bits + 1), min(uc_phase1, 4);
|————Node:field_declaration Text: uint8_t uc_sp;
|—————Node:primitive_type Text: uint8_t
|—————Node:field_identifier Text: uc_sp
|—————Node:; Text: ;
|————Node:comment Text: //! Sample point value, 0~100 in percent.
|————Node:} Text: }
|——Node:type_identifier Text: can_bit_timing_t
|——Node:; Text: ;
|—Node:comment Text: /** Values of bit time register for different baudrates, Sample point = ((1 + uc_prog + uc_phase1) / uc_tq) * 100%. */
|—Node:declaration Text: const can_bit_timing_t can_bit_time[] = {
	{8,   (2 + 1), (1 + 1), (1 + 1), (2 + 1), 75},
	{9,   (1 + 1), (2 + 1), (2 + 1), (1 + 1), 67},
	{10,  (2 + 1), (2 + 1), (2 + 1), (2 + 1), 70},
	{11,  (3 + 1), (2 + 1), (2 + 1), (3 + 1), 72},
	{12,  (2 + 1), (3 + 1), (3 + 1), (3 + 1), 67},
	{13,  (3 + 1), (3 + 1), (3 + 1), (3 + 1), 77},
	{14,  (3 + 1), (3 + 1), (4 + 1), (3 + 1), 64},
	{15,  (3 + 1), (4 + 1), (4 + 1), (3 + 1), 67},
	{16,  (4 + 1), (4 + 1), (4 + 1), (3 + 1), 69},
	{17,  (5 + 1), (4 + 1), (4 + 1), (3 + 1), 71},
	{18,  (4 + 1), (5 + 1), (5 + 1), (3 + 1), 67},
	{19,  (5 + 1), (5 + 1), (5 + 1), (3 + 1), 68},
	{20,  (6 + 1), (5 + 1), (5 + 1), (3 + 1), 70},
	{21,  (7 + 1), (5 + 1), (5 + 1), (3 + 1), 71},
	{22,  (6 + 1), (6 + 1), (6 + 1), (3 + 1), 68},
	{23,  (7 + 1), (7 + 1), (6 + 1), (3 + 1), 70},
	{24,  (6 + 1), (7 + 1), (7 + 1), (3 + 1), 67},
	{25,  (7 + 1), (7 + 1), (7 + 1), (3 + 1), 68}
};
|——Node:type_qualifier Text: const
|———Node:const Text: const
|——Node:type_identifier Text: can_bit_timing_t
|——Node:init_declarator Text: can_bit_time[] = {
	{8,   (2 + 1), (1 + 1), (1 + 1), (2 + 1), 75},
	{9,   (1 + 1), (2 + 1), (2 + 1), (1 + 1), 67},
	{10,  (2 + 1), (2 + 1), (2 + 1), (2 + 1), 70},
	{11,  (3 + 1), (2 + 1), (2 + 1), (3 + 1), 72},
	{12,  (2 + 1), (3 + 1), (3 + 1), (3 + 1), 67},
	{13,  (3 + 1), (3 + 1), (3 + 1), (3 + 1), 77},
	{14,  (3 + 1), (3 + 1), (4 + 1), (3 + 1), 64},
	{15,  (3 + 1), (4 + 1), (4 + 1), (3 + 1), 67},
	{16,  (4 + 1), (4 + 1), (4 + 1), (3 + 1), 69},
	{17,  (5 + 1), (4 + 1), (4 + 1), (3 + 1), 71},
	{18,  (4 + 1), (5 + 1), (5 + 1), (3 + 1), 67},
	{19,  (5 + 1), (5 + 1), (5 + 1), (3 + 1), 68},
	{20,  (6 + 1), (5 + 1), (5 + 1), (3 + 1), 70},
	{21,  (7 + 1), (5 + 1), (5 + 1), (3 + 1), 71},
	{22,  (6 + 1), (6 + 1), (6 + 1), (3 + 1), 68},
	{23,  (7 + 1), (7 + 1), (6 + 1), (3 + 1), 70},
	{24,  (6 + 1), (7 + 1), (7 + 1), (3 + 1), 67},
	{25,  (7 + 1), (7 + 1), (7 + 1), (3 + 1), 68}
}
|———Node:array_declarator Text: can_bit_time[]
|————Node:identifier Text: can_bit_time
|————Node:[ Text: [
|————Node:] Text: ]
|———Node:= Text: =
|———Node:initializer_list Text: {
	{8,   (2 + 1), (1 + 1), (1 + 1), (2 + 1), 75},
	{9,   (1 + 1), (2 + 1), (2 + 1), (1 + 1), 67},
	{10,  (2 + 1), (2 + 1), (2 + 1), (2 + 1), 70},
	{11,  (3 + 1), (2 + 1), (2 + 1), (3 + 1), 72},
	{12,  (2 + 1), (3 + 1), (3 + 1), (3 + 1), 67},
	{13,  (3 + 1), (3 + 1), (3 + 1), (3 + 1), 77},
	{14,  (3 + 1), (3 + 1), (4 + 1), (3 + 1), 64},
	{15,  (3 + 1), (4 + 1), (4 + 1), (3 + 1), 67},
	{16,  (4 + 1), (4 + 1), (4 + 1), (3 + 1), 69},
	{17,  (5 + 1), (4 + 1), (4 + 1), (3 + 1), 71},
	{18,  (4 + 1), (5 + 1), (5 + 1), (3 + 1), 67},
	{19,  (5 + 1), (5 + 1), (5 + 1), (3 + 1), 68},
	{20,  (6 + 1), (5 + 1), (5 + 1), (3 + 1), 70},
	{21,  (7 + 1), (5 + 1), (5 + 1), (3 + 1), 71},
	{22,  (6 + 1), (6 + 1), (6 + 1), (3 + 1), 68},
	{23,  (7 + 1), (7 + 1), (6 + 1), (3 + 1), 70},
	{24,  (6 + 1), (7 + 1), (7 + 1), (3 + 1), 67},
	{25,  (7 + 1), (7 + 1), (7 + 1), (3 + 1), 68}
}
|————Node:{ Text: {
|————Node:initializer_list Text: {8,   (2 + 1), (1 + 1), (1 + 1), (2 + 1), 75}
|—————Node:{ Text: {
|—————Node:number_literal Text: 8
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (1 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 + 1
|———————Node:number_literal Text: 1
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (1 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 + 1
|———————Node:number_literal Text: 1
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 75
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {9,   (1 + 1), (2 + 1), (2 + 1), (1 + 1), 67}
|—————Node:{ Text: {
|—————Node:number_literal Text: 9
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (1 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 + 1
|———————Node:number_literal Text: 1
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (1 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 1 + 1
|———————Node:number_literal Text: 1
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 67
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {10,  (2 + 1), (2 + 1), (2 + 1), (2 + 1), 70}
|—————Node:{ Text: {
|—————Node:number_literal Text: 10
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 70
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {11,  (3 + 1), (2 + 1), (2 + 1), (3 + 1), 72}
|—————Node:{ Text: {
|—————Node:number_literal Text: 11
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 72
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {12,  (2 + 1), (3 + 1), (3 + 1), (3 + 1), 67}
|—————Node:{ Text: {
|—————Node:number_literal Text: 12
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (2 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 2 + 1
|———————Node:number_literal Text: 2
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 67
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {13,  (3 + 1), (3 + 1), (3 + 1), (3 + 1), 77}
|—————Node:{ Text: {
|—————Node:number_literal Text: 13
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 77
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {14,  (3 + 1), (3 + 1), (4 + 1), (3 + 1), 64}
|—————Node:{ Text: {
|—————Node:number_literal Text: 14
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 64
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {15,  (3 + 1), (4 + 1), (4 + 1), (3 + 1), 67}
|—————Node:{ Text: {
|—————Node:number_literal Text: 15
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 67
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {16,  (4 + 1), (4 + 1), (4 + 1), (3 + 1), 69}
|—————Node:{ Text: {
|—————Node:number_literal Text: 16
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 69
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {17,  (5 + 1), (4 + 1), (4 + 1), (3 + 1), 71}
|—————Node:{ Text: {
|—————Node:number_literal Text: 17
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 71
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {18,  (4 + 1), (5 + 1), (5 + 1), (3 + 1), 67}
|—————Node:{ Text: {
|—————Node:number_literal Text: 18
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (4 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 4 + 1
|———————Node:number_literal Text: 4
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 67
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {19,  (5 + 1), (5 + 1), (5 + 1), (3 + 1), 68}
|—————Node:{ Text: {
|—————Node:number_literal Text: 19
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 68
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {20,  (6 + 1), (5 + 1), (5 + 1), (3 + 1), 70}
|—————Node:{ Text: {
|—————Node:number_literal Text: 20
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 70
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {21,  (7 + 1), (5 + 1), (5 + 1), (3 + 1), 71}
|—————Node:{ Text: {
|—————Node:number_literal Text: 21
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (5 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 5 + 1
|———————Node:number_literal Text: 5
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 71
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {22,  (6 + 1), (6 + 1), (6 + 1), (3 + 1), 68}
|—————Node:{ Text: {
|—————Node:number_literal Text: 22
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 68
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {23,  (7 + 1), (7 + 1), (6 + 1), (3 + 1), 70}
|—————Node:{ Text: {
|—————Node:number_literal Text: 23
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 70
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {24,  (6 + 1), (7 + 1), (7 + 1), (3 + 1), 67}
|—————Node:{ Text: {
|—————Node:number_literal Text: 24
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (6 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 6 + 1
|———————Node:number_literal Text: 6
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 67
|—————Node:} Text: }
|————Node:, Text: ,
|————Node:initializer_list Text: {25,  (7 + 1), (7 + 1), (7 + 1), (3 + 1), 68}
|—————Node:{ Text: {
|—————Node:number_literal Text: 25
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (7 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 7 + 1
|———————Node:number_literal Text: 7
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:parenthesized_expression Text: (3 + 1)
|——————Node:( Text: (
|——————Node:binary_expression Text: 3 + 1
|———————Node:number_literal Text: 3
|———————Node:+ Text: +
|———————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:, Text: ,
|—————Node:number_literal Text: 68
|—————Node:} Text: }
|————Node:} Text: }
|——Node:; Text: ;
|—Node:comment Text: /**
 * \brief Configure CAN baudrate.
 *
 * \param ul_baudrate Baudrate value (kB/s), allowed values:
 *                    1000, 800, 500, 250, 125, 50, 25, 10, 5.
 *
 * \retval Set the baudrate successfully or not.
 */
|—Node:function_definition Text: uint32_t CANRaw::set_baudrate(uint32_t ul_baudrate)
{
	uint8_t uc_tq;
	uint8_t uc_prescale;
	uint32_t ul_mod;
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	static uint32_t ul_mck = SystemCoreClock;

	/* Check whether the baudrate prescale will be greater than the max divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)) > CAN_BAUDRATE_MAX_DIV) {
		return 0;
	}

	/* Check whether the input MCK is too small. */
	if (ul_mck  < ul_baudrate * CAN_MIN_TQ_NUM) {
		return 0;
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;

	/* Initialize the remainder as the max value. When the remainder is 0, get the right TQ number. */
	ul_mod = 0xffffffff;
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
		if ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq);

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];

	/* Before modifying the CANBR register, disable the CAN controller. */
	//can_disable(m_pCan);
    m_pCan->CAN_MR &= ~CAN_MR_CANEN;

	/* Write into the CAN baudrate register. */
	m_pCan->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
					CAN_BR_BRP(uc_prescale - 1);
	return 1;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::set_baudrate(uint32_t ul_baudrate)
|———Node:qualified_identifier Text: CANRaw::set_baudrate
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: set_baudrate
|———Node:parameter_list Text: (uint32_t ul_baudrate)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t ul_baudrate
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: ul_baudrate
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint8_t uc_tq;
	uint8_t uc_prescale;
	uint32_t ul_mod;
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	static uint32_t ul_mck = SystemCoreClock;

	/* Check whether the baudrate prescale will be greater than the max divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)) > CAN_BAUDRATE_MAX_DIV) {
		return 0;
	}

	/* Check whether the input MCK is too small. */
	if (ul_mck  < ul_baudrate * CAN_MIN_TQ_NUM) {
		return 0;
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;

	/* Initialize the remainder as the max value. When the remainder is 0, get the right TQ number. */
	ul_mod = 0xffffffff;
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
		if ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq);

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];

	/* Before modifying the CANBR register, disable the CAN controller. */
	//can_disable(m_pCan);
    m_pCan->CAN_MR &= ~CAN_MR_CANEN;

	/* Write into the CAN baudrate register. */
	m_pCan->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
					CAN_BR_BRP(uc_prescale - 1);
	return 1;
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t uc_tq;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: uc_tq
|————Node:; Text: ;
|———Node:declaration Text: uint8_t uc_prescale;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: uc_prescale
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_mod;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_mod
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_cur_mod;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_cur_mod
|————Node:; Text: ;
|———Node:declaration Text: can_bit_timing_t *p_bit_time;
|————Node:type_identifier Text: can_bit_timing_t
|————Node:pointer_declarator Text: *p_bit_time
|—————Node:* Text: *
|—————Node:identifier Text: p_bit_time
|————Node:; Text: ;
|———Node:declaration Text: static uint32_t ul_mck = SystemCoreClock;
|————Node:storage_class_specifier Text: static
|—————Node:static Text: static
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: ul_mck = SystemCoreClock
|—————Node:identifier Text: ul_mck
|—————Node:= Text: =
|—————Node:identifier Text: SystemCoreClock
|————Node:; Text: ;
|———Node:comment Text: /* Check whether the baudrate prescale will be greater than the max divide value. */
|———Node:if_statement Text: if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)) > CAN_BAUDRATE_MAX_DIV) {
		return 0;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)) > CAN_BAUDRATE_MAX_DIV)
|—————Node:( Text: (
|—————Node:binary_expression Text: ((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)) > CAN_BAUDRATE_MAX_DIV
|——————Node:parenthesized_expression Text: ((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM))
|———————Node:( Text: (
|———————Node:binary_expression Text: (ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)) /
		(ul_baudrate * CAN_MAX_TQ_NUM)
|————————Node:parenthesized_expression Text: (ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM - 1)
|——————————Node:identifier Text: ul_mck
|——————————Node:+ Text: +
|——————————Node:parenthesized_expression Text: (ul_baudrate * CAN_MAX_TQ_NUM - 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ul_baudrate * CAN_MAX_TQ_NUM - 1
|————————————Node:binary_expression Text: ul_baudrate * CAN_MAX_TQ_NUM
|—————————————Node:identifier Text: ul_baudrate
|—————————————Node:* Text: *
|—————————————Node:identifier Text: CAN_MAX_TQ_NUM
|————————————Node:- Text: -
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:/ Text: /
|————————Node:parenthesized_expression Text: (ul_baudrate * CAN_MAX_TQ_NUM)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ul_baudrate * CAN_MAX_TQ_NUM
|——————————Node:identifier Text: ul_baudrate
|——————————Node:* Text: *
|——————————Node:identifier Text: CAN_MAX_TQ_NUM
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:> Text: >
|——————Node:identifier Text: CAN_BAUDRATE_MAX_DIV
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return 0;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Check whether the input MCK is too small. */
|———Node:if_statement Text: if (ul_mck  < ul_baudrate * CAN_MIN_TQ_NUM) {
		return 0;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_mck  < ul_baudrate * CAN_MIN_TQ_NUM)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_mck  < ul_baudrate * CAN_MIN_TQ_NUM
|——————Node:identifier Text: ul_mck
|——————Node:< Text: <
|——————Node:binary_expression Text: ul_baudrate * CAN_MIN_TQ_NUM
|———————Node:identifier Text: ul_baudrate
|———————Node:* Text: *
|———————Node:identifier Text: CAN_MIN_TQ_NUM
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return 0;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Initialize it as the minimum Time Quantum. */
|———Node:expression_statement Text: uc_tq = CAN_MIN_TQ_NUM;
|————Node:assignment_expression Text: uc_tq = CAN_MIN_TQ_NUM
|—————Node:identifier Text: uc_tq
|—————Node:= Text: =
|—————Node:identifier Text: CAN_MIN_TQ_NUM
|————Node:; Text: ;
|———Node:comment Text: /* Initialize the remainder as the max value. When the remainder is 0, get the right TQ number. */
|———Node:expression_statement Text: ul_mod = 0xffffffff;
|————Node:assignment_expression Text: ul_mod = 0xffffffff
|—————Node:identifier Text: ul_mod
|—————Node:= Text: =
|—————Node:number_literal Text: 0xffffffff
|————Node:; Text: ;
|———Node:comment Text: /* Find out the approximate Time Quantum according to the baudrate. */
|———Node:for_statement Text: for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
		if ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: uint8_t i = CAN_MIN_TQ_NUM;
|—————Node:primitive_type Text: uint8_t
|—————Node:init_declarator Text: i = CAN_MIN_TQ_NUM
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:identifier Text: CAN_MIN_TQ_NUM
|—————Node:; Text: ;
|————Node:binary_expression Text: i <= CAN_MAX_TQ_NUM
|—————Node:identifier Text: i
|—————Node:<= Text: <=
|—————Node:identifier Text: CAN_MAX_TQ_NUM
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		if ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: ((ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV)
|———————Node:( Text: (
|———————Node:binary_expression Text: (ul_mck / (ul_baudrate * i)) <= CAN_BAUDRATE_MAX_DIV
|————————Node:parenthesized_expression Text: (ul_mck / (ul_baudrate * i))
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ul_mck / (ul_baudrate * i)
|——————————Node:identifier Text: ul_mck
|——————————Node:/ Text: /
|——————————Node:parenthesized_expression Text: (ul_baudrate * i)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ul_baudrate * i
|————————————Node:identifier Text: ul_baudrate
|————————————Node:* Text: *
|————————————Node:identifier Text: i
|———————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:<= Text: <=
|————————Node:identifier Text: CAN_BAUDRATE_MAX_DIV
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			ul_cur_mod = ul_mck % (ul_baudrate * i);
			if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
		}
|———————Node:{ Text: {
|———————Node:expression_statement Text: ul_cur_mod = ul_mck % (ul_baudrate * i);
|————————Node:assignment_expression Text: ul_cur_mod = ul_mck % (ul_baudrate * i)
|—————————Node:identifier Text: ul_cur_mod
|—————————Node:= Text: =
|—————————Node:binary_expression Text: ul_mck % (ul_baudrate * i)
|——————————Node:identifier Text: ul_mck
|——————————Node:% Text: %
|——————————Node:parenthesized_expression Text: (ul_baudrate * i)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ul_baudrate * i
|————————————Node:identifier Text: ul_baudrate
|————————————Node:* Text: *
|————————————Node:identifier Text: i
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (ul_cur_mod < ul_mod){
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (ul_cur_mod < ul_mod)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ul_cur_mod < ul_mod
|——————————Node:identifier Text: ul_cur_mod
|——————————Node:< Text: <
|——————————Node:identifier Text: ul_mod
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				ul_mod = ul_cur_mod;
				uc_tq = i;
				if (!ul_mod) {
					break;
				}
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: ul_mod = ul_cur_mod;
|——————————Node:assignment_expression Text: ul_mod = ul_cur_mod
|———————————Node:identifier Text: ul_mod
|———————————Node:= Text: =
|———————————Node:identifier Text: ul_cur_mod
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: uc_tq = i;
|——————————Node:assignment_expression Text: uc_tq = i
|———————————Node:identifier Text: uc_tq
|———————————Node:= Text: =
|———————————Node:identifier Text: i
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (!ul_mod) {
					break;
				}
|——————————Node:if Text: if
|——————————Node:condition_clause Text: (!ul_mod)
|———————————Node:( Text: (
|———————————Node:unary_expression Text: !ul_mod
|————————————Node:! Text: !
|————————————Node:identifier Text: ul_mod
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
					break;
				}
|———————————Node:{ Text: {
|———————————Node:break_statement Text: break;
|————————————Node:break Text: break
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:comment Text: /* Calculate the baudrate prescale value. */
|———Node:expression_statement Text: uc_prescale = ul_mck / (ul_baudrate * uc_tq);
|————Node:assignment_expression Text: uc_prescale = ul_mck / (ul_baudrate * uc_tq)
|—————Node:identifier Text: uc_prescale
|—————Node:= Text: =
|—————Node:binary_expression Text: ul_mck / (ul_baudrate * uc_tq)
|——————Node:identifier Text: ul_mck
|——————Node:/ Text: /
|——————Node:parenthesized_expression Text: (ul_baudrate * uc_tq)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_baudrate * uc_tq
|————————Node:identifier Text: ul_baudrate
|————————Node:* Text: *
|————————Node:identifier Text: uc_tq
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Get the right CAN BIT Timing group. */
|———Node:expression_statement Text: p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
|————Node:assignment_expression Text: p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM]
|—————Node:identifier Text: p_bit_time
|—————Node:= Text: =
|—————Node:cast_expression Text: (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM]
|——————Node:( Text: (
|——————Node:type_descriptor Text: can_bit_timing_t *
|———————Node:type_identifier Text: can_bit_timing_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:pointer_expression Text: &can_bit_time[uc_tq - CAN_MIN_TQ_NUM]
|———————Node:& Text: &
|———————Node:subscript_expression Text: can_bit_time[uc_tq - CAN_MIN_TQ_NUM]
|————————Node:identifier Text: can_bit_time
|————————Node:subscript_argument_list Text: [uc_tq - CAN_MIN_TQ_NUM]
|—————————Node:[ Text: [
|—————————Node:binary_expression Text: uc_tq - CAN_MIN_TQ_NUM
|——————————Node:identifier Text: uc_tq
|——————————Node:- Text: -
|——————————Node:identifier Text: CAN_MIN_TQ_NUM
|—————————Node:] Text: ]
|————Node:; Text: ;
|———Node:comment Text: /* Before modifying the CANBR register, disable the CAN controller. */
|———Node:comment Text: //can_disable(m_pCan);
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_CANEN;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_CANEN
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_CANEN
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_CANEN
|————Node:; Text: ;
|———Node:comment Text: /* Write into the CAN baudrate register. */
|———Node:expression_statement Text: m_pCan->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
					CAN_BR_BRP(uc_prescale - 1);
|————Node:assignment_expression Text: m_pCan->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
					CAN_BR_BRP(uc_prescale - 1)
|—————Node:field_expression Text: m_pCan->CAN_BR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_BR
|—————Node:= Text: =
|—————Node:binary_expression Text: CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
					CAN_BR_BRP(uc_prescale - 1)
|——————Node:binary_expression Text: CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
					CAN_BR_SJW(p_bit_time->uc_sjw - 1)
|———————Node:binary_expression Text: CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
					CAN_BR_PROPAG(p_bit_time->uc_prog - 1)
|————————Node:binary_expression Text: CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
					CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1)
|—————————Node:call_expression Text: CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1)
|——————————Node:identifier Text: CAN_BR_PHASE2
|——————————Node:argument_list Text: (p_bit_time->uc_phase2 - 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: p_bit_time->uc_phase2 - 1
|————————————Node:field_expression Text: p_bit_time->uc_phase2
|—————————————Node:identifier Text: p_bit_time
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: uc_phase2
|————————————Node:- Text: -
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:call_expression Text: CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1)
|——————————Node:identifier Text: CAN_BR_PHASE1
|——————————Node:argument_list Text: (p_bit_time->uc_phase1 - 1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: p_bit_time->uc_phase1 - 1
|————————————Node:field_expression Text: p_bit_time->uc_phase1
|—————————————Node:identifier Text: p_bit_time
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: uc_phase1
|————————————Node:- Text: -
|————————————Node:number_literal Text: 1
|———————————Node:) Text: )
|————————Node:| Text: |
|————————Node:call_expression Text: CAN_BR_PROPAG(p_bit_time->uc_prog - 1)
|—————————Node:identifier Text: CAN_BR_PROPAG
|—————————Node:argument_list Text: (p_bit_time->uc_prog - 1)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: p_bit_time->uc_prog - 1
|———————————Node:field_expression Text: p_bit_time->uc_prog
|————————————Node:identifier Text: p_bit_time
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: uc_prog
|———————————Node:- Text: -
|———————————Node:number_literal Text: 1
|——————————Node:) Text: )
|———————Node:| Text: |
|———————Node:call_expression Text: CAN_BR_SJW(p_bit_time->uc_sjw - 1)
|————————Node:identifier Text: CAN_BR_SJW
|————————Node:argument_list Text: (p_bit_time->uc_sjw - 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: p_bit_time->uc_sjw - 1
|——————————Node:field_expression Text: p_bit_time->uc_sjw
|———————————Node:identifier Text: p_bit_time
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: uc_sjw
|——————————Node:- Text: -
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:| Text: |
|——————Node:call_expression Text: CAN_BR_BRP(uc_prescale - 1)
|———————Node:identifier Text: CAN_BR_BRP
|———————Node:argument_list Text: (uc_prescale - 1)
|————————Node:( Text: (
|————————Node:binary_expression Text: uc_prescale - 1
|—————————Node:identifier Text: uc_prescale
|—————————Node:- Text: -
|—————————Node:number_literal Text: 1
|————————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Initialize CAN controller.
 *
 * \param ul_mck CAN module input clock.
 * \param ul_baudrate CAN communication baudrate in kbs.
 *
 * \retval 0 If failed to initialize the CAN module; otherwise successful.
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this function.
 */
|—Node:function_definition Text: uint32_t CANRaw::init(uint32_t ul_baudrate)
{
	uint32_t ul_flag;
	uint32_t ul_tick;

//arduino 1.5.2 doesn't init canbus so make sure to do it here. 
#ifdef ARDUINO152
	PIO_Configure(PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT);
	PIO_Configure(PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT);
#endif
	
	if (m_pCan == CAN0) pmc_enable_periph_clk(ID_CAN0);
	if (m_pCan == CAN1) pmc_enable_periph_clk(ID_CAN1);

	m_Transceiver->DisableLowPower();
	m_Transceiver->Enable();

	/* Initialize the baudrate for CAN module. */
	ul_flag = set_baudrate(ul_baudrate);
	if (ul_flag == 0) {
		return 0;
	}

	/* Reset the CAN eight message mailbox. */
	reset_all_mailbox();

	//Also disable all interrupts by default
	disable_interrupt(CAN_DISABLE_ALL_INTERRUPT_MASK);

	//By default use one mailbox for TX 
	setNumTXBoxes(1);

	/* Enable the CAN controller. */
	enable();

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
	ul_tick = 0;
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
		ul_flag = m_pCan->CAN_SR;
		ul_tick++;
	}

	NVIC_EnableIRQ(m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn); //tell the nested interrupt controller to turn on our interrupt

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
		return 0;
	} else {
		return 1;
	}
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::init(uint32_t ul_baudrate)
|———Node:qualified_identifier Text: CANRaw::init
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: init
|———Node:parameter_list Text: (uint32_t ul_baudrate)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t ul_baudrate
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: ul_baudrate
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_flag;
	uint32_t ul_tick;

//arduino 1.5.2 doesn't init canbus so make sure to do it here. 
#ifdef ARDUINO152
	PIO_Configure(PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT);
	PIO_Configure(PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT);
#endif
	
	if (m_pCan == CAN0) pmc_enable_periph_clk(ID_CAN0);
	if (m_pCan == CAN1) pmc_enable_periph_clk(ID_CAN1);

	m_Transceiver->DisableLowPower();
	m_Transceiver->Enable();

	/* Initialize the baudrate for CAN module. */
	ul_flag = set_baudrate(ul_baudrate);
	if (ul_flag == 0) {
		return 0;
	}

	/* Reset the CAN eight message mailbox. */
	reset_all_mailbox();

	//Also disable all interrupts by default
	disable_interrupt(CAN_DISABLE_ALL_INTERRUPT_MASK);

	//By default use one mailbox for TX 
	setNumTXBoxes(1);

	/* Enable the CAN controller. */
	enable();

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
	ul_tick = 0;
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
		ul_flag = m_pCan->CAN_SR;
		ul_tick++;
	}

	NVIC_EnableIRQ(m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn); //tell the nested interrupt controller to turn on our interrupt

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
		return 0;
	} else {
		return 1;
	}
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_flag;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_flag
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_tick;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_tick
|————Node:; Text: ;
|———Node:comment Text: //arduino 1.5.2 doesn't init canbus so make sure to do it here. 
|———Node:preproc_ifdef Text: #ifdef ARDUINO152
	PIO_Configure(PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT);
	PIO_Configure(PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT);
#endif
|————Node:#ifdef Text: #ifdef
|————Node:identifier Text: ARDUINO152
|————Node:expression_statement Text: PIO_Configure(PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT);
|—————Node:call_expression Text: PIO_Configure(PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT)
|——————Node:identifier Text: PIO_Configure
|——————Node:argument_list Text: (PIOA,PIO_PERIPH_A, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, PIO_DEFAULT)
|———————Node:( Text: (
|———————Node:identifier Text: PIOA
|———————Node:, Text: ,
|———————Node:identifier Text: PIO_PERIPH_A
|———————Node:, Text: ,
|———————Node:binary_expression Text: PIO_PA1A_CANRX0|PIO_PA0A_CANTX0
|————————Node:identifier Text: PIO_PA1A_CANRX0
|————————Node:| Text: |
|————————Node:identifier Text: PIO_PA0A_CANTX0
|———————Node:, Text: ,
|———————Node:identifier Text: PIO_DEFAULT
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:expression_statement Text: PIO_Configure(PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT);
|—————Node:call_expression Text: PIO_Configure(PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT)
|——————Node:identifier Text: PIO_Configure
|——————Node:argument_list Text: (PIOB,PIO_PERIPH_A, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, PIO_DEFAULT)
|———————Node:( Text: (
|———————Node:identifier Text: PIOB
|———————Node:, Text: ,
|———————Node:identifier Text: PIO_PERIPH_A
|———————Node:, Text: ,
|———————Node:binary_expression Text: PIO_PB15A_CANRX1|PIO_PB14A_CANTX1
|————————Node:identifier Text: PIO_PB15A_CANRX1
|————————Node:| Text: |
|————————Node:identifier Text: PIO_PB14A_CANTX1
|———————Node:, Text: ,
|———————Node:identifier Text: PIO_DEFAULT
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:if_statement Text: if (m_pCan == CAN0) pmc_enable_periph_clk(ID_CAN0);
|————Node:if Text: if
|————Node:condition_clause Text: (m_pCan == CAN0)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_pCan == CAN0
|——————Node:identifier Text: m_pCan
|——————Node:== Text: ==
|——————Node:identifier Text: CAN0
|—————Node:) Text: )
|————Node:expression_statement Text: pmc_enable_periph_clk(ID_CAN0);
|—————Node:call_expression Text: pmc_enable_periph_clk(ID_CAN0)
|——————Node:identifier Text: pmc_enable_periph_clk
|——————Node:argument_list Text: (ID_CAN0)
|———————Node:( Text: (
|———————Node:identifier Text: ID_CAN0
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:if_statement Text: if (m_pCan == CAN1) pmc_enable_periph_clk(ID_CAN1);
|————Node:if Text: if
|————Node:condition_clause Text: (m_pCan == CAN1)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_pCan == CAN1
|——————Node:identifier Text: m_pCan
|——————Node:== Text: ==
|——————Node:identifier Text: CAN1
|—————Node:) Text: )
|————Node:expression_statement Text: pmc_enable_periph_clk(ID_CAN1);
|—————Node:call_expression Text: pmc_enable_periph_clk(ID_CAN1)
|——————Node:identifier Text: pmc_enable_periph_clk
|——————Node:argument_list Text: (ID_CAN1)
|———————Node:( Text: (
|———————Node:identifier Text: ID_CAN1
|———————Node:) Text: )
|—————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver->DisableLowPower();
|————Node:call_expression Text: m_Transceiver->DisableLowPower()
|—————Node:field_expression Text: m_Transceiver->DisableLowPower
|——————Node:identifier Text: m_Transceiver
|——————Node:-> Text: ->
|——————Node:field_identifier Text: DisableLowPower
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver->Enable();
|————Node:call_expression Text: m_Transceiver->Enable()
|—————Node:field_expression Text: m_Transceiver->Enable
|——————Node:identifier Text: m_Transceiver
|——————Node:-> Text: ->
|——————Node:field_identifier Text: Enable
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Initialize the baudrate for CAN module. */
|———Node:expression_statement Text: ul_flag = set_baudrate(ul_baudrate);
|————Node:assignment_expression Text: ul_flag = set_baudrate(ul_baudrate)
|—————Node:identifier Text: ul_flag
|—————Node:= Text: =
|—————Node:call_expression Text: set_baudrate(ul_baudrate)
|——————Node:identifier Text: set_baudrate
|——————Node:argument_list Text: (ul_baudrate)
|———————Node:( Text: (
|———————Node:identifier Text: ul_baudrate
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ul_flag == 0) {
		return 0;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_flag == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_flag == 0
|——————Node:identifier Text: ul_flag
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return 0;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Reset the CAN eight message mailbox. */
|———Node:expression_statement Text: reset_all_mailbox();
|————Node:call_expression Text: reset_all_mailbox()
|—————Node:identifier Text: reset_all_mailbox
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //Also disable all interrupts by default
|———Node:expression_statement Text: disable_interrupt(CAN_DISABLE_ALL_INTERRUPT_MASK);
|————Node:call_expression Text: disable_interrupt(CAN_DISABLE_ALL_INTERRUPT_MASK)
|—————Node:identifier Text: disable_interrupt
|—————Node:argument_list Text: (CAN_DISABLE_ALL_INTERRUPT_MASK)
|——————Node:( Text: (
|——————Node:identifier Text: CAN_DISABLE_ALL_INTERRUPT_MASK
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //By default use one mailbox for TX 
|———Node:expression_statement Text: setNumTXBoxes(1);
|————Node:call_expression Text: setNumTXBoxes(1)
|—————Node:identifier Text: setNumTXBoxes
|—————Node:argument_list Text: (1)
|——————Node:( Text: (
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Enable the CAN controller. */
|———Node:expression_statement Text: enable();
|————Node:call_expression Text: enable()
|—————Node:identifier Text: enable
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Wait until the CAN is synchronized with the bus activity. */
|———Node:expression_statement Text: ul_flag = 0;
|————Node:assignment_expression Text: ul_flag = 0
|—————Node:identifier Text: ul_flag
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: ul_tick = 0;
|————Node:assignment_expression Text: ul_tick = 0
|—————Node:identifier Text: ul_tick
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:while_statement Text: while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
		ul_flag = m_pCan->CAN_SR;
		ul_tick++;
	}
|————Node:while Text: while
|————Node:condition_clause Text: (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT))
|—————Node:( Text: (
|—————Node:binary_expression Text: !(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)
|——————Node:unary_expression Text: !(ul_flag & CAN_SR_WAKEUP)
|———————Node:! Text: !
|———————Node:parenthesized_expression Text: (ul_flag & CAN_SR_WAKEUP)
|————————Node:( Text: (
|————————Node:binary_expression Text: ul_flag & CAN_SR_WAKEUP
|—————————Node:identifier Text: ul_flag
|—————————Node:& Text: &
|—————————Node:identifier Text: CAN_SR_WAKEUP
|————————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (ul_tick < CAN_TIMEOUT)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_tick < CAN_TIMEOUT
|————————Node:identifier Text: ul_tick
|————————Node:< Text: <
|————————Node:identifier Text: CAN_TIMEOUT
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ul_flag = m_pCan->CAN_SR;
		ul_tick++;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ul_flag = m_pCan->CAN_SR;
|——————Node:assignment_expression Text: ul_flag = m_pCan->CAN_SR
|———————Node:identifier Text: ul_flag
|———————Node:= Text: =
|———————Node:field_expression Text: m_pCan->CAN_SR
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_SR
|——————Node:; Text: ;
|—————Node:expression_statement Text: ul_tick++;
|——————Node:update_expression Text: ul_tick++
|———————Node:identifier Text: ul_tick
|———————Node:++ Text: ++
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: NVIC_EnableIRQ(m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn);
|————Node:call_expression Text: NVIC_EnableIRQ(m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn)
|—————Node:identifier Text: NVIC_EnableIRQ
|—————Node:argument_list Text: (m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn)
|——————Node:( Text: (
|——————Node:conditional_expression Text: m_pCan == CAN0 ? CAN0_IRQn : CAN1_IRQn
|———————Node:binary_expression Text: m_pCan == CAN0
|————————Node:identifier Text: m_pCan
|————————Node:== Text: ==
|————————Node:identifier Text: CAN0
|———————Node:? Text: ?
|———————Node:identifier Text: CAN0_IRQn
|———————Node:: Text: :
|———————Node:identifier Text: CAN1_IRQn
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //tell the nested interrupt controller to turn on our interrupt
|———Node:comment Text: /* Timeout or the CAN module has been synchronized with the bus. */
|———Node:if_statement Text: if (CAN_TIMEOUT == ul_tick) {
		return 0;
	} else {
		return 1;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (CAN_TIMEOUT == ul_tick)
|—————Node:( Text: (
|—————Node:binary_expression Text: CAN_TIMEOUT == ul_tick
|——————Node:identifier Text: CAN_TIMEOUT
|——————Node:== Text: ==
|——————Node:identifier Text: ul_tick
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return 0;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return 0;
|——————Node:return Text: return
|——————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		return 1;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		return 1;
	}
|——————Node:{ Text: {
|——————Node:return_statement Text: return 1;
|———————Node:return Text: return
|———————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::setNumTXBoxes(int txboxes) {
	int c;

	if (txboxes > 8) txboxes = 8;
	if (txboxes < 0) txboxes = 0;
	numTXBoxes = txboxes;

	//Inialize RX boxen
	for (c = 0; c < 8 - numTXBoxes; c++) {
		mailbox_set_mode(c, CAN_MB_RX_MODE);
		mailbox_set_id(c, 0x0, false);
		mailbox_set_accept_mask(c, 0x7FF, false);
	}

	//Initialize TX boxen
	for (c = 8 - numTXBoxes; c < 8; c++) {
		mailbox_set_mode(c, CAN_MB_TX_MODE);
		mailbox_set_priority(7, 10);
		mailbox_set_accept_mask(7, 0x7FF, false);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::setNumTXBoxes(int txboxes)
|———Node:qualified_identifier Text: CANRaw::setNumTXBoxes
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: setNumTXBoxes
|———Node:parameter_list Text: (int txboxes)
|————Node:( Text: (
|————Node:parameter_declaration Text: int txboxes
|—————Node:primitive_type Text: int
|—————Node:identifier Text: txboxes
|————Node:) Text: )
|——Node:compound_statement Text: {
	int c;

	if (txboxes > 8) txboxes = 8;
	if (txboxes < 0) txboxes = 0;
	numTXBoxes = txboxes;

	//Inialize RX boxen
	for (c = 0; c < 8 - numTXBoxes; c++) {
		mailbox_set_mode(c, CAN_MB_RX_MODE);
		mailbox_set_id(c, 0x0, false);
		mailbox_set_accept_mask(c, 0x7FF, false);
	}

	//Initialize TX boxen
	for (c = 8 - numTXBoxes; c < 8; c++) {
		mailbox_set_mode(c, CAN_MB_TX_MODE);
		mailbox_set_priority(7, 10);
		mailbox_set_accept_mask(7, 0x7FF, false);
	}
}
|———Node:{ Text: {
|———Node:declaration Text: int c;
|————Node:primitive_type Text: int
|————Node:identifier Text: c
|————Node:; Text: ;
|———Node:if_statement Text: if (txboxes > 8) txboxes = 8;
|————Node:if Text: if
|————Node:condition_clause Text: (txboxes > 8)
|—————Node:( Text: (
|—————Node:binary_expression Text: txboxes > 8
|——————Node:identifier Text: txboxes
|——————Node:> Text: >
|——————Node:number_literal Text: 8
|—————Node:) Text: )
|————Node:expression_statement Text: txboxes = 8;
|—————Node:assignment_expression Text: txboxes = 8
|——————Node:identifier Text: txboxes
|——————Node:= Text: =
|——————Node:number_literal Text: 8
|—————Node:; Text: ;
|———Node:if_statement Text: if (txboxes < 0) txboxes = 0;
|————Node:if Text: if
|————Node:condition_clause Text: (txboxes < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: txboxes < 0
|——————Node:identifier Text: txboxes
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:expression_statement Text: txboxes = 0;
|—————Node:assignment_expression Text: txboxes = 0
|——————Node:identifier Text: txboxes
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:expression_statement Text: numTXBoxes = txboxes;
|————Node:assignment_expression Text: numTXBoxes = txboxes
|—————Node:identifier Text: numTXBoxes
|—————Node:= Text: =
|—————Node:identifier Text: txboxes
|————Node:; Text: ;
|———Node:comment Text: //Inialize RX boxen
|———Node:for_statement Text: for (c = 0; c < 8 - numTXBoxes; c++) {
		mailbox_set_mode(c, CAN_MB_RX_MODE);
		mailbox_set_id(c, 0x0, false);
		mailbox_set_accept_mask(c, 0x7FF, false);
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: c = 0
|—————Node:identifier Text: c
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: c < 8 - numTXBoxes
|—————Node:identifier Text: c
|—————Node:< Text: <
|—————Node:binary_expression Text: 8 - numTXBoxes
|——————Node:number_literal Text: 8
|——————Node:- Text: -
|——————Node:identifier Text: numTXBoxes
|————Node:; Text: ;
|————Node:update_expression Text: c++
|—————Node:identifier Text: c
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		mailbox_set_mode(c, CAN_MB_RX_MODE);
		mailbox_set_id(c, 0x0, false);
		mailbox_set_accept_mask(c, 0x7FF, false);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: mailbox_set_mode(c, CAN_MB_RX_MODE);
|——————Node:call_expression Text: mailbox_set_mode(c, CAN_MB_RX_MODE)
|———————Node:identifier Text: mailbox_set_mode
|———————Node:argument_list Text: (c, CAN_MB_RX_MODE)
|————————Node:( Text: (
|————————Node:identifier Text: c
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_MB_RX_MODE
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mailbox_set_id(c, 0x0, false);
|——————Node:call_expression Text: mailbox_set_id(c, 0x0, false)
|———————Node:identifier Text: mailbox_set_id
|———————Node:argument_list Text: (c, 0x0, false)
|————————Node:( Text: (
|————————Node:identifier Text: c
|————————Node:, Text: ,
|————————Node:number_literal Text: 0x0
|————————Node:, Text: ,
|————————Node:false Text: false
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mailbox_set_accept_mask(c, 0x7FF, false);
|——————Node:call_expression Text: mailbox_set_accept_mask(c, 0x7FF, false)
|———————Node:identifier Text: mailbox_set_accept_mask
|———————Node:argument_list Text: (c, 0x7FF, false)
|————————Node:( Text: (
|————————Node:identifier Text: c
|————————Node:, Text: ,
|————————Node:number_literal Text: 0x7FF
|————————Node:, Text: ,
|————————Node:false Text: false
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: //Initialize TX boxen
|———Node:for_statement Text: for (c = 8 - numTXBoxes; c < 8; c++) {
		mailbox_set_mode(c, CAN_MB_TX_MODE);
		mailbox_set_priority(7, 10);
		mailbox_set_accept_mask(7, 0x7FF, false);
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: c = 8 - numTXBoxes
|—————Node:identifier Text: c
|—————Node:= Text: =
|—————Node:binary_expression Text: 8 - numTXBoxes
|——————Node:number_literal Text: 8
|——————Node:- Text: -
|——————Node:identifier Text: numTXBoxes
|————Node:; Text: ;
|————Node:binary_expression Text: c < 8
|—————Node:identifier Text: c
|—————Node:< Text: <
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|————Node:update_expression Text: c++
|—————Node:identifier Text: c
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		mailbox_set_mode(c, CAN_MB_TX_MODE);
		mailbox_set_priority(7, 10);
		mailbox_set_accept_mask(7, 0x7FF, false);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: mailbox_set_mode(c, CAN_MB_TX_MODE);
|——————Node:call_expression Text: mailbox_set_mode(c, CAN_MB_TX_MODE)
|———————Node:identifier Text: mailbox_set_mode
|———————Node:argument_list Text: (c, CAN_MB_TX_MODE)
|————————Node:( Text: (
|————————Node:identifier Text: c
|————————Node:, Text: ,
|————————Node:identifier Text: CAN_MB_TX_MODE
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mailbox_set_priority(7, 10);
|——————Node:call_expression Text: mailbox_set_priority(7, 10)
|———————Node:identifier Text: mailbox_set_priority
|———————Node:argument_list Text: (7, 10)
|————————Node:( Text: (
|————————Node:number_literal Text: 7
|————————Node:, Text: ,
|————————Node:number_literal Text: 10
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: mailbox_set_accept_mask(7, 0x7FF, false);
|——————Node:call_expression Text: mailbox_set_accept_mask(7, 0x7FF, false)
|———————Node:identifier Text: mailbox_set_accept_mask
|———————Node:argument_list Text: (7, 0x7FF, false)
|————————Node:( Text: (
|————————Node:number_literal Text: 7
|————————Node:, Text: ,
|————————Node:number_literal Text: 0x7FF
|————————Node:, Text: ,
|————————Node:false Text: false
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller.
 *
 */
|—Node:function_definition Text: void CANRaw::enable()
{
	m_pCan->CAN_MR |= CAN_MR_CANEN;
	m_Transceiver->Enable();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable()
|———Node:qualified_identifier Text: CANRaw::enable
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_CANEN;
	m_Transceiver->Enable();
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_CANEN;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_CANEN
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_CANEN
|————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver->Enable();
|————Node:call_expression Text: m_Transceiver->Enable()
|—————Node:field_expression Text: m_Transceiver->Enable
|——————Node:identifier Text: m_Transceiver
|——————Node:-> Text: ->
|——————Node:field_identifier Text: Enable
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller.
 *
 */
|—Node:function_definition Text: void CANRaw::disable()
{
	m_pCan->CAN_MR &= ~CAN_MR_CANEN;

	m_Transceiver->EnableLowPower();
    m_Transceiver->Disable();

}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable()
|———Node:qualified_identifier Text: CANRaw::disable
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_CANEN;

	m_Transceiver->EnableLowPower();
    m_Transceiver->Disable();

}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_CANEN;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_CANEN
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_CANEN
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_CANEN
|————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver->EnableLowPower();
|————Node:call_expression Text: m_Transceiver->EnableLowPower()
|—————Node:field_expression Text: m_Transceiver->EnableLowPower
|——————Node:identifier Text: m_Transceiver
|——————Node:-> Text: ->
|——————Node:field_identifier Text: EnableLowPower
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver->Disable();
|————Node:call_expression Text: m_Transceiver->Disable()
|—————Node:field_expression Text: m_Transceiver->Disable
|——————Node:identifier Text: m_Transceiver
|——————Node:-> Text: ->
|——————Node:field_identifier Text: Disable
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller low power mode.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_low_power_mode()
{
	m_pCan->CAN_MR &= ~CAN_MR_LPM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_low_power_mode()
|———Node:qualified_identifier Text: CANRaw::disable_low_power_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_low_power_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_LPM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_LPM;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_LPM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_LPM
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_LPM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller low power mode.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_low_power_mode()
{
	m_pCan->CAN_MR |= CAN_MR_LPM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_low_power_mode()
|———Node:qualified_identifier Text: CANRaw::enable_low_power_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_low_power_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_LPM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_LPM;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_LPM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_LPM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller autobaud/listen mode.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_autobaud_listen_mode()
{
	m_pCan->CAN_MR &= ~CAN_MR_ABM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_autobaud_listen_mode()
|———Node:qualified_identifier Text: CANRaw::disable_autobaud_listen_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_autobaud_listen_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_ABM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_ABM;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_ABM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_ABM
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_ABM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller autobaud/listen mode.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_autobaud_listen_mode()
{
	m_pCan->CAN_MR |= CAN_MR_ABM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_autobaud_listen_mode()
|———Node:qualified_identifier Text: CANRaw::enable_autobaud_listen_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_autobaud_listen_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_ABM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_ABM;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_ABM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_ABM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief CAN Controller won't generate overload frame.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_overload_frame()
{
	m_pCan->CAN_MR &= ~CAN_MR_OVL;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_overload_frame()
|———Node:qualified_identifier Text: CANRaw::disable_overload_frame
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_overload_frame
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_OVL;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_OVL;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_OVL
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_OVL
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_OVL
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief CAN Controller will generate an overload frame after each successful
 * reception for mailboxes configured in Receive mode, Producer and Consumer.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_overload_frame()
{
	m_pCan->CAN_MR |= CAN_MR_OVL;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_overload_frame()
|———Node:qualified_identifier Text: CANRaw::enable_overload_frame
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_overload_frame
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_OVL;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_OVL;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_OVL
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_OVL
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Configure the timestamp capture point, at the start or the end of frame.
 *
 * \param m_pCan   Pointer to a CAN peripheral instance.
 * \param ul_flag 0: Timestamp is captured at each start of frame;
 *                1: Timestamp is captured at each end of frame.
 */
|—Node:function_definition Text: void CANRaw::set_timestamp_capture_point(uint32_t ul_flag)
{
	if (ul_flag) {
		m_pCan->CAN_MR |= CAN_MR_TEOF;
	} else {
		m_pCan->CAN_MR &= ~CAN_MR_TEOF;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::set_timestamp_capture_point(uint32_t ul_flag)
|———Node:qualified_identifier Text: CANRaw::set_timestamp_capture_point
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: set_timestamp_capture_point
|———Node:parameter_list Text: (uint32_t ul_flag)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t ul_flag
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: ul_flag
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (ul_flag) {
		m_pCan->CAN_MR |= CAN_MR_TEOF;
	} else {
		m_pCan->CAN_MR &= ~CAN_MR_TEOF;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (ul_flag) {
		m_pCan->CAN_MR |= CAN_MR_TEOF;
	} else {
		m_pCan->CAN_MR &= ~CAN_MR_TEOF;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_flag)
|—————Node:( Text: (
|—————Node:identifier Text: ul_flag
|—————Node:) Text: )
|————Node:compound_statement Text: {
		m_pCan->CAN_MR |= CAN_MR_TEOF;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_TEOF;
|——————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_TEOF
|———————Node:field_expression Text: m_pCan->CAN_MR
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MR
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN_MR_TEOF
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		m_pCan->CAN_MR &= ~CAN_MR_TEOF;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		m_pCan->CAN_MR &= ~CAN_MR_TEOF;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_TEOF;
|———————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_TEOF
|————————Node:field_expression Text: m_pCan->CAN_MR
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MR
|————————Node:&= Text: &=
|————————Node:unary_expression Text: ~CAN_MR_TEOF
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MR_TEOF
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller time triggered mode.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_time_triggered_mode()
{
	m_pCan->CAN_MR &= ~CAN_MR_TTM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_time_triggered_mode()
|———Node:qualified_identifier Text: CANRaw::disable_time_triggered_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_time_triggered_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_TTM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_TTM;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_TTM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_TTM
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_TTM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller time triggered mode.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_time_triggered_mode()
{
	m_pCan->CAN_MR |= CAN_MR_TTM;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_time_triggered_mode()
|———Node:qualified_identifier Text: CANRaw::enable_time_triggered_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_time_triggered_mode
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_TTM;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_TTM;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_TTM
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_TTM
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller timer freeze.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_timer_freeze()
{
	m_pCan->CAN_MR &= ~CAN_MR_TIMFRZ;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_timer_freeze()
|———Node:qualified_identifier Text: CANRaw::disable_timer_freeze
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_timer_freeze
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_TIMFRZ;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_TIMFRZ;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_TIMFRZ
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_TIMFRZ
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_TIMFRZ
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller timer freeze.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_timer_freeze()
{
	m_pCan->CAN_MR |= CAN_MR_TIMFRZ;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_timer_freeze()
|———Node:qualified_identifier Text: CANRaw::enable_timer_freeze
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_timer_freeze
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_TIMFRZ;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_TIMFRZ;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_TIMFRZ
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_TIMFRZ
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN Controller transmit repeat function.
 *
 */
|—Node:function_definition Text: void CANRaw::disable_tx_repeat()
{
	m_pCan->CAN_MR |= CAN_MR_DRPT;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_tx_repeat()
|———Node:qualified_identifier Text: CANRaw::disable_tx_repeat
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_tx_repeat
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR |= CAN_MR_DRPT;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR |= CAN_MR_DRPT;
|————Node:assignment_expression Text: m_pCan->CAN_MR |= CAN_MR_DRPT
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MR_DRPT
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN Controller transmit repeat function.
 *
 */
|—Node:function_definition Text: void CANRaw::enable_tx_repeat()
{
	m_pCan->CAN_MR &= ~CAN_MR_DRPT;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_tx_repeat()
|———Node:qualified_identifier Text: CANRaw::enable_tx_repeat
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_tx_repeat
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR &= ~CAN_MR_DRPT;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR &= ~CAN_MR_DRPT;
|————Node:assignment_expression Text: m_pCan->CAN_MR &= ~CAN_MR_DRPT
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~CAN_MR_DRPT
|——————Node:~ Text: ~
|——————Node:identifier Text: CAN_MR_DRPT
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Configure CAN Controller reception synchronization stage.
 *
 * \param ul_stage The reception stage to be configured.
 *
 * \note This is just for debug purpose only.
 */
|—Node:function_definition Text: void CANRaw::set_rx_sync_stage(uint32_t ul_stage)
{
	m_pCan->CAN_MR = (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk) | ul_stage;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::set_rx_sync_stage(uint32_t ul_stage)
|———Node:qualified_identifier Text: CANRaw::set_rx_sync_stage
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: set_rx_sync_stage
|———Node:parameter_list Text: (uint32_t ul_stage)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t ul_stage
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: ul_stage
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_MR = (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk) | ul_stage;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_MR = (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk) | ul_stage;
|————Node:assignment_expression Text: m_pCan->CAN_MR = (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk) | ul_stage
|—————Node:field_expression Text: m_pCan->CAN_MR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_MR
|—————Node:= Text: =
|—————Node:binary_expression Text: (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk) | ul_stage
|——————Node:parenthesized_expression Text: (m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk)
|———————Node:( Text: (
|———————Node:binary_expression Text: m_pCan->CAN_MR & ~CAN_MR_RXSYNC_Msk
|————————Node:field_expression Text: m_pCan->CAN_MR
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MR
|————————Node:& Text: &
|————————Node:unary_expression Text: ~CAN_MR_RXSYNC_Msk
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MR_RXSYNC_Msk
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:identifier Text: ul_stage
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Enable CAN interrupt.
 *
 * \param dw_mask Interrupt to be enabled.
 */
|—Node:function_definition Text: void CANRaw::enable_interrupt(uint32_t dw_mask)
{
	m_pCan->CAN_IER = dw_mask;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::enable_interrupt(uint32_t dw_mask)
|———Node:qualified_identifier Text: CANRaw::enable_interrupt
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: enable_interrupt
|———Node:parameter_list Text: (uint32_t dw_mask)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t dw_mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: dw_mask
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_IER = dw_mask;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_IER = dw_mask;
|————Node:assignment_expression Text: m_pCan->CAN_IER = dw_mask
|—————Node:field_expression Text: m_pCan->CAN_IER
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_IER
|—————Node:= Text: =
|—————Node:identifier Text: dw_mask
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Disable CAN interrupt.
 *
 * \param dw_mask Interrupt to be disabled.
 */
|—Node:function_definition Text: void CANRaw::disable_interrupt(uint32_t dw_mask)
{
	m_pCan->CAN_IDR = dw_mask;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::disable_interrupt(uint32_t dw_mask)
|———Node:qualified_identifier Text: CANRaw::disable_interrupt
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: disable_interrupt
|———Node:parameter_list Text: (uint32_t dw_mask)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t dw_mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: dw_mask
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_IDR = dw_mask;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_IDR = dw_mask;
|————Node:assignment_expression Text: m_pCan->CAN_IDR = dw_mask
|—————Node:field_expression Text: m_pCan->CAN_IDR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_IDR
|—————Node:= Text: =
|—————Node:identifier Text: dw_mask
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get CAN Interrupt Mask.
 *
 *
 * \retval CAN interrupt mask.
 */
|—Node:function_definition Text: uint32_t CANRaw::get_interrupt_mask()
{
	return (m_pCan->CAN_IMR);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::get_interrupt_mask()
|———Node:qualified_identifier Text: CANRaw::get_interrupt_mask
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_interrupt_mask
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (m_pCan->CAN_IMR);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (m_pCan->CAN_IMR);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (m_pCan->CAN_IMR)
|—————Node:( Text: (
|—————Node:field_expression Text: m_pCan->CAN_IMR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_IMR
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get CAN status.
 *
 *
 * \retval CAN status.
 */
|—Node:function_definition Text: uint32_t CANRaw::get_status()
{
	return (m_pCan->CAN_SR);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::get_status()
|———Node:qualified_identifier Text: CANRaw::get_status
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_status
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (m_pCan->CAN_SR);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (m_pCan->CAN_SR);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (m_pCan->CAN_SR)
|—————Node:( Text: (
|—————Node:field_expression Text: m_pCan->CAN_SR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_SR
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get the 16-bit free-running internal timer count.
 *
 *
 * \retval The internal CAN free-running timer counter.
 */
|—Node:function_definition Text: uint32_t CANRaw::get_internal_timer_value()
{
	return (m_pCan->CAN_TIM);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::get_internal_timer_value()
|———Node:qualified_identifier Text: CANRaw::get_internal_timer_value
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_internal_timer_value
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (m_pCan->CAN_TIM);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (m_pCan->CAN_TIM);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (m_pCan->CAN_TIM)
|—————Node:( Text: (
|—————Node:field_expression Text: m_pCan->CAN_TIM
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_TIM
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get CAN timestamp register value.
 *
 *
 * \retval The timestamp value.
 */
|—Node:function_definition Text: uint32_t CANRaw::get_timestamp_value()
{
	return (m_pCan->CAN_TIMESTP);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::get_timestamp_value()
|———Node:qualified_identifier Text: CANRaw::get_timestamp_value
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_timestamp_value
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (m_pCan->CAN_TIMESTP);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (m_pCan->CAN_TIMESTP);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (m_pCan->CAN_TIMESTP)
|—————Node:( Text: (
|—————Node:field_expression Text: m_pCan->CAN_TIMESTP
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_TIMESTP
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get CAN transmit error counter.
 *
 *
 * \retval Transmit error counter.
 */
|—Node:function_definition Text: uint8_t CANRaw::get_tx_error_cnt()
{
	return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANRaw::get_tx_error_cnt()
|———Node:qualified_identifier Text: CANRaw::get_tx_error_cnt
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_tx_error_cnt
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos);
|————Node:return Text: return
|————Node:cast_expression Text: (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos)
|—————Node:( Text: (
|—————Node:type_descriptor Text: uint8_t
|——————Node:primitive_type Text: uint8_t
|—————Node:) Text: )
|—————Node:parenthesized_expression Text: (m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos)
|——————Node:( Text: (
|——————Node:binary_expression Text: m_pCan->CAN_ECR >> CAN_ECR_TEC_Pos
|———————Node:field_expression Text: m_pCan->CAN_ECR
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_ECR
|———————Node:>> Text: >>
|———————Node:identifier Text: CAN_ECR_TEC_Pos
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get CAN receive error counter.
 *
 *
 * \retval Receive error counter.
 */
|—Node:function_definition Text: uint8_t CANRaw::get_rx_error_cnt()
{
	return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_REC_Pos);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANRaw::get_rx_error_cnt()
|———Node:qualified_identifier Text: CANRaw::get_rx_error_cnt
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_rx_error_cnt
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_REC_Pos);
}
|———Node:{ Text: {
|———Node:return_statement Text: return (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_REC_Pos);
|————Node:return Text: return
|————Node:cast_expression Text: (uint8_t) (m_pCan->CAN_ECR >> CAN_ECR_REC_Pos)
|—————Node:( Text: (
|—————Node:type_descriptor Text: uint8_t
|——————Node:primitive_type Text: uint8_t
|—————Node:) Text: )
|—————Node:parenthesized_expression Text: (m_pCan->CAN_ECR >> CAN_ECR_REC_Pos)
|——————Node:( Text: (
|——————Node:binary_expression Text: m_pCan->CAN_ECR >> CAN_ECR_REC_Pos
|———————Node:field_expression Text: m_pCan->CAN_ECR
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_ECR
|———————Node:>> Text: >>
|———————Node:identifier Text: CAN_ECR_REC_Pos
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Reset the internal free-running 16-bit timer.
 *
 *
 * \note If the internal timer counter is frozen, this function automatically
 * re-enables it.
 */
|—Node:function_definition Text: void CANRaw::reset_internal_timer()
{
	m_pCan->CAN_TCR |= CAN_TCR_TIMRST;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::reset_internal_timer()
|———Node:qualified_identifier Text: CANRaw::reset_internal_timer
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: reset_internal_timer
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan->CAN_TCR |= CAN_TCR_TIMRST;
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan->CAN_TCR |= CAN_TCR_TIMRST;
|————Node:assignment_expression Text: m_pCan->CAN_TCR |= CAN_TCR_TIMRST
|—————Node:field_expression Text: m_pCan->CAN_TCR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_TCR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_TCR_TIMRST
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Send global transfer request.
 *
 * \param uc_mask Mask for mailboxes that are requested to transfer.
 */
|—Node:function_definition Text: void CANRaw::global_send_transfer_cmd(uint8_t uc_mask)
{
	uint32_t ul_reg;

	ul_reg = m_pCan->CAN_TCR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
	m_pCan->CAN_TCR = ul_reg | uc_mask;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::global_send_transfer_cmd(uint8_t uc_mask)
|———Node:qualified_identifier Text: CANRaw::global_send_transfer_cmd
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: global_send_transfer_cmd
|———Node:parameter_list Text: (uint8_t uc_mask)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_mask
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_mask
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_reg;

	ul_reg = m_pCan->CAN_TCR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
	m_pCan->CAN_TCR = ul_reg | uc_mask;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_reg;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_reg
|————Node:; Text: ;
|———Node:expression_statement Text: ul_reg = m_pCan->CAN_TCR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
|————Node:assignment_expression Text: ul_reg = m_pCan->CAN_TCR & ((uint32_t)~GLOBAL_MAILBOX_MASK)
|—————Node:identifier Text: ul_reg
|—————Node:= Text: =
|—————Node:binary_expression Text: m_pCan->CAN_TCR & ((uint32_t)~GLOBAL_MAILBOX_MASK)
|——————Node:field_expression Text: m_pCan->CAN_TCR
|———————Node:identifier Text: m_pCan
|———————Node:-> Text: ->
|———————Node:field_identifier Text: CAN_TCR
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: ((uint32_t)~GLOBAL_MAILBOX_MASK)
|———————Node:( Text: (
|———————Node:cast_expression Text: (uint32_t)~GLOBAL_MAILBOX_MASK
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint32_t
|—————————Node:primitive_type Text: uint32_t
|————————Node:) Text: )
|————————Node:unary_expression Text: ~GLOBAL_MAILBOX_MASK
|—————————Node:~ Text: ~
|—————————Node:identifier Text: GLOBAL_MAILBOX_MASK
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_TCR = ul_reg | uc_mask;
|————Node:assignment_expression Text: m_pCan->CAN_TCR = ul_reg | uc_mask
|—————Node:field_expression Text: m_pCan->CAN_TCR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_TCR
|—————Node:= Text: =
|—————Node:binary_expression Text: ul_reg | uc_mask
|——————Node:identifier Text: ul_reg
|——————Node:| Text: |
|——————Node:identifier Text: uc_mask
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Send global abort request.
 *
 * \param uc_mask Mask for mailboxes that are requested to abort.
 */
|—Node:function_definition Text: void CANRaw::global_send_abort_cmd(uint8_t uc_mask)
{
	uint32_t ul_reg;
	
	ul_reg = m_pCan->CAN_ACR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
	m_pCan->CAN_ACR = ul_reg | uc_mask;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::global_send_abort_cmd(uint8_t uc_mask)
|———Node:qualified_identifier Text: CANRaw::global_send_abort_cmd
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: global_send_abort_cmd
|———Node:parameter_list Text: (uint8_t uc_mask)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_mask
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_mask
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_reg;
	
	ul_reg = m_pCan->CAN_ACR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
	m_pCan->CAN_ACR = ul_reg | uc_mask;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_reg;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_reg
|————Node:; Text: ;
|———Node:expression_statement Text: ul_reg = m_pCan->CAN_ACR & ((uint32_t)~GLOBAL_MAILBOX_MASK);
|————Node:assignment_expression Text: ul_reg = m_pCan->CAN_ACR & ((uint32_t)~GLOBAL_MAILBOX_MASK)
|—————Node:identifier Text: ul_reg
|—————Node:= Text: =
|—————Node:binary_expression Text: m_pCan->CAN_ACR & ((uint32_t)~GLOBAL_MAILBOX_MASK)
|——————Node:field_expression Text: m_pCan->CAN_ACR
|———————Node:identifier Text: m_pCan
|———————Node:-> Text: ->
|———————Node:field_identifier Text: CAN_ACR
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: ((uint32_t)~GLOBAL_MAILBOX_MASK)
|———————Node:( Text: (
|———————Node:cast_expression Text: (uint32_t)~GLOBAL_MAILBOX_MASK
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint32_t
|—————————Node:primitive_type Text: uint32_t
|————————Node:) Text: )
|————————Node:unary_expression Text: ~GLOBAL_MAILBOX_MASK
|—————————Node:~ Text: ~
|—————————Node:identifier Text: GLOBAL_MAILBOX_MASK
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_ACR = ul_reg | uc_mask;
|————Node:assignment_expression Text: m_pCan->CAN_ACR = ul_reg | uc_mask
|—————Node:field_expression Text: m_pCan->CAN_ACR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_ACR
|—————Node:= Text: =
|—————Node:binary_expression Text: ul_reg | uc_mask
|——————Node:identifier Text: ul_reg
|——————Node:| Text: |
|——————Node:identifier Text: uc_mask
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Configure the timemark for the mailbox.
 *
 * \param uc_index Indicate which mailbox is to be configured.
 * \param us_cnt   The timemark to be set.
 *
 * \note The timemark is active in Time Triggered mode only.
 */
|—Node:function_definition Text: void CANRaw::mailbox_set_timemark(uint8_t uc_index, uint16_t us_cnt)
{
	uint32_t ul_reg;
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	ul_reg = m_pCan->CAN_MB[uc_index].CAN_MMR & ((uint32_t)~TIMEMARK_MASK);
	m_pCan->CAN_MB[uc_index].CAN_MMR = ul_reg | us_cnt;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_timemark(uint8_t uc_index, uint16_t us_cnt)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_timemark
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_timemark
|———Node:parameter_list Text: (uint8_t uc_index, uint16_t us_cnt)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint16_t us_cnt
|—————Node:primitive_type Text: uint16_t
|—————Node:identifier Text: us_cnt
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_reg;
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	ul_reg = m_pCan->CAN_MB[uc_index].CAN_MMR & ((uint32_t)~TIMEMARK_MASK);
	m_pCan->CAN_MB[uc_index].CAN_MMR = ul_reg | us_cnt;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_reg;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_reg
|————Node:; Text: ;
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: ul_reg = m_pCan->CAN_MB[uc_index].CAN_MMR & ((uint32_t)~TIMEMARK_MASK);
|————Node:assignment_expression Text: ul_reg = m_pCan->CAN_MB[uc_index].CAN_MMR & ((uint32_t)~TIMEMARK_MASK)
|—————Node:identifier Text: ul_reg
|—————Node:= Text: =
|—————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR & ((uint32_t)~TIMEMARK_MASK)
|——————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|———————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|————————Node:field_expression Text: m_pCan->CAN_MB
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MB
|————————Node:subscript_argument_list Text: [uc_index]
|—————————Node:[ Text: [
|—————————Node:identifier Text: uc_index
|—————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: CAN_MMR
|——————Node:& Text: &
|——————Node:parenthesized_expression Text: ((uint32_t)~TIMEMARK_MASK)
|———————Node:( Text: (
|———————Node:cast_expression Text: (uint32_t)~TIMEMARK_MASK
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint32_t
|—————————Node:primitive_type Text: uint32_t
|————————Node:) Text: )
|————————Node:unary_expression Text: ~TIMEMARK_MASK
|—————————Node:~ Text: ~
|—————————Node:identifier Text: TIMEMARK_MASK
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MMR = ul_reg | us_cnt;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR = ul_reg | us_cnt
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MMR
|—————Node:= Text: =
|—————Node:binary_expression Text: ul_reg | us_cnt
|——————Node:identifier Text: ul_reg
|——————Node:| Text: |
|——————Node:identifier Text: us_cnt
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Get status of the mailbox.
 *
 * \param uc_index Indicate which mailbox is to be read.
 *
 * \retval The mailbox status.
 */
|—Node:function_definition Text: uint32_t CANRaw::mailbox_get_status(uint8_t uc_index)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	return (m_pCan->CAN_MB[uc_index].CAN_MSR);
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::mailbox_get_status(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_get_status
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_get_status
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	return (m_pCan->CAN_MB[uc_index].CAN_MSR);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:return_statement Text: return (m_pCan->CAN_MB[uc_index].CAN_MSR);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MSR)
|—————Node:( Text: (
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MSR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MSR
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Send single mailbox transfer request.
 *
 * \param uc_index Indicate which mailbox is to be configured.
 */
|—Node:function_definition Text: void CANRaw::mailbox_send_transfer_cmd(uint8_t uc_index)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MTCR;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_send_transfer_cmd(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_send_transfer_cmd
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_send_transfer_cmd
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MTCR;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MTCR;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MTCR
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MCR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MCR_MTCR
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Send single mailbox abort request.
 *
 * \param uc_index Indicate which mailbox is to be configured.
 */
|—Node:function_definition Text: void CANRaw::mailbox_send_abort_cmd(uint8_t uc_index)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MACR;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_send_abort_cmd(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_send_abort_cmd
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_send_abort_cmd
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MACR;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MACR;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MACR
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MCR
|—————Node:|= Text: |=
|—————Node:identifier Text: CAN_MCR_MACR
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Initialize the mailbox to a default, known state.
 *
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
|—Node:function_definition Text: void CANRaw::mailbox_init(uint8_t uc_index)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MMR = 0;
	m_pCan->CAN_MB[uc_index].CAN_MAM = 0;
	m_pCan->CAN_MB[uc_index].CAN_MID = 0;
	m_pCan->CAN_MB[uc_index].CAN_MDL = 0;
	m_pCan->CAN_MB[uc_index].CAN_MDH = 0;
	m_pCan->CAN_MB[uc_index].CAN_MCR = 0;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_init(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_init
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_init
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MMR = 0;
	m_pCan->CAN_MB[uc_index].CAN_MAM = 0;
	m_pCan->CAN_MB[uc_index].CAN_MID = 0;
	m_pCan->CAN_MB[uc_index].CAN_MDL = 0;
	m_pCan->CAN_MB[uc_index].CAN_MDH = 0;
	m_pCan->CAN_MB[uc_index].CAN_MCR = 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MMR = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MMR
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MAM = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MAM
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MID = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MID
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDL = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDL
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDH = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDH
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MCR = 0;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR = 0
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MCR
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Reset the eight mailboxes.
 *
 * \param m_pCan Pointer to a CAN peripheral instance.
 */
|—Node:function_definition Text: void CANRaw::reset_all_mailbox()
{
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {		
		mailbox_init(i);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::reset_all_mailbox()
|———Node:qualified_identifier Text: CANRaw::reset_all_mailbox
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: reset_all_mailbox
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {		
		mailbox_init(i);
	}
}
|———Node:{ Text: {
|———Node:for_statement Text: for (uint8_t i = 0; i < CANMB_NUMBER; i++) {		
		mailbox_init(i);
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: uint8_t i = 0;
|—————Node:primitive_type Text: uint8_t
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < CANMB_NUMBER
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:identifier Text: CANMB_NUMBER
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {		
		mailbox_init(i);
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: mailbox_init(i);
|——————Node:call_expression Text: mailbox_init(i)
|———————Node:identifier Text: mailbox_init
|———————Node:argument_list Text: (i)
|————————Node:( Text: (
|————————Node:identifier Text: i
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*
Does one of two things, either sends the given frame out on the first
TX mailbox that's open or queues the frame for sending later via interrupts.
This vastly simplifies the sending of frames - It does, however, assume
that you're going to use interrupt driven transmission - It forces it really.
*/
|—Node:function_definition Text: void CANRaw::sendFrame(CAN_FRAME& txFrame) 
{
	bool foundTX = false;
	for (int i = 0; i < 8; i++) {
		if (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
		{//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
	}
	if (!foundTX) //there was no open TX boxes. Queue it.
	{
		tx_frame_buff[tx_buffer_tail].id = txFrame.id;
		tx_frame_buff[tx_buffer_tail].extended = txFrame.extended;
		tx_frame_buff[tx_buffer_tail].length = txFrame.length;
		tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value;
		tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER;
		return;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::sendFrame(CAN_FRAME& txFrame)
|———Node:qualified_identifier Text: CANRaw::sendFrame
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: sendFrame
|———Node:parameter_list Text: (CAN_FRAME& txFrame)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_FRAME& txFrame
|—————Node:type_identifier Text: CAN_FRAME
|—————Node:reference_declarator Text: & txFrame
|——————Node:& Text: &
|——————Node:identifier Text: txFrame
|————Node:) Text: )
|——Node:compound_statement Text: {
	bool foundTX = false;
	for (int i = 0; i < 8; i++) {
		if (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
		{//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
	}
	if (!foundTX) //there was no open TX boxes. Queue it.
	{
		tx_frame_buff[tx_buffer_tail].id = txFrame.id;
		tx_frame_buff[tx_buffer_tail].extended = txFrame.extended;
		tx_frame_buff[tx_buffer_tail].length = txFrame.length;
		tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value;
		tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER;
		return;
	}
}
|———Node:{ Text: {
|———Node:declaration Text: bool foundTX = false;
|————Node:primitive_type Text: bool
|————Node:init_declarator Text: foundTX = false
|—————Node:identifier Text: foundTX
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:for_statement Text: for (int i = 0; i < 8; i++) {
		if (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
		{//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int i = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: i < 8
|—————Node:identifier Text: i
|—————Node:< Text: <
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|————Node:update_expression Text: i++
|—————Node:identifier Text: i
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		if (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
		{//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
		{//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE)
|———————Node:( Text: (
|———————Node:binary_expression Text: ((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7) == CAN_MB_TX_MODE
|————————Node:parenthesized_expression Text: ((m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (m_pCan->CAN_MB[i].CAN_MMR >> 24) & 7
|——————————Node:parenthesized_expression Text: (m_pCan->CAN_MB[i].CAN_MMR >> 24)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: m_pCan->CAN_MB[i].CAN_MMR >> 24
|————————————Node:field_expression Text: m_pCan->CAN_MB[i].CAN_MMR
|—————————————Node:subscript_expression Text: m_pCan->CAN_MB[i]
|——————————————Node:field_expression Text: m_pCan->CAN_MB
|———————————————Node:identifier Text: m_pCan
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: CAN_MB
|——————————————Node:subscript_argument_list Text: [i]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: i
|———————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: CAN_MMR
|————————————Node:>> Text: >>
|————————————Node:number_literal Text: 24
|———————————Node:) Text: )
|——————————Node:& Text: &
|——————————Node:number_literal Text: 7
|—————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:identifier Text: CAN_MB_TX_MODE
|———————Node:) Text: )
|——————Node:compound_statement Text: {//is this mailbox set up as a TX box?
			if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
		}
|———————Node:{ Text: {
|———————Node:comment Text: //is this mailbox set up as a TX box?
|———————Node:if_statement Text: if (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY) 
			{//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: m_pCan->CAN_MB[i].CAN_MSR & CAN_MSR_MRDY
|——————————Node:field_expression Text: m_pCan->CAN_MB[i].CAN_MSR
|———————————Node:subscript_expression Text: m_pCan->CAN_MB[i]
|————————————Node:field_expression Text: m_pCan->CAN_MB
|—————————————Node:identifier Text: m_pCan
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: CAN_MB
|————————————Node:subscript_argument_list Text: [i]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: i
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: CAN_MSR
|——————————Node:& Text: &
|——————————Node:identifier Text: CAN_MSR_MRDY
|—————————Node:) Text: )
|————————Node:compound_statement Text: {//is it also available (not sending anything?)
				foundTX = true;
				mailbox_set_id(i, txFrame.id, txFrame.extended);
				mailbox_set_datalen(i, txFrame.length);
				mailbox_set_priority(i, txFrame.priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
				enable_interrupt(0x01u << i); //enable the TX interrupt for this box
				global_send_transfer_cmd((0x1u << i));
				return; //we've sent it. mission accomplished.
			}
|—————————Node:{ Text: {
|—————————Node:comment Text: //is it also available (not sending anything?)
|—————————Node:expression_statement Text: foundTX = true;
|——————————Node:assignment_expression Text: foundTX = true
|———————————Node:identifier Text: foundTX
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: mailbox_set_id(i, txFrame.id, txFrame.extended);
|——————————Node:call_expression Text: mailbox_set_id(i, txFrame.id, txFrame.extended)
|———————————Node:identifier Text: mailbox_set_id
|———————————Node:argument_list Text: (i, txFrame.id, txFrame.extended)
|————————————Node:( Text: (
|————————————Node:identifier Text: i
|————————————Node:, Text: ,
|————————————Node:field_expression Text: txFrame.id
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: id
|————————————Node:, Text: ,
|————————————Node:field_expression Text: txFrame.extended
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: extended
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: mailbox_set_datalen(i, txFrame.length);
|——————————Node:call_expression Text: mailbox_set_datalen(i, txFrame.length)
|———————————Node:identifier Text: mailbox_set_datalen
|———————————Node:argument_list Text: (i, txFrame.length)
|————————————Node:( Text: (
|————————————Node:identifier Text: i
|————————————Node:, Text: ,
|————————————Node:field_expression Text: txFrame.length
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: length
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: mailbox_set_priority(i, txFrame.priority);
|——————————Node:call_expression Text: mailbox_set_priority(i, txFrame.priority)
|———————————Node:identifier Text: mailbox_set_priority
|———————————Node:argument_list Text: (i, txFrame.priority)
|————————————Node:( Text: (
|————————————Node:identifier Text: i
|————————————Node:, Text: ,
|————————————Node:field_expression Text: txFrame.priority
|—————————————Node:identifier Text: txFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: priority
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:for_statement Text: for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
|——————————Node:for Text: for
|——————————Node:( Text: (
|——————————Node:declaration Text: uint8_t cnt = 0;
|———————————Node:primitive_type Text: uint8_t
|———————————Node:init_declarator Text: cnt = 0
|————————————Node:identifier Text: cnt
|————————————Node:= Text: =
|————————————Node:number_literal Text: 0
|———————————Node:; Text: ;
|——————————Node:binary_expression Text: cnt < 8
|———————————Node:identifier Text: cnt
|———————————Node:< Text: <
|———————————Node:number_literal Text: 8
|——————————Node:; Text: ;
|——————————Node:update_expression Text: cnt++
|———————————Node:identifier Text: cnt
|———————————Node:++ Text: ++
|——————————Node:) Text: )
|——————————Node:expression_statement Text: mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt]);
|———————————Node:call_expression Text: mailbox_set_databyte(i, cnt, txFrame.data.bytes[cnt])
|————————————Node:identifier Text: mailbox_set_databyte
|————————————Node:argument_list Text: (i, cnt, txFrame.data.bytes[cnt])
|—————————————Node:( Text: (
|—————————————Node:identifier Text: i
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: cnt
|—————————————Node:, Text: ,
|—————————————Node:subscript_expression Text: txFrame.data.bytes[cnt]
|——————————————Node:field_expression Text: txFrame.data.bytes
|———————————————Node:field_expression Text: txFrame.data
|————————————————Node:identifier Text: txFrame
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: data
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: bytes
|——————————————Node:subscript_argument_list Text: [cnt]
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: cnt
|———————————————Node:] Text: ]
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|—————————Node:expression_statement Text: enable_interrupt(0x01u << i);
|——————————Node:call_expression Text: enable_interrupt(0x01u << i)
|———————————Node:identifier Text: enable_interrupt
|———————————Node:argument_list Text: (0x01u << i)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: 0x01u << i
|—————————————Node:number_literal Text: 0x01u
|—————————————Node:<< Text: <<
|—————————————Node:identifier Text: i
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:comment Text: //enable the TX interrupt for this box
|—————————Node:expression_statement Text: global_send_transfer_cmd((0x1u << i));
|——————————Node:call_expression Text: global_send_transfer_cmd((0x1u << i))
|———————————Node:identifier Text: global_send_transfer_cmd
|———————————Node:argument_list Text: ((0x1u << i))
|————————————Node:( Text: (
|————————————Node:parenthesized_expression Text: (0x1u << i)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: 0x1u << i
|——————————————Node:number_literal Text: 0x1u
|——————————————Node:<< Text: <<
|——————————————Node:identifier Text: i
|—————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return;
|——————————Node:return Text: return
|——————————Node:; Text: ;
|—————————Node:comment Text: //we've sent it. mission accomplished.
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:if_statement Text: if (!foundTX) //there was no open TX boxes. Queue it.
	{
		tx_frame_buff[tx_buffer_tail].id = txFrame.id;
		tx_frame_buff[tx_buffer_tail].extended = txFrame.extended;
		tx_frame_buff[tx_buffer_tail].length = txFrame.length;
		tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value;
		tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER;
		return;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (!foundTX)
|—————Node:( Text: (
|—————Node:unary_expression Text: !foundTX
|——————Node:! Text: !
|——————Node:identifier Text: foundTX
|—————Node:) Text: )
|————Node:comment Text: //there was no open TX boxes. Queue it.
|————Node:compound_statement Text: {
		tx_frame_buff[tx_buffer_tail].id = txFrame.id;
		tx_frame_buff[tx_buffer_tail].extended = txFrame.extended;
		tx_frame_buff[tx_buffer_tail].length = txFrame.length;
		tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value;
		tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER;
		return;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: tx_frame_buff[tx_buffer_tail].id = txFrame.id;
|——————Node:assignment_expression Text: tx_frame_buff[tx_buffer_tail].id = txFrame.id
|———————Node:field_expression Text: tx_frame_buff[tx_buffer_tail].id
|————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_tail]
|—————————Node:identifier Text: tx_frame_buff
|—————————Node:subscript_argument_list Text: [tx_buffer_tail]
|——————————Node:[ Text: [
|——————————Node:identifier Text: tx_buffer_tail
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:field_expression Text: txFrame.id
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|——————Node:; Text: ;
|—————Node:expression_statement Text: tx_frame_buff[tx_buffer_tail].extended = txFrame.extended;
|——————Node:assignment_expression Text: tx_frame_buff[tx_buffer_tail].extended = txFrame.extended
|———————Node:field_expression Text: tx_frame_buff[tx_buffer_tail].extended
|————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_tail]
|—————————Node:identifier Text: tx_frame_buff
|—————————Node:subscript_argument_list Text: [tx_buffer_tail]
|——————————Node:[ Text: [
|——————————Node:identifier Text: tx_buffer_tail
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: extended
|———————Node:= Text: =
|———————Node:field_expression Text: txFrame.extended
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: extended
|——————Node:; Text: ;
|—————Node:expression_statement Text: tx_frame_buff[tx_buffer_tail].length = txFrame.length;
|——————Node:assignment_expression Text: tx_frame_buff[tx_buffer_tail].length = txFrame.length
|———————Node:field_expression Text: tx_frame_buff[tx_buffer_tail].length
|————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_tail]
|—————————Node:identifier Text: tx_frame_buff
|—————————Node:subscript_argument_list Text: [tx_buffer_tail]
|——————————Node:[ Text: [
|——————————Node:identifier Text: tx_buffer_tail
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: length
|———————Node:= Text: =
|———————Node:field_expression Text: txFrame.length
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: length
|——————Node:; Text: ;
|—————Node:expression_statement Text: tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value;
|——————Node:assignment_expression Text: tx_frame_buff[tx_buffer_tail].data.value = txFrame.data.value
|———————Node:field_expression Text: tx_frame_buff[tx_buffer_tail].data.value
|————————Node:field_expression Text: tx_frame_buff[tx_buffer_tail].data
|—————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_tail]
|——————————Node:identifier Text: tx_frame_buff
|——————————Node:subscript_argument_list Text: [tx_buffer_tail]
|———————————Node:[ Text: [
|———————————Node:identifier Text: tx_buffer_tail
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: data
|————————Node:. Text: .
|————————Node:field_identifier Text: value
|———————Node:= Text: =
|———————Node:field_expression Text: txFrame.data.value
|————————Node:field_expression Text: txFrame.data
|—————————Node:identifier Text: txFrame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: data
|————————Node:. Text: .
|————————Node:field_identifier Text: value
|——————Node:; Text: ;
|—————Node:expression_statement Text: tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER;
|——————Node:assignment_expression Text: tx_buffer_tail = (tx_buffer_tail + 1) % SIZE_TX_BUFFER
|———————Node:identifier Text: tx_buffer_tail
|———————Node:= Text: =
|———————Node:binary_expression Text: (tx_buffer_tail + 1) % SIZE_TX_BUFFER
|————————Node:parenthesized_expression Text: (tx_buffer_tail + 1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: tx_buffer_tail + 1
|——————————Node:identifier Text: tx_buffer_tail
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|————————Node:% Text: %
|————————Node:identifier Text: SIZE_TX_BUFFER
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
 * \brief Read a frame from out of the mailbox and into a software buffer
 *
 * \param uc_index which mailbox to read
 * \param rxframe Pointer to a receive frame structure which we'll fill out
 *
 * \retval Different CAN mailbox transfer status.
 *
 */
|—Node:function_definition Text: uint32_t CANRaw::mailbox_read(uint8_t uc_index, volatile CAN_FRAME *rxframe)
{
	uint32_t ul_status;
	uint32_t ul_retval;
	uint32_t ul_id;
	uint32_t ul_datal, ul_datah;

	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;

	ul_retval = 0;
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;

	/* Check whether there is overwriting happening in Receive with Overwrite mode,
	   or there're messages lost in Receive mode. */
	if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
		ul_retval = CAN_MAILBOX_RX_OVER;
	}

	ul_id = m_pCan->CAN_MB[uc_index].CAN_MID;
	if ((ul_id & CAN_MID_MIDE) == CAN_MID_MIDE) { //extended id
		rxframe->id = ul_id & 0x1FFFFFFFu;
		rxframe->extended = true;
	}
	else { //standard ID
		rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
		rxframe->extended = false;
	}
	rxframe->fid = m_pCan->CAN_MB[uc_index].CAN_MFID;
	rxframe->length = (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
	ul_datal = m_pCan->CAN_MB[uc_index].CAN_MDL;
	ul_datah = m_pCan->CAN_MB[uc_index].CAN_MDH;

	rxframe->data.high = ul_datah;
	rxframe->data.low = ul_datal;

	/* Read the mailbox status again to check whether the software needs to re-read mailbox data register. */
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;	
	if (ul_status & CAN_MSR_MMI) {
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}

	/* Enable next receive process. */
	mailbox_send_transfer_cmd(uc_index);

	return ul_retval;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::mailbox_read(uint8_t uc_index, volatile CAN_FRAME *rxframe)
|———Node:qualified_identifier Text: CANRaw::mailbox_read
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_read
|———Node:parameter_list Text: (uint8_t uc_index, volatile CAN_FRAME *rxframe)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: volatile CAN_FRAME *rxframe
|—————Node:type_qualifier Text: volatile
|——————Node:volatile Text: volatile
|—————Node:type_identifier Text: CAN_FRAME
|—————Node:pointer_declarator Text: *rxframe
|——————Node:* Text: *
|——————Node:identifier Text: rxframe
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_status;
	uint32_t ul_retval;
	uint32_t ul_id;
	uint32_t ul_datal, ul_datah;

	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;

	ul_retval = 0;
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;

	/* Check whether there is overwriting happening in Receive with Overwrite mode,
	   or there're messages lost in Receive mode. */
	if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
		ul_retval = CAN_MAILBOX_RX_OVER;
	}

	ul_id = m_pCan->CAN_MB[uc_index].CAN_MID;
	if ((ul_id & CAN_MID_MIDE) == CAN_MID_MIDE) { //extended id
		rxframe->id = ul_id & 0x1FFFFFFFu;
		rxframe->extended = true;
	}
	else { //standard ID
		rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
		rxframe->extended = false;
	}
	rxframe->fid = m_pCan->CAN_MB[uc_index].CAN_MFID;
	rxframe->length = (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
	ul_datal = m_pCan->CAN_MB[uc_index].CAN_MDL;
	ul_datah = m_pCan->CAN_MB[uc_index].CAN_MDH;

	rxframe->data.high = ul_datah;
	rxframe->data.low = ul_datal;

	/* Read the mailbox status again to check whether the software needs to re-read mailbox data register. */
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;	
	if (ul_status & CAN_MSR_MMI) {
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}

	/* Enable next receive process. */
	mailbox_send_transfer_cmd(uc_index);

	return ul_retval;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_status;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_status
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_retval;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_retval
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_id;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_id
|————Node:; Text: ;
|———Node:declaration Text: uint32_t ul_datal, ul_datah;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_datal
|————Node:, Text: ,
|————Node:identifier Text: ul_datah
|————Node:; Text: ;
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: ul_retval = 0;
|————Node:assignment_expression Text: ul_retval = 0
|—————Node:identifier Text: ul_retval
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;
|————Node:assignment_expression Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR
|—————Node:identifier Text: ul_status
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MSR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MSR
|————Node:; Text: ;
|———Node:comment Text: /* Check whether there is overwriting happening in Receive with Overwrite mode,
	   or there're messages lost in Receive mode. */
|———Node:if_statement Text: if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
		ul_retval = CAN_MAILBOX_RX_OVER;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI))
|—————Node:( Text: (
|—————Node:binary_expression Text: (ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)
|——————Node:parenthesized_expression Text: (ul_status & CAN_MSR_MRDY)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_status & CAN_MSR_MRDY
|————————Node:identifier Text: ul_status
|————————Node:& Text: &
|————————Node:identifier Text: CAN_MSR_MRDY
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (ul_status & CAN_MSR_MMI)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_status & CAN_MSR_MMI
|————————Node:identifier Text: ul_status
|————————Node:& Text: &
|————————Node:identifier Text: CAN_MSR_MMI
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ul_retval = CAN_MAILBOX_RX_OVER;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ul_retval = CAN_MAILBOX_RX_OVER;
|——————Node:assignment_expression Text: ul_retval = CAN_MAILBOX_RX_OVER
|———————Node:identifier Text: ul_retval
|———————Node:= Text: =
|———————Node:identifier Text: CAN_MAILBOX_RX_OVER
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ul_id = m_pCan->CAN_MB[uc_index].CAN_MID;
|————Node:assignment_expression Text: ul_id = m_pCan->CAN_MB[uc_index].CAN_MID
|—————Node:identifier Text: ul_id
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MID
|————Node:; Text: ;
|———Node:if_statement Text: if ((ul_id & CAN_MID_MIDE) == CAN_MID_MIDE) { //extended id
		rxframe->id = ul_id & 0x1FFFFFFFu;
		rxframe->extended = true;
	}
	else { //standard ID
		rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
		rxframe->extended = false;
	}
|————Node:if Text: if
|————Node:condition_clause Text: ((ul_id & CAN_MID_MIDE) == CAN_MID_MIDE)
|—————Node:( Text: (
|—————Node:binary_expression Text: (ul_id & CAN_MID_MIDE) == CAN_MID_MIDE
|——————Node:parenthesized_expression Text: (ul_id & CAN_MID_MIDE)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_id & CAN_MID_MIDE
|————————Node:identifier Text: ul_id
|————————Node:& Text: &
|————————Node:identifier Text: CAN_MID_MIDE
|———————Node:) Text: )
|——————Node:== Text: ==
|——————Node:identifier Text: CAN_MID_MIDE
|—————Node:) Text: )
|————Node:compound_statement Text: { //extended id
		rxframe->id = ul_id & 0x1FFFFFFFu;
		rxframe->extended = true;
	}
|—————Node:{ Text: {
|—————Node:comment Text: //extended id
|—————Node:expression_statement Text: rxframe->id = ul_id & 0x1FFFFFFFu;
|——————Node:assignment_expression Text: rxframe->id = ul_id & 0x1FFFFFFFu
|———————Node:field_expression Text: rxframe->id
|————————Node:identifier Text: rxframe
|————————Node:-> Text: ->
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: ul_id & 0x1FFFFFFFu
|————————Node:identifier Text: ul_id
|————————Node:& Text: &
|————————Node:number_literal Text: 0x1FFFFFFFu
|——————Node:; Text: ;
|—————Node:expression_statement Text: rxframe->extended = true;
|——————Node:assignment_expression Text: rxframe->extended = true
|———————Node:field_expression Text: rxframe->extended
|————————Node:identifier Text: rxframe
|————————Node:-> Text: ->
|————————Node:field_identifier Text: extended
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else { //standard ID
		rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
		rxframe->extended = false;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: { //standard ID
		rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
		rxframe->extended = false;
	}
|——————Node:{ Text: {
|——————Node:comment Text: //standard ID
|——————Node:expression_statement Text: rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu;
|———————Node:assignment_expression Text: rxframe->id = (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu
|————————Node:field_expression Text: rxframe->id
|—————————Node:identifier Text: rxframe
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: id
|————————Node:= Text: =
|————————Node:binary_expression Text: (ul_id  >> CAN_MID_MIDvA_Pos) & 0x7ffu
|—————————Node:parenthesized_expression Text: (ul_id  >> CAN_MID_MIDvA_Pos)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ul_id  >> CAN_MID_MIDvA_Pos
|———————————Node:identifier Text: ul_id
|———————————Node:>> Text: >>
|———————————Node:identifier Text: CAN_MID_MIDvA_Pos
|——————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:number_literal Text: 0x7ffu
|———————Node:; Text: ;
|——————Node:expression_statement Text: rxframe->extended = false;
|———————Node:assignment_expression Text: rxframe->extended = false
|————————Node:field_expression Text: rxframe->extended
|—————————Node:identifier Text: rxframe
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: extended
|————————Node:= Text: =
|————————Node:false Text: false
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:expression_statement Text: rxframe->fid = m_pCan->CAN_MB[uc_index].CAN_MFID;
|————Node:assignment_expression Text: rxframe->fid = m_pCan->CAN_MB[uc_index].CAN_MFID
|—————Node:field_expression Text: rxframe->fid
|——————Node:identifier Text: rxframe
|——————Node:-> Text: ->
|——————Node:field_identifier Text: fid
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MFID
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MFID
|————Node:; Text: ;
|———Node:expression_statement Text: rxframe->length = (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
|————Node:assignment_expression Text: rxframe->length = (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos
|—————Node:field_expression Text: rxframe->length
|——————Node:identifier Text: rxframe
|——————Node:-> Text: ->
|——————Node:field_identifier Text: length
|—————Node:= Text: =
|—————Node:binary_expression Text: (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos
|——————Node:parenthesized_expression Text: (ul_status & CAN_MSR_MDLC_Msk)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_status & CAN_MSR_MDLC_Msk
|————————Node:identifier Text: ul_status
|————————Node:& Text: &
|————————Node:identifier Text: CAN_MSR_MDLC_Msk
|———————Node:) Text: )
|——————Node:>> Text: >>
|——————Node:identifier Text: CAN_MSR_MDLC_Pos
|————Node:; Text: ;
|———Node:expression_statement Text: ul_datal = m_pCan->CAN_MB[uc_index].CAN_MDL;
|————Node:assignment_expression Text: ul_datal = m_pCan->CAN_MB[uc_index].CAN_MDL
|—————Node:identifier Text: ul_datal
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDL
|————Node:; Text: ;
|———Node:expression_statement Text: ul_datah = m_pCan->CAN_MB[uc_index].CAN_MDH;
|————Node:assignment_expression Text: ul_datah = m_pCan->CAN_MB[uc_index].CAN_MDH
|—————Node:identifier Text: ul_datah
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDH
|————Node:; Text: ;
|———Node:expression_statement Text: rxframe->data.high = ul_datah;
|————Node:assignment_expression Text: rxframe->data.high = ul_datah
|—————Node:field_expression Text: rxframe->data.high
|——————Node:field_expression Text: rxframe->data
|———————Node:identifier Text: rxframe
|———————Node:-> Text: ->
|———————Node:field_identifier Text: data
|——————Node:. Text: .
|——————Node:field_identifier Text: high
|—————Node:= Text: =
|—————Node:identifier Text: ul_datah
|————Node:; Text: ;
|———Node:expression_statement Text: rxframe->data.low = ul_datal;
|————Node:assignment_expression Text: rxframe->data.low = ul_datal
|—————Node:field_expression Text: rxframe->data.low
|——————Node:field_expression Text: rxframe->data
|———————Node:identifier Text: rxframe
|———————Node:-> Text: ->
|———————Node:field_identifier Text: data
|——————Node:. Text: .
|——————Node:field_identifier Text: low
|—————Node:= Text: =
|—————Node:identifier Text: ul_datal
|————Node:; Text: ;
|———Node:comment Text: /* Read the mailbox status again to check whether the software needs to re-read mailbox data register. */
|———Node:expression_statement Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;
|————Node:assignment_expression Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR
|—————Node:identifier Text: ul_status
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MSR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MSR
|————Node:; Text: ;
|———Node:if_statement Text: if (ul_status & CAN_MSR_MMI) {
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_MSR_MMI)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_MSR_MMI
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_MSR_MMI
|—————Node:) Text: )
|————Node:compound_statement Text: {
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
|——————Node:assignment_expression Text: ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN
|———————Node:identifier Text: ul_retval
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN_MAILBOX_RX_NEED_RD_AGAIN
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: ul_retval |= CAN_MAILBOX_TRANSFER_OK;
|———————Node:assignment_expression Text: ul_retval |= CAN_MAILBOX_TRANSFER_OK
|————————Node:identifier Text: ul_retval
|————————Node:|= Text: |=
|————————Node:identifier Text: CAN_MAILBOX_TRANSFER_OK
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:comment Text: /* Enable next receive process. */
|———Node:expression_statement Text: mailbox_send_transfer_cmd(uc_index);
|————Node:call_expression Text: mailbox_send_transfer_cmd(uc_index)
|—————Node:identifier Text: mailbox_send_transfer_cmd
|—————Node:argument_list Text: (uc_index)
|——————Node:( Text: (
|——————Node:identifier Text: uc_index
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return ul_retval;
|————Node:return Text: return
|————Node:identifier Text: ul_retval
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_id(uint8_t uc_index, uint32_t id, bool extended) 
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (extended) {
		m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE;
	}
	else {
		m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_id(uint8_t uc_index, uint32_t id, bool extended)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_id
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_id
|———Node:parameter_list Text: (uint8_t uc_index, uint32_t id, bool extended)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool extended
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: extended
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (extended) {
		m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE;
	}
	else {
		m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (extended) {
		m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE;
	}
	else {
		m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (extended)
|—————Node:( Text: (
|—————Node:identifier Text: extended
|—————Node:) Text: )
|————Node:compound_statement Text: {
		m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE;
|——————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID = id | CAN_MID_MIDE
|———————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|—————————Node:field_expression Text: m_pCan->CAN_MB
|——————————Node:identifier Text: m_pCan
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: CAN_MB
|—————————Node:subscript_argument_list Text: [uc_index]
|——————————Node:[ Text: [
|——————————Node:identifier Text: uc_index
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: CAN_MID
|———————Node:= Text: =
|———————Node:binary_expression Text: id | CAN_MID_MIDE
|————————Node:identifier Text: id
|————————Node:| Text: |
|————————Node:identifier Text: CAN_MID_MIDE
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id);
|———————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID = CAN_MID_MIDvA(id)
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MID
|————————Node:= Text: =
|————————Node:call_expression Text: CAN_MID_MIDvA(id)
|—————————Node:identifier Text: CAN_MID_MIDvA
|—————————Node:argument_list Text: (id)
|——————————Node:( Text: (
|——————————Node:identifier Text: id
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: uint32_t CANRaw::mailbox_get_id(uint8_t uc_index) {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (m_pCan->CAN_MB[uc_index].CAN_MID & CAN_MID_MIDE) {
		return m_pCan->CAN_MB[uc_index].CAN_MID;
	}
	else {
		return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
	}
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::mailbox_get_id(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_get_id
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_get_id
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (m_pCan->CAN_MB[uc_index].CAN_MID & CAN_MID_MIDE) {
		return m_pCan->CAN_MB[uc_index].CAN_MID;
	}
	else {
		return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (m_pCan->CAN_MB[uc_index].CAN_MID & CAN_MID_MIDE) {
		return m_pCan->CAN_MB[uc_index].CAN_MID;
	}
	else {
		return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (m_pCan->CAN_MB[uc_index].CAN_MID & CAN_MID_MIDE)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID & CAN_MID_MIDE
|——————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|———————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|————————Node:field_expression Text: m_pCan->CAN_MB
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MB
|————————Node:subscript_argument_list Text: [uc_index]
|—————————Node:[ Text: [
|—————————Node:identifier Text: uc_index
|—————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: CAN_MID
|——————Node:& Text: &
|——————Node:identifier Text: CAN_MID_MIDE
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return m_pCan->CAN_MB[uc_index].CAN_MID;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return m_pCan->CAN_MB[uc_index].CAN_MID;
|——————Node:return Text: return
|——————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|———————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|————————Node:field_expression Text: m_pCan->CAN_MB
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MB
|————————Node:subscript_argument_list Text: [uc_index]
|—————————Node:[ Text: [
|—————————Node:identifier Text: uc_index
|—————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: CAN_MID
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
	}
|——————Node:{ Text: {
|——————Node:return_statement Text: return (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu;
|———————Node:return Text: return
|———————Node:binary_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos) & 0x7ffu
|————————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID >> CAN_MID_MIDvA_Pos
|——————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|———————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|————————————Node:field_expression Text: m_pCan->CAN_MB
|—————————————Node:identifier Text: m_pCan
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: CAN_MB
|————————————Node:subscript_argument_list Text: [uc_index]
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: uc_index
|—————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: CAN_MID
|——————————Node:>> Text: >>
|——————————Node:identifier Text: CAN_MID_MIDvA_Pos
|—————————Node:) Text: )
|————————Node:& Text: &
|————————Node:number_literal Text: 0x7ffu
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_priority(uint8_t uc_index, uint8_t pri) 
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk) | (pri << CAN_MMR_PRIOR_Pos);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_priority(uint8_t uc_index, uint8_t pri)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_priority
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_priority
|———Node:parameter_list Text: (uint8_t uc_index, uint8_t pri)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t pri
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: pri
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk) | (pri << CAN_MMR_PRIOR_Pos);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk) | (pri << CAN_MMR_PRIOR_Pos);
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk) | (pri << CAN_MMR_PRIOR_Pos)
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MMR
|—————Node:= Text: =
|—————Node:binary_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk) | (pri << CAN_MMR_PRIOR_Pos)
|——————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk)
|———————Node:( Text: (
|———————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR & ~CAN_MMR_PRIOR_Msk
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MMR
|————————Node:& Text: &
|————————Node:unary_expression Text: ~CAN_MMR_PRIOR_Msk
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MMR_PRIOR_Msk
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: (pri << CAN_MMR_PRIOR_Pos)
|———————Node:( Text: (
|———————Node:binary_expression Text: pri << CAN_MMR_PRIOR_Pos
|————————Node:identifier Text: pri
|————————Node:<< Text: <<
|————————Node:identifier Text: CAN_MMR_PRIOR_Pos
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_accept_mask(uint8_t uc_index, uint32_t mask, bool ext)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (ext) {
		m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE;
		m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE;
	} else {
		m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
		m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_accept_mask(uint8_t uc_index, uint32_t mask, bool ext)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_accept_mask
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_accept_mask
|———Node:parameter_list Text: (uint8_t uc_index, uint32_t mask, bool ext)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool ext
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: ext
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (ext) {
		m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE;
		m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE;
	} else {
		m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
		m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (ext) {
		m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE;
		m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE;
	} else {
		m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
		m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ext)
|—————Node:( Text: (
|—————Node:identifier Text: ext
|—————Node:) Text: )
|————Node:compound_statement Text: {
		m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE;
		m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE;
|——————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM = mask | CAN_MAM_MIDE
|———————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM
|————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|—————————Node:field_expression Text: m_pCan->CAN_MB
|——————————Node:identifier Text: m_pCan
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: CAN_MB
|—————————Node:subscript_argument_list Text: [uc_index]
|——————————Node:[ Text: [
|——————————Node:identifier Text: uc_index
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: CAN_MAM
|———————Node:= Text: =
|———————Node:binary_expression Text: mask | CAN_MAM_MIDE
|————————Node:identifier Text: mask
|————————Node:| Text: |
|————————Node:identifier Text: CAN_MAM_MIDE
|——————Node:; Text: ;
|—————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE;
|——————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID |= CAN_MAM_MIDE
|———————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|—————————Node:field_expression Text: m_pCan->CAN_MB
|——————————Node:identifier Text: m_pCan
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: CAN_MB
|—————————Node:subscript_argument_list Text: [uc_index]
|——————————Node:[ Text: [
|——————————Node:identifier Text: uc_index
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: CAN_MID
|———————Node:|= Text: |=
|———————Node:identifier Text: CAN_MAM_MIDE
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
		m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
		m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
		m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask);
|———————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM = CAN_MAM_MIDvA(mask)
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MAM
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MAM
|————————Node:= Text: =
|————————Node:call_expression Text: CAN_MAM_MIDvA(mask)
|—————————Node:identifier Text: CAN_MAM_MIDvA
|—————————Node:argument_list Text: (mask)
|——————————Node:( Text: (
|——————————Node:identifier Text: mask
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE;
|———————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID &= ~CAN_MAM_MIDE
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MID
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MID
|————————Node:&= Text: &=
|————————Node:unary_expression Text: ~CAN_MAM_MIDE
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MAM_MIDE
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_mode(uint8_t uc_index, uint8_t mode) {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (mode > 5) mode = 0; //set disabled on invalid mode
	m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk) | (mode << CAN_MMR_MOT_Pos);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_mode(uint8_t uc_index, uint8_t mode)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_mode
|———Node:parameter_list Text: (uint8_t uc_index, uint8_t mode)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t mode
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: mode
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (mode > 5) mode = 0; //set disabled on invalid mode
	m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk) | (mode << CAN_MMR_MOT_Pos);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (mode > 5) mode = 0;
|————Node:if Text: if
|————Node:condition_clause Text: (mode > 5)
|—————Node:( Text: (
|—————Node:binary_expression Text: mode > 5
|——————Node:identifier Text: mode
|——————Node:> Text: >
|——————Node:number_literal Text: 5
|—————Node:) Text: )
|————Node:expression_statement Text: mode = 0;
|—————Node:assignment_expression Text: mode = 0
|——————Node:identifier Text: mode
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:comment Text: //set disabled on invalid mode
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk) | (mode << CAN_MMR_MOT_Pos);
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR = (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk) | (mode << CAN_MMR_MOT_Pos)
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MMR
|—————Node:= Text: =
|—————Node:binary_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk) | (mode << CAN_MMR_MOT_Pos)
|——————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk)
|———————Node:( Text: (
|———————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR &
		~CAN_MMR_MOT_Msk
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MMR
|————————Node:& Text: &
|————————Node:unary_expression Text: ~CAN_MMR_MOT_Msk
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MMR_MOT_Msk
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:parenthesized_expression Text: (mode << CAN_MMR_MOT_Pos)
|———————Node:( Text: (
|———————Node:binary_expression Text: mode << CAN_MMR_MOT_Pos
|————————Node:identifier Text: mode
|————————Node:<< Text: <<
|————————Node:identifier Text: CAN_MMR_MOT_Pos
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint8_t CANRaw::mailbox_get_mode(uint8_t uc_index) {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	return (uint8_t)((m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANRaw::mailbox_get_mode(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_get_mode
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_get_mode
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	return (uint8_t)((m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:return_statement Text: return (uint8_t)((m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos);
|————Node:return Text: return
|————Node:cast_expression Text: (uint8_t)((m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos)
|—————Node:( Text: (
|—————Node:type_descriptor Text: uint8_t
|——————Node:primitive_type Text: uint8_t
|—————Node:) Text: )
|—————Node:parenthesized_expression Text: ((m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos)
|——————Node:( Text: (
|——————Node:binary_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)) >> CAN_MMR_MOT_Pos
|———————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk))
|————————Node:( Text: (
|————————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR & (~CAN_MMR_MOT_Msk)
|—————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MMR
|——————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————————Node:field_expression Text: m_pCan->CAN_MB
|————————————Node:identifier Text: m_pCan
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: CAN_MB
|———————————Node:subscript_argument_list Text: [uc_index]
|————————————Node:[ Text: [
|————————————Node:identifier Text: uc_index
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: CAN_MMR
|—————————Node:& Text: &
|—————————Node:parenthesized_expression Text: (~CAN_MMR_MOT_Msk)
|——————————Node:( Text: (
|——————————Node:unary_expression Text: ~CAN_MMR_MOT_Msk
|———————————Node:~ Text: ~
|———————————Node:identifier Text: CAN_MMR_MOT_Msk
|——————————Node:) Text: )
|————————Node:) Text: )
|———————Node:>> Text: >>
|———————Node:identifier Text: CAN_MMR_MOT_Pos
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_databyte(uint8_t uc_index, uint8_t bytepos, uint8_t val)
{
	uint8_t shift; //how many bits to shift
	uint32_t working;  //working copy of the relevant data int
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (bytepos > 7) bytepos = 7;
	shift = 8 * (bytepos & 3); //how many bytes to shift up into position
	if (bytepos < 4) { //low data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDL = working;
	}
	else { //high data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDH = working;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_databyte(uint8_t uc_index, uint8_t bytepos, uint8_t val)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_databyte
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_databyte
|———Node:parameter_list Text: (uint8_t uc_index, uint8_t bytepos, uint8_t val)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t bytepos
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: bytepos
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t val
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint8_t shift; //how many bits to shift
	uint32_t working;  //working copy of the relevant data int
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (bytepos > 7) bytepos = 7;
	shift = 8 * (bytepos & 3); //how many bytes to shift up into position
	if (bytepos < 4) { //low data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDL = working;
	}
	else { //high data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDH = working;
	}
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t shift;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: shift
|————Node:; Text: ;
|———Node:comment Text: //how many bits to shift
|———Node:declaration Text: uint32_t working;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: working
|————Node:; Text: ;
|———Node:comment Text: //working copy of the relevant data int
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (bytepos > 7) bytepos = 7;
|————Node:if Text: if
|————Node:condition_clause Text: (bytepos > 7)
|—————Node:( Text: (
|—————Node:binary_expression Text: bytepos > 7
|——————Node:identifier Text: bytepos
|——————Node:> Text: >
|——————Node:number_literal Text: 7
|—————Node:) Text: )
|————Node:expression_statement Text: bytepos = 7;
|—————Node:assignment_expression Text: bytepos = 7
|——————Node:identifier Text: bytepos
|——————Node:= Text: =
|——————Node:number_literal Text: 7
|—————Node:; Text: ;
|———Node:expression_statement Text: shift = 8 * (bytepos & 3);
|————Node:assignment_expression Text: shift = 8 * (bytepos & 3)
|—————Node:identifier Text: shift
|—————Node:= Text: =
|—————Node:binary_expression Text: 8 * (bytepos & 3)
|——————Node:number_literal Text: 8
|——————Node:* Text: *
|——————Node:parenthesized_expression Text: (bytepos & 3)
|———————Node:( Text: (
|———————Node:binary_expression Text: bytepos & 3
|————————Node:identifier Text: bytepos
|————————Node:& Text: &
|————————Node:number_literal Text: 3
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: //how many bytes to shift up into position
|———Node:if_statement Text: if (bytepos < 4) { //low data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDL = working;
	}
	else { //high data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDH = working;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (bytepos < 4)
|—————Node:( Text: (
|—————Node:binary_expression Text: bytepos < 4
|——————Node:identifier Text: bytepos
|——————Node:< Text: <
|——————Node:number_literal Text: 4
|—————Node:) Text: )
|————Node:compound_statement Text: { //low data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDL = working;
	}
|—————Node:{ Text: {
|—————Node:comment Text: //low data block
|—————Node:expression_statement Text: working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift);
|——————Node:assignment_expression Text: working = m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift)
|———————Node:identifier Text: working
|———————Node:= Text: =
|———————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL & ~(255 << shift)
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MDL
|————————Node:& Text: &
|————————Node:unary_expression Text: ~(255 << shift)
|—————————Node:~ Text: ~
|—————————Node:parenthesized_expression Text: (255 << shift)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: 255 << shift
|———————————Node:number_literal Text: 255
|———————————Node:<< Text: <<
|———————————Node:identifier Text: shift
|——————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: //mask out where we have to be
|—————Node:expression_statement Text: working |= (val << shift);
|——————Node:assignment_expression Text: working |= (val << shift)
|———————Node:identifier Text: working
|———————Node:|= Text: |=
|———————Node:parenthesized_expression Text: (val << shift)
|————————Node:( Text: (
|————————Node:binary_expression Text: val << shift
|—————————Node:identifier Text: val
|—————————Node:<< Text: <<
|—————————Node:identifier Text: shift
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDL = working;
|——————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL = working
|———————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL
|————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|—————————Node:field_expression Text: m_pCan->CAN_MB
|——————————Node:identifier Text: m_pCan
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: CAN_MB
|—————————Node:subscript_argument_list Text: [uc_index]
|——————————Node:[ Text: [
|——————————Node:identifier Text: uc_index
|——————————Node:] Text: ]
|————————Node:. Text: .
|————————Node:field_identifier Text: CAN_MDL
|———————Node:= Text: =
|———————Node:identifier Text: working
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else { //high data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDH = working;
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: { //high data block
		working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift); //mask out where we have to be
		working |= (val << shift);
		m_pCan->CAN_MB[uc_index].CAN_MDH = working;
	}
|——————Node:{ Text: {
|——————Node:comment Text: //high data block
|——————Node:expression_statement Text: working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift);
|———————Node:assignment_expression Text: working = m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift)
|————————Node:identifier Text: working
|————————Node:= Text: =
|————————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH & ~(255 << shift)
|—————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH
|——————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————————Node:field_expression Text: m_pCan->CAN_MB
|————————————Node:identifier Text: m_pCan
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: CAN_MB
|———————————Node:subscript_argument_list Text: [uc_index]
|————————————Node:[ Text: [
|————————————Node:identifier Text: uc_index
|————————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: CAN_MDH
|—————————Node:& Text: &
|—————————Node:unary_expression Text: ~(255 << shift)
|——————————Node:~ Text: ~
|——————————Node:parenthesized_expression Text: (255 << shift)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: 255 << shift
|————————————Node:number_literal Text: 255
|————————————Node:<< Text: <<
|————————————Node:identifier Text: shift
|———————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: //mask out where we have to be
|——————Node:expression_statement Text: working |= (val << shift);
|———————Node:assignment_expression Text: working |= (val << shift)
|————————Node:identifier Text: working
|————————Node:|= Text: |=
|————————Node:parenthesized_expression Text: (val << shift)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: val << shift
|——————————Node:identifier Text: val
|——————————Node:<< Text: <<
|——————————Node:identifier Text: shift
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDH = working;
|———————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH = working
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MDH
|————————Node:= Text: =
|————————Node:identifier Text: working
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_datal(uint8_t uc_index, uint32_t val)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MDL = val;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_datal(uint8_t uc_index, uint32_t val)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_datal
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_datal
|———Node:parameter_list Text: (uint8_t uc_index, uint32_t val)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t val
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MDL = val;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDL = val;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL = val
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDL
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDL
|—————Node:= Text: =
|—————Node:identifier Text: val
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_datah(uint8_t uc_index, uint32_t val)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MDH = val;
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_datah(uint8_t uc_index, uint32_t val)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_datah
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_datah
|———Node:parameter_list Text: (uint8_t uc_index, uint32_t val)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t val
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: val
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	m_pCan->CAN_MB[uc_index].CAN_MDH = val;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MDH = val;
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH = val
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MDH
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MDH
|—————Node:= Text: =
|—————Node:identifier Text: val
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CANRaw::mailbox_set_datalen(uint8_t uc_index, uint8_t dlen)
{
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (dlen > 8) dlen = 8;
	m_pCan->CAN_MB[uc_index].CAN_MCR = (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk) | CAN_MCR_MDLC(dlen);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_set_datalen(uint8_t uc_index, uint8_t dlen)
|———Node:qualified_identifier Text: CANRaw::mailbox_set_datalen
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_set_datalen
|———Node:parameter_list Text: (uint8_t uc_index, uint8_t dlen)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t dlen
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: dlen
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
	if (dlen > 8) dlen = 8;
	m_pCan->CAN_MB[uc_index].CAN_MCR = (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk) | CAN_MCR_MDLC(dlen);
}
|———Node:{ Text: {
|———Node:if_statement Text: if (uc_index > CANMB_NUMBER-1) uc_index = CANMB_NUMBER-1;
|————Node:if Text: if
|————Node:condition_clause Text: (uc_index > CANMB_NUMBER-1)
|—————Node:( Text: (
|—————Node:binary_expression Text: uc_index > CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:> Text: >
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:expression_statement Text: uc_index = CANMB_NUMBER-1;
|—————Node:assignment_expression Text: uc_index = CANMB_NUMBER-1
|——————Node:identifier Text: uc_index
|——————Node:= Text: =
|——————Node:binary_expression Text: CANMB_NUMBER-1
|———————Node:identifier Text: CANMB_NUMBER
|———————Node:- Text: -
|———————Node:number_literal Text: 1
|—————Node:; Text: ;
|———Node:if_statement Text: if (dlen > 8) dlen = 8;
|————Node:if Text: if
|————Node:condition_clause Text: (dlen > 8)
|—————Node:( Text: (
|—————Node:binary_expression Text: dlen > 8
|——————Node:identifier Text: dlen
|——————Node:> Text: >
|——————Node:number_literal Text: 8
|—————Node:) Text: )
|————Node:expression_statement Text: dlen = 8;
|—————Node:assignment_expression Text: dlen = 8
|——————Node:identifier Text: dlen
|——————Node:= Text: =
|——————Node:number_literal Text: 8
|—————Node:; Text: ;
|———Node:expression_statement Text: m_pCan->CAN_MB[uc_index].CAN_MCR = (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk) | CAN_MCR_MDLC(dlen);
|————Node:assignment_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR = (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk) | CAN_MCR_MDLC(dlen)
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MCR
|—————Node:= Text: =
|—————Node:binary_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk) | CAN_MCR_MDLC(dlen)
|——————Node:parenthesized_expression Text: (m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk)
|———————Node:( Text: (
|———————Node:binary_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR &
			~CAN_MCR_MDLC_Msk
|————————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MCR
|—————————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|——————————Node:field_expression Text: m_pCan->CAN_MB
|———————————Node:identifier Text: m_pCan
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: CAN_MB
|——————————Node:subscript_argument_list Text: [uc_index]
|———————————Node:[ Text: [
|———————————Node:identifier Text: uc_index
|———————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: CAN_MCR
|————————Node:& Text: &
|————————Node:unary_expression Text: ~CAN_MCR_MDLC_Msk
|—————————Node:~ Text: ~
|—————————Node:identifier Text: CAN_MCR_MDLC_Msk
|———————Node:) Text: )
|——————Node:| Text: |
|——————Node:call_expression Text: CAN_MCR_MDLC(dlen)
|———————Node:identifier Text: CAN_MCR_MDLC
|———————Node:argument_list Text: (dlen)
|————————Node:( Text: (
|————————Node:identifier Text: dlen
|————————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* Set the RTR bit in the sent frame. 
	m_pCan->CAN_MB[uc_index].CAN_MCR |= CAN_MCR_MRTR;
    */
|—Node:comment Text: /**
 * \brief Require to send out a frame.
 *
 * \param uc_index which mailbox to send frame. Load it up first
 *
 * \retval CAN_MAILBOX_NOT_READY: Failed because mailbox isn't ready for transmitting message.
 *       CAN_MAILBOX_TRANSFER_OK: Successfully send out a frame.
 */
|—Node:function_definition Text: uint32_t CANRaw::mailbox_tx_frame(uint8_t uc_index)
{
	uint32_t ul_status;
	
	/* Read the mailbox status firstly to check whether the mailbox is ready or not. */
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;	
	if (!(ul_status & CAN_MSR_MRDY)) {
		return CAN_MAILBOX_NOT_READY;
	}
	
	/* Set the MBx bit in the Transfer Command Register to send out the remote frame. */
	global_send_transfer_cmd((1 << uc_index));

	return CAN_MAILBOX_TRANSFER_OK;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::mailbox_tx_frame(uint8_t uc_index)
|———Node:qualified_identifier Text: CANRaw::mailbox_tx_frame
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_tx_frame
|———Node:parameter_list Text: (uint8_t uc_index)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t uc_index
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: uc_index
|————Node:) Text: )
|——Node:compound_statement Text: {
	uint32_t ul_status;
	
	/* Read the mailbox status firstly to check whether the mailbox is ready or not. */
	ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;	
	if (!(ul_status & CAN_MSR_MRDY)) {
		return CAN_MAILBOX_NOT_READY;
	}
	
	/* Set the MBx bit in the Transfer Command Register to send out the remote frame. */
	global_send_transfer_cmd((1 << uc_index));

	return CAN_MAILBOX_TRANSFER_OK;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_status;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: ul_status
|————Node:; Text: ;
|———Node:comment Text: /* Read the mailbox status firstly to check whether the mailbox is ready or not. */
|———Node:expression_statement Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR;
|————Node:assignment_expression Text: ul_status = m_pCan->CAN_MB[uc_index].CAN_MSR
|—————Node:identifier Text: ul_status
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_MB[uc_index].CAN_MSR
|——————Node:subscript_expression Text: m_pCan->CAN_MB[uc_index]
|———————Node:field_expression Text: m_pCan->CAN_MB
|————————Node:identifier Text: m_pCan
|————————Node:-> Text: ->
|————————Node:field_identifier Text: CAN_MB
|———————Node:subscript_argument_list Text: [uc_index]
|————————Node:[ Text: [
|————————Node:identifier Text: uc_index
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: CAN_MSR
|————Node:; Text: ;
|———Node:if_statement Text: if (!(ul_status & CAN_MSR_MRDY)) {
		return CAN_MAILBOX_NOT_READY;
	}
|————Node:if Text: if
|————Node:condition_clause Text: (!(ul_status & CAN_MSR_MRDY))
|—————Node:( Text: (
|—————Node:unary_expression Text: !(ul_status & CAN_MSR_MRDY)
|——————Node:! Text: !
|——————Node:parenthesized_expression Text: (ul_status & CAN_MSR_MRDY)
|———————Node:( Text: (
|———————Node:binary_expression Text: ul_status & CAN_MSR_MRDY
|————————Node:identifier Text: ul_status
|————————Node:& Text: &
|————————Node:identifier Text: CAN_MSR_MRDY
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
		return CAN_MAILBOX_NOT_READY;
	}
|—————Node:{ Text: {
|—————Node:return_statement Text: return CAN_MAILBOX_NOT_READY;
|——————Node:return Text: return
|——————Node:identifier Text: CAN_MAILBOX_NOT_READY
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Set the MBx bit in the Transfer Command Register to send out the remote frame. */
|———Node:expression_statement Text: global_send_transfer_cmd((1 << uc_index));
|————Node:call_expression Text: global_send_transfer_cmd((1 << uc_index))
|—————Node:identifier Text: global_send_transfer_cmd
|—————Node:argument_list Text: ((1 << uc_index))
|——————Node:( Text: (
|——————Node:parenthesized_expression Text: (1 << uc_index)
|———————Node:( Text: (
|———————Node:binary_expression Text: 1 << uc_index
|————————Node:number_literal Text: 1
|————————Node:<< Text: <<
|————————Node:identifier Text: uc_index
|———————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return CAN_MAILBOX_TRANSFER_OK;
|————Node:return Text: return
|————Node:identifier Text: CAN_MAILBOX_TRANSFER_OK
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief constructor for the class
*
* \param pCan Which canbus hardware to use (CAN0 or CAN1)
* \param Rs pin to use for transceiver Rs control
* \param En pin to use for transceiver enable
*/
|—Node:function_definition Text: CANRaw::CANRaw(Can* pCan, uint32_t Rs, uint32_t En ) {
	m_pCan = pCan;
	m_Transceiver = new SSN65HVD234(Rs, En);
}
|——Node:function_declarator Text: CANRaw::CANRaw(Can* pCan, uint32_t Rs, uint32_t En )
|———Node:qualified_identifier Text: CANRaw::CANRaw
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: CANRaw
|———Node:parameter_list Text: (Can* pCan, uint32_t Rs, uint32_t En )
|————Node:( Text: (
|————Node:parameter_declaration Text: Can* pCan
|—————Node:type_identifier Text: Can
|—————Node:pointer_declarator Text: * pCan
|——————Node:* Text: *
|——————Node:identifier Text: pCan
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t Rs
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: Rs
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t En
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: En
|————Node:) Text: )
|——Node:compound_statement Text: {
	m_pCan = pCan;
	m_Transceiver = new SSN65HVD234(Rs, En);
}
|———Node:{ Text: {
|———Node:expression_statement Text: m_pCan = pCan;
|————Node:assignment_expression Text: m_pCan = pCan
|—————Node:identifier Text: m_pCan
|—————Node:= Text: =
|—————Node:identifier Text: pCan
|————Node:; Text: ;
|———Node:expression_statement Text: m_Transceiver = new SSN65HVD234(Rs, En);
|————Node:assignment_expression Text: m_Transceiver = new SSN65HVD234(Rs, En)
|—————Node:identifier Text: m_Transceiver
|—————Node:= Text: =
|—————Node:new_expression Text: new SSN65HVD234(Rs, En)
|——————Node:new Text: new
|——————Node:type_identifier Text: SSN65HVD234
|——————Node:argument_list Text: (Rs, En)
|———————Node:( Text: (
|———————Node:identifier Text: Rs
|———————Node:, Text: ,
|———————Node:identifier Text: En
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Check whether there are received canbus frames in the buffer
*/
|—Node:function_definition Text: bool CANRaw::rx_avail() {
	return (rx_buffer_head != rx_buffer_tail)?true:false;
}
|——Node:primitive_type Text: bool
|——Node:function_declarator Text: CANRaw::rx_avail()
|———Node:qualified_identifier Text: CANRaw::rx_avail
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: rx_avail
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	return (rx_buffer_head != rx_buffer_tail)?true:false;
}
|———Node:{ Text: {
|———Node:return_statement Text: return (rx_buffer_head != rx_buffer_tail)?true:false;
|————Node:return Text: return
|————Node:conditional_expression Text: (rx_buffer_head != rx_buffer_tail)?true:false
|—————Node:parenthesized_expression Text: (rx_buffer_head != rx_buffer_tail)
|——————Node:( Text: (
|——————Node:binary_expression Text: rx_buffer_head != rx_buffer_tail
|———————Node:identifier Text: rx_buffer_head
|———————Node:!= Text: !=
|———————Node:identifier Text: rx_buffer_tail
|——————Node:) Text: )
|—————Node:? Text: ?
|—————Node:true Text: true
|—————Node:: Text: :
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: uint32_t CANRaw::get_rx_buff(CAN_FRAME& buffer) {
	if (rx_buffer_head == rx_buffer_tail) return 0;
	buffer.id = rx_frame_buff[rx_buffer_tail].id;
	buffer.extended = rx_frame_buff[rx_buffer_tail].extended;
	buffer.length = rx_frame_buff[rx_buffer_tail].length;
	buffer.data.value = rx_frame_buff[rx_buffer_tail].data.value;
	rx_buffer_tail = (rx_buffer_tail + 1) % SIZE_RX_BUFFER;
	return 1;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::get_rx_buff(CAN_FRAME& buffer)
|———Node:qualified_identifier Text: CANRaw::get_rx_buff
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: get_rx_buff
|———Node:parameter_list Text: (CAN_FRAME& buffer)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN_FRAME& buffer
|—————Node:type_identifier Text: CAN_FRAME
|—————Node:reference_declarator Text: & buffer
|——————Node:& Text: &
|——————Node:identifier Text: buffer
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (rx_buffer_head == rx_buffer_tail) return 0;
	buffer.id = rx_frame_buff[rx_buffer_tail].id;
	buffer.extended = rx_frame_buff[rx_buffer_tail].extended;
	buffer.length = rx_frame_buff[rx_buffer_tail].length;
	buffer.data.value = rx_frame_buff[rx_buffer_tail].data.value;
	rx_buffer_tail = (rx_buffer_tail + 1) % SIZE_RX_BUFFER;
	return 1;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (rx_buffer_head == rx_buffer_tail) return 0;
|————Node:if Text: if
|————Node:condition_clause Text: (rx_buffer_head == rx_buffer_tail)
|—————Node:( Text: (
|—————Node:binary_expression Text: rx_buffer_head == rx_buffer_tail
|——————Node:identifier Text: rx_buffer_head
|——————Node:== Text: ==
|——————Node:identifier Text: rx_buffer_tail
|—————Node:) Text: )
|————Node:return_statement Text: return 0;
|—————Node:return Text: return
|—————Node:number_literal Text: 0
|—————Node:; Text: ;
|———Node:expression_statement Text: buffer.id = rx_frame_buff[rx_buffer_tail].id;
|————Node:assignment_expression Text: buffer.id = rx_frame_buff[rx_buffer_tail].id
|—————Node:field_expression Text: buffer.id
|——————Node:identifier Text: buffer
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|—————Node:= Text: =
|—————Node:field_expression Text: rx_frame_buff[rx_buffer_tail].id
|——————Node:subscript_expression Text: rx_frame_buff[rx_buffer_tail]
|———————Node:identifier Text: rx_frame_buff
|———————Node:subscript_argument_list Text: [rx_buffer_tail]
|————————Node:[ Text: [
|————————Node:identifier Text: rx_buffer_tail
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|————Node:; Text: ;
|———Node:expression_statement Text: buffer.extended = rx_frame_buff[rx_buffer_tail].extended;
|————Node:assignment_expression Text: buffer.extended = rx_frame_buff[rx_buffer_tail].extended
|—————Node:field_expression Text: buffer.extended
|——————Node:identifier Text: buffer
|——————Node:. Text: .
|——————Node:field_identifier Text: extended
|—————Node:= Text: =
|—————Node:field_expression Text: rx_frame_buff[rx_buffer_tail].extended
|——————Node:subscript_expression Text: rx_frame_buff[rx_buffer_tail]
|———————Node:identifier Text: rx_frame_buff
|———————Node:subscript_argument_list Text: [rx_buffer_tail]
|————————Node:[ Text: [
|————————Node:identifier Text: rx_buffer_tail
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: extended
|————Node:; Text: ;
|———Node:expression_statement Text: buffer.length = rx_frame_buff[rx_buffer_tail].length;
|————Node:assignment_expression Text: buffer.length = rx_frame_buff[rx_buffer_tail].length
|—————Node:field_expression Text: buffer.length
|——————Node:identifier Text: buffer
|——————Node:. Text: .
|——————Node:field_identifier Text: length
|—————Node:= Text: =
|—————Node:field_expression Text: rx_frame_buff[rx_buffer_tail].length
|——————Node:subscript_expression Text: rx_frame_buff[rx_buffer_tail]
|———————Node:identifier Text: rx_frame_buff
|———————Node:subscript_argument_list Text: [rx_buffer_tail]
|————————Node:[ Text: [
|————————Node:identifier Text: rx_buffer_tail
|————————Node:] Text: ]
|——————Node:. Text: .
|——————Node:field_identifier Text: length
|————Node:; Text: ;
|———Node:expression_statement Text: buffer.data.value = rx_frame_buff[rx_buffer_tail].data.value;
|————Node:assignment_expression Text: buffer.data.value = rx_frame_buff[rx_buffer_tail].data.value
|—————Node:field_expression Text: buffer.data.value
|——————Node:field_expression Text: buffer.data
|———————Node:identifier Text: buffer
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:. Text: .
|——————Node:field_identifier Text: value
|—————Node:= Text: =
|—————Node:field_expression Text: rx_frame_buff[rx_buffer_tail].data.value
|——————Node:field_expression Text: rx_frame_buff[rx_buffer_tail].data
|———————Node:subscript_expression Text: rx_frame_buff[rx_buffer_tail]
|————————Node:identifier Text: rx_frame_buff
|————————Node:subscript_argument_list Text: [rx_buffer_tail]
|—————————Node:[ Text: [
|—————————Node:identifier Text: rx_buffer_tail
|—————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: data
|——————Node:. Text: .
|——————Node:field_identifier Text: value
|————Node:; Text: ;
|———Node:expression_statement Text: rx_buffer_tail = (rx_buffer_tail + 1) % SIZE_RX_BUFFER;
|————Node:assignment_expression Text: rx_buffer_tail = (rx_buffer_tail + 1) % SIZE_RX_BUFFER
|—————Node:identifier Text: rx_buffer_tail
|—————Node:= Text: =
|—————Node:binary_expression Text: (rx_buffer_tail + 1) % SIZE_RX_BUFFER
|——————Node:parenthesized_expression Text: (rx_buffer_tail + 1)
|———————Node:( Text: (
|———————Node:binary_expression Text: rx_buffer_tail + 1
|————————Node:identifier Text: rx_buffer_tail
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|———————Node:) Text: )
|——————Node:% Text: %
|——————Node:identifier Text: SIZE_RX_BUFFER
|————Node:; Text: ;
|———Node:return_statement Text: return 1;
|————Node:return Text: return
|————Node:number_literal Text: 1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Handle all interrupt reasons
*/
|—Node:function_definition Text: void CANRaw::interruptHandler() {

	uint32_t ul_status = m_pCan->CAN_SR; //get status of interrupts

	if (ul_status & CAN_SR_MB0) { //mailbox 0 event
		mailbox_int_handler(0, ul_status);
	}
	if (ul_status & CAN_SR_MB1) { //mailbox 1 event
		mailbox_int_handler(1, ul_status);
	}
	if (ul_status & CAN_SR_MB2) { //mailbox 2 event
		mailbox_int_handler(2, ul_status);
	}
	if (ul_status & CAN_SR_MB3) { //mailbox 3 event
		mailbox_int_handler(3, ul_status);
	}
	if (ul_status & CAN_SR_MB4) { //mailbox 4 event
		mailbox_int_handler(4, ul_status);
	}
	if (ul_status & CAN_SR_MB5) { //mailbox 5 event
		mailbox_int_handler(5, ul_status);
	}
	if (ul_status & CAN_SR_MB6) { //mailbox 6 event
		mailbox_int_handler(6, ul_status);
	}
	if (ul_status & CAN_SR_MB7) { //mailbox 7 event
		mailbox_int_handler(7, ul_status);
	}
	if (ul_status & CAN_SR_ERRA) { //error active
	}
	if (ul_status & CAN_SR_WARN) { //warning limit
	}
	if (ul_status & CAN_SR_ERRP) { //error passive
	}
	if (ul_status & CAN_SR_BOFF) { //bus off
	}
	if (ul_status & CAN_SR_SLEEP) { //controller in sleep mode
	}
	if (ul_status & CAN_SR_WAKEUP) { //controller woke up
	}
	if (ul_status & CAN_SR_TOVF) { //timer overflow
	}
	if (ul_status & CAN_SR_TSTP) { //timestamp - start or end of frame
	}
	if (ul_status & CAN_SR_CERR) { //CRC error in mailbox
	}
	if (ul_status & CAN_SR_SERR) { //stuffing error in mailbox
	}
	if (ul_status & CAN_SR_AERR) { //ack error
	}
	if (ul_status & CAN_SR_FERR) { //form error
	} 
	if (ul_status & CAN_SR_BERR) { //bit error
	}  
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::interruptHandler()
|———Node:qualified_identifier Text: CANRaw::interruptHandler
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: interruptHandler
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {

	uint32_t ul_status = m_pCan->CAN_SR; //get status of interrupts

	if (ul_status & CAN_SR_MB0) { //mailbox 0 event
		mailbox_int_handler(0, ul_status);
	}
	if (ul_status & CAN_SR_MB1) { //mailbox 1 event
		mailbox_int_handler(1, ul_status);
	}
	if (ul_status & CAN_SR_MB2) { //mailbox 2 event
		mailbox_int_handler(2, ul_status);
	}
	if (ul_status & CAN_SR_MB3) { //mailbox 3 event
		mailbox_int_handler(3, ul_status);
	}
	if (ul_status & CAN_SR_MB4) { //mailbox 4 event
		mailbox_int_handler(4, ul_status);
	}
	if (ul_status & CAN_SR_MB5) { //mailbox 5 event
		mailbox_int_handler(5, ul_status);
	}
	if (ul_status & CAN_SR_MB6) { //mailbox 6 event
		mailbox_int_handler(6, ul_status);
	}
	if (ul_status & CAN_SR_MB7) { //mailbox 7 event
		mailbox_int_handler(7, ul_status);
	}
	if (ul_status & CAN_SR_ERRA) { //error active
	}
	if (ul_status & CAN_SR_WARN) { //warning limit
	}
	if (ul_status & CAN_SR_ERRP) { //error passive
	}
	if (ul_status & CAN_SR_BOFF) { //bus off
	}
	if (ul_status & CAN_SR_SLEEP) { //controller in sleep mode
	}
	if (ul_status & CAN_SR_WAKEUP) { //controller woke up
	}
	if (ul_status & CAN_SR_TOVF) { //timer overflow
	}
	if (ul_status & CAN_SR_TSTP) { //timestamp - start or end of frame
	}
	if (ul_status & CAN_SR_CERR) { //CRC error in mailbox
	}
	if (ul_status & CAN_SR_SERR) { //stuffing error in mailbox
	}
	if (ul_status & CAN_SR_AERR) { //ack error
	}
	if (ul_status & CAN_SR_FERR) { //form error
	} 
	if (ul_status & CAN_SR_BERR) { //bit error
	}  
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t ul_status = m_pCan->CAN_SR;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: ul_status = m_pCan->CAN_SR
|—————Node:identifier Text: ul_status
|—————Node:= Text: =
|—————Node:field_expression Text: m_pCan->CAN_SR
|——————Node:identifier Text: m_pCan
|——————Node:-> Text: ->
|——————Node:field_identifier Text: CAN_SR
|————Node:; Text: ;
|———Node:comment Text: //get status of interrupts
|———Node:if_statement Text: if (ul_status & CAN_SR_MB0) { //mailbox 0 event
		mailbox_int_handler(0, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB0)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB0
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB0
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 0 event
		mailbox_int_handler(0, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 0 event
|—————Node:expression_statement Text: mailbox_int_handler(0, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(0, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (0, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB1) { //mailbox 1 event
		mailbox_int_handler(1, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB1)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB1
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB1
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 1 event
		mailbox_int_handler(1, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 1 event
|—————Node:expression_statement Text: mailbox_int_handler(1, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(1, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (1, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 1
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB2) { //mailbox 2 event
		mailbox_int_handler(2, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB2)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB2
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB2
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 2 event
		mailbox_int_handler(2, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 2 event
|—————Node:expression_statement Text: mailbox_int_handler(2, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(2, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (2, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 2
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB3) { //mailbox 3 event
		mailbox_int_handler(3, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB3)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB3
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB3
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 3 event
		mailbox_int_handler(3, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 3 event
|—————Node:expression_statement Text: mailbox_int_handler(3, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(3, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (3, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 3
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB4) { //mailbox 4 event
		mailbox_int_handler(4, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB4)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB4
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB4
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 4 event
		mailbox_int_handler(4, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 4 event
|—————Node:expression_statement Text: mailbox_int_handler(4, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(4, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (4, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 4
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB5) { //mailbox 5 event
		mailbox_int_handler(5, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB5)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB5
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB5
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 5 event
		mailbox_int_handler(5, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 5 event
|—————Node:expression_statement Text: mailbox_int_handler(5, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(5, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (5, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 5
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB6) { //mailbox 6 event
		mailbox_int_handler(6, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB6)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB6
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB6
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 6 event
		mailbox_int_handler(6, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 6 event
|—————Node:expression_statement Text: mailbox_int_handler(6, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(6, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (6, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 6
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_MB7) { //mailbox 7 event
		mailbox_int_handler(7, ul_status);
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_MB7)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_MB7
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_MB7
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox 7 event
		mailbox_int_handler(7, ul_status);
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox 7 event
|—————Node:expression_statement Text: mailbox_int_handler(7, ul_status);
|——————Node:call_expression Text: mailbox_int_handler(7, ul_status)
|———————Node:identifier Text: mailbox_int_handler
|———————Node:argument_list Text: (7, ul_status)
|————————Node:( Text: (
|————————Node:number_literal Text: 7
|————————Node:, Text: ,
|————————Node:identifier Text: ul_status
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_ERRA) { //error active
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_ERRA)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_ERRA
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_ERRA
|—————Node:) Text: )
|————Node:compound_statement Text: { //error active
	}
|—————Node:{ Text: {
|—————Node:comment Text: //error active
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_WARN) { //warning limit
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_WARN)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_WARN
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_WARN
|—————Node:) Text: )
|————Node:compound_statement Text: { //warning limit
	}
|—————Node:{ Text: {
|—————Node:comment Text: //warning limit
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_ERRP) { //error passive
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_ERRP)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_ERRP
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_ERRP
|—————Node:) Text: )
|————Node:compound_statement Text: { //error passive
	}
|—————Node:{ Text: {
|—————Node:comment Text: //error passive
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_BOFF) { //bus off
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_BOFF)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_BOFF
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_BOFF
|—————Node:) Text: )
|————Node:compound_statement Text: { //bus off
	}
|—————Node:{ Text: {
|—————Node:comment Text: //bus off
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_SLEEP) { //controller in sleep mode
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_SLEEP)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_SLEEP
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_SLEEP
|—————Node:) Text: )
|————Node:compound_statement Text: { //controller in sleep mode
	}
|—————Node:{ Text: {
|—————Node:comment Text: //controller in sleep mode
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_WAKEUP) { //controller woke up
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_WAKEUP)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_WAKEUP
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_WAKEUP
|—————Node:) Text: )
|————Node:compound_statement Text: { //controller woke up
	}
|—————Node:{ Text: {
|—————Node:comment Text: //controller woke up
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_TOVF) { //timer overflow
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_TOVF)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_TOVF
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_TOVF
|—————Node:) Text: )
|————Node:compound_statement Text: { //timer overflow
	}
|—————Node:{ Text: {
|—————Node:comment Text: //timer overflow
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_TSTP) { //timestamp - start or end of frame
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_TSTP)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_TSTP
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_TSTP
|—————Node:) Text: )
|————Node:compound_statement Text: { //timestamp - start or end of frame
	}
|—————Node:{ Text: {
|—————Node:comment Text: //timestamp - start or end of frame
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_CERR) { //CRC error in mailbox
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_CERR)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_CERR
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_CERR
|—————Node:) Text: )
|————Node:compound_statement Text: { //CRC error in mailbox
	}
|—————Node:{ Text: {
|—————Node:comment Text: //CRC error in mailbox
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_SERR) { //stuffing error in mailbox
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_SERR)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_SERR
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_SERR
|—————Node:) Text: )
|————Node:compound_statement Text: { //stuffing error in mailbox
	}
|—————Node:{ Text: {
|—————Node:comment Text: //stuffing error in mailbox
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_AERR) { //ack error
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_AERR)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_AERR
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_AERR
|—————Node:) Text: )
|————Node:compound_statement Text: { //ack error
	}
|—————Node:{ Text: {
|—————Node:comment Text: //ack error
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_FERR) { //form error
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_FERR)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_FERR
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_FERR
|—————Node:) Text: )
|————Node:compound_statement Text: { //form error
	}
|—————Node:{ Text: {
|—————Node:comment Text: //form error
|—————Node:} Text: }
|———Node:if_statement Text: if (ul_status & CAN_SR_BERR) { //bit error
	}
|————Node:if Text: if
|————Node:condition_clause Text: (ul_status & CAN_SR_BERR)
|—————Node:( Text: (
|—————Node:binary_expression Text: ul_status & CAN_SR_BERR
|——————Node:identifier Text: ul_status
|——————Node:& Text: &
|——————Node:identifier Text: CAN_SR_BERR
|—————Node:) Text: )
|————Node:compound_statement Text: { //bit error
	}
|—————Node:{ Text: {
|—————Node:comment Text: //bit error
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Find unused RX mailbox and return its number
*/
|—Node:function_definition Text: int CANRaw::findFreeRXMailbox() {
	for (int c = 0; c < 8; c++) {
		if (mailbox_get_mode(c) == CAN_MB_RX_MODE) {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
	}
	return -1;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: CANRaw::findFreeRXMailbox()
|———Node:qualified_identifier Text: CANRaw::findFreeRXMailbox
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: findFreeRXMailbox
|———Node:parameter_list Text: ()
|————Node:( Text: (
|————Node:) Text: )
|——Node:compound_statement Text: {
	for (int c = 0; c < 8; c++) {
		if (mailbox_get_mode(c) == CAN_MB_RX_MODE) {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
	}
	return -1;
}
|———Node:{ Text: {
|———Node:for_statement Text: for (int c = 0; c < 8; c++) {
		if (mailbox_get_mode(c) == CAN_MB_RX_MODE) {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
	}
|————Node:for Text: for
|————Node:( Text: (
|————Node:declaration Text: int c = 0;
|—————Node:primitive_type Text: int
|—————Node:init_declarator Text: c = 0
|——————Node:identifier Text: c
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|————Node:binary_expression Text: c < 8
|—————Node:identifier Text: c
|—————Node:< Text: <
|—————Node:number_literal Text: 8
|————Node:; Text: ;
|————Node:update_expression Text: c++
|—————Node:identifier Text: c
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
		if (mailbox_get_mode(c) == CAN_MB_RX_MODE) {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
	}
|—————Node:{ Text: {
|—————Node:if_statement Text: if (mailbox_get_mode(c) == CAN_MB_RX_MODE) {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
|——————Node:if Text: if
|——————Node:condition_clause Text: (mailbox_get_mode(c) == CAN_MB_RX_MODE)
|———————Node:( Text: (
|———————Node:binary_expression Text: mailbox_get_mode(c) == CAN_MB_RX_MODE
|————————Node:call_expression Text: mailbox_get_mode(c)
|—————————Node:identifier Text: mailbox_get_mode
|—————————Node:argument_list Text: (c)
|——————————Node:( Text: (
|——————————Node:identifier Text: c
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:identifier Text: CAN_MB_RX_MODE
|———————Node:) Text: )
|——————Node:compound_statement Text: {
			if (mailbox_get_id(c) == 0) {
				return c;
			}
		}
|———————Node:{ Text: {
|———————Node:if_statement Text: if (mailbox_get_id(c) == 0) {
				return c;
			}
|————————Node:if Text: if
|————————Node:condition_clause Text: (mailbox_get_id(c) == 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: mailbox_get_id(c) == 0
|——————————Node:call_expression Text: mailbox_get_id(c)
|———————————Node:identifier Text: mailbox_get_id
|———————————Node:argument_list Text: (c)
|————————————Node:( Text: (
|————————————Node:identifier Text: c
|————————————Node:) Text: )
|——————————Node:== Text: ==
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
				return c;
			}
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return c;
|——————————Node:return Text: return
|——————————Node:identifier Text: c
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return -1;
|————Node:return Text: return
|————Node:number_literal Text: -1
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Set up an RX mailbox (first free) for the given parameters.
*
* \param id - the post mask ID to match against
* \param mask - the mask to use for this filter
* \param extended - whether to use 29 bit filter
*
* \ret number of mailbox we just used (or -1 if there are no free boxes to use)
*/
|—Node:function_definition Text: int CANRaw::setRXFilter(uint32_t id, uint32_t mask, bool extended) {
	int c = findFreeRXMailbox();
	if (c < 0) return -1;

	mailbox_set_accept_mask(c, mask, extended);
	mailbox_set_id(c, id, extended);
	enable_interrupt(getMailboxIer(c));

	return c;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: CANRaw::setRXFilter(uint32_t id, uint32_t mask, bool extended)
|———Node:qualified_identifier Text: CANRaw::setRXFilter
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: setRXFilter
|———Node:parameter_list Text: (uint32_t id, uint32_t mask, bool extended)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool extended
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: extended
|————Node:) Text: )
|——Node:compound_statement Text: {
	int c = findFreeRXMailbox();
	if (c < 0) return -1;

	mailbox_set_accept_mask(c, mask, extended);
	mailbox_set_id(c, id, extended);
	enable_interrupt(getMailboxIer(c));

	return c;
}
|———Node:{ Text: {
|———Node:declaration Text: int c = findFreeRXMailbox();
|————Node:primitive_type Text: int
|————Node:init_declarator Text: c = findFreeRXMailbox()
|—————Node:identifier Text: c
|—————Node:= Text: =
|—————Node:call_expression Text: findFreeRXMailbox()
|——————Node:identifier Text: findFreeRXMailbox
|——————Node:argument_list Text: ()
|———————Node:( Text: (
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (c < 0) return -1;
|————Node:if Text: if
|————Node:condition_clause Text: (c < 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: c < 0
|——————Node:identifier Text: c
|——————Node:< Text: <
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:return_statement Text: return -1;
|—————Node:return Text: return
|—————Node:number_literal Text: -1
|—————Node:; Text: ;
|———Node:expression_statement Text: mailbox_set_accept_mask(c, mask, extended);
|————Node:call_expression Text: mailbox_set_accept_mask(c, mask, extended)
|—————Node:identifier Text: mailbox_set_accept_mask
|—————Node:argument_list Text: (c, mask, extended)
|——————Node:( Text: (
|——————Node:identifier Text: c
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:, Text: ,
|——————Node:identifier Text: extended
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mailbox_set_id(c, id, extended);
|————Node:call_expression Text: mailbox_set_id(c, id, extended)
|—————Node:identifier Text: mailbox_set_id
|—————Node:argument_list Text: (c, id, extended)
|——————Node:( Text: (
|——————Node:identifier Text: c
|——————Node:, Text: ,
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:identifier Text: extended
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: enable_interrupt(getMailboxIer(c));
|————Node:call_expression Text: enable_interrupt(getMailboxIer(c))
|—————Node:identifier Text: enable_interrupt
|—————Node:argument_list Text: (getMailboxIer(c))
|——————Node:( Text: (
|——————Node:call_expression Text: getMailboxIer(c)
|———————Node:identifier Text: getMailboxIer
|———————Node:argument_list Text: (c)
|————————Node:( Text: (
|————————Node:identifier Text: c
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return c;
|————Node:return Text: return
|————Node:identifier Text: c
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Set up an RX mailbox (given MB number) for the given parameters.
*
* \param pCan Which canbus hardware to use (CAN0 or CAN1)
* \param Rs pin to use for transceiver Rs control
* \param En pin to use for transceiver enable
*/
|—Node:function_definition Text: int CANRaw::setRXFilter(uint8_t mailbox, uint32_t id, uint32_t mask, bool extended) {
	if (mailbox > 7) return -1;

	mailbox_set_accept_mask(mailbox, mask, extended);
	mailbox_set_id(mailbox, id, extended);
	enable_interrupt(getMailboxIer(mailbox));
	return mailbox;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: CANRaw::setRXFilter(uint8_t mailbox, uint32_t id, uint32_t mask, bool extended)
|———Node:qualified_identifier Text: CANRaw::setRXFilter
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: setRXFilter
|———Node:parameter_list Text: (uint8_t mailbox, uint32_t id, uint32_t mask, bool extended)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t mailbox
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: mailbox
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t mask
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: mask
|————Node:, Text: ,
|————Node:parameter_declaration Text: bool extended
|—————Node:primitive_type Text: bool
|—————Node:identifier Text: extended
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (mailbox > 7) return -1;

	mailbox_set_accept_mask(mailbox, mask, extended);
	mailbox_set_id(mailbox, id, extended);
	enable_interrupt(getMailboxIer(mailbox));
	return mailbox;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (mailbox > 7) return -1;
|————Node:if Text: if
|————Node:condition_clause Text: (mailbox > 7)
|—————Node:( Text: (
|—————Node:binary_expression Text: mailbox > 7
|——————Node:identifier Text: mailbox
|——————Node:> Text: >
|——————Node:number_literal Text: 7
|—————Node:) Text: )
|————Node:return_statement Text: return -1;
|—————Node:return Text: return
|—————Node:number_literal Text: -1
|—————Node:; Text: ;
|———Node:expression_statement Text: mailbox_set_accept_mask(mailbox, mask, extended);
|————Node:call_expression Text: mailbox_set_accept_mask(mailbox, mask, extended)
|—————Node:identifier Text: mailbox_set_accept_mask
|—————Node:argument_list Text: (mailbox, mask, extended)
|——————Node:( Text: (
|——————Node:identifier Text: mailbox
|——————Node:, Text: ,
|——————Node:identifier Text: mask
|——————Node:, Text: ,
|——————Node:identifier Text: extended
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: mailbox_set_id(mailbox, id, extended);
|————Node:call_expression Text: mailbox_set_id(mailbox, id, extended)
|—————Node:identifier Text: mailbox_set_id
|—————Node:argument_list Text: (mailbox, id, extended)
|——————Node:( Text: (
|——————Node:identifier Text: mailbox
|——————Node:, Text: ,
|——————Node:identifier Text: id
|——————Node:, Text: ,
|——————Node:identifier Text: extended
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: enable_interrupt(getMailboxIer(mailbox));
|————Node:call_expression Text: enable_interrupt(getMailboxIer(mailbox))
|—————Node:identifier Text: enable_interrupt
|—————Node:argument_list Text: (getMailboxIer(mailbox))
|——————Node:( Text: (
|——————Node:call_expression Text: getMailboxIer(mailbox)
|———————Node:identifier Text: getMailboxIer
|———————Node:argument_list Text: (mailbox)
|————————Node:( Text: (
|————————Node:identifier Text: mailbox
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return mailbox;
|————Node:return Text: return
|————Node:identifier Text: mailbox
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 * Get the IER (interrupt mask) for the specified mailbox index.
 *
 * \param mailbox - the index of the mailbox to get the IER for
 * \retval the IER of the specified mailbox
 */
|—Node:function_definition Text: uint32_t CANRaw::getMailboxIer(int8_t mailbox) {
	switch (mailbox) {
	case 0:
		return CAN_IER_MB0;
	case 1:
		return CAN_IER_MB1;
	case 2:
		return CAN_IER_MB2;
	case 3:
		return CAN_IER_MB3;
	case 4:
		return CAN_IER_MB4;
	case 5:
		return CAN_IER_MB5;
	case 6:
		return CAN_IER_MB6;
	case 7:
		return CAN_IER_MB7;
	}
	return 0;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: CANRaw::getMailboxIer(int8_t mailbox)
|———Node:qualified_identifier Text: CANRaw::getMailboxIer
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: getMailboxIer
|———Node:parameter_list Text: (int8_t mailbox)
|————Node:( Text: (
|————Node:parameter_declaration Text: int8_t mailbox
|—————Node:primitive_type Text: int8_t
|—————Node:identifier Text: mailbox
|————Node:) Text: )
|——Node:compound_statement Text: {
	switch (mailbox) {
	case 0:
		return CAN_IER_MB0;
	case 1:
		return CAN_IER_MB1;
	case 2:
		return CAN_IER_MB2;
	case 3:
		return CAN_IER_MB3;
	case 4:
		return CAN_IER_MB4;
	case 5:
		return CAN_IER_MB5;
	case 6:
		return CAN_IER_MB6;
	case 7:
		return CAN_IER_MB7;
	}
	return 0;
}
|———Node:{ Text: {
|———Node:switch_statement Text: switch (mailbox) {
	case 0:
		return CAN_IER_MB0;
	case 1:
		return CAN_IER_MB1;
	case 2:
		return CAN_IER_MB2;
	case 3:
		return CAN_IER_MB3;
	case 4:
		return CAN_IER_MB4;
	case 5:
		return CAN_IER_MB5;
	case 6:
		return CAN_IER_MB6;
	case 7:
		return CAN_IER_MB7;
	}
|————Node:switch Text: switch
|————Node:condition_clause Text: (mailbox)
|—————Node:( Text: (
|—————Node:identifier Text: mailbox
|—————Node:) Text: )
|————Node:compound_statement Text: {
	case 0:
		return CAN_IER_MB0;
	case 1:
		return CAN_IER_MB1;
	case 2:
		return CAN_IER_MB2;
	case 3:
		return CAN_IER_MB3;
	case 4:
		return CAN_IER_MB4;
	case 5:
		return CAN_IER_MB5;
	case 6:
		return CAN_IER_MB6;
	case 7:
		return CAN_IER_MB7;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case 0:
		return CAN_IER_MB0;
|——————Node:case Text: case
|——————Node:number_literal Text: 0
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB0;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB0
|———————Node:; Text: ;
|—————Node:case_statement Text: case 1:
		return CAN_IER_MB1;
|——————Node:case Text: case
|——————Node:number_literal Text: 1
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB1;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB1
|———————Node:; Text: ;
|—————Node:case_statement Text: case 2:
		return CAN_IER_MB2;
|——————Node:case Text: case
|——————Node:number_literal Text: 2
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB2;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB2
|———————Node:; Text: ;
|—————Node:case_statement Text: case 3:
		return CAN_IER_MB3;
|——————Node:case Text: case
|——————Node:number_literal Text: 3
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB3;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB3
|———————Node:; Text: ;
|—————Node:case_statement Text: case 4:
		return CAN_IER_MB4;
|——————Node:case Text: case
|——————Node:number_literal Text: 4
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB4;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB4
|———————Node:; Text: ;
|—————Node:case_statement Text: case 5:
		return CAN_IER_MB5;
|——————Node:case Text: case
|——————Node:number_literal Text: 5
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB5;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB5
|———————Node:; Text: ;
|—————Node:case_statement Text: case 6:
		return CAN_IER_MB6;
|——————Node:case Text: case
|——————Node:number_literal Text: 6
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB6;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB6
|———————Node:; Text: ;
|—————Node:case_statement Text: case 7:
		return CAN_IER_MB7;
|——————Node:case Text: case
|——————Node:number_literal Text: 7
|——————Node:: Text: :
|——————Node:return_statement Text: return CAN_IER_MB7;
|———————Node:return Text: return
|———————Node:identifier Text: CAN_IER_MB7
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /**
* \brief Handle a mailbox interrupt event
* \param mb which mailbox generated this event
*/
|—Node:function_definition Text: void CANRaw::mailbox_int_handler(uint8_t mb, uint32_t ul_status) {
	if (mb > 7) mb = 7;
	if (m_pCan->CAN_MB[mb].CAN_MSR & CAN_MSR_MRDY) { //mailbox signals it is ready
		switch(((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)) { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CANRaw::mailbox_int_handler(uint8_t mb, uint32_t ul_status)
|———Node:qualified_identifier Text: CANRaw::mailbox_int_handler
|————Node:namespace_identifier Text: CANRaw
|————Node::: Text: ::
|————Node:identifier Text: mailbox_int_handler
|———Node:parameter_list Text: (uint8_t mb, uint32_t ul_status)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t mb
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: mb
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t ul_status
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: ul_status
|————Node:) Text: )
|——Node:compound_statement Text: {
	if (mb > 7) mb = 7;
	if (m_pCan->CAN_MB[mb].CAN_MSR & CAN_MSR_MRDY) { //mailbox signals it is ready
		switch(((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)) { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if (mb > 7) mb = 7;
|————Node:if Text: if
|————Node:condition_clause Text: (mb > 7)
|—————Node:( Text: (
|—————Node:binary_expression Text: mb > 7
|——————Node:identifier Text: mb
|——————Node:> Text: >
|——————Node:number_literal Text: 7
|—————Node:) Text: )
|————Node:expression_statement Text: mb = 7;
|—————Node:assignment_expression Text: mb = 7
|——————Node:identifier Text: mb
|——————Node:= Text: =
|——————Node:number_literal Text: 7
|—————Node:; Text: ;
|———Node:if_statement Text: if (m_pCan->CAN_MB[mb].CAN_MSR & CAN_MSR_MRDY) { //mailbox signals it is ready
		switch(((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)) { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
	}
|————Node:if Text: if
|————Node:condition_clause Text: (m_pCan->CAN_MB[mb].CAN_MSR & CAN_MSR_MRDY)
|—————Node:( Text: (
|—————Node:binary_expression Text: m_pCan->CAN_MB[mb].CAN_MSR & CAN_MSR_MRDY
|——————Node:field_expression Text: m_pCan->CAN_MB[mb].CAN_MSR
|———————Node:subscript_expression Text: m_pCan->CAN_MB[mb]
|————————Node:field_expression Text: m_pCan->CAN_MB
|—————————Node:identifier Text: m_pCan
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: CAN_MB
|————————Node:subscript_argument_list Text: [mb]
|—————————Node:[ Text: [
|—————————Node:identifier Text: mb
|—————————Node:] Text: ]
|———————Node:. Text: .
|———————Node:field_identifier Text: CAN_MSR
|——————Node:& Text: &
|——————Node:identifier Text: CAN_MSR_MRDY
|—————Node:) Text: )
|————Node:compound_statement Text: { //mailbox signals it is ready
		switch(((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)) { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
	}
|—————Node:{ Text: {
|—————Node:comment Text: //mailbox signals it is ready
|—————Node:switch_statement Text: switch(((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)) { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
|——————Node:switch Text: switch
|——————Node:condition_clause Text: (((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7))
|———————Node:( Text: (
|———————Node:parenthesized_expression Text: ((m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7)
|————————Node:( Text: (
|————————Node:binary_expression Text: (m_pCan->CAN_MB[mb].CAN_MMR >> 24) & 7
|—————————Node:parenthesized_expression Text: (m_pCan->CAN_MB[mb].CAN_MMR >> 24)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: m_pCan->CAN_MB[mb].CAN_MMR >> 24
|———————————Node:field_expression Text: m_pCan->CAN_MB[mb].CAN_MMR
|————————————Node:subscript_expression Text: m_pCan->CAN_MB[mb]
|—————————————Node:field_expression Text: m_pCan->CAN_MB
|——————————————Node:identifier Text: m_pCan
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: CAN_MB
|—————————————Node:subscript_argument_list Text: [mb]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: mb
|——————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: CAN_MMR
|———————————Node:>> Text: >>
|———————————Node:number_literal Text: 24
|——————————Node:) Text: )
|—————————Node:& Text: &
|—————————Node:number_literal Text: 7
|————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: { //what sort of mailbox is it?
		case 1: //receive
		case 2: //receive w/ overwrite
		case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
		case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
		case 5: //producer - technically still a transmit buffer
			break;
		}
|———————Node:{ Text: {
|———————Node:comment Text: //what sort of mailbox is it?
|———————Node:case_statement Text: case 1:
|————————Node:case Text: case
|————————Node:number_literal Text: 1
|————————Node:: Text: :
|———————Node:comment Text: //receive
|———————Node:case_statement Text: case 2:
|————————Node:case Text: case
|————————Node:number_literal Text: 2
|————————Node:: Text: :
|———————Node:comment Text: //receive w/ overwrite
|———————Node:case_statement Text: case 4: //consumer - technically still a receive buffer
		    mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
			rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
			break;
|————————Node:case Text: case
|————————Node:number_literal Text: 4
|————————Node:: Text: :
|————————Node:comment Text: //consumer - technically still a receive buffer
|————————Node:expression_statement Text: mailbox_read(mb, &rx_frame_buff[rx_buffer_head]);
|—————————Node:call_expression Text: mailbox_read(mb, &rx_frame_buff[rx_buffer_head])
|——————————Node:identifier Text: mailbox_read
|——————————Node:argument_list Text: (mb, &rx_frame_buff[rx_buffer_head])
|———————————Node:( Text: (
|———————————Node:identifier Text: mb
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &rx_frame_buff[rx_buffer_head]
|————————————Node:& Text: &
|————————————Node:subscript_expression Text: rx_frame_buff[rx_buffer_head]
|—————————————Node:identifier Text: rx_frame_buff
|—————————————Node:subscript_argument_list Text: [rx_buffer_head]
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: rx_buffer_head
|——————————————Node:] Text: ]
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER;
|—————————Node:assignment_expression Text: rx_buffer_head = (rx_buffer_head + 1) % SIZE_RX_BUFFER
|——————————Node:identifier Text: rx_buffer_head
|——————————Node:= Text: =
|——————————Node:binary_expression Text: (rx_buffer_head + 1) % SIZE_RX_BUFFER
|———————————Node:parenthesized_expression Text: (rx_buffer_head + 1)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: rx_buffer_head + 1
|—————————————Node:identifier Text: rx_buffer_head
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:) Text: )
|———————————Node:% Text: %
|———————————Node:identifier Text: SIZE_RX_BUFFER
|—————————Node:; Text: ;
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case 3: //transmit
			if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
			break;
|————————Node:case Text: case
|————————Node:number_literal Text: 3
|————————Node:: Text: :
|————————Node:comment Text: //transmit
|————————Node:if_statement Text: if (tx_buffer_head != tx_buffer_tail) 
			{ //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
			else {
				disable_interrupt(0x01 << mb);
			}
|—————————Node:if Text: if
|—————————Node:condition_clause Text: (tx_buffer_head != tx_buffer_tail)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: tx_buffer_head != tx_buffer_tail
|———————————Node:identifier Text: tx_buffer_head
|———————————Node:!= Text: !=
|———————————Node:identifier Text: tx_buffer_tail
|——————————Node:) Text: )
|—————————Node:compound_statement Text: { //if there is a frame in the queue to send
				mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
				mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
				mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
				for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
				global_send_transfer_cmd((0x1u << mb));
				tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
			}
|——————————Node:{ Text: {
|——————————Node:comment Text: //if there is a frame in the queue to send
|——————————Node:expression_statement Text: mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended);
|———————————Node:call_expression Text: mailbox_set_id(mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended)
|————————————Node:identifier Text: mailbox_set_id
|————————————Node:argument_list Text: (mb, tx_frame_buff[tx_buffer_head].id, tx_frame_buff[tx_buffer_head].extended)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: mb
|—————————————Node:, Text: ,
|—————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].id
|——————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head]
|———————————————Node:identifier Text: tx_frame_buff
|———————————————Node:subscript_argument_list Text: [tx_buffer_head]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: tx_buffer_head
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: id
|—————————————Node:, Text: ,
|—————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].extended
|——————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head]
|———————————————Node:identifier Text: tx_frame_buff
|———————————————Node:subscript_argument_list Text: [tx_buffer_head]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: tx_buffer_head
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: extended
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length);
|———————————Node:call_expression Text: mailbox_set_datalen(mb, tx_frame_buff[tx_buffer_head].length)
|————————————Node:identifier Text: mailbox_set_datalen
|————————————Node:argument_list Text: (mb, tx_frame_buff[tx_buffer_head].length)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: mb
|—————————————Node:, Text: ,
|—————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].length
|——————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head]
|———————————————Node:identifier Text: tx_frame_buff
|———————————————Node:subscript_argument_list Text: [tx_buffer_head]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: tx_buffer_head
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: length
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority);
|———————————Node:call_expression Text: mailbox_set_priority(mb, tx_frame_buff[tx_buffer_head].priority)
|————————————Node:identifier Text: mailbox_set_priority
|————————————Node:argument_list Text: (mb, tx_frame_buff[tx_buffer_head].priority)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: mb
|—————————————Node:, Text: ,
|—————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].priority
|——————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head]
|———————————————Node:identifier Text: tx_frame_buff
|———————————————Node:subscript_argument_list Text: [tx_buffer_head]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: tx_buffer_head
|————————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: priority
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:for_statement Text: for (uint8_t cnt = 0; cnt < 8; cnt++)
					mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
|———————————Node:for Text: for
|———————————Node:( Text: (
|———————————Node:declaration Text: uint8_t cnt = 0;
|————————————Node:primitive_type Text: uint8_t
|————————————Node:init_declarator Text: cnt = 0
|—————————————Node:identifier Text: cnt
|—————————————Node:= Text: =
|—————————————Node:number_literal Text: 0
|————————————Node:; Text: ;
|———————————Node:binary_expression Text: cnt < 8
|————————————Node:identifier Text: cnt
|————————————Node:< Text: <
|————————————Node:number_literal Text: 8
|———————————Node:; Text: ;
|———————————Node:update_expression Text: cnt++
|————————————Node:identifier Text: cnt
|————————————Node:++ Text: ++
|———————————Node:) Text: )
|———————————Node:expression_statement Text: mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt]);
|————————————Node:call_expression Text: mailbox_set_databyte(mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt])
|—————————————Node:identifier Text: mailbox_set_databyte
|—————————————Node:argument_list Text: (mb, cnt, tx_frame_buff[tx_buffer_head].data.bytes[cnt])
|——————————————Node:( Text: (
|——————————————Node:identifier Text: mb
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: cnt
|——————————————Node:, Text: ,
|——————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head].data.bytes[cnt]
|———————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].data.bytes
|————————————————Node:field_expression Text: tx_frame_buff[tx_buffer_head].data
|—————————————————Node:subscript_expression Text: tx_frame_buff[tx_buffer_head]
|——————————————————Node:identifier Text: tx_frame_buff
|——————————————————Node:subscript_argument_list Text: [tx_buffer_head]
|———————————————————Node:[ Text: [
|———————————————————Node:identifier Text: tx_buffer_head
|———————————————————Node:] Text: ]
|—————————————————Node:. Text: .
|—————————————————Node:field_identifier Text: data
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: bytes
|———————————————Node:subscript_argument_list Text: [cnt]
|————————————————Node:[ Text: [
|————————————————Node:identifier Text: cnt
|————————————————Node:] Text: ]
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|——————————Node:expression_statement Text: global_send_transfer_cmd((0x1u << mb));
|———————————Node:call_expression Text: global_send_transfer_cmd((0x1u << mb))
|————————————Node:identifier Text: global_send_transfer_cmd
|————————————Node:argument_list Text: ((0x1u << mb))
|—————————————Node:( Text: (
|—————————————Node:parenthesized_expression Text: (0x1u << mb)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: 0x1u << mb
|———————————————Node:number_literal Text: 0x1u
|———————————————Node:<< Text: <<
|———————————————Node:identifier Text: mb
|——————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER;
|———————————Node:assignment_expression Text: tx_buffer_head = (tx_buffer_head + 1) % SIZE_TX_BUFFER
|————————————Node:identifier Text: tx_buffer_head
|————————————Node:= Text: =
|————————————Node:binary_expression Text: (tx_buffer_head + 1) % SIZE_TX_BUFFER
|—————————————Node:parenthesized_expression Text: (tx_buffer_head + 1)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: tx_buffer_head + 1
|———————————————Node:identifier Text: tx_buffer_head
|———————————————Node:+ Text: +
|———————————————Node:number_literal Text: 1
|——————————————Node:) Text: )
|—————————————Node:% Text: %
|—————————————Node:identifier Text: SIZE_TX_BUFFER
|———————————Node:; Text: ;
|——————————Node:} Text: }
|—————————Node:else_clause Text: else {
				disable_interrupt(0x01 << mb);
			}
|——————————Node:else Text: else
|——————————Node:compound_statement Text: {
				disable_interrupt(0x01 << mb);
			}
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: disable_interrupt(0x01 << mb);
|————————————Node:call_expression Text: disable_interrupt(0x01 << mb)
|—————————————Node:identifier Text: disable_interrupt
|—————————————Node:argument_list Text: (0x01 << mb)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: 0x01 << mb
|———————————————Node:number_literal Text: 0x01
|———————————————Node:<< Text: <<
|———————————————Node:identifier Text: mb
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:case_statement Text: case 5: //producer - technically still a transmit buffer
			break;
|————————Node:case Text: case
|————————Node:number_literal Text: 5
|————————Node:: Text: :
|————————Node:comment Text: //producer - technically still a transmit buffer
|————————Node:break_statement Text: break;
|—————————Node:break Text: break
|—————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: //Outside of object interrupt dispatcher. Needed because interrupt handlers can't really be members of a class
|—Node:function_definition Text: void CAN0_Handler(void)
{
	CAN.interruptHandler();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CAN0_Handler(void)
|———Node:identifier Text: CAN0_Handler
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
	CAN.interruptHandler();
}
|———Node:{ Text: {
|———Node:expression_statement Text: CAN.interruptHandler();
|————Node:call_expression Text: CAN.interruptHandler()
|—————Node:field_expression Text: CAN.interruptHandler
|——————Node:identifier Text: CAN
|——————Node:. Text: .
|——————Node:field_identifier Text: interruptHandler
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void CAN1_Handler(void)
{
	CAN2.interruptHandler();
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: CAN1_Handler(void)
|———Node:identifier Text: CAN1_Handler
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
	CAN2.interruptHandler();
}
|———Node:{ Text: {
|———Node:expression_statement Text: CAN2.interruptHandler();
|————Node:call_expression Text: CAN2.interruptHandler()
|—————Node:field_expression Text: CAN2.interruptHandler
|——————Node:identifier Text: CAN2
|——————Node:. Text: .
|——————Node:field_identifier Text: interruptHandler
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /// instantiate the two canbus adapters
|—Node:declaration Text: CANRaw CAN(CAN0, CAN0_RS, CAN0_EN);
|——Node:type_identifier Text: CANRaw
|——Node:function_declarator Text: CAN(CAN0, CAN0_RS, CAN0_EN)
|———Node:identifier Text: CAN
|———Node:parameter_list Text: (CAN0, CAN0_RS, CAN0_EN)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN0
|—————Node:type_identifier Text: CAN0
|————Node:, Text: ,
|————Node:parameter_declaration Text: CAN0_RS
|—————Node:type_identifier Text: CAN0_RS
|————Node:, Text: ,
|————Node:parameter_declaration Text: CAN0_EN
|—————Node:type_identifier Text: CAN0_EN
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: CANRaw CAN2(CAN1, CAN1_RS, CAN1_EN);
|——Node:type_identifier Text: CANRaw
|——Node:function_declarator Text: CAN2(CAN1, CAN1_RS, CAN1_EN)
|———Node:identifier Text: CAN2
|———Node:parameter_list Text: (CAN1, CAN1_RS, CAN1_EN)
|————Node:( Text: (
|————Node:parameter_declaration Text: CAN1
|—————Node:type_identifier Text: CAN1
|————Node:, Text: ,
|————Node:parameter_declaration Text: CAN1_RS
|—————Node:type_identifier Text: CAN1_RS
|————Node:, Text: ,
|————Node:parameter_declaration Text: CAN1_EN
|—————Node:type_identifier Text: CAN1_EN
|————Node:) Text: )
|——Node:; Text: ;
