dev-can-linux-src\resmgr.c

|Node:translation_unit
|—Node:comment Text: /*
 * \file    resmgr.c
 *
 * Copyright (C) 2022 Deniz Eren <deniz.eren@outlook.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
|—Node:preproc_include Text: #include <stdio.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <stdio.h>
|—Node:preproc_include Text: #include <string.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <string.h>
|—Node:preproc_include Text: #include <resmgr.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <resmgr.h>
|—Node:preproc_include Text: #include <config.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <config.h>
|—Node:preproc_include Text: #include <pci.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <pci.h>
|—Node:preproc_include Text: #include <dev-can-linux/commands.h>

|——Node:#include Text: #include
|——Node:system_lib_string Text: <dev-can-linux/commands.h>
|—Node:declaration Text: static can_resmgr_t* root_resmgr = NULL;
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: can_resmgr_t
|——Node:init_declarator Text: * root_resmgr = NULL
|———Node:pointer_declarator Text: * root_resmgr
|————Node:* Text: *
|————Node:identifier Text: root_resmgr
|———Node:= Text: =
|———Node:null Text: NULL
|————Node:NULL Text: NULL
|——Node:; Text: ;
|—Node:declaration Text: IOFUNC_OCB_T* can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr);
|——Node:type_identifier Text: IOFUNC_OCB_T
|——Node:pointer_declarator Text: * can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|———Node:* Text: *
|———Node:function_declarator Text: can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|————Node:identifier Text: can_ocb_calloc
|————Node:parameter_list Text: (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: resmgr_context_t* ctp
|——————Node:type_identifier Text: resmgr_context_t
|——————Node:pointer_declarator Text: * ctp
|———————Node:* Text: *
|———————Node:identifier Text: ctp
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: IOFUNC_ATTR_T* attr
|——————Node:type_identifier Text: IOFUNC_ATTR_T
|——————Node:pointer_declarator Text: * attr
|———————Node:* Text: *
|———————Node:identifier Text: attr
|—————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: void can_ocb_free (IOFUNC_OCB_T* ocb);
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can_ocb_free (IOFUNC_OCB_T* ocb)
|———Node:identifier Text: can_ocb_free
|———Node:parameter_list Text: (IOFUNC_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: IOFUNC_OCB_T* ocb
|—————Node:type_identifier Text: IOFUNC_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:comment Text: /*
 * Resource manager POSIX callback functions for clients to call.
 */
|—Node:declaration Text: int io_close_ocb (resmgr_context_t* ctp, void* reserved,   RESMGR_OCB_T* ocb);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_close_ocb (resmgr_context_t* ctp, void* reserved,   RESMGR_OCB_T* ocb)
|———Node:identifier Text: io_close_ocb
|———Node:parameter_list Text: (resmgr_context_t* ctp, void* reserved,   RESMGR_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* reserved
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * reserved
|——————Node:* Text: *
|——————Node:identifier Text: reserved
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: int io_read      (resmgr_context_t* ctp, io_read_t*   msg, RESMGR_OCB_T* ocb);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_read      (resmgr_context_t* ctp, io_read_t*   msg, RESMGR_OCB_T* ocb)
|———Node:identifier Text: io_read
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_read_t*   msg, RESMGR_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_read_t*   msg
|—————Node:type_identifier Text: io_read_t
|—————Node:pointer_declarator Text: *   msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: int io_write     (resmgr_context_t* ctp, io_write_t*  msg, RESMGR_OCB_T* ocb);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_write     (resmgr_context_t* ctp, io_write_t*  msg, RESMGR_OCB_T* ocb)
|———Node:identifier Text: io_write
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_write_t*  msg, RESMGR_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_write_t*  msg
|—————Node:type_identifier Text: io_write_t
|—————Node:pointer_declarator Text: *  msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: int io_unblock   (resmgr_context_t* ctp, io_pulse_t* msg,  RESMGR_OCB_T* ocb);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_unblock   (resmgr_context_t* ctp, io_pulse_t* msg,  RESMGR_OCB_T* ocb)
|———Node:identifier Text: io_unblock
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_pulse_t* msg,  RESMGR_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_pulse_t* msg
|—————Node:type_identifier Text: io_pulse_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: int io_devctl    (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* ocb);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_devctl    (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* ocb)
|———Node:identifier Text: io_devctl
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_devctl_t* msg
|—————Node:type_identifier Text: io_devctl_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: int io_open      (resmgr_context_t* ctp, io_open_t*   msg,
                    RESMGR_HANDLE_T* handle, void* extra);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_open      (resmgr_context_t* ctp, io_open_t*   msg,
                    RESMGR_HANDLE_T* handle, void* extra)
|———Node:identifier Text: io_open
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_open_t*   msg,
                    RESMGR_HANDLE_T* handle, void* extra)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_open_t*   msg
|—————Node:type_identifier Text: io_open_t
|—————Node:pointer_declarator Text: *   msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_HANDLE_T* handle
|—————Node:type_identifier Text: RESMGR_HANDLE_T
|—————Node:pointer_declarator Text: * handle
|——————Node:* Text: *
|——————Node:identifier Text: handle
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* extra
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * extra
|——————Node:* Text: *
|——————Node:identifier Text: extra
|————Node:) Text: )
|——Node:; Text: ;
|—Node:declaration Text: void* rx_loop (void* arg);
|——Node:primitive_type Text: void
|——Node:pointer_declarator Text: * rx_loop (void* arg)
|———Node:* Text: *
|———Node:function_declarator Text: rx_loop (void* arg)
|————Node:identifier Text: rx_loop
|————Node:parameter_list Text: (void* arg)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: void* arg
|——————Node:primitive_type Text: void
|——————Node:pointer_declarator Text: * arg
|———————Node:* Text: *
|———————Node:identifier Text: arg
|—————Node:) Text: )
|——Node:; Text: ;
|—Node:preproc_if Text: #if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
void* dispatch_receive_loop (void* arg);
#endif
|——Node:#if Text: #if
|——Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|———Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|———Node:== Text: ==
|———Node:number_literal Text: 1
|——Node:
 Text: 

|——Node:declaration Text: void* dispatch_receive_loop (void* arg);
|———Node:primitive_type Text: void
|———Node:pointer_declarator Text: * dispatch_receive_loop (void* arg)
|————Node:* Text: *
|————Node:function_declarator Text: dispatch_receive_loop (void* arg)
|—————Node:identifier Text: dispatch_receive_loop
|—————Node:parameter_list Text: (void* arg)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void* arg
|———————Node:primitive_type Text: void
|———————Node:pointer_declarator Text: * arg
|————————Node:* Text: *
|————————Node:identifier Text: arg
|——————Node:) Text: )
|———Node:; Text: ;
|——Node:#endif Text: #endif
|—Node:comment Text: /*
 * Managing blocking clients
 */
|—Node:type_definition Text: typedef struct {
    uint16_t id;
    int rcvid;
} msg_again_t;
|——Node:typedef Text: typedef
|——Node:struct_specifier Text: struct {
    uint16_t id;
    int rcvid;
}
|———Node:struct Text: struct
|———Node:field_declaration_list Text: {
    uint16_t id;
    int rcvid;
}
|————Node:{ Text: {
|————Node:field_declaration Text: uint16_t id;
|—————Node:primitive_type Text: uint16_t
|—————Node:field_identifier Text: id
|—————Node:; Text: ;
|————Node:field_declaration Text: int rcvid;
|—————Node:primitive_type Text: int
|—————Node:field_identifier Text: rcvid
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:type_identifier Text: msg_again_t
|——Node:; Text: ;
|—Node:declaration Text: int msg_again_callback(
        message_context_t* ctp, int type, unsigned flags, void* handle);
|——Node:primitive_type Text: int
|——Node:function_declarator Text: msg_again_callback(
        message_context_t* ctp, int type, unsigned flags, void* handle)
|———Node:identifier Text: msg_again_callback
|———Node:parameter_list Text: (
        message_context_t* ctp, int type, unsigned flags, void* handle)
|————Node:( Text: (
|————Node:parameter_declaration Text: message_context_t* ctp
|—————Node:type_identifier Text: message_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: int type
|—————Node:primitive_type Text: int
|—————Node:identifier Text: type
|————Node:, Text: ,
|————Node:parameter_declaration Text: unsigned flags
|—————Node:sized_type_specifier Text: unsigned
|——————Node:unsigned Text: unsigned
|—————Node:identifier Text: flags
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* handle
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * handle
|——————Node:* Text: *
|——————Node:identifier Text: handle
|————Node:) Text: )
|——Node:; Text: ;
|—Node:function_definition Text: void create_user_dev_setup ( struct can_devctl_timing* timing, u32 freq,
        struct user_dev_setup* user )
{
    int TQ = timing->bit_rate_prescaler * BILLION / freq;
    int one_bit = BILLION / timing->ref_clock_freq / TQ;
    int prop_seg = one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
                - timing->time_segment_2;

    struct user_dev_setup user1 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
    };

    struct user_dev_setup user2 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
    };

    if (timing->bit_rate_prescaler == 0) {
        memcpy(user, &user2, sizeof(struct user_dev_setup));
    }
    else {
        memcpy(user, &user1, sizeof(struct user_dev_setup));
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: create_user_dev_setup ( struct can_devctl_timing* timing, u32 freq,
        struct user_dev_setup* user )
|———Node:identifier Text: create_user_dev_setup
|———Node:parameter_list Text: ( struct can_devctl_timing* timing, u32 freq,
        struct user_dev_setup* user )
|————Node:( Text: (
|————Node:parameter_declaration Text: struct can_devctl_timing* timing
|—————Node:struct_specifier Text: struct can_devctl_timing
|——————Node:struct Text: struct
|——————Node:type_identifier Text: can_devctl_timing
|—————Node:pointer_declarator Text: * timing
|——————Node:* Text: *
|——————Node:identifier Text: timing
|————Node:, Text: ,
|————Node:parameter_declaration Text: u32 freq
|—————Node:type_identifier Text: u32
|—————Node:identifier Text: freq
|————Node:, Text: ,
|————Node:parameter_declaration Text: struct user_dev_setup* user
|—————Node:struct_specifier Text: struct user_dev_setup
|——————Node:struct Text: struct
|——————Node:type_identifier Text: user_dev_setup
|—————Node:pointer_declarator Text: * user
|——————Node:* Text: *
|——————Node:identifier Text: user
|————Node:) Text: )
|——Node:compound_statement Text: {
    int TQ = timing->bit_rate_prescaler * BILLION / freq;
    int one_bit = BILLION / timing->ref_clock_freq / TQ;
    int prop_seg = one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
                - timing->time_segment_2;

    struct user_dev_setup user1 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
    };

    struct user_dev_setup user2 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
    };

    if (timing->bit_rate_prescaler == 0) {
        memcpy(user, &user2, sizeof(struct user_dev_setup));
    }
    else {
        memcpy(user, &user1, sizeof(struct user_dev_setup));
    }
}
|———Node:{ Text: {
|———Node:declaration Text: int TQ = timing->bit_rate_prescaler * BILLION / freq;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: TQ = timing->bit_rate_prescaler * BILLION / freq
|—————Node:identifier Text: TQ
|—————Node:= Text: =
|—————Node:binary_expression Text: timing->bit_rate_prescaler * BILLION / freq
|——————Node:binary_expression Text: timing->bit_rate_prescaler * BILLION
|———————Node:field_expression Text: timing->bit_rate_prescaler
|————————Node:identifier Text: timing
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bit_rate_prescaler
|———————Node:* Text: *
|———————Node:identifier Text: BILLION
|——————Node:/ Text: /
|——————Node:identifier Text: freq
|————Node:; Text: ;
|———Node:declaration Text: int one_bit = BILLION / timing->ref_clock_freq / TQ;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: one_bit = BILLION / timing->ref_clock_freq / TQ
|—————Node:identifier Text: one_bit
|—————Node:= Text: =
|—————Node:binary_expression Text: BILLION / timing->ref_clock_freq / TQ
|——————Node:binary_expression Text: BILLION / timing->ref_clock_freq
|———————Node:identifier Text: BILLION
|———————Node:/ Text: /
|———————Node:field_expression Text: timing->ref_clock_freq
|————————Node:identifier Text: timing
|————————Node:-> Text: ->
|————————Node:field_identifier Text: ref_clock_freq
|——————Node:/ Text: /
|——————Node:identifier Text: TQ
|————Node:; Text: ;
|———Node:declaration Text: int prop_seg = one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
                - timing->time_segment_2;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: prop_seg = one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
                - timing->time_segment_2
|—————Node:identifier Text: prop_seg
|—————Node:= Text: =
|—————Node:binary_expression Text: one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
                - timing->time_segment_2
|——————Node:binary_expression Text: one_bit
                - timing->sync_jump_width
                - timing->time_segment_1
|———————Node:binary_expression Text: one_bit
                - timing->sync_jump_width
|————————Node:identifier Text: one_bit
|————————Node:- Text: -
|————————Node:field_expression Text: timing->sync_jump_width
|—————————Node:identifier Text: timing
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: sync_jump_width
|———————Node:- Text: -
|———————Node:field_expression Text: timing->time_segment_1
|————————Node:identifier Text: timing
|————————Node:-> Text: ->
|————————Node:field_identifier Text: time_segment_1
|——————Node:- Text: -
|——————Node:field_expression Text: timing->time_segment_2
|———————Node:identifier Text: timing
|———————Node:-> Text: ->
|———————Node:field_identifier Text: time_segment_2
|————Node:; Text: ;
|———Node:declaration Text: struct user_dev_setup user1 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
    };
|————Node:struct_specifier Text: struct user_dev_setup
|—————Node:struct Text: struct
|—————Node:type_identifier Text: user_dev_setup
|————Node:init_declarator Text: user1 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
    }
|—————Node:identifier Text: user1
|—————Node:= Text: =
|—————Node:initializer_list Text: {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
    }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .set_bittiming = true
|———————Node:field_designator Text: .set_bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: set_bittiming
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .bittiming = {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
|———————Node:field_designator Text: .bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: bittiming
|———————Node:= Text: =
|———————Node:initializer_list Text: {
                .bitrate = 0, // set to zero to invoke it's calculation
                .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit,
                .tq = TQ,
                .prop_seg = prop_seg,
                .sjw = timing->sync_jump_width,
                .phase_seg1 = timing->time_segment_1,
                .phase_seg2 = timing->time_segment_2,
                .brp = timing->bit_rate_prescaler
            }
|————————Node:{ Text: {
|————————Node:initializer_pair Text: .bitrate = 0
|—————————Node:field_designator Text: .bitrate
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:comment Text: // set to zero to invoke it's calculation
|————————Node:initializer_pair Text: .sample_point = (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit
|—————————Node:field_designator Text: .sample_point
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sample_point
|—————————Node:= Text: =
|—————————Node:binary_expression Text: (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10/one_bit
|——————————Node:binary_expression Text: (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)*10
|———————————Node:parenthesized_expression Text: (timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: timing->sync_jump_width
                                + prop_seg
                                + timing->time_segment_1
|—————————————Node:binary_expression Text: timing->sync_jump_width
                                + prop_seg
|——————————————Node:field_expression Text: timing->sync_jump_width
|———————————————Node:identifier Text: timing
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: sync_jump_width
|——————————————Node:+ Text: +
|——————————————Node:identifier Text: prop_seg
|—————————————Node:+ Text: +
|—————————————Node:field_expression Text: timing->time_segment_1
|——————————————Node:identifier Text: timing
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: time_segment_1
|————————————Node:) Text: )
|———————————Node:* Text: *
|———————————Node:number_literal Text: 10
|——————————Node:/ Text: /
|——————————Node:identifier Text: one_bit
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .tq = TQ
|—————————Node:field_designator Text: .tq
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tq
|—————————Node:= Text: =
|—————————Node:identifier Text: TQ
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .prop_seg = prop_seg
|—————————Node:field_designator Text: .prop_seg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: prop_seg
|—————————Node:= Text: =
|—————————Node:identifier Text: prop_seg
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .sjw = timing->sync_jump_width
|—————————Node:field_designator Text: .sjw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sjw
|—————————Node:= Text: =
|—————————Node:field_expression Text: timing->sync_jump_width
|——————————Node:identifier Text: timing
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: sync_jump_width
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .phase_seg1 = timing->time_segment_1
|—————————Node:field_designator Text: .phase_seg1
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg1
|—————————Node:= Text: =
|—————————Node:field_expression Text: timing->time_segment_1
|——————————Node:identifier Text: timing
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: time_segment_1
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .phase_seg2 = timing->time_segment_2
|—————————Node:field_designator Text: .phase_seg2
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg2
|—————————Node:= Text: =
|—————————Node:field_expression Text: timing->time_segment_2
|——————————Node:identifier Text: timing
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: time_segment_2
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .brp = timing->bit_rate_prescaler
|—————————Node:field_designator Text: .brp
|——————————Node:. Text: .
|——————————Node:field_identifier Text: brp
|—————————Node:= Text: =
|—————————Node:field_expression Text: timing->bit_rate_prescaler
|——————————Node:identifier Text: timing
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: bit_rate_prescaler
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: struct user_dev_setup user2 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
    };
|————Node:struct_specifier Text: struct user_dev_setup
|—————Node:struct Text: struct
|—————Node:type_identifier Text: user_dev_setup
|————Node:init_declarator Text: user2 = {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
    }
|—————Node:identifier Text: user2
|—————Node:= Text: =
|—————Node:initializer_list Text: {
            .set_bittiming = true,
            .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
    }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .set_bittiming = true
|———————Node:field_designator Text: .set_bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: set_bittiming
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .bittiming = {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
|———————Node:field_designator Text: .bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: bittiming
|———————Node:= Text: =
|———————Node:initializer_list Text: {
                .bitrate = timing->ref_clock_freq,
                .sample_point = 0,
                .tq = 0,
                .prop_seg = 0,
                .sjw = 0,
                .phase_seg1 = 0,
                .phase_seg2 = 0,
                .brp = 0
            }
|————————Node:{ Text: {
|————————Node:initializer_pair Text: .bitrate = timing->ref_clock_freq
|—————————Node:field_designator Text: .bitrate
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitrate
|—————————Node:= Text: =
|—————————Node:field_expression Text: timing->ref_clock_freq
|——————————Node:identifier Text: timing
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: ref_clock_freq
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .sample_point = 0
|—————————Node:field_designator Text: .sample_point
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sample_point
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .tq = 0
|—————————Node:field_designator Text: .tq
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tq
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .prop_seg = 0
|—————————Node:field_designator Text: .prop_seg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: prop_seg
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .sjw = 0
|—————————Node:field_designator Text: .sjw
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sjw
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .phase_seg1 = 0
|—————————Node:field_designator Text: .phase_seg1
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg1
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .phase_seg2 = 0
|—————————Node:field_designator Text: .phase_seg2
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg2
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:initializer_pair Text: .brp = 0
|—————————Node:field_designator Text: .brp
|——————————Node:. Text: .
|——————————Node:field_identifier Text: brp
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:if_statement Text: if (timing->bit_rate_prescaler == 0) {
        memcpy(user, &user2, sizeof(struct user_dev_setup));
    }
    else {
        memcpy(user, &user1, sizeof(struct user_dev_setup));
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (timing->bit_rate_prescaler == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: timing->bit_rate_prescaler == 0
|——————Node:field_expression Text: timing->bit_rate_prescaler
|———————Node:identifier Text: timing
|———————Node:-> Text: ->
|———————Node:field_identifier Text: bit_rate_prescaler
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        memcpy(user, &user2, sizeof(struct user_dev_setup));
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: memcpy(user, &user2, sizeof(struct user_dev_setup));
|——————Node:call_expression Text: memcpy(user, &user2, sizeof(struct user_dev_setup))
|———————Node:identifier Text: memcpy
|———————Node:argument_list Text: (user, &user2, sizeof(struct user_dev_setup))
|————————Node:( Text: (
|————————Node:identifier Text: user
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &user2
|—————————Node:& Text: &
|—————————Node:identifier Text: user2
|————————Node:, Text: ,
|————————Node:sizeof_expression Text: sizeof(struct user_dev_setup)
|—————————Node:sizeof Text: sizeof
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: struct user_dev_setup
|——————————Node:struct_specifier Text: struct user_dev_setup
|———————————Node:struct Text: struct
|———————————Node:type_identifier Text: user_dev_setup
|—————————Node:) Text: )
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        memcpy(user, &user1, sizeof(struct user_dev_setup));
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        memcpy(user, &user1, sizeof(struct user_dev_setup));
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: memcpy(user, &user1, sizeof(struct user_dev_setup));
|———————Node:call_expression Text: memcpy(user, &user1, sizeof(struct user_dev_setup))
|————————Node:identifier Text: memcpy
|————————Node:argument_list Text: (user, &user1, sizeof(struct user_dev_setup))
|—————————Node:( Text: (
|—————————Node:identifier Text: user
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &user1
|——————————Node:& Text: &
|——————————Node:identifier Text: user1
|—————————Node:, Text: ,
|—————————Node:sizeof_expression Text: sizeof(struct user_dev_setup)
|——————————Node:sizeof Text: sizeof
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: struct user_dev_setup
|———————————Node:struct_specifier Text: struct user_dev_setup
|————————————Node:struct Text: struct
|————————————Node:type_identifier Text: user_dev_setup
|——————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:} Text: }
|—Node:comment Text: /*
 * Our connect and I/O functions - we supply two tables
 * which will be filled with pointers to callback functions
 * for each POSIX function. The connect functions are all
 * functions that take a path, e.g. open(), while the I/O
 * functions are those functions that are used with a file
 * descriptor (fd), e.g. read().
 */
|—Node:declaration Text: resmgr_connect_funcs_t connect_funcs;
|——Node:type_identifier Text: resmgr_connect_funcs_t
|——Node:identifier Text: connect_funcs
|——Node:; Text: ;
|—Node:declaration Text: resmgr_io_funcs_t io_funcs;
|——Node:type_identifier Text: resmgr_io_funcs_t
|——Node:identifier Text: io_funcs
|——Node:; Text: ;
|—Node:declaration Text: void log_trace_bittiming_info (struct net_device* device);
|——Node:primitive_type Text: void
|——Node:function_declarator Text: log_trace_bittiming_info (struct net_device* device)
|———Node:identifier Text: log_trace_bittiming_info
|———Node:parameter_list Text: (struct net_device* device)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device* device
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: * device
|——————Node:* Text: *
|——————Node:identifier Text: device
|————Node:) Text: )
|——Node:; Text: ;
|—Node:function_definition Text: int register_netdev (struct net_device* dev) {
    if (dev == NULL) {
        log_err("register_netdev failed: invalid net_device\n");
        return -1;
    }

    if (probe_driver_selection == NULL) {
        log_err("register_netdev failed: invalid probe_driver_selection\n");
        return -1;
    }

    int id = next_device_id++;

    snprintf( dev->name, IFNAMSIZ, "%s-can%d",
            probe_driver_selection->driver->name, dev->dev_id );

    log_trace("register_netdev: %s\n", dev->name);

    struct user_dev_setup user = {
            .set_restart_ms = true,
            .restart_ms = optr_restart_ms,
            .set_bittiming = true,
            .bittiming = { .bitrate = 250000 }
    };

    if (id < num_optb_configs) {
        if (id == optb_config[id].id && optb_config[id].bitrate != 0) {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
    }

    if (opts) { /* silent mode; disable all CAN-bus TX capability */
        user.set_ctrlmode = true;
        user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY;
    }

    int err;
    if ((err = dev->resmgr_ops->changelink(dev, &user, NULL)) != 0) {
        log_err("register_netdev: changelink failed: %d\n", err);

        return -1;
    }

    dev->device_session = NULL;

    log_trace_bittiming_info(dev);

    if (dev->netdev_ops->ndo_open(dev)) {
        log_err("register_netdev failed: ndo_open error\n");

        return -1;
    }

    const queue_attr_t tx_attr = { .size = 15 };

    device_session_t* device_session;
    if ((device_session = create_device_session(dev, &tx_attr)) != NULL) {
    }

    dev->device_session = device_session;

    static int io_created = 0;

    if (!io_created) {
        io_created = 1;

        /* Now, let's initialize the tables of connect functions and
         * I/O functions to their defaults (system fallback
         * routines) and then override the defaults with the
         * functions that we are providing. */
        iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs );

        /* Now we override the default function pointers with
         * some of our own coded functions: */
        connect_funcs.open = io_open;
        io_funcs.close_ocb = io_close_ocb;
        io_funcs.read = io_read;
        io_funcs.unblock = io_unblock;
        io_funcs.write = io_write;
        io_funcs.devctl = io_devctl;
    }

    int num_channels[2] = {
        DEFAULT_NUM_RX_CHANNELS,
        DEFAULT_NUM_TX_CHANNELS
    };

    int is_extended_mid = 0; // Default is standard MIDs

    if (optx) {
        is_extended_mid = 1; // Change to extended if driver option is given
    }

    if (id < num_optu_configs) {
        if (id == optu_config[id].id) {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
    }

    int i, j;
    for (j = 0; j < 2; ++j) { // 2 for rx & tx
        for (i = 0; i < num_channels[j]; ++i) { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
    }

    return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: register_netdev (struct net_device* dev)
|———Node:identifier Text: register_netdev
|———Node:parameter_list Text: (struct net_device* dev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device* dev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: * dev
|——————Node:* Text: *
|——————Node:identifier Text: dev
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (dev == NULL) {
        log_err("register_netdev failed: invalid net_device\n");
        return -1;
    }

    if (probe_driver_selection == NULL) {
        log_err("register_netdev failed: invalid probe_driver_selection\n");
        return -1;
    }

    int id = next_device_id++;

    snprintf( dev->name, IFNAMSIZ, "%s-can%d",
            probe_driver_selection->driver->name, dev->dev_id );

    log_trace("register_netdev: %s\n", dev->name);

    struct user_dev_setup user = {
            .set_restart_ms = true,
            .restart_ms = optr_restart_ms,
            .set_bittiming = true,
            .bittiming = { .bitrate = 250000 }
    };

    if (id < num_optb_configs) {
        if (id == optb_config[id].id && optb_config[id].bitrate != 0) {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
    }

    if (opts) { /* silent mode; disable all CAN-bus TX capability */
        user.set_ctrlmode = true;
        user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY;
    }

    int err;
    if ((err = dev->resmgr_ops->changelink(dev, &user, NULL)) != 0) {
        log_err("register_netdev: changelink failed: %d\n", err);

        return -1;
    }

    dev->device_session = NULL;

    log_trace_bittiming_info(dev);

    if (dev->netdev_ops->ndo_open(dev)) {
        log_err("register_netdev failed: ndo_open error\n");

        return -1;
    }

    const queue_attr_t tx_attr = { .size = 15 };

    device_session_t* device_session;
    if ((device_session = create_device_session(dev, &tx_attr)) != NULL) {
    }

    dev->device_session = device_session;

    static int io_created = 0;

    if (!io_created) {
        io_created = 1;

        /* Now, let's initialize the tables of connect functions and
         * I/O functions to their defaults (system fallback
         * routines) and then override the defaults with the
         * functions that we are providing. */
        iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs );

        /* Now we override the default function pointers with
         * some of our own coded functions: */
        connect_funcs.open = io_open;
        io_funcs.close_ocb = io_close_ocb;
        io_funcs.read = io_read;
        io_funcs.unblock = io_unblock;
        io_funcs.write = io_write;
        io_funcs.devctl = io_devctl;
    }

    int num_channels[2] = {
        DEFAULT_NUM_RX_CHANNELS,
        DEFAULT_NUM_TX_CHANNELS
    };

    int is_extended_mid = 0; // Default is standard MIDs

    if (optx) {
        is_extended_mid = 1; // Change to extended if driver option is given
    }

    if (id < num_optu_configs) {
        if (id == optu_config[id].id) {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
    }

    int i, j;
    for (j = 0; j < 2; ++j) { // 2 for rx & tx
        for (i = 0; i < num_channels[j]; ++i) { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
    }

    return 0;
}
|———Node:{ Text: {
|———Node:if_statement Text: if (dev == NULL) {
        log_err("register_netdev failed: invalid net_device\n");
        return -1;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dev == NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: dev == NULL
|——————Node:identifier Text: dev
|——————Node:== Text: ==
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("register_netdev failed: invalid net_device\n");
        return -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("register_netdev failed: invalid net_device\n");
|——————Node:call_expression Text: log_err("register_netdev failed: invalid net_device\n")
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("register_netdev failed: invalid net_device\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "register_netdev failed: invalid net_device\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: register_netdev failed: invalid net_device
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -1;
|——————Node:return Text: return
|——————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (probe_driver_selection == NULL) {
        log_err("register_netdev failed: invalid probe_driver_selection\n");
        return -1;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (probe_driver_selection == NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: probe_driver_selection == NULL
|——————Node:identifier Text: probe_driver_selection
|——————Node:== Text: ==
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("register_netdev failed: invalid probe_driver_selection\n");
        return -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("register_netdev failed: invalid probe_driver_selection\n");
|——————Node:call_expression Text: log_err("register_netdev failed: invalid probe_driver_selection\n")
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("register_netdev failed: invalid probe_driver_selection\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "register_netdev failed: invalid probe_driver_selection\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: register_netdev failed: invalid probe_driver_selection
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -1;
|——————Node:return Text: return
|——————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: int id = next_device_id++;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: id = next_device_id++
|—————Node:identifier Text: id
|—————Node:= Text: =
|—————Node:update_expression Text: next_device_id++
|——————Node:identifier Text: next_device_id
|——————Node:++ Text: ++
|————Node:; Text: ;
|———Node:expression_statement Text: snprintf( dev->name, IFNAMSIZ, "%s-can%d",
            probe_driver_selection->driver->name, dev->dev_id );
|————Node:call_expression Text: snprintf( dev->name, IFNAMSIZ, "%s-can%d",
            probe_driver_selection->driver->name, dev->dev_id )
|—————Node:identifier Text: snprintf
|—————Node:argument_list Text: ( dev->name, IFNAMSIZ, "%s-can%d",
            probe_driver_selection->driver->name, dev->dev_id )
|——————Node:( Text: (
|——————Node:field_expression Text: dev->name
|———————Node:identifier Text: dev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:, Text: ,
|——————Node:identifier Text: IFNAMSIZ
|——————Node:, Text: ,
|——————Node:string_literal Text: "%s-can%d"
|———————Node:" Text: "
|———————Node:string_content Text: %s-can%d
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: probe_driver_selection->driver->name
|———————Node:field_expression Text: probe_driver_selection->driver
|————————Node:identifier Text: probe_driver_selection
|————————Node:-> Text: ->
|————————Node:field_identifier Text: driver
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:, Text: ,
|——————Node:field_expression Text: dev->dev_id
|———————Node:identifier Text: dev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dev_id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("register_netdev: %s\n", dev->name);
|————Node:call_expression Text: log_trace("register_netdev: %s\n", dev->name)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("register_netdev: %s\n", dev->name)
|——————Node:( Text: (
|——————Node:string_literal Text: "register_netdev: %s\n"
|———————Node:" Text: "
|———————Node:string_content Text: register_netdev: %s
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: dev->name
|———————Node:identifier Text: dev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct user_dev_setup user = {
            .set_restart_ms = true,
            .restart_ms = optr_restart_ms,
            .set_bittiming = true,
            .bittiming = { .bitrate = 250000 }
    };
|————Node:struct_specifier Text: struct user_dev_setup
|—————Node:struct Text: struct
|—————Node:type_identifier Text: user_dev_setup
|————Node:init_declarator Text: user = {
            .set_restart_ms = true,
            .restart_ms = optr_restart_ms,
            .set_bittiming = true,
            .bittiming = { .bitrate = 250000 }
    }
|—————Node:identifier Text: user
|—————Node:= Text: =
|—————Node:initializer_list Text: {
            .set_restart_ms = true,
            .restart_ms = optr_restart_ms,
            .set_bittiming = true,
            .bittiming = { .bitrate = 250000 }
    }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .set_restart_ms = true
|———————Node:field_designator Text: .set_restart_ms
|————————Node:. Text: .
|————————Node:field_identifier Text: set_restart_ms
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .restart_ms = optr_restart_ms
|———————Node:field_designator Text: .restart_ms
|————————Node:. Text: .
|————————Node:field_identifier Text: restart_ms
|———————Node:= Text: =
|———————Node:identifier Text: optr_restart_ms
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .set_bittiming = true
|———————Node:field_designator Text: .set_bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: set_bittiming
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .bittiming = { .bitrate = 250000 }
|———————Node:field_designator Text: .bittiming
|————————Node:. Text: .
|————————Node:field_identifier Text: bittiming
|———————Node:= Text: =
|———————Node:initializer_list Text: { .bitrate = 250000 }
|————————Node:{ Text: {
|————————Node:initializer_pair Text: .bitrate = 250000
|—————————Node:field_designator Text: .bitrate
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitrate
|—————————Node:= Text: =
|—————————Node:number_literal Text: 250000
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:if_statement Text: if (id < num_optb_configs) {
        if (id == optb_config[id].id && optb_config[id].bitrate != 0) {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (id < num_optb_configs)
|—————Node:( Text: (
|—————Node:binary_expression Text: id < num_optb_configs
|——————Node:identifier Text: id
|——————Node:< Text: <
|——————Node:identifier Text: num_optb_configs
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (id == optb_config[id].id && optb_config[id].bitrate != 0) {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (id == optb_config[id].id && optb_config[id].bitrate != 0) {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (id == optb_config[id].id && optb_config[id].bitrate != 0)
|———————Node:( Text: (
|———————Node:binary_expression Text: id == optb_config[id].id && optb_config[id].bitrate != 0
|————————Node:binary_expression Text: id == optb_config[id].id
|—————————Node:identifier Text: id
|—————————Node:== Text: ==
|—————————Node:field_expression Text: optb_config[id].id
|——————————Node:subscript_expression Text: optb_config[id]
|———————————Node:identifier Text: optb_config
|———————————Node:[ Text: [
|———————————Node:identifier Text: id
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: id
|————————Node:&& Text: &&
|————————Node:binary_expression Text: optb_config[id].bitrate != 0
|—————————Node:field_expression Text: optb_config[id].bitrate
|——————————Node:subscript_expression Text: optb_config[id]
|———————————Node:identifier Text: optb_config
|———————————Node:[ Text: [
|———————————Node:identifier Text: id
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitrate
|—————————Node:!= Text: !=
|—————————Node:number_literal Text: 0
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
        }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0) {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
            else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: optb_config[id].btr0 != 0 || optb_config[id].btr1 != 0
|——————————Node:binary_expression Text: optb_config[id].btr0 != 0
|———————————Node:field_expression Text: optb_config[id].btr0
|————————————Node:subscript_expression Text: optb_config[id]
|—————————————Node:identifier Text: optb_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr0
|———————————Node:!= Text: !=
|———————————Node:number_literal Text: 0
|——————————Node:|| Text: ||
|——————————Node:binary_expression Text: optb_config[id].btr1 != 0
|———————————Node:field_expression Text: optb_config[id].btr1
|————————————Node:subscript_expression Text: optb_config[id]
|—————————————Node:identifier Text: optb_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr1
|———————————Node:!= Text: !=
|———————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                user.set_bittiming = false;
                user.set_btr = true;
                user.bittiming.bitrate = optb_config[id].bitrate;
                user.can_btr.btr0 = optb_config[id].btr0;
                user.can_btr.btr1 = optb_config[id].btr1;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: user.set_bittiming = false;
|——————————Node:assignment_expression Text: user.set_bittiming = false
|———————————Node:field_expression Text: user.set_bittiming
|————————————Node:identifier Text: user
|————————————Node:. Text: .
|————————————Node:field_identifier Text: set_bittiming
|———————————Node:= Text: =
|———————————Node:false Text: false
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: user.set_btr = true;
|——————————Node:assignment_expression Text: user.set_btr = true
|———————————Node:field_expression Text: user.set_btr
|————————————Node:identifier Text: user
|————————————Node:. Text: .
|————————————Node:field_identifier Text: set_btr
|———————————Node:= Text: =
|———————————Node:true Text: true
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: user.bittiming.bitrate = optb_config[id].bitrate;
|——————————Node:assignment_expression Text: user.bittiming.bitrate = optb_config[id].bitrate
|———————————Node:field_expression Text: user.bittiming.bitrate
|————————————Node:field_expression Text: user.bittiming
|—————————————Node:identifier Text: user
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: bittiming
|————————————Node:. Text: .
|————————————Node:field_identifier Text: bitrate
|———————————Node:= Text: =
|———————————Node:field_expression Text: optb_config[id].bitrate
|————————————Node:subscript_expression Text: optb_config[id]
|—————————————Node:identifier Text: optb_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: bitrate
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: user.can_btr.btr0 = optb_config[id].btr0;
|——————————Node:assignment_expression Text: user.can_btr.btr0 = optb_config[id].btr0
|———————————Node:field_expression Text: user.can_btr.btr0
|————————————Node:field_expression Text: user.can_btr
|—————————————Node:identifier Text: user
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: can_btr
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr0
|———————————Node:= Text: =
|———————————Node:field_expression Text: optb_config[id].btr0
|————————————Node:subscript_expression Text: optb_config[id]
|—————————————Node:identifier Text: optb_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr0
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: user.can_btr.btr1 = optb_config[id].btr1;
|——————————Node:assignment_expression Text: user.can_btr.btr1 = optb_config[id].btr1
|———————————Node:field_expression Text: user.can_btr.btr1
|————————————Node:field_expression Text: user.can_btr
|—————————————Node:identifier Text: user
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: can_btr
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr1
|———————————Node:= Text: =
|———————————Node:field_expression Text: optb_config[id].btr1
|————————————Node:subscript_expression Text: optb_config[id]
|—————————————Node:identifier Text: optb_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: btr1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (optb_config[id].bitrate != 0) {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (optb_config[id].bitrate != 0)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: optb_config[id].bitrate != 0
|————————————Node:field_expression Text: optb_config[id].bitrate
|—————————————Node:subscript_expression Text: optb_config[id]
|——————————————Node:identifier Text: optb_config
|——————————————Node:[ Text: [
|——————————————Node:identifier Text: id
|——————————————Node:] Text: ]
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: bitrate
|————————————Node:!= Text: !=
|————————————Node:number_literal Text: 0
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                struct can_priv* priv = netdev_priv(dev);
                struct can_devctl_timing timing;

                user.bittiming.bitrate = optb_config[id].bitrate;
                timing.ref_clock_freq = optb_config[id].bitrate;
                timing.sync_jump_width = optb_config[id].sjw;
                timing.time_segment_1 = optb_config[id].phase_seg1;
                timing.time_segment_2 = optb_config[id].phase_seg2;
                timing.bit_rate_prescaler = optb_config[id].bprm;

                create_user_dev_setup(&timing, priv->clock.freq, &user);
            }
|———————————Node:{ Text: {
|———————————Node:declaration Text: struct can_priv* priv = netdev_priv(dev);
|————————————Node:struct_specifier Text: struct can_priv
|—————————————Node:struct Text: struct
|—————————————Node:type_identifier Text: can_priv
|————————————Node:init_declarator Text: * priv = netdev_priv(dev)
|—————————————Node:pointer_declarator Text: * priv
|——————————————Node:* Text: *
|——————————————Node:identifier Text: priv
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: netdev_priv(dev)
|——————————————Node:identifier Text: netdev_priv
|——————————————Node:argument_list Text: (dev)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: dev
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:declaration Text: struct can_devctl_timing timing;
|————————————Node:struct_specifier Text: struct can_devctl_timing
|—————————————Node:struct Text: struct
|—————————————Node:type_identifier Text: can_devctl_timing
|————————————Node:identifier Text: timing
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: user.bittiming.bitrate = optb_config[id].bitrate;
|————————————Node:assignment_expression Text: user.bittiming.bitrate = optb_config[id].bitrate
|—————————————Node:field_expression Text: user.bittiming.bitrate
|——————————————Node:field_expression Text: user.bittiming
|———————————————Node:identifier Text: user
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: bittiming
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: bitrate
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].bitrate
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: bitrate
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: timing.ref_clock_freq = optb_config[id].bitrate;
|————————————Node:assignment_expression Text: timing.ref_clock_freq = optb_config[id].bitrate
|—————————————Node:field_expression Text: timing.ref_clock_freq
|——————————————Node:identifier Text: timing
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: ref_clock_freq
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].bitrate
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: bitrate
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: timing.sync_jump_width = optb_config[id].sjw;
|————————————Node:assignment_expression Text: timing.sync_jump_width = optb_config[id].sjw
|—————————————Node:field_expression Text: timing.sync_jump_width
|——————————————Node:identifier Text: timing
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: sync_jump_width
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].sjw
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: sjw
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: timing.time_segment_1 = optb_config[id].phase_seg1;
|————————————Node:assignment_expression Text: timing.time_segment_1 = optb_config[id].phase_seg1
|—————————————Node:field_expression Text: timing.time_segment_1
|——————————————Node:identifier Text: timing
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: time_segment_1
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].phase_seg1
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: phase_seg1
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: timing.time_segment_2 = optb_config[id].phase_seg2;
|————————————Node:assignment_expression Text: timing.time_segment_2 = optb_config[id].phase_seg2
|—————————————Node:field_expression Text: timing.time_segment_2
|——————————————Node:identifier Text: timing
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: time_segment_2
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].phase_seg2
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: phase_seg2
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: timing.bit_rate_prescaler = optb_config[id].bprm;
|————————————Node:assignment_expression Text: timing.bit_rate_prescaler = optb_config[id].bprm
|—————————————Node:field_expression Text: timing.bit_rate_prescaler
|——————————————Node:identifier Text: timing
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: bit_rate_prescaler
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: optb_config[id].bprm
|——————————————Node:subscript_expression Text: optb_config[id]
|———————————————Node:identifier Text: optb_config
|———————————————Node:[ Text: [
|———————————————Node:identifier Text: id
|———————————————Node:] Text: ]
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: bprm
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: create_user_dev_setup(&timing, priv->clock.freq, &user);
|————————————Node:call_expression Text: create_user_dev_setup(&timing, priv->clock.freq, &user)
|—————————————Node:identifier Text: create_user_dev_setup
|—————————————Node:argument_list Text: (&timing, priv->clock.freq, &user)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &timing
|———————————————Node:& Text: &
|———————————————Node:identifier Text: timing
|——————————————Node:, Text: ,
|——————————————Node:field_expression Text: priv->clock.freq
|———————————————Node:field_expression Text: priv->clock
|————————————————Node:identifier Text: priv
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: clock
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: freq
|——————————————Node:, Text: ,
|——————————————Node:pointer_expression Text: &user
|———————————————Node:& Text: &
|———————————————Node:identifier Text: user
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:if_statement Text: if (opts) { /* silent mode; disable all CAN-bus TX capability */
        user.set_ctrlmode = true;
        user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (opts)
|—————Node:( Text: (
|—————Node:identifier Text: opts
|—————Node:) Text: )
|————Node:compound_statement Text: { /* silent mode; disable all CAN-bus TX capability */
        user.set_ctrlmode = true;
        user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY;
    }
|—————Node:{ Text: {
|—————Node:comment Text: /* silent mode; disable all CAN-bus TX capability */
|—————Node:expression_statement Text: user.set_ctrlmode = true;
|——————Node:assignment_expression Text: user.set_ctrlmode = true
|———————Node:field_expression Text: user.set_ctrlmode
|————————Node:identifier Text: user
|————————Node:. Text: .
|————————Node:field_identifier Text: set_ctrlmode
|———————Node:= Text: =
|———————Node:true Text: true
|——————Node:; Text: ;
|—————Node:expression_statement Text: user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY;
|——————Node:assignment_expression Text: user.ctrlmode.flags = user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY
|———————Node:field_expression Text: user.ctrlmode.flags
|————————Node:field_expression Text: user.ctrlmode
|—————————Node:identifier Text: user
|—————————Node:. Text: .
|—————————Node:field_identifier Text: ctrlmode
|————————Node:. Text: .
|————————Node:field_identifier Text: flags
|———————Node:= Text: =
|———————Node:assignment_expression Text: user.ctrlmode.mask = CAN_CTRLMODE_LISTENONLY
|————————Node:field_expression Text: user.ctrlmode.mask
|—————————Node:field_expression Text: user.ctrlmode
|——————————Node:identifier Text: user
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ctrlmode
|—————————Node:. Text: .
|—————————Node:field_identifier Text: mask
|————————Node:= Text: =
|————————Node:identifier Text: CAN_CTRLMODE_LISTENONLY
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: int err;
|————Node:primitive_type Text: int
|————Node:identifier Text: err
|————Node:; Text: ;
|———Node:if_statement Text: if ((err = dev->resmgr_ops->changelink(dev, &user, NULL)) != 0) {
        log_err("register_netdev: changelink failed: %d\n", err);

        return -1;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((err = dev->resmgr_ops->changelink(dev, &user, NULL)) != 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: (err = dev->resmgr_ops->changelink(dev, &user, NULL)) != 0
|——————Node:parenthesized_expression Text: (err = dev->resmgr_ops->changelink(dev, &user, NULL))
|———————Node:( Text: (
|———————Node:assignment_expression Text: err = dev->resmgr_ops->changelink(dev, &user, NULL)
|————————Node:identifier Text: err
|————————Node:= Text: =
|————————Node:call_expression Text: dev->resmgr_ops->changelink(dev, &user, NULL)
|—————————Node:field_expression Text: dev->resmgr_ops->changelink
|——————————Node:field_expression Text: dev->resmgr_ops
|———————————Node:identifier Text: dev
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr_ops
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: changelink
|—————————Node:argument_list Text: (dev, &user, NULL)
|——————————Node:( Text: (
|——————————Node:identifier Text: dev
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &user
|———————————Node:& Text: &
|———————————Node:identifier Text: user
|——————————Node:, Text: ,
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("register_netdev: changelink failed: %d\n", err);

        return -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("register_netdev: changelink failed: %d\n", err);
|——————Node:call_expression Text: log_err("register_netdev: changelink failed: %d\n", err)
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("register_netdev: changelink failed: %d\n", err)
|————————Node:( Text: (
|————————Node:string_literal Text: "register_netdev: changelink failed: %d\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: register_netdev: changelink failed: %d
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: err
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -1;
|——————Node:return Text: return
|——————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: dev->device_session = NULL;
|————Node:assignment_expression Text: dev->device_session = NULL
|—————Node:field_expression Text: dev->device_session
|——————Node:identifier Text: dev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: device_session
|—————Node:= Text: =
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace_bittiming_info(dev);
|————Node:call_expression Text: log_trace_bittiming_info(dev)
|—————Node:identifier Text: log_trace_bittiming_info
|—————Node:argument_list Text: (dev)
|——————Node:( Text: (
|——————Node:identifier Text: dev
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (dev->netdev_ops->ndo_open(dev)) {
        log_err("register_netdev failed: ndo_open error\n");

        return -1;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dev->netdev_ops->ndo_open(dev))
|—————Node:( Text: (
|—————Node:call_expression Text: dev->netdev_ops->ndo_open(dev)
|——————Node:field_expression Text: dev->netdev_ops->ndo_open
|———————Node:field_expression Text: dev->netdev_ops
|————————Node:identifier Text: dev
|————————Node:-> Text: ->
|————————Node:field_identifier Text: netdev_ops
|———————Node:-> Text: ->
|———————Node:field_identifier Text: ndo_open
|——————Node:argument_list Text: (dev)
|———————Node:( Text: (
|———————Node:identifier Text: dev
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("register_netdev failed: ndo_open error\n");

        return -1;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("register_netdev failed: ndo_open error\n");
|——————Node:call_expression Text: log_err("register_netdev failed: ndo_open error\n")
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("register_netdev failed: ndo_open error\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "register_netdev failed: ndo_open error\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: register_netdev failed: ndo_open error
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return -1;
|——————Node:return Text: return
|——————Node:number_literal Text: -1
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: const queue_attr_t tx_attr = { .size = 15 };
|————Node:type_qualifier Text: const
|—————Node:const Text: const
|————Node:type_identifier Text: queue_attr_t
|————Node:init_declarator Text: tx_attr = { .size = 15 }
|—————Node:identifier Text: tx_attr
|—————Node:= Text: =
|—————Node:initializer_list Text: { .size = 15 }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .size = 15
|———————Node:field_designator Text: .size
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:= Text: =
|———————Node:number_literal Text: 15
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: device_session_t* device_session;
|————Node:type_identifier Text: device_session_t
|————Node:pointer_declarator Text: * device_session
|—————Node:* Text: *
|—————Node:identifier Text: device_session
|————Node:; Text: ;
|———Node:if_statement Text: if ((device_session = create_device_session(dev, &tx_attr)) != NULL) {
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((device_session = create_device_session(dev, &tx_attr)) != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: (device_session = create_device_session(dev, &tx_attr)) != NULL
|——————Node:parenthesized_expression Text: (device_session = create_device_session(dev, &tx_attr))
|———————Node:( Text: (
|———————Node:assignment_expression Text: device_session = create_device_session(dev, &tx_attr)
|————————Node:identifier Text: device_session
|————————Node:= Text: =
|————————Node:call_expression Text: create_device_session(dev, &tx_attr)
|—————————Node:identifier Text: create_device_session
|—————————Node:argument_list Text: (dev, &tx_attr)
|——————————Node:( Text: (
|——————————Node:identifier Text: dev
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &tx_attr
|———————————Node:& Text: &
|———————————Node:identifier Text: tx_attr
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
    }
|—————Node:{ Text: {
|—————Node:} Text: }
|———Node:expression_statement Text: dev->device_session = device_session;
|————Node:assignment_expression Text: dev->device_session = device_session
|—————Node:field_expression Text: dev->device_session
|——————Node:identifier Text: dev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: device_session
|—————Node:= Text: =
|—————Node:identifier Text: device_session
|————Node:; Text: ;
|———Node:declaration Text: static int io_created = 0;
|————Node:storage_class_specifier Text: static
|—————Node:static Text: static
|————Node:primitive_type Text: int
|————Node:init_declarator Text: io_created = 0
|—————Node:identifier Text: io_created
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (!io_created) {
        io_created = 1;

        /* Now, let's initialize the tables of connect functions and
         * I/O functions to their defaults (system fallback
         * routines) and then override the defaults with the
         * functions that we are providing. */
        iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs );

        /* Now we override the default function pointers with
         * some of our own coded functions: */
        connect_funcs.open = io_open;
        io_funcs.close_ocb = io_close_ocb;
        io_funcs.read = io_read;
        io_funcs.unblock = io_unblock;
        io_funcs.write = io_write;
        io_funcs.devctl = io_devctl;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!io_created)
|—————Node:( Text: (
|—————Node:unary_expression Text: !io_created
|——————Node:! Text: !
|——————Node:identifier Text: io_created
|—————Node:) Text: )
|————Node:compound_statement Text: {
        io_created = 1;

        /* Now, let's initialize the tables of connect functions and
         * I/O functions to their defaults (system fallback
         * routines) and then override the defaults with the
         * functions that we are providing. */
        iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs );

        /* Now we override the default function pointers with
         * some of our own coded functions: */
        connect_funcs.open = io_open;
        io_funcs.close_ocb = io_close_ocb;
        io_funcs.read = io_read;
        io_funcs.unblock = io_unblock;
        io_funcs.write = io_write;
        io_funcs.devctl = io_devctl;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: io_created = 1;
|——————Node:assignment_expression Text: io_created = 1
|———————Node:identifier Text: io_created
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:comment Text: /* Now, let's initialize the tables of connect functions and
         * I/O functions to their defaults (system fallback
         * routines) and then override the defaults with the
         * functions that we are providing. */
|—————Node:expression_statement Text: iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs );
|——————Node:call_expression Text: iofunc_func_init( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs )
|———————Node:identifier Text: iofunc_func_init
|———————Node:argument_list Text: ( _RESMGR_CONNECT_NFUNCS, &connect_funcs,
                _RESMGR_IO_NFUNCS, &io_funcs )
|————————Node:( Text: (
|————————Node:identifier Text: _RESMGR_CONNECT_NFUNCS
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &connect_funcs
|—————————Node:& Text: &
|—————————Node:identifier Text: connect_funcs
|————————Node:, Text: ,
|————————Node:identifier Text: _RESMGR_IO_NFUNCS
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &io_funcs
|—————————Node:& Text: &
|—————————Node:identifier Text: io_funcs
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: /* Now we override the default function pointers with
         * some of our own coded functions: */
|—————Node:expression_statement Text: connect_funcs.open = io_open;
|——————Node:assignment_expression Text: connect_funcs.open = io_open
|———————Node:field_expression Text: connect_funcs.open
|————————Node:identifier Text: connect_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: open
|———————Node:= Text: =
|———————Node:identifier Text: io_open
|——————Node:; Text: ;
|—————Node:expression_statement Text: io_funcs.close_ocb = io_close_ocb;
|——————Node:assignment_expression Text: io_funcs.close_ocb = io_close_ocb
|———————Node:field_expression Text: io_funcs.close_ocb
|————————Node:identifier Text: io_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: close_ocb
|———————Node:= Text: =
|———————Node:identifier Text: io_close_ocb
|——————Node:; Text: ;
|—————Node:expression_statement Text: io_funcs.read = io_read;
|——————Node:assignment_expression Text: io_funcs.read = io_read
|———————Node:field_expression Text: io_funcs.read
|————————Node:identifier Text: io_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: read
|———————Node:= Text: =
|———————Node:identifier Text: io_read
|——————Node:; Text: ;
|—————Node:expression_statement Text: io_funcs.unblock = io_unblock;
|——————Node:assignment_expression Text: io_funcs.unblock = io_unblock
|———————Node:field_expression Text: io_funcs.unblock
|————————Node:identifier Text: io_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: unblock
|———————Node:= Text: =
|———————Node:identifier Text: io_unblock
|——————Node:; Text: ;
|—————Node:expression_statement Text: io_funcs.write = io_write;
|——————Node:assignment_expression Text: io_funcs.write = io_write
|———————Node:field_expression Text: io_funcs.write
|————————Node:identifier Text: io_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: write
|———————Node:= Text: =
|———————Node:identifier Text: io_write
|——————Node:; Text: ;
|—————Node:expression_statement Text: io_funcs.devctl = io_devctl;
|——————Node:assignment_expression Text: io_funcs.devctl = io_devctl
|———————Node:field_expression Text: io_funcs.devctl
|————————Node:identifier Text: io_funcs
|————————Node:. Text: .
|————————Node:field_identifier Text: devctl
|———————Node:= Text: =
|———————Node:identifier Text: io_devctl
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:declaration Text: int num_channels[2] = {
        DEFAULT_NUM_RX_CHANNELS,
        DEFAULT_NUM_TX_CHANNELS
    };
|————Node:primitive_type Text: int
|————Node:init_declarator Text: num_channels[2] = {
        DEFAULT_NUM_RX_CHANNELS,
        DEFAULT_NUM_TX_CHANNELS
    }
|—————Node:array_declarator Text: num_channels[2]
|——————Node:identifier Text: num_channels
|——————Node:[ Text: [
|——————Node:number_literal Text: 2
|——————Node:] Text: ]
|—————Node:= Text: =
|—————Node:initializer_list Text: {
        DEFAULT_NUM_RX_CHANNELS,
        DEFAULT_NUM_TX_CHANNELS
    }
|——————Node:{ Text: {
|——————Node:identifier Text: DEFAULT_NUM_RX_CHANNELS
|——————Node:, Text: ,
|——————Node:identifier Text: DEFAULT_NUM_TX_CHANNELS
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:declaration Text: int is_extended_mid = 0;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: is_extended_mid = 0
|—————Node:identifier Text: is_extended_mid
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // Default is standard MIDs
|———Node:if_statement Text: if (optx) {
        is_extended_mid = 1; // Change to extended if driver option is given
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (optx)
|—————Node:( Text: (
|—————Node:identifier Text: optx
|—————Node:) Text: )
|————Node:compound_statement Text: {
        is_extended_mid = 1; // Change to extended if driver option is given
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: is_extended_mid = 1;
|——————Node:assignment_expression Text: is_extended_mid = 1
|———————Node:identifier Text: is_extended_mid
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:comment Text: // Change to extended if driver option is given
|—————Node:} Text: }
|———Node:if_statement Text: if (id < num_optu_configs) {
        if (id == optu_config[id].id) {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (id < num_optu_configs)
|—————Node:( Text: (
|—————Node:binary_expression Text: id < num_optu_configs
|——————Node:identifier Text: id
|——————Node:< Text: <
|——————Node:identifier Text: num_optu_configs
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (id == optu_config[id].id) {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (id == optu_config[id].id) {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (id == optu_config[id].id)
|———————Node:( Text: (
|———————Node:binary_expression Text: id == optu_config[id].id
|————————Node:identifier Text: id
|————————Node:== Text: ==
|————————Node:field_expression Text: optu_config[id].id
|—————————Node:subscript_expression Text: optu_config[id]
|——————————Node:identifier Text: optu_config
|——————————Node:[ Text: [
|——————————Node:identifier Text: id
|——————————Node:] Text: ]
|—————————Node:. Text: .
|—————————Node:field_identifier Text: id
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            num_channels[0] = optu_config[id].num_rx_channels;
            num_channels[1] = optu_config[id].num_tx_channels;

            if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: num_channels[0] = optu_config[id].num_rx_channels;
|————————Node:assignment_expression Text: num_channels[0] = optu_config[id].num_rx_channels
|—————————Node:subscript_expression Text: num_channels[0]
|——————————Node:identifier Text: num_channels
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 0
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:field_expression Text: optu_config[id].num_rx_channels
|——————————Node:subscript_expression Text: optu_config[id]
|———————————Node:identifier Text: optu_config
|———————————Node:[ Text: [
|———————————Node:identifier Text: id
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: num_rx_channels
|————————Node:; Text: ;
|———————Node:expression_statement Text: num_channels[1] = optu_config[id].num_tx_channels;
|————————Node:assignment_expression Text: num_channels[1] = optu_config[id].num_tx_channels
|—————————Node:subscript_expression Text: num_channels[1]
|——————————Node:identifier Text: num_channels
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 1
|——————————Node:] Text: ]
|—————————Node:= Text: =
|—————————Node:field_expression Text: optu_config[id].num_tx_channels
|——————————Node:subscript_expression Text: optu_config[id]
|———————————Node:identifier Text: optu_config
|———————————Node:[ Text: [
|———————————Node:identifier Text: id
|———————————Node:] Text: ]
|——————————Node:. Text: .
|——————————Node:field_identifier Text: num_tx_channels
|————————Node:; Text: ;
|———————Node:if_statement Text: if (optu_config[id].is_extended_mid != -1) {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (optu_config[id].is_extended_mid != -1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: optu_config[id].is_extended_mid != -1
|——————————Node:field_expression Text: optu_config[id].is_extended_mid
|———————————Node:subscript_expression Text: optu_config[id]
|————————————Node:identifier Text: optu_config
|————————————Node:[ Text: [
|————————————Node:identifier Text: id
|————————————Node:] Text: ]
|———————————Node:. Text: .
|———————————Node:field_identifier Text: is_extended_mid
|——————————Node:!= Text: !=
|——————————Node:number_literal Text: -1
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                // Override driver option if individual device option is giben
                is_extended_mid = optu_config[id].is_extended_mid;
            }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Override driver option if individual device option is giben
|—————————Node:expression_statement Text: is_extended_mid = optu_config[id].is_extended_mid;
|——————————Node:assignment_expression Text: is_extended_mid = optu_config[id].is_extended_mid
|———————————Node:identifier Text: is_extended_mid
|———————————Node:= Text: =
|———————————Node:field_expression Text: optu_config[id].is_extended_mid
|————————————Node:subscript_expression Text: optu_config[id]
|—————————————Node:identifier Text: optu_config
|—————————————Node:[ Text: [
|—————————————Node:identifier Text: id
|—————————————Node:] Text: ]
|————————————Node:. Text: .
|————————————Node:field_identifier Text: is_extended_mid
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:declaration Text: int i, j;
|————Node:primitive_type Text: int
|————Node:identifier Text: i
|————Node:, Text: ,
|————Node:identifier Text: j
|————Node:; Text: ;
|———Node:for_statement Text: for (j = 0; j < 2; ++j) { // 2 for rx & tx
        for (i = 0; i < num_channels[j]; ++i) { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
    }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: j = 0
|—————Node:identifier Text: j
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: j < 2
|—————Node:identifier Text: j
|—————Node:< Text: <
|—————Node:number_literal Text: 2
|————Node:; Text: ;
|————Node:update_expression Text: ++j
|—————Node:++ Text: ++
|—————Node:identifier Text: j
|————Node:) Text: )
|————Node:compound_statement Text: { // 2 for rx & tx
        for (i = 0; i < num_channels[j]; ++i) { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
    }
|—————Node:{ Text: {
|—————Node:comment Text: // 2 for rx & tx
|—————Node:for_statement Text: for (i = 0; i < num_channels[j]; ++i) { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: i < num_channels[j]
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:subscript_expression Text: num_channels[j]
|————————Node:identifier Text: num_channels
|————————Node:[ Text: [
|————————Node:identifier Text: j
|————————Node:] Text: ]
|——————Node:; Text: ;
|——————Node:update_expression Text: ++i
|———————Node:++ Text: ++
|———————Node:identifier Text: i
|——————Node:) Text: )
|——————Node:compound_statement Text: { // number of channels
            can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));

            store_resmgr(&root_resmgr, resmgr);

            resmgr->device_session = device_session;
            resmgr->driver_selection = probe_driver_selection;

            // Property is_extended_mid is only applicable for read and write
            // functions not used for direct devctl send/receive functionality.
            resmgr->is_extended_mid = is_extended_mid;

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif

            if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }

            /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
            memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
            resmgr->resmgr_attr.nparts_max = 1;
            resmgr->resmgr_attr.msg_max_size = 2048;

            if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }

            iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);

            // set up the mount functions structure
            // with our allocate/deallocate functions

            // _IOFUNC_NFUNCS is from the .h file
            resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;

            // your new OCB allocator
            resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;

            // your new OCB deallocator
            resmgr->mount_funcs.ocb_free = can_ocb_free;

            // set up the mount structure
            memset(&resmgr->mount, 0, sizeof (mount));

            resmgr->mount.funcs = &resmgr->mount_funcs;
            resmgr->iofunc_attr.mount = &resmgr->mount;

            resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );

            if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }

            resmgr->latency_limit_ms = 0;   /* Maximum allowed latency in
                                               milliseconds */
            resmgr->mid = 0x00000000;       /* CAN message identifier */
            resmgr->mfilter = 0xFFFFFFFF;   /* CAN message filter */
            resmgr->prio = 0;               /* CAN priority - not used */
            resmgr->shutdown = 0;

            /* Attach a callback (handler) for two message types */
            if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif

            log_trace("resmgr_attach -> %d\n", resmgr->id);

		    dev->flags |= IFF_UP;
        }
|———————Node:{ Text: {
|———————Node:comment Text: // number of channels
|———————Node:declaration Text: can_resmgr_t* resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t));
|————————Node:type_identifier Text: can_resmgr_t
|————————Node:init_declarator Text: * resmgr = (can_resmgr_t*)malloc(sizeof(can_resmgr_t))
|—————————Node:pointer_declarator Text: * resmgr
|——————————Node:* Text: *
|——————————Node:identifier Text: resmgr
|—————————Node:= Text: =
|—————————Node:cast_expression Text: (can_resmgr_t*)malloc(sizeof(can_resmgr_t))
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: can_resmgr_t*
|———————————Node:type_identifier Text: can_resmgr_t
|———————————Node:abstract_pointer_declarator Text: *
|————————————Node:* Text: *
|——————————Node:) Text: )
|——————————Node:call_expression Text: malloc(sizeof(can_resmgr_t))
|———————————Node:identifier Text: malloc
|———————————Node:argument_list Text: (sizeof(can_resmgr_t))
|————————————Node:( Text: (
|————————————Node:sizeof_expression Text: sizeof(can_resmgr_t)
|—————————————Node:sizeof Text: sizeof
|—————————————Node:parenthesized_expression Text: (can_resmgr_t)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: can_resmgr_t
|——————————————Node:) Text: )
|————————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: store_resmgr(&root_resmgr, resmgr);
|————————Node:call_expression Text: store_resmgr(&root_resmgr, resmgr)
|—————————Node:identifier Text: store_resmgr
|—————————Node:argument_list Text: (&root_resmgr, resmgr)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &root_resmgr
|———————————Node:& Text: &
|———————————Node:identifier Text: root_resmgr
|——————————Node:, Text: ,
|——————————Node:identifier Text: resmgr
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->device_session = device_session;
|————————Node:assignment_expression Text: resmgr->device_session = device_session
|—————————Node:field_expression Text: resmgr->device_session
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: device_session
|—————————Node:= Text: =
|—————————Node:identifier Text: device_session
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->driver_selection = probe_driver_selection;
|————————Node:assignment_expression Text: resmgr->driver_selection = probe_driver_selection
|—————————Node:field_expression Text: resmgr->driver_selection
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: driver_selection
|—————————Node:= Text: =
|—————————Node:identifier Text: probe_driver_selection
|————————Node:; Text: ;
|———————Node:comment Text: // Property is_extended_mid is only applicable for read and write
|———————Node:comment Text: // functions not used for direct devctl send/receive functionality.
|———————Node:expression_statement Text: resmgr->is_extended_mid = is_extended_mid;
|————————Node:assignment_expression Text: resmgr->is_extended_mid = is_extended_mid
|—————————Node:field_expression Text: resmgr->is_extended_mid
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: is_extended_mid
|—————————Node:= Text: =
|—————————Node:identifier Text: is_extended_mid
|————————Node:; Text: ;
|———————Node:preproc_if Text: #if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize dispatch interface */
            resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
#endif
|————————Node:#if Text: #if
|————————Node:binary_expression Text: CONFIG_QNX_RESMGR_THREAD_POOL == 1
|—————————Node:identifier Text: CONFIG_QNX_RESMGR_THREAD_POOL
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 1
|————————Node:
 Text: 

|————————Node:comment Text: /* initialize dispatch interface */
|————————Node:expression_statement Text: resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK);
|—————————Node:assignment_expression Text: resmgr->dispatch = dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK)
|——————————Node:field_expression Text: resmgr->dispatch
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|——————————Node:= Text: =
|——————————Node:call_expression Text: dispatch_create_channel(-1, DISPATCH_FLAG_NOLOCK)
|———————————Node:identifier Text: dispatch_create_channel
|———————————Node:argument_list Text: (-1, DISPATCH_FLAG_NOLOCK)
|————————————Node:( Text: (
|————————————Node:number_literal Text: -1
|————————————Node:, Text: ,
|————————————Node:identifier Text: DISPATCH_FLAG_NOLOCK
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:preproc_elif Text: #elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
            resmgr->dispatch = dispatch_create();
|—————————Node:#elif Text: #elif
|—————————Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|——————————Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|——————————Node:== Text: ==
|——————————Node:number_literal Text: 1
|—————————Node:
 Text: 

|—————————Node:comment Text: /* Allocate and initialize a dispatch structure for use
             * by our main loop. This is for the resource manager
             * framework to use. It will receive messages for us,
             * analyze the message type integer and call the matching
             * handler callback function (i.e. io_open, io_read, etc.) */
|—————————Node:expression_statement Text: resmgr->dispatch = dispatch_create();
|——————————Node:assignment_expression Text: resmgr->dispatch = dispatch_create()
|———————————Node:field_expression Text: resmgr->dispatch
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dispatch
|———————————Node:= Text: =
|———————————Node:call_expression Text: dispatch_create()
|————————————Node:identifier Text: dispatch_create
|————————————Node:argument_list Text: ()
|—————————————Node:( Text: (
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:if_statement Text: if (resmgr->dispatch == NULL) {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (resmgr->dispatch == NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: resmgr->dispatch == NULL
|——————————Node:field_expression Text: resmgr->dispatch
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|——————————Node:== Text: ==
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                log_err("couldn't dispatch_create: %s\n", strerror(errno));

                return -1;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: log_err("couldn't dispatch_create: %s\n", strerror(errno));
|——————————Node:call_expression Text: log_err("couldn't dispatch_create: %s\n", strerror(errno))
|———————————Node:identifier Text: log_err
|———————————Node:argument_list Text: ("couldn't dispatch_create: %s\n", strerror(errno))
|————————————Node:( Text: (
|————————————Node:string_literal Text: "couldn't dispatch_create: %s\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: couldn't dispatch_create: %s
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:call_expression Text: strerror(errno)
|—————————————Node:identifier Text: strerror
|—————————————Node:argument_list Text: (errno)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: errno
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -1;
|——————————Node:return Text: return
|——————————Node:number_literal Text: -1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:comment Text: /* Set up the resource manager attributes structure. We'll
             * use this as a way of passing information to
             * resmgr_attach(). The attributes are used to specify
             * the maximum message length to be received at once,
             * and the number of message fragments (iov's) that
             * are possible for the reply.
             * For now, we'll just use defaults by setting the
             * attribute structure to zeroes. */
|———————Node:expression_statement Text: memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t));
|————————Node:call_expression Text: memset(&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t))
|—————————Node:identifier Text: memset
|—————————Node:argument_list Text: (&resmgr->resmgr_attr, 0, sizeof(resmgr_attr_t))
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &resmgr->resmgr_attr
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->resmgr_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr_attr
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(resmgr_attr_t)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (resmgr_attr_t)
|————————————Node:( Text: (
|————————————Node:identifier Text: resmgr_attr_t
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->resmgr_attr.nparts_max = 1;
|————————Node:assignment_expression Text: resmgr->resmgr_attr.nparts_max = 1
|—————————Node:field_expression Text: resmgr->resmgr_attr.nparts_max
|——————————Node:field_expression Text: resmgr->resmgr_attr
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr_attr
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nparts_max
|—————————Node:= Text: =
|—————————Node:number_literal Text: 1
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->resmgr_attr.msg_max_size = 2048;
|————————Node:assignment_expression Text: resmgr->resmgr_attr.msg_max_size = 2048
|—————————Node:field_expression Text: resmgr->resmgr_attr.msg_max_size
|——————————Node:field_expression Text: resmgr->resmgr_attr
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr_attr
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msg_max_size
|—————————Node:= Text: =
|—————————Node:number_literal Text: 2048
|————————Node:; Text: ;
|———————Node:if_statement Text: if (j == 0) {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
            else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (j == 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: j == 0
|——————————Node:identifier Text: j
|——————————Node:== Text: ==
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );

                resmgr->channel_type = RX_CHANNEL;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i );
|——————————Node:call_expression Text: snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i )
|———————————Node:identifier Text: snprintf
|———————————Node:argument_list Text: ( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/rx%d", id, i )
|————————————Node:( Text: (
|————————————Node:field_expression Text: resmgr->name
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: name
|————————————Node:, Text: ,
|————————————Node:identifier Text: MAX_NAME_SIZE
|————————————Node:, Text: ,
|————————————Node:string_literal Text: "/dev/can%d/rx%d"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: /dev/can%d/rx%d
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:identifier Text: id
|————————————Node:, Text: ,
|————————————Node:identifier Text: i
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: resmgr->channel_type = RX_CHANNEL;
|——————————Node:assignment_expression Text: resmgr->channel_type = RX_CHANNEL
|———————————Node:field_expression Text: resmgr->channel_type
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: channel_type
|———————————Node:= Text: =
|———————————Node:identifier Text: RX_CHANNEL
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
                snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );

                resmgr->channel_type = TX_CHANNEL;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i );
|———————————Node:call_expression Text: snprintf( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i )
|————————————Node:identifier Text: snprintf
|————————————Node:argument_list Text: ( resmgr->name, MAX_NAME_SIZE,
                        "/dev/can%d/tx%d", id, i )
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: resmgr->name
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: name
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: MAX_NAME_SIZE
|—————————————Node:, Text: ,
|—————————————Node:string_literal Text: "/dev/can%d/tx%d"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: /dev/can%d/tx%d
|——————————————Node:" Text: "
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: id
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: i
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: resmgr->channel_type = TX_CHANNEL;
|———————————Node:assignment_expression Text: resmgr->channel_type = TX_CHANNEL
|————————————Node:field_expression Text: resmgr->channel_type
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: channel_type
|————————————Node:= Text: =
|————————————Node:identifier Text: TX_CHANNEL
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:expression_statement Text: iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL);
|————————Node:call_expression Text: iofunc_attr_init(&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL)
|—————————Node:identifier Text: iofunc_attr_init
|—————————Node:argument_list Text: (&resmgr->iofunc_attr, S_IFCHR | 0666, NULL, NULL)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &resmgr->iofunc_attr
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->iofunc_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: iofunc_attr
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: S_IFCHR | 0666
|———————————Node:identifier Text: S_IFCHR
|———————————Node:| Text: |
|———————————Node:number_literal Text: 0666
|——————————Node:, Text: ,
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:, Text: ,
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // set up the mount functions structure
|———————Node:comment Text: // with our allocate/deallocate functions
|———————Node:comment Text: // _IOFUNC_NFUNCS is from the .h file
|———————Node:expression_statement Text: resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS;
|————————Node:assignment_expression Text: resmgr->mount_funcs.nfuncs = _IOFUNC_NFUNCS
|—————————Node:field_expression Text: resmgr->mount_funcs.nfuncs
|——————————Node:field_expression Text: resmgr->mount_funcs
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount_funcs
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nfuncs
|—————————Node:= Text: =
|—————————Node:identifier Text: _IOFUNC_NFUNCS
|————————Node:; Text: ;
|———————Node:comment Text: // your new OCB allocator
|———————Node:expression_statement Text: resmgr->mount_funcs.ocb_calloc = can_ocb_calloc;
|————————Node:assignment_expression Text: resmgr->mount_funcs.ocb_calloc = can_ocb_calloc
|—————————Node:field_expression Text: resmgr->mount_funcs.ocb_calloc
|——————————Node:field_expression Text: resmgr->mount_funcs
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount_funcs
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ocb_calloc
|—————————Node:= Text: =
|—————————Node:identifier Text: can_ocb_calloc
|————————Node:; Text: ;
|———————Node:comment Text: // your new OCB deallocator
|———————Node:expression_statement Text: resmgr->mount_funcs.ocb_free = can_ocb_free;
|————————Node:assignment_expression Text: resmgr->mount_funcs.ocb_free = can_ocb_free
|—————————Node:field_expression Text: resmgr->mount_funcs.ocb_free
|——————————Node:field_expression Text: resmgr->mount_funcs
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount_funcs
|——————————Node:. Text: .
|——————————Node:field_identifier Text: ocb_free
|—————————Node:= Text: =
|—————————Node:identifier Text: can_ocb_free
|————————Node:; Text: ;
|———————Node:comment Text: // set up the mount structure
|———————Node:expression_statement Text: memset(&resmgr->mount, 0, sizeof (mount));
|————————Node:call_expression Text: memset(&resmgr->mount, 0, sizeof (mount))
|—————————Node:identifier Text: memset
|—————————Node:argument_list Text: (&resmgr->mount, 0, sizeof (mount))
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &resmgr->mount
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->mount
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: mount
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof (mount)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (mount)
|————————————Node:( Text: (
|————————————Node:identifier Text: mount
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->mount.funcs = &resmgr->mount_funcs;
|————————Node:assignment_expression Text: resmgr->mount.funcs = &resmgr->mount_funcs
|—————————Node:field_expression Text: resmgr->mount.funcs
|——————————Node:field_expression Text: resmgr->mount
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount
|——————————Node:. Text: .
|——————————Node:field_identifier Text: funcs
|—————————Node:= Text: =
|—————————Node:pointer_expression Text: &resmgr->mount_funcs
|——————————Node:& Text: &
|——————————Node:field_expression Text: resmgr->mount_funcs
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount_funcs
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->iofunc_attr.mount = &resmgr->mount;
|————————Node:assignment_expression Text: resmgr->iofunc_attr.mount = &resmgr->mount
|—————————Node:field_expression Text: resmgr->iofunc_attr.mount
|——————————Node:field_expression Text: resmgr->iofunc_attr
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: iofunc_attr
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mount
|—————————Node:= Text: =
|—————————Node:pointer_expression Text: &resmgr->mount
|——————————Node:& Text: &
|——————————Node:field_expression Text: resmgr->mount
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: mount
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr );
|————————Node:assignment_expression Text: resmgr->id = resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr )
|—————————Node:field_expression Text: resmgr->id
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: id
|—————————Node:= Text: =
|—————————Node:call_expression Text: resmgr_attach(
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr )
|——————————Node:identifier Text: resmgr_attach
|——————————Node:argument_list Text: (
                    resmgr->dispatch, &resmgr->resmgr_attr, resmgr->name,
                    _FTYPE_ANY, 0, &connect_funcs, &io_funcs,
                    &resmgr->iofunc_attr )
|———————————Node:( Text: (
|———————————Node:field_expression Text: resmgr->dispatch
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dispatch
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &resmgr->resmgr_attr
|————————————Node:& Text: &
|————————————Node:field_expression Text: resmgr->resmgr_attr
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: resmgr_attr
|———————————Node:, Text: ,
|———————————Node:field_expression Text: resmgr->name
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: name
|———————————Node:, Text: ,
|———————————Node:identifier Text: _FTYPE_ANY
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 0
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &connect_funcs
|————————————Node:& Text: &
|————————————Node:identifier Text: connect_funcs
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &io_funcs
|————————————Node:& Text: &
|————————————Node:identifier Text: io_funcs
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &resmgr->iofunc_attr
|————————————Node:& Text: &
|————————————Node:field_expression Text: resmgr->iofunc_attr
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: iofunc_attr
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (resmgr->id == -1) {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (resmgr->id == -1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: resmgr->id == -1
|——————————Node:field_expression Text: resmgr->id
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: id
|——————————Node:== Text: ==
|——————————Node:number_literal Text: -1
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                log_err("resmgr_attach fail: %s\n", strerror(errno));

                return -1;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: log_err("resmgr_attach fail: %s\n", strerror(errno));
|——————————Node:call_expression Text: log_err("resmgr_attach fail: %s\n", strerror(errno))
|———————————Node:identifier Text: log_err
|———————————Node:argument_list Text: ("resmgr_attach fail: %s\n", strerror(errno))
|————————————Node:( Text: (
|————————————Node:string_literal Text: "resmgr_attach fail: %s\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: resmgr_attach fail: %s
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:call_expression Text: strerror(errno)
|—————————————Node:identifier Text: strerror
|—————————————Node:argument_list Text: (errno)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: errno
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -1;
|——————————Node:return Text: return
|——————————Node:number_literal Text: -1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: resmgr->latency_limit_ms = 0;
|————————Node:assignment_expression Text: resmgr->latency_limit_ms = 0
|—————————Node:field_expression Text: resmgr->latency_limit_ms
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: latency_limit_ms
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: /* Maximum allowed latency in
                                               milliseconds */
|———————Node:expression_statement Text: resmgr->mid = 0x00000000;
|————————Node:assignment_expression Text: resmgr->mid = 0x00000000
|—————————Node:field_expression Text: resmgr->mid
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mid
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0x00000000
|————————Node:; Text: ;
|———————Node:comment Text: /* CAN message identifier */
|———————Node:expression_statement Text: resmgr->mfilter = 0xFFFFFFFF;
|————————Node:assignment_expression Text: resmgr->mfilter = 0xFFFFFFFF
|—————————Node:field_expression Text: resmgr->mfilter
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mfilter
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0xFFFFFFFF
|————————Node:; Text: ;
|———————Node:comment Text: /* CAN message filter */
|———————Node:expression_statement Text: resmgr->prio = 0;
|————————Node:assignment_expression Text: resmgr->prio = 0
|—————————Node:field_expression Text: resmgr->prio
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prio
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: /* CAN priority - not used */
|———————Node:expression_statement Text: resmgr->shutdown = 0;
|————————Node:assignment_expression Text: resmgr->shutdown = 0
|—————————Node:field_expression Text: resmgr->shutdown
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: shutdown
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: /* Attach a callback (handler) for two message types */
|———————Node:if_statement Text: if (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
            {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL ) == -1
|——————————Node:call_expression Text: message_attach( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL )
|———————————Node:identifier Text: message_attach
|———————————Node:argument_list Text: ( resmgr->dispatch, NULL, _IO_MAX + 1,
                        _IO_MAX + 1, msg_again_callback, NULL )
|————————————Node:( Text: (
|————————————Node:field_expression Text: resmgr->dispatch
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dispatch
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: _IO_MAX + 1
|—————————————Node:identifier Text: _IO_MAX
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:, Text: ,
|————————————Node:binary_expression Text: _IO_MAX + 1
|—————————————Node:identifier Text: _IO_MAX
|—————————————Node:+ Text: +
|—————————————Node:number_literal Text: 1
|————————————Node:, Text: ,
|————————————Node:identifier Text: msg_again_callback
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:) Text: )
|——————————Node:== Text: ==
|——————————Node:number_literal Text: -1
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                log_err("message_attach() failed: %s\n", strerror(errno));

                return -1;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: log_err("message_attach() failed: %s\n", strerror(errno));
|——————————Node:call_expression Text: log_err("message_attach() failed: %s\n", strerror(errno))
|———————————Node:identifier Text: log_err
|———————————Node:argument_list Text: ("message_attach() failed: %s\n", strerror(errno))
|————————————Node:( Text: (
|————————————Node:string_literal Text: "message_attach() failed: %s\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: message_attach() failed: %s
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:call_expression Text: strerror(errno)
|—————————————Node:identifier Text: strerror
|—————————————Node:argument_list Text: (errno)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: errno
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -1;
|——————————Node:return Text: return
|——————————Node:number_literal Text: -1
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:preproc_if Text: #if CONFIG_QNX_RESMGR_THREAD_POOL == 1
            /* initialize thread pool attributes */
            memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
            resmgr->thread_pool_attr.handle = resmgr->dispatch;
            resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
            resmgr->thread_pool_attr.block_func = dispatch_block; 
            resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
            resmgr->thread_pool_attr.handler_func = dispatch_handler;
            resmgr->thread_pool_attr.context_free = dispatch_context_free;
            resmgr->thread_pool_attr.lo_water = 4;
            resmgr->thread_pool_attr.hi_water = 8;
            resmgr->thread_pool_attr.increment = 1;
            resmgr->thread_pool_attr.maximum = 50;

            /* allocate a thread pool handle */
            if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }

            /* Start the threads. This function doesn't return. */
            thread_pool_start(resmgr->thread_pool);

#elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
#endif
|————————Node:#if Text: #if
|————————Node:binary_expression Text: CONFIG_QNX_RESMGR_THREAD_POOL == 1
|—————————Node:identifier Text: CONFIG_QNX_RESMGR_THREAD_POOL
|—————————Node:== Text: ==
|—————————Node:number_literal Text: 1
|————————Node:
 Text: 

|————————Node:comment Text: /* initialize thread pool attributes */
|————————Node:expression_statement Text: memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t));
|—————————Node:call_expression Text: memset(&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t))
|——————————Node:identifier Text: memset
|——————————Node:argument_list Text: (&resmgr->thread_pool_attr, 0, sizeof(thread_pool_attr_t))
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &resmgr->thread_pool_attr
|————————————Node:& Text: &
|————————————Node:field_expression Text: resmgr->thread_pool_attr
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:, Text: ,
|———————————Node:number_literal Text: 0
|———————————Node:, Text: ,
|———————————Node:sizeof_expression Text: sizeof(thread_pool_attr_t)
|————————————Node:sizeof Text: sizeof
|————————————Node:parenthesized_expression Text: (thread_pool_attr_t)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: thread_pool_attr_t
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.handle = resmgr->dispatch;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.handle = resmgr->dispatch
|——————————Node:field_expression Text: resmgr->thread_pool_attr.handle
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: handle
|——————————Node:= Text: =
|——————————Node:field_expression Text: resmgr->dispatch
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.context_alloc = dispatch_context_alloc
|——————————Node:field_expression Text: resmgr->thread_pool_attr.context_alloc
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: context_alloc
|——————————Node:= Text: =
|——————————Node:identifier Text: dispatch_context_alloc
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.block_func = dispatch_block;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.block_func = dispatch_block
|——————————Node:field_expression Text: resmgr->thread_pool_attr.block_func
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: block_func
|——————————Node:= Text: =
|——————————Node:identifier Text: dispatch_block
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.unblock_func = dispatch_unblock;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.unblock_func = dispatch_unblock
|——————————Node:field_expression Text: resmgr->thread_pool_attr.unblock_func
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: unblock_func
|——————————Node:= Text: =
|——————————Node:identifier Text: dispatch_unblock
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.handler_func = dispatch_handler;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.handler_func = dispatch_handler
|——————————Node:field_expression Text: resmgr->thread_pool_attr.handler_func
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: handler_func
|——————————Node:= Text: =
|——————————Node:identifier Text: dispatch_handler
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.context_free = dispatch_context_free;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.context_free = dispatch_context_free
|——————————Node:field_expression Text: resmgr->thread_pool_attr.context_free
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: context_free
|——————————Node:= Text: =
|——————————Node:identifier Text: dispatch_context_free
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.lo_water = 4;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.lo_water = 4
|——————————Node:field_expression Text: resmgr->thread_pool_attr.lo_water
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: lo_water
|——————————Node:= Text: =
|——————————Node:number_literal Text: 4
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.hi_water = 8;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.hi_water = 8
|——————————Node:field_expression Text: resmgr->thread_pool_attr.hi_water
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: hi_water
|——————————Node:= Text: =
|——————————Node:number_literal Text: 8
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.increment = 1;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.increment = 1
|——————————Node:field_expression Text: resmgr->thread_pool_attr.increment
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: increment
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1
|—————————Node:; Text: ;
|————————Node:expression_statement Text: resmgr->thread_pool_attr.maximum = 50;
|—————————Node:assignment_expression Text: resmgr->thread_pool_attr.maximum = 50
|——————————Node:field_expression Text: resmgr->thread_pool_attr.maximum
|———————————Node:field_expression Text: resmgr->thread_pool_attr
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool_attr
|———————————Node:. Text: .
|———————————Node:field_identifier Text: maximum
|——————————Node:= Text: =
|——————————Node:number_literal Text: 50
|—————————Node:; Text: ;
|————————Node:comment Text: /* allocate a thread pool handle */
|————————Node:if_statement Text: if (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
            {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) ) == NULL
|———————————Node:parenthesized_expression Text: ( resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0) )
|————————————Node:( Text: (
|————————————Node:assignment_expression Text: resmgr->thread_pool =
                    thread_pool_create(&resmgr->thread_pool_attr, 0)
|—————————————Node:field_expression Text: resmgr->thread_pool
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: thread_pool
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: thread_pool_create(&resmgr->thread_pool_attr, 0)
|——————————————Node:identifier Text: thread_pool_create
|——————————————Node:argument_list Text: (&resmgr->thread_pool_attr, 0)
|———————————————Node:( Text: (
|———————————————Node:pointer_expression Text: &resmgr->thread_pool_attr
|————————————————Node:& Text: &
|————————————————Node:field_expression Text: resmgr->thread_pool_attr
|—————————————————Node:identifier Text: resmgr
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: thread_pool_attr
|———————————————Node:, Text: ,
|———————————————Node:number_literal Text: 0
|———————————————Node:) Text: )
|————————————Node:) Text: )
|———————————Node:== Text: ==
|———————————Node:null Text: NULL
|————————————Node:NULL Text: NULL
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");

                return -1;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n");
|———————————Node:call_expression Text: log_err( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n")
|————————————Node:identifier Text: log_err
|————————————Node:argument_list Text: ( "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n")
|—————————————Node:( Text: (
|—————————————Node:concatenated_string Text: "thread_pool_create fail: " \
                         "Unable to initialize thread pool.\n"
|——————————————Node:string_literal Text: "thread_pool_create fail: "
|———————————————Node:" Text: "
|———————————————Node:string_content Text: thread_pool_create fail: 
|———————————————Node:" Text: "
|——————————————Node:string_literal Text: "Unable to initialize thread pool.\n"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: Unable to initialize thread pool.
|———————————————Node:escape_sequence Text: \n
|———————————————Node:" Text: "
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:return_statement Text: return -1;
|———————————Node:return Text: return
|———————————Node:number_literal Text: -1
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:comment Text: /* Start the threads. This function doesn't return. */
|————————Node:expression_statement Text: thread_pool_start(resmgr->thread_pool);
|—————————Node:call_expression Text: thread_pool_start(resmgr->thread_pool)
|——————————Node:identifier Text: thread_pool_start
|——————————Node:argument_list Text: (resmgr->thread_pool)
|———————————Node:( Text: (
|———————————Node:field_expression Text: resmgr->thread_pool
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:preproc_elif Text: #elif CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
            /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
            resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);

            if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }

            pthread_attr_init(&resmgr->dispatch_thread_attr);
            pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );

            pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
|—————————Node:#elif Text: #elif
|—————————Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|——————————Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|——————————Node:== Text: ==
|——————————Node:number_literal Text: 1
|—————————Node:
 Text: 

|—————————Node:comment Text: /* Now we allocate some memory for the dispatch context
             * structure, which will later be used when we receive
             * messages. */
|—————————Node:expression_statement Text: resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch);
|——————————Node:assignment_expression Text: resmgr->dispatch_context = dispatch_context_alloc(resmgr->dispatch)
|———————————Node:field_expression Text: resmgr->dispatch_context
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dispatch_context
|———————————Node:= Text: =
|———————————Node:call_expression Text: dispatch_context_alloc(resmgr->dispatch)
|————————————Node:identifier Text: dispatch_context_alloc
|————————————Node:argument_list Text: (resmgr->dispatch)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: resmgr->dispatch
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dispatch
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (resmgr->dispatch_context == NULL) {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (resmgr->dispatch_context == NULL)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: resmgr->dispatch_context == NULL
|————————————Node:field_expression Text: resmgr->dispatch_context
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dispatch_context
|————————————Node:== Text: ==
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                log_err("dispatch_context_alloc fail: %s\n", strerror(errno));

                return -1;
            }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: log_err("dispatch_context_alloc fail: %s\n", strerror(errno));
|————————————Node:call_expression Text: log_err("dispatch_context_alloc fail: %s\n", strerror(errno))
|—————————————Node:identifier Text: log_err
|—————————————Node:argument_list Text: ("dispatch_context_alloc fail: %s\n", strerror(errno))
|——————————————Node:( Text: (
|——————————————Node:string_literal Text: "dispatch_context_alloc fail: %s\n"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: dispatch_context_alloc fail: %s
|———————————————Node:escape_sequence Text: \n
|———————————————Node:" Text: "
|——————————————Node:, Text: ,
|——————————————Node:call_expression Text: strerror(errno)
|———————————————Node:identifier Text: strerror
|———————————————Node:argument_list Text: (errno)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: errno
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:return_statement Text: return -1;
|————————————Node:return Text: return
|————————————Node:number_literal Text: -1
|————————————Node:; Text: ;
|———————————Node:} Text: }
|—————————Node:expression_statement Text: pthread_attr_init(&resmgr->dispatch_thread_attr);
|——————————Node:call_expression Text: pthread_attr_init(&resmgr->dispatch_thread_attr)
|———————————Node:identifier Text: pthread_attr_init
|———————————Node:argument_list Text: (&resmgr->dispatch_thread_attr)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &resmgr->dispatch_thread_attr
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: resmgr->dispatch_thread_attr
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dispatch_thread_attr
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED );
|——————————Node:call_expression Text: pthread_attr_setdetachstate(
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED )
|———————————Node:identifier Text: pthread_attr_setdetachstate
|———————————Node:argument_list Text: (
                    &resmgr->dispatch_thread_attr, PTHREAD_CREATE_DETACHED )
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &resmgr->dispatch_thread_attr
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: resmgr->dispatch_thread_attr
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dispatch_thread_attr
|————————————Node:, Text: ,
|————————————Node:identifier Text: PTHREAD_CREATE_DETACHED
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr );
|——————————Node:call_expression Text: pthread_create( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr )
|———————————Node:identifier Text: pthread_create
|———————————Node:argument_list Text: ( &resmgr->dispatch_thread,
                    &resmgr->dispatch_thread_attr,
                    &dispatch_receive_loop, resmgr )
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &resmgr->dispatch_thread
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: resmgr->dispatch_thread
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dispatch_thread
|————————————Node:, Text: ,
|————————————Node:pointer_expression Text: &resmgr->dispatch_thread_attr
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: resmgr->dispatch_thread_attr
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dispatch_thread_attr
|————————————Node:, Text: ,
|————————————Node:pointer_expression Text: &dispatch_receive_loop
|—————————————Node:& Text: &
|—————————————Node:identifier Text: dispatch_receive_loop
|————————————Node:, Text: ,
|————————————Node:identifier Text: resmgr
|————————————Node:) Text: )
|——————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:expression_statement Text: log_trace("resmgr_attach -> %d\n", resmgr->id);
|————————Node:call_expression Text: log_trace("resmgr_attach -> %d\n", resmgr->id)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("resmgr_attach -> %d\n", resmgr->id)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "resmgr_attach -> %d\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: resmgr_attach -> %d
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: resmgr->id
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: id
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: dev->flags |= IFF_UP;
|————————Node:assignment_expression Text: dev->flags |= IFF_UP
|—————————Node:field_expression Text: dev->flags
|——————————Node:identifier Text: dev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: flags
|—————————Node:|= Text: |=
|—————————Node:identifier Text: IFF_UP
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void unregister_netdev(struct net_device *dev) {
    if (dev == NULL) {
        log_err("unregister_netdev failed: invalid net_device\n");
        return;
    }

    log_trace("unregister_netdev: %s\n", dev->name);

    dev->flags &= ~IFF_UP;

    if (dev->netdev_ops) {
        if (dev->netdev_ops->ndo_stop(dev)) {
            log_err("internal error; ndo_stop failure\n");
        }
    }

    can_resmgr_t* location = root_resmgr;

    while (location != NULL) {
        can_resmgr_t* resmgr = location;

        char name[MAX_NAME_SIZE];
        strncpy(name, resmgr->name, MAX_NAME_SIZE);

        if (resmgr->device_session->device != dev) {
            location = location->next;

            continue;
        }

        resmgr->shutdown = 1;

        destroy_device_session(resmgr->device_session);

        if (resmgr->prev && resmgr->next) {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
        else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
        if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
#endif

        if (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1) {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        pthread_join(resmgr->dispatch_thread, NULL);
#endif

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        // TODO: investigate if dispatch_context_free() is needed and why
        //       we get SIGSEGV when following code is uncommented.
        //dispatch_context_free(resmgr->dispatch_context);
#endif

        if (dispatch_destroy(resmgr->dispatch) == -1) {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }

        free(resmgr);
        break;
    }
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: unregister_netdev(struct net_device *dev)
|———Node:identifier Text: unregister_netdev
|———Node:parameter_list Text: (struct net_device *dev)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device *dev
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: *dev
|——————Node:* Text: *
|——————Node:identifier Text: dev
|————Node:) Text: )
|——Node:compound_statement Text: {
    if (dev == NULL) {
        log_err("unregister_netdev failed: invalid net_device\n");
        return;
    }

    log_trace("unregister_netdev: %s\n", dev->name);

    dev->flags &= ~IFF_UP;

    if (dev->netdev_ops) {
        if (dev->netdev_ops->ndo_stop(dev)) {
            log_err("internal error; ndo_stop failure\n");
        }
    }

    can_resmgr_t* location = root_resmgr;

    while (location != NULL) {
        can_resmgr_t* resmgr = location;

        char name[MAX_NAME_SIZE];
        strncpy(name, resmgr->name, MAX_NAME_SIZE);

        if (resmgr->device_session->device != dev) {
            location = location->next;

            continue;
        }

        resmgr->shutdown = 1;

        destroy_device_session(resmgr->device_session);

        if (resmgr->prev && resmgr->next) {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
        else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
        if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
#endif

        if (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1) {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        pthread_join(resmgr->dispatch_thread, NULL);
#endif

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        // TODO: investigate if dispatch_context_free() is needed and why
        //       we get SIGSEGV when following code is uncommented.
        //dispatch_context_free(resmgr->dispatch_context);
#endif

        if (dispatch_destroy(resmgr->dispatch) == -1) {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }

        free(resmgr);
        break;
    }
}
|———Node:{ Text: {
|———Node:if_statement Text: if (dev == NULL) {
        log_err("unregister_netdev failed: invalid net_device\n");
        return;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dev == NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: dev == NULL
|——————Node:identifier Text: dev
|——————Node:== Text: ==
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("unregister_netdev failed: invalid net_device\n");
        return;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("unregister_netdev failed: invalid net_device\n");
|——————Node:call_expression Text: log_err("unregister_netdev failed: invalid net_device\n")
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("unregister_netdev failed: invalid net_device\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "unregister_netdev failed: invalid net_device\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: unregister_netdev failed: invalid net_device
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return;
|——————Node:return Text: return
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: log_trace("unregister_netdev: %s\n", dev->name);
|————Node:call_expression Text: log_trace("unregister_netdev: %s\n", dev->name)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("unregister_netdev: %s\n", dev->name)
|——————Node:( Text: (
|——————Node:string_literal Text: "unregister_netdev: %s\n"
|———————Node:" Text: "
|———————Node:string_content Text: unregister_netdev: %s
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: dev->name
|———————Node:identifier Text: dev
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: dev->flags &= ~IFF_UP;
|————Node:assignment_expression Text: dev->flags &= ~IFF_UP
|—————Node:field_expression Text: dev->flags
|——————Node:identifier Text: dev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: flags
|—————Node:&= Text: &=
|—————Node:unary_expression Text: ~IFF_UP
|——————Node:~ Text: ~
|——————Node:identifier Text: IFF_UP
|————Node:; Text: ;
|———Node:if_statement Text: if (dev->netdev_ops) {
        if (dev->netdev_ops->ndo_stop(dev)) {
            log_err("internal error; ndo_stop failure\n");
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (dev->netdev_ops)
|—————Node:( Text: (
|—————Node:field_expression Text: dev->netdev_ops
|——————Node:identifier Text: dev
|——————Node:-> Text: ->
|——————Node:field_identifier Text: netdev_ops
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (dev->netdev_ops->ndo_stop(dev)) {
            log_err("internal error; ndo_stop failure\n");
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (dev->netdev_ops->ndo_stop(dev)) {
            log_err("internal error; ndo_stop failure\n");
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (dev->netdev_ops->ndo_stop(dev))
|———————Node:( Text: (
|———————Node:call_expression Text: dev->netdev_ops->ndo_stop(dev)
|————————Node:field_expression Text: dev->netdev_ops->ndo_stop
|—————————Node:field_expression Text: dev->netdev_ops
|——————————Node:identifier Text: dev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: netdev_ops
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: ndo_stop
|————————Node:argument_list Text: (dev)
|—————————Node:( Text: (
|—————————Node:identifier Text: dev
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_err("internal error; ndo_stop failure\n");
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_err("internal error; ndo_stop failure\n");
|————————Node:call_expression Text: log_err("internal error; ndo_stop failure\n")
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ("internal error; ndo_stop failure\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "internal error; ndo_stop failure\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: internal error; ndo_stop failure
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:declaration Text: can_resmgr_t* location = root_resmgr;
|————Node:type_identifier Text: can_resmgr_t
|————Node:init_declarator Text: * location = root_resmgr
|—————Node:pointer_declarator Text: * location
|——————Node:* Text: *
|——————Node:identifier Text: location
|—————Node:= Text: =
|—————Node:identifier Text: root_resmgr
|————Node:; Text: ;
|———Node:while_statement Text: while (location != NULL) {
        can_resmgr_t* resmgr = location;

        char name[MAX_NAME_SIZE];
        strncpy(name, resmgr->name, MAX_NAME_SIZE);

        if (resmgr->device_session->device != dev) {
            location = location->next;

            continue;
        }

        resmgr->shutdown = 1;

        destroy_device_session(resmgr->device_session);

        if (resmgr->prev && resmgr->next) {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
        else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
        if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
#endif

        if (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1) {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        pthread_join(resmgr->dispatch_thread, NULL);
#endif

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        // TODO: investigate if dispatch_context_free() is needed and why
        //       we get SIGSEGV when following code is uncommented.
        //dispatch_context_free(resmgr->dispatch_context);
#endif

        if (dispatch_destroy(resmgr->dispatch) == -1) {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }

        free(resmgr);
        break;
    }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (location != NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: location != NULL
|——————Node:identifier Text: location
|——————Node:!= Text: !=
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        can_resmgr_t* resmgr = location;

        char name[MAX_NAME_SIZE];
        strncpy(name, resmgr->name, MAX_NAME_SIZE);

        if (resmgr->device_session->device != dev) {
            location = location->next;

            continue;
        }

        resmgr->shutdown = 1;

        destroy_device_session(resmgr->device_session);

        if (resmgr->prev && resmgr->next) {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
        else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }

#if CONFIG_QNX_RESMGR_THREAD_POOL == 1
        if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
#endif

        if (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1) {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        pthread_join(resmgr->dispatch_thread, NULL);
#endif

#if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        // TODO: investigate if dispatch_context_free() is needed and why
        //       we get SIGSEGV when following code is uncommented.
        //dispatch_context_free(resmgr->dispatch_context);
#endif

        if (dispatch_destroy(resmgr->dispatch) == -1) {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }

        free(resmgr);
        break;
    }
|—————Node:{ Text: {
|—————Node:declaration Text: can_resmgr_t* resmgr = location;
|——————Node:type_identifier Text: can_resmgr_t
|——————Node:init_declarator Text: * resmgr = location
|———————Node:pointer_declarator Text: * resmgr
|————————Node:* Text: *
|————————Node:identifier Text: resmgr
|———————Node:= Text: =
|———————Node:identifier Text: location
|——————Node:; Text: ;
|—————Node:declaration Text: char name[MAX_NAME_SIZE];
|——————Node:primitive_type Text: char
|——————Node:array_declarator Text: name[MAX_NAME_SIZE]
|———————Node:identifier Text: name
|———————Node:[ Text: [
|———————Node:identifier Text: MAX_NAME_SIZE
|———————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: strncpy(name, resmgr->name, MAX_NAME_SIZE);
|——————Node:call_expression Text: strncpy(name, resmgr->name, MAX_NAME_SIZE)
|———————Node:identifier Text: strncpy
|———————Node:argument_list Text: (name, resmgr->name, MAX_NAME_SIZE)
|————————Node:( Text: (
|————————Node:identifier Text: name
|————————Node:, Text: ,
|————————Node:field_expression Text: resmgr->name
|—————————Node:identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: name
|————————Node:, Text: ,
|————————Node:identifier Text: MAX_NAME_SIZE
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (resmgr->device_session->device != dev) {
            location = location->next;

            continue;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (resmgr->device_session->device != dev)
|———————Node:( Text: (
|———————Node:binary_expression Text: resmgr->device_session->device != dev
|————————Node:field_expression Text: resmgr->device_session->device
|—————————Node:field_expression Text: resmgr->device_session
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: device_session
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: device
|————————Node:!= Text: !=
|————————Node:identifier Text: dev
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            location = location->next;

            continue;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: location = location->next;
|————————Node:assignment_expression Text: location = location->next
|—————————Node:identifier Text: location
|—————————Node:= Text: =
|—————————Node:field_expression Text: location->next
|——————————Node:identifier Text: location
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: next
|————————Node:; Text: ;
|———————Node:continue_statement Text: continue;
|————————Node:continue Text: continue
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: resmgr->shutdown = 1;
|——————Node:assignment_expression Text: resmgr->shutdown = 1
|———————Node:field_expression Text: resmgr->shutdown
|————————Node:identifier Text: resmgr
|————————Node:-> Text: ->
|————————Node:field_identifier Text: shutdown
|———————Node:= Text: =
|———————Node:number_literal Text: 1
|——————Node:; Text: ;
|—————Node:expression_statement Text: destroy_device_session(resmgr->device_session);
|——————Node:call_expression Text: destroy_device_session(resmgr->device_session)
|———————Node:identifier Text: destroy_device_session
|———————Node:argument_list Text: (resmgr->device_session)
|————————Node:( Text: (
|————————Node:field_expression Text: resmgr->device_session
|—————————Node:identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: device_session
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (resmgr->prev && resmgr->next) {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
        else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (resmgr->prev && resmgr->next)
|———————Node:( Text: (
|———————Node:binary_expression Text: resmgr->prev && resmgr->next
|————————Node:field_expression Text: resmgr->prev
|—————————Node:identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: prev
|————————Node:&& Text: &&
|————————Node:field_expression Text: resmgr->next
|—————————Node:identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: next
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            resmgr->prev->next = resmgr->next;
            resmgr->next->prev = resmgr->prev;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: resmgr->prev->next = resmgr->next;
|————————Node:assignment_expression Text: resmgr->prev->next = resmgr->next
|—————————Node:field_expression Text: resmgr->prev->next
|——————————Node:field_expression Text: resmgr->prev
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: prev
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: next
|—————————Node:= Text: =
|—————————Node:field_expression Text: resmgr->next
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: next
|————————Node:; Text: ;
|———————Node:expression_statement Text: resmgr->next->prev = resmgr->prev;
|————————Node:assignment_expression Text: resmgr->next->prev = resmgr->prev
|—————————Node:field_expression Text: resmgr->next->prev
|——————————Node:field_expression Text: resmgr->next
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: next
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prev
|—————————Node:= Text: =
|—————————Node:field_expression Text: resmgr->prev
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prev
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|———————Node:else Text: else
|———————Node:if_statement Text: if (resmgr->prev) {
            resmgr->prev->next = NULL;
        }
        else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (resmgr->prev)
|—————————Node:( Text: (
|—————————Node:field_expression Text: resmgr->prev
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prev
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            resmgr->prev->next = NULL;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: resmgr->prev->next = NULL;
|——————————Node:assignment_expression Text: resmgr->prev->next = NULL
|———————————Node:field_expression Text: resmgr->prev->next
|————————————Node:field_expression Text: resmgr->prev
|—————————————Node:identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: prev
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: next
|———————————Node:= Text: =
|———————————Node:null Text: NULL
|————————————Node:NULL Text: NULL
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (resmgr->next) {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
        else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (resmgr->next)
|———————————Node:( Text: (
|———————————Node:field_expression Text: resmgr->next
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: next
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
            resmgr->next->prev = NULL;

            /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
            root_resmgr = resmgr->next;
        }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: resmgr->next->prev = NULL;
|————————————Node:assignment_expression Text: resmgr->next->prev = NULL
|—————————————Node:field_expression Text: resmgr->next->prev
|——————————————Node:field_expression Text: resmgr->next
|———————————————Node:identifier Text: resmgr
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: next
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: prev
|—————————————Node:= Text: =
|—————————————Node:null Text: NULL
|——————————————Node:NULL Text: NULL
|————————————Node:; Text: ;
|———————————Node:comment Text: /* Since this node does not have a previous node, it must be the
             * root node. Therefore when it is destroyed the new root node must
             * then be the next node. */
|———————————Node:expression_statement Text: root_resmgr = resmgr->next;
|————————————Node:assignment_expression Text: root_resmgr = resmgr->next
|—————————————Node:identifier Text: root_resmgr
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: resmgr->next
|——————————————Node:identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: next
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
            /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */

            root_resmgr = NULL;
        }
|————————————Node:{ Text: {
|————————————Node:comment Text: /* Since this node does not have a previous or a next node, it must
             * be the root and last remaining node. Therefore when it is
             * destroyed the root node must be set to NULL. */
|————————————Node:expression_statement Text: root_resmgr = NULL;
|—————————————Node:assignment_expression Text: root_resmgr = NULL
|——————————————Node:identifier Text: root_resmgr
|——————————————Node:= Text: =
|——————————————Node:null Text: NULL
|———————————————Node:NULL Text: NULL
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|—————Node:preproc_if Text: #if CONFIG_QNX_RESMGR_THREAD_POOL == 1
        if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
#endif
|——————Node:#if Text: #if
|——————Node:binary_expression Text: CONFIG_QNX_RESMGR_THREAD_POOL == 1
|———————Node:identifier Text: CONFIG_QNX_RESMGR_THREAD_POOL
|———————Node:== Text: ==
|———————Node:number_literal Text: 1
|——————Node:
 Text: 

|——————Node:if_statement Text: if (thread_pool_destroy(resmgr->thread_pool) == -1) {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (thread_pool_destroy(resmgr->thread_pool) == -1)
|————————Node:( Text: (
|————————Node:binary_expression Text: thread_pool_destroy(resmgr->thread_pool) == -1
|—————————Node:call_expression Text: thread_pool_destroy(resmgr->thread_pool)
|——————————Node:identifier Text: thread_pool_destroy
|——————————Node:argument_list Text: (resmgr->thread_pool)
|———————————Node:( Text: (
|———————————Node:field_expression Text: resmgr->thread_pool
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: thread_pool
|———————————Node:) Text: )
|—————————Node:== Text: ==
|—————————Node:number_literal Text: -1
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name );
|—————————Node:call_expression Text: log_err( "internal error; thread_pool_destroy failure (%s)\n",
                    name )
|——————————Node:identifier Text: log_err
|——————————Node:argument_list Text: ( "internal error; thread_pool_destroy failure (%s)\n",
                    name )
|———————————Node:( Text: (
|———————————Node:string_literal Text: "internal error; thread_pool_destroy failure (%s)\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: internal error; thread_pool_destroy failure (%s)
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|———————————Node:, Text: ,
|———————————Node:identifier Text: name
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:#endif Text: #endif
|—————Node:if_statement Text: if (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1) {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1)
|———————Node:( Text: (
|———————Node:binary_expression Text: resmgr_detach(resmgr->dispatch, resmgr->id, 0) == -1
|————————Node:call_expression Text: resmgr_detach(resmgr->dispatch, resmgr->id, 0)
|—————————Node:identifier Text: resmgr_detach
|—————————Node:argument_list Text: (resmgr->dispatch, resmgr->id, 0)
|——————————Node:( Text: (
|——————————Node:field_expression Text: resmgr->dispatch
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|——————————Node:, Text: ,
|——————————Node:field_expression Text: resmgr->id
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: id
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: -1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_err("internal error; resmgr_detach failure (%s)\n", name);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_err("internal error; resmgr_detach failure (%s)\n", name);
|————————Node:call_expression Text: log_err("internal error; resmgr_detach failure (%s)\n", name)
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ("internal error; resmgr_detach failure (%s)\n", name)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "internal error; resmgr_detach failure (%s)\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: internal error; resmgr_detach failure (%s)
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: name
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:preproc_if Text: #if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        pthread_join(resmgr->dispatch_thread, NULL);
#endif
|——————Node:#if Text: #if
|——————Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|———————Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|———————Node:== Text: ==
|———————Node:number_literal Text: 1
|——————Node:
 Text: 

|——————Node:expression_statement Text: pthread_join(resmgr->dispatch_thread, NULL);
|———————Node:call_expression Text: pthread_join(resmgr->dispatch_thread, NULL)
|————————Node:identifier Text: pthread_join
|————————Node:argument_list Text: (resmgr->dispatch_thread, NULL)
|—————————Node:( Text: (
|—————————Node:field_expression Text: resmgr->dispatch_thread
|——————————Node:identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: dispatch_thread
|—————————Node:, Text: ,
|—————————Node:null Text: NULL
|——————————Node:NULL Text: NULL
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:preproc_if Text: #if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
        // TODO: investigate if dispatch_context_free() is needed and why
        //       we get SIGSEGV when following code is uncommented.
        //dispatch_context_free(resmgr->dispatch_context);
#endif
|——————Node:#if Text: #if
|——————Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|———————Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|———————Node:== Text: ==
|———————Node:number_literal Text: 1
|——————Node:
 Text: 

|——————Node:comment Text: // TODO: investigate if dispatch_context_free() is needed and why
|——————Node:comment Text: //       we get SIGSEGV when following code is uncommented.
|——————Node:comment Text: //dispatch_context_free(resmgr->dispatch_context);
|——————Node:#endif Text: #endif
|—————Node:if_statement Text: if (dispatch_destroy(resmgr->dispatch) == -1) {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (dispatch_destroy(resmgr->dispatch) == -1)
|———————Node:( Text: (
|———————Node:binary_expression Text: dispatch_destroy(resmgr->dispatch) == -1
|————————Node:call_expression Text: dispatch_destroy(resmgr->dispatch)
|—————————Node:identifier Text: dispatch_destroy
|—————————Node:argument_list Text: (resmgr->dispatch)
|——————————Node:( Text: (
|——————————Node:field_expression Text: resmgr->dispatch
|———————————Node:identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: -1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name );
|————————Node:call_expression Text: log_err( "internal error; dispatch_destroy failure (%s)\n",
                    name )
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ( "internal error; dispatch_destroy failure (%s)\n",
                    name )
|——————————Node:( Text: (
|——————————Node:string_literal Text: "internal error; dispatch_destroy failure (%s)\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: internal error; dispatch_destroy failure (%s)
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: name
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: free(resmgr);
|——————Node:call_expression Text: free(resmgr)
|———————Node:identifier Text: free
|———————Node:argument_list Text: (resmgr)
|————————Node:( Text: (
|————————Node:identifier Text: resmgr
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:break_statement Text: break;
|——————Node:break Text: break
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:function_definition Text: IOFUNC_OCB_T* can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr) {
    can_resmgr_t* resmgr = get_resmgr(&root_resmgr, ctp->id);

    log_trace("can_ocb_calloc -> %s (id: %d)\n", resmgr->name, ctp->id);

    struct can_ocb* ocb;

    if (!(ocb = calloc(1, sizeof(*ocb)))) {
        return NULL;
    }

    ocb->resmgr = resmgr;

    device_session_t* ds = resmgr->device_session;
    struct net_device* device = ds->device;

    queue_attr_t rx_attr = { .size = 1024 };

    if (ocb->resmgr->channel_type != RX_CHANNEL) {
        rx_attr.size = 0;
    }

    if ((ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )) == NULL)
    {
        log_err("create_client_session failed: %s\n", ocb->resmgr->name);
    }

    ocb->rx.read_size = 0;
    ocb->rx.read_buffer = NULL;
    ocb->rx.nbytes = 0;
    ocb->rx.offset = 0;

    // Every rx session has it's own rx thread to call resmgr_msg_again()
    if (ocb->resmgr->channel_type == RX_CHANNEL) {
        ocb->rx.queue = &ocb->session->rx_queue;
        ocb->rx.blocked_clients = NULL;

        ocb->rx.read_size = 4096;
        ocb->rx.read_buffer = malloc(ocb->rx.read_size);

        int result;
        if ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK) {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        if ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK) {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb);
    }

    return ocb;
}
|——Node:type_identifier Text: IOFUNC_OCB_T
|——Node:pointer_declarator Text: * can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|———Node:* Text: *
|———Node:function_declarator Text: can_ocb_calloc (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|————Node:identifier Text: can_ocb_calloc
|————Node:parameter_list Text: (resmgr_context_t* ctp, IOFUNC_ATTR_T* attr)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: resmgr_context_t* ctp
|——————Node:type_identifier Text: resmgr_context_t
|——————Node:pointer_declarator Text: * ctp
|———————Node:* Text: *
|———————Node:identifier Text: ctp
|—————Node:, Text: ,
|—————Node:parameter_declaration Text: IOFUNC_ATTR_T* attr
|——————Node:type_identifier Text: IOFUNC_ATTR_T
|——————Node:pointer_declarator Text: * attr
|———————Node:* Text: *
|———————Node:identifier Text: attr
|—————Node:) Text: )
|——Node:compound_statement Text: {
    can_resmgr_t* resmgr = get_resmgr(&root_resmgr, ctp->id);

    log_trace("can_ocb_calloc -> %s (id: %d)\n", resmgr->name, ctp->id);

    struct can_ocb* ocb;

    if (!(ocb = calloc(1, sizeof(*ocb)))) {
        return NULL;
    }

    ocb->resmgr = resmgr;

    device_session_t* ds = resmgr->device_session;
    struct net_device* device = ds->device;

    queue_attr_t rx_attr = { .size = 1024 };

    if (ocb->resmgr->channel_type != RX_CHANNEL) {
        rx_attr.size = 0;
    }

    if ((ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )) == NULL)
    {
        log_err("create_client_session failed: %s\n", ocb->resmgr->name);
    }

    ocb->rx.read_size = 0;
    ocb->rx.read_buffer = NULL;
    ocb->rx.nbytes = 0;
    ocb->rx.offset = 0;

    // Every rx session has it's own rx thread to call resmgr_msg_again()
    if (ocb->resmgr->channel_type == RX_CHANNEL) {
        ocb->rx.queue = &ocb->session->rx_queue;
        ocb->rx.blocked_clients = NULL;

        ocb->rx.read_size = 4096;
        ocb->rx.read_buffer = malloc(ocb->rx.read_size);

        int result;
        if ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK) {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        if ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK) {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb);
    }

    return ocb;
}
|———Node:{ Text: {
|———Node:declaration Text: can_resmgr_t* resmgr = get_resmgr(&root_resmgr, ctp->id);
|————Node:type_identifier Text: can_resmgr_t
|————Node:init_declarator Text: * resmgr = get_resmgr(&root_resmgr, ctp->id)
|—————Node:pointer_declarator Text: * resmgr
|——————Node:* Text: *
|——————Node:identifier Text: resmgr
|—————Node:= Text: =
|—————Node:call_expression Text: get_resmgr(&root_resmgr, ctp->id)
|——————Node:identifier Text: get_resmgr
|——————Node:argument_list Text: (&root_resmgr, ctp->id)
|———————Node:( Text: (
|———————Node:pointer_expression Text: &root_resmgr
|————————Node:& Text: &
|————————Node:identifier Text: root_resmgr
|———————Node:, Text: ,
|———————Node:field_expression Text: ctp->id
|————————Node:identifier Text: ctp
|————————Node:-> Text: ->
|————————Node:field_identifier Text: id
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("can_ocb_calloc -> %s (id: %d)\n", resmgr->name, ctp->id);
|————Node:call_expression Text: log_trace("can_ocb_calloc -> %s (id: %d)\n", resmgr->name, ctp->id)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("can_ocb_calloc -> %s (id: %d)\n", resmgr->name, ctp->id)
|——————Node:( Text: (
|——————Node:string_literal Text: "can_ocb_calloc -> %s (id: %d)\n"
|———————Node:" Text: "
|———————Node:string_content Text: can_ocb_calloc -> %s (id: %d)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: resmgr->name
|———————Node:identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct can_ocb* ocb;
|————Node:struct_specifier Text: struct can_ocb
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_ocb
|————Node:pointer_declarator Text: * ocb
|—————Node:* Text: *
|—————Node:identifier Text: ocb
|————Node:; Text: ;
|———Node:if_statement Text: if (!(ocb = calloc(1, sizeof(*ocb)))) {
        return NULL;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (!(ocb = calloc(1, sizeof(*ocb))))
|—————Node:( Text: (
|—————Node:unary_expression Text: !(ocb = calloc(1, sizeof(*ocb)))
|——————Node:! Text: !
|——————Node:parenthesized_expression Text: (ocb = calloc(1, sizeof(*ocb)))
|———————Node:( Text: (
|———————Node:assignment_expression Text: ocb = calloc(1, sizeof(*ocb))
|————————Node:identifier Text: ocb
|————————Node:= Text: =
|————————Node:call_expression Text: calloc(1, sizeof(*ocb))
|—————————Node:identifier Text: calloc
|—————————Node:argument_list Text: (1, sizeof(*ocb))
|——————————Node:( Text: (
|——————————Node:number_literal Text: 1
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(*ocb)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (*ocb)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: *ocb
|—————————————Node:* Text: *
|—————————————Node:identifier Text: ocb
|————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return NULL;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return NULL;
|——————Node:return Text: return
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ocb->resmgr = resmgr;
|————Node:assignment_expression Text: ocb->resmgr = resmgr
|—————Node:field_expression Text: ocb->resmgr
|——————Node:identifier Text: ocb
|——————Node:-> Text: ->
|——————Node:field_identifier Text: resmgr
|—————Node:= Text: =
|—————Node:identifier Text: resmgr
|————Node:; Text: ;
|———Node:declaration Text: device_session_t* ds = resmgr->device_session;
|————Node:type_identifier Text: device_session_t
|————Node:init_declarator Text: * ds = resmgr->device_session
|—————Node:pointer_declarator Text: * ds
|——————Node:* Text: *
|——————Node:identifier Text: ds
|—————Node:= Text: =
|—————Node:field_expression Text: resmgr->device_session
|——————Node:identifier Text: resmgr
|——————Node:-> Text: ->
|——————Node:field_identifier Text: device_session
|————Node:; Text: ;
|———Node:declaration Text: struct net_device* device = ds->device;
|————Node:struct_specifier Text: struct net_device
|—————Node:struct Text: struct
|—————Node:type_identifier Text: net_device
|————Node:init_declarator Text: * device = ds->device
|—————Node:pointer_declarator Text: * device
|——————Node:* Text: *
|——————Node:identifier Text: device
|—————Node:= Text: =
|—————Node:field_expression Text: ds->device
|——————Node:identifier Text: ds
|——————Node:-> Text: ->
|——————Node:field_identifier Text: device
|————Node:; Text: ;
|———Node:declaration Text: queue_attr_t rx_attr = { .size = 1024 };
|————Node:type_identifier Text: queue_attr_t
|————Node:init_declarator Text: rx_attr = { .size = 1024 }
|—————Node:identifier Text: rx_attr
|—————Node:= Text: =
|—————Node:initializer_list Text: { .size = 1024 }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .size = 1024
|———————Node:field_designator Text: .size
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:= Text: =
|———————Node:number_literal Text: 1024
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:if_statement Text: if (ocb->resmgr->channel_type != RX_CHANNEL) {
        rx_attr.size = 0;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ocb->resmgr->channel_type != RX_CHANNEL)
|—————Node:( Text: (
|—————Node:binary_expression Text: ocb->resmgr->channel_type != RX_CHANNEL
|——————Node:field_expression Text: ocb->resmgr->channel_type
|———————Node:field_expression Text: ocb->resmgr
|————————Node:identifier Text: ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: channel_type
|——————Node:!= Text: !=
|——————Node:identifier Text: RX_CHANNEL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        rx_attr.size = 0;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: rx_attr.size = 0;
|——————Node:assignment_expression Text: rx_attr.size = 0
|———————Node:field_expression Text: rx_attr.size
|————————Node:identifier Text: rx_attr
|————————Node:. Text: .
|————————Node:field_identifier Text: size
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if ((ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )) == NULL)
    {
        log_err("create_client_session failed: %s\n", ocb->resmgr->name);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )) == NULL)
|—————Node:( Text: (
|—————Node:binary_expression Text: (ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )) == NULL
|——————Node:parenthesized_expression Text: (ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio ))
|———————Node:( Text: (
|———————Node:assignment_expression Text: ocb->session =
            create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )
|————————Node:field_expression Text: ocb->session
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: session
|————————Node:= Text: =
|————————Node:call_expression Text: create_client_session( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )
|—————————Node:identifier Text: create_client_session
|—————————Node:argument_list Text: ( device, &rx_attr,
                &resmgr->mid,
                &resmgr->mfilter,
                &resmgr->prio )
|——————————Node:( Text: (
|——————————Node:identifier Text: device
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &rx_attr
|———————————Node:& Text: &
|———————————Node:identifier Text: rx_attr
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &resmgr->mid
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->mid
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: mid
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &resmgr->mfilter
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->mfilter
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: mfilter
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &resmgr->prio
|———————————Node:& Text: &
|———————————Node:field_expression Text: resmgr->prio
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: prio
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:== Text: ==
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("create_client_session failed: %s\n", ocb->resmgr->name);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("create_client_session failed: %s\n", ocb->resmgr->name);
|——————Node:call_expression Text: log_err("create_client_session failed: %s\n", ocb->resmgr->name)
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("create_client_session failed: %s\n", ocb->resmgr->name)
|————————Node:( Text: (
|————————Node:string_literal Text: "create_client_session failed: %s\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: create_client_session failed: %s
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:field_expression Text: ocb->resmgr->name
|—————————Node:field_expression Text: ocb->resmgr
|——————————Node:identifier Text: ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: name
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: ocb->rx.read_size = 0;
|————Node:assignment_expression Text: ocb->rx.read_size = 0
|—————Node:field_expression Text: ocb->rx.read_size
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: read_size
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: ocb->rx.read_buffer = NULL;
|————Node:assignment_expression Text: ocb->rx.read_buffer = NULL
|—————Node:field_expression Text: ocb->rx.read_buffer
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: read_buffer
|—————Node:= Text: =
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:expression_statement Text: ocb->rx.nbytes = 0;
|————Node:assignment_expression Text: ocb->rx.nbytes = 0
|—————Node:field_expression Text: ocb->rx.nbytes
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: nbytes
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: ocb->rx.offset = 0;
|————Node:assignment_expression Text: ocb->rx.offset = 0
|—————Node:field_expression Text: ocb->rx.offset
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: offset
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: // Every rx session has it's own rx thread to call resmgr_msg_again()
|———Node:if_statement Text: if (ocb->resmgr->channel_type == RX_CHANNEL) {
        ocb->rx.queue = &ocb->session->rx_queue;
        ocb->rx.blocked_clients = NULL;

        ocb->rx.read_size = 4096;
        ocb->rx.read_buffer = malloc(ocb->rx.read_size);

        int result;
        if ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK) {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        if ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK) {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ocb->resmgr->channel_type == RX_CHANNEL)
|—————Node:( Text: (
|—————Node:binary_expression Text: ocb->resmgr->channel_type == RX_CHANNEL
|——————Node:field_expression Text: ocb->resmgr->channel_type
|———————Node:field_expression Text: ocb->resmgr
|————————Node:identifier Text: ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: channel_type
|——————Node:== Text: ==
|——————Node:identifier Text: RX_CHANNEL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        ocb->rx.queue = &ocb->session->rx_queue;
        ocb->rx.blocked_clients = NULL;

        ocb->rx.read_size = 4096;
        ocb->rx.read_buffer = malloc(ocb->rx.read_size);

        int result;
        if ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK) {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        if ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK) {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }

        pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ocb->rx.queue = &ocb->session->rx_queue;
|——————Node:assignment_expression Text: ocb->rx.queue = &ocb->session->rx_queue
|———————Node:field_expression Text: ocb->rx.queue
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: queue
|———————Node:= Text: =
|———————Node:pointer_expression Text: &ocb->session->rx_queue
|————————Node:& Text: &
|————————Node:field_expression Text: ocb->session->rx_queue
|—————————Node:field_expression Text: ocb->session
|——————————Node:identifier Text: ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: session
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_queue
|——————Node:; Text: ;
|—————Node:expression_statement Text: ocb->rx.blocked_clients = NULL;
|——————Node:assignment_expression Text: ocb->rx.blocked_clients = NULL
|———————Node:field_expression Text: ocb->rx.blocked_clients
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: blocked_clients
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:expression_statement Text: ocb->rx.read_size = 4096;
|——————Node:assignment_expression Text: ocb->rx.read_size = 4096
|———————Node:field_expression Text: ocb->rx.read_size
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_size
|———————Node:= Text: =
|———————Node:number_literal Text: 4096
|——————Node:; Text: ;
|—————Node:expression_statement Text: ocb->rx.read_buffer = malloc(ocb->rx.read_size);
|——————Node:assignment_expression Text: ocb->rx.read_buffer = malloc(ocb->rx.read_size)
|———————Node:field_expression Text: ocb->rx.read_buffer
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_buffer
|———————Node:= Text: =
|———————Node:call_expression Text: malloc(ocb->rx.read_size)
|————————Node:identifier Text: malloc
|————————Node:argument_list Text: (ocb->rx.read_size)
|—————————Node:( Text: (
|—————————Node:field_expression Text: ocb->rx.read_size
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_size
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: int result;
|——————Node:primitive_type Text: int
|——————Node:identifier Text: result
|——————Node:; Text: ;
|—————Node:if_statement Text: if ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK) {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: ((result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK)
|———————Node:( Text: (
|———————Node:binary_expression Text: (result = pthread_mutex_init(&ocb->rx.mutex, NULL)) != EOK
|————————Node:parenthesized_expression Text: (result = pthread_mutex_init(&ocb->rx.mutex, NULL))
|—————————Node:( Text: (
|—————————Node:assignment_expression Text: result = pthread_mutex_init(&ocb->rx.mutex, NULL)
|——————————Node:identifier Text: result
|——————————Node:= Text: =
|——————————Node:call_expression Text: pthread_mutex_init(&ocb->rx.mutex, NULL)
|———————————Node:identifier Text: pthread_mutex_init
|———————————Node:argument_list Text: (&ocb->rx.mutex, NULL)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: ocb->rx.mutex
|——————————————Node:field_expression Text: ocb->rx
|———————————————Node:identifier Text: ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: EOK
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);

            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result);
|————————Node:call_expression Text: log_err("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result)
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ("can_ocb_calloc pthread_mutex_init failed: %d\n",
                    result)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "can_ocb_calloc pthread_mutex_init failed: %d\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: can_ocb_calloc pthread_mutex_init failed: %d
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: result
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: destroy_client_session(ocb->session);
|————————Node:call_expression Text: destroy_client_session(ocb->session)
|—————————Node:identifier Text: destroy_client_session
|—————————Node:argument_list Text: (ocb->session)
|——————————Node:( Text: (
|——————————Node:field_expression Text: ocb->session
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: session
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: free(ocb);
|————————Node:call_expression Text: free(ocb)
|—————————Node:identifier Text: free
|—————————Node:argument_list Text: (ocb)
|——————————Node:( Text: (
|——————————Node:identifier Text: ocb
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return NULL;
|————————Node:return Text: return
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK) {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: ((result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK)
|———————Node:( Text: (
|———————Node:binary_expression Text: (result = pthread_cond_init(&ocb->rx.cond, NULL)) != EOK
|————————Node:parenthesized_expression Text: (result = pthread_cond_init(&ocb->rx.cond, NULL))
|—————————Node:( Text: (
|—————————Node:assignment_expression Text: result = pthread_cond_init(&ocb->rx.cond, NULL)
|——————————Node:identifier Text: result
|——————————Node:= Text: =
|——————————Node:call_expression Text: pthread_cond_init(&ocb->rx.cond, NULL)
|———————————Node:identifier Text: pthread_cond_init
|———————————Node:argument_list Text: (&ocb->rx.cond, NULL)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &ocb->rx.cond
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: ocb->rx.cond
|——————————————Node:field_expression Text: ocb->rx
|———————————————Node:identifier Text: ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: cond
|————————————Node:, Text: ,
|————————————Node:null Text: NULL
|—————————————Node:NULL Text: NULL
|————————————Node:) Text: )
|—————————Node:) Text: )
|————————Node:!= Text: !=
|————————Node:identifier Text: EOK
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);

            pthread_mutex_destroy(&ocb->rx.mutex);
            destroy_client_session(ocb->session);
            free(ocb);

            return NULL;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_err("create_device_session pthread_cond_init failed: %d\n",
                    result);
|————————Node:call_expression Text: log_err("create_device_session pthread_cond_init failed: %d\n",
                    result)
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ("create_device_session pthread_cond_init failed: %d\n",
                    result)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "create_device_session pthread_cond_init failed: %d\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: create_device_session pthread_cond_init failed: %d
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: result
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: pthread_mutex_destroy(&ocb->rx.mutex);
|————————Node:call_expression Text: pthread_mutex_destroy(&ocb->rx.mutex)
|—————————Node:identifier Text: pthread_mutex_destroy
|—————————Node:argument_list Text: (&ocb->rx.mutex)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &ocb->rx.mutex
|———————————Node:& Text: &
|———————————Node:field_expression Text: ocb->rx.mutex
|————————————Node:field_expression Text: ocb->rx
|—————————————Node:identifier Text: ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mutex
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: destroy_client_session(ocb->session);
|————————Node:call_expression Text: destroy_client_session(ocb->session)
|—————————Node:identifier Text: destroy_client_session
|—————————Node:argument_list Text: (ocb->session)
|——————————Node:( Text: (
|——————————Node:field_expression Text: ocb->session
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: session
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: free(ocb);
|————————Node:call_expression Text: free(ocb)
|—————————Node:identifier Text: free
|—————————Node:argument_list Text: (ocb)
|——————————Node:( Text: (
|——————————Node:identifier Text: ocb
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return NULL;
|————————Node:return Text: return
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb);
|——————Node:call_expression Text: pthread_create(&ocb->rx.thread, NULL, &rx_loop, ocb)
|———————Node:identifier Text: pthread_create
|———————Node:argument_list Text: (&ocb->rx.thread, NULL, &rx_loop, ocb)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.thread
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.thread
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: thread
|————————Node:, Text: ,
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &rx_loop
|—————————Node:& Text: &
|—————————Node:identifier Text: rx_loop
|————————Node:, Text: ,
|————————Node:identifier Text: ocb
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return ocb;
|————Node:return Text: return
|————Node:identifier Text: ocb
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void can_ocb_free (IOFUNC_OCB_T* ocb) {
    log_trace("can_ocb_free -> %s\n", ocb->resmgr->name);

    pthread_mutex_lock(&ocb->rx.mutex);
    ocb->rx.queue = NULL;
    pthread_cond_signal(&ocb->rx.cond);
    pthread_mutex_unlock(&ocb->rx.mutex);

    if (ocb->session) {
        destroy_client_session(ocb->session);
        ocb->session = NULL;
    }

    // Wait for rx thread to exit
    if (ocb->resmgr->channel_type == RX_CHANNEL) {
        pthread_join(ocb->rx.thread, NULL);

        pthread_mutex_lock(&ocb->rx.mutex);

        // Don't leave any blocking clients hanging
        blocked_client_t *client = ocb->rx.blocked_clients;

        while (client != NULL) {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }

        free_all_blocked_clients(&ocb->rx.blocked_clients);
        pthread_mutex_unlock(&ocb->rx.mutex);
    }

    pthread_mutex_lock(&ocb->rx.mutex);
    pthread_mutex_destroy(&ocb->rx.mutex);
    pthread_cond_destroy(&ocb->rx.cond);

    ocb->rx.read_size = 0;
    if (ocb->rx.read_buffer) {
       free(ocb->rx.read_buffer);
       ocb->rx.read_buffer = NULL;
    }

    free(ocb);

    // Notice we never unlocked the mutex, since we know the dequeue() is not
    // waiting and we are in the process of destroying the session.
    // No need: pthread_mutex_unlock(&ocb->rx.mutex);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: can_ocb_free (IOFUNC_OCB_T* ocb)
|———Node:identifier Text: can_ocb_free
|———Node:parameter_list Text: (IOFUNC_OCB_T* ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: IOFUNC_OCB_T* ocb
|—————Node:type_identifier Text: IOFUNC_OCB_T
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    log_trace("can_ocb_free -> %s\n", ocb->resmgr->name);

    pthread_mutex_lock(&ocb->rx.mutex);
    ocb->rx.queue = NULL;
    pthread_cond_signal(&ocb->rx.cond);
    pthread_mutex_unlock(&ocb->rx.mutex);

    if (ocb->session) {
        destroy_client_session(ocb->session);
        ocb->session = NULL;
    }

    // Wait for rx thread to exit
    if (ocb->resmgr->channel_type == RX_CHANNEL) {
        pthread_join(ocb->rx.thread, NULL);

        pthread_mutex_lock(&ocb->rx.mutex);

        // Don't leave any blocking clients hanging
        blocked_client_t *client = ocb->rx.blocked_clients;

        while (client != NULL) {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }

        free_all_blocked_clients(&ocb->rx.blocked_clients);
        pthread_mutex_unlock(&ocb->rx.mutex);
    }

    pthread_mutex_lock(&ocb->rx.mutex);
    pthread_mutex_destroy(&ocb->rx.mutex);
    pthread_cond_destroy(&ocb->rx.cond);

    ocb->rx.read_size = 0;
    if (ocb->rx.read_buffer) {
       free(ocb->rx.read_buffer);
       ocb->rx.read_buffer = NULL;
    }

    free(ocb);

    // Notice we never unlocked the mutex, since we know the dequeue() is not
    // waiting and we are in the process of destroying the session.
    // No need: pthread_mutex_unlock(&ocb->rx.mutex);
}
|———Node:{ Text: {
|———Node:expression_statement Text: log_trace("can_ocb_free -> %s\n", ocb->resmgr->name);
|————Node:call_expression Text: log_trace("can_ocb_free -> %s\n", ocb->resmgr->name)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("can_ocb_free -> %s\n", ocb->resmgr->name)
|——————Node:( Text: (
|——————Node:string_literal Text: "can_ocb_free -> %s\n"
|———————Node:" Text: "
|———————Node:string_content Text: can_ocb_free -> %s
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ocb->resmgr->name
|———————Node:field_expression Text: ocb->resmgr
|————————Node:identifier Text: ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: name
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pthread_mutex_lock(&ocb->rx.mutex);
|————Node:call_expression Text: pthread_mutex_lock(&ocb->rx.mutex)
|—————Node:identifier Text: pthread_mutex_lock
|—————Node:argument_list Text: (&ocb->rx.mutex)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.mutex
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.mutex
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: mutex
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ocb->rx.queue = NULL;
|————Node:assignment_expression Text: ocb->rx.queue = NULL
|—————Node:field_expression Text: ocb->rx.queue
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: queue
|—————Node:= Text: =
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:expression_statement Text: pthread_cond_signal(&ocb->rx.cond);
|————Node:call_expression Text: pthread_cond_signal(&ocb->rx.cond)
|—————Node:identifier Text: pthread_cond_signal
|—————Node:argument_list Text: (&ocb->rx.cond)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.cond
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.cond
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: cond
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pthread_mutex_unlock(&ocb->rx.mutex);
|————Node:call_expression Text: pthread_mutex_unlock(&ocb->rx.mutex)
|—————Node:identifier Text: pthread_mutex_unlock
|—————Node:argument_list Text: (&ocb->rx.mutex)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.mutex
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.mutex
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: mutex
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:if_statement Text: if (ocb->session) {
        destroy_client_session(ocb->session);
        ocb->session = NULL;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ocb->session)
|—————Node:( Text: (
|—————Node:field_expression Text: ocb->session
|——————Node:identifier Text: ocb
|——————Node:-> Text: ->
|——————Node:field_identifier Text: session
|—————Node:) Text: )
|————Node:compound_statement Text: {
        destroy_client_session(ocb->session);
        ocb->session = NULL;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: destroy_client_session(ocb->session);
|——————Node:call_expression Text: destroy_client_session(ocb->session)
|———————Node:identifier Text: destroy_client_session
|———————Node:argument_list Text: (ocb->session)
|————————Node:( Text: (
|————————Node:field_expression Text: ocb->session
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: session
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ocb->session = NULL;
|——————Node:assignment_expression Text: ocb->session = NULL
|———————Node:field_expression Text: ocb->session
|————————Node:identifier Text: ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: session
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: // Wait for rx thread to exit
|———Node:if_statement Text: if (ocb->resmgr->channel_type == RX_CHANNEL) {
        pthread_join(ocb->rx.thread, NULL);

        pthread_mutex_lock(&ocb->rx.mutex);

        // Don't leave any blocking clients hanging
        blocked_client_t *client = ocb->rx.blocked_clients;

        while (client != NULL) {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }

        free_all_blocked_clients(&ocb->rx.blocked_clients);
        pthread_mutex_unlock(&ocb->rx.mutex);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ocb->resmgr->channel_type == RX_CHANNEL)
|—————Node:( Text: (
|—————Node:binary_expression Text: ocb->resmgr->channel_type == RX_CHANNEL
|——————Node:field_expression Text: ocb->resmgr->channel_type
|———————Node:field_expression Text: ocb->resmgr
|————————Node:identifier Text: ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: channel_type
|——————Node:== Text: ==
|——————Node:identifier Text: RX_CHANNEL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        pthread_join(ocb->rx.thread, NULL);

        pthread_mutex_lock(&ocb->rx.mutex);

        // Don't leave any blocking clients hanging
        blocked_client_t *client = ocb->rx.blocked_clients;

        while (client != NULL) {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }

        free_all_blocked_clients(&ocb->rx.blocked_clients);
        pthread_mutex_unlock(&ocb->rx.mutex);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: pthread_join(ocb->rx.thread, NULL);
|——————Node:call_expression Text: pthread_join(ocb->rx.thread, NULL)
|———————Node:identifier Text: pthread_join
|———————Node:argument_list Text: (ocb->rx.thread, NULL)
|————————Node:( Text: (
|————————Node:field_expression Text: ocb->rx.thread
|—————————Node:field_expression Text: ocb->rx
|——————————Node:identifier Text: ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rx
|—————————Node:. Text: .
|—————————Node:field_identifier Text: thread
|————————Node:, Text: ,
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: pthread_mutex_lock(&ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_lock(&ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_lock
|———————Node:argument_list Text: (&ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.mutex
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:comment Text: // Don't leave any blocking clients hanging
|—————Node:declaration Text: blocked_client_t *client = ocb->rx.blocked_clients;
|——————Node:type_identifier Text: blocked_client_t
|——————Node:init_declarator Text: *client = ocb->rx.blocked_clients
|———————Node:pointer_declarator Text: *client
|————————Node:* Text: *
|————————Node:identifier Text: client
|———————Node:= Text: =
|———————Node:field_expression Text: ocb->rx.blocked_clients
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: blocked_clients
|——————Node:; Text: ;
|—————Node:while_statement Text: while (client != NULL) {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }
|——————Node:while Text: while
|——————Node:parenthesized_expression Text: (client != NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: client != NULL
|————————Node:identifier Text: client
|————————Node:!= Text: !=
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            MsgError(client->rcvid, EBADF);

            client = client->next;
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: MsgError(client->rcvid, EBADF);
|————————Node:call_expression Text: MsgError(client->rcvid, EBADF)
|—————————Node:identifier Text: MsgError
|—————————Node:argument_list Text: (client->rcvid, EBADF)
|——————————Node:( Text: (
|——————————Node:field_expression Text: client->rcvid
|———————————Node:identifier Text: client
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rcvid
|——————————Node:, Text: ,
|——————————Node:identifier Text: EBADF
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: client = client->next;
|————————Node:assignment_expression Text: client = client->next
|—————————Node:identifier Text: client
|—————————Node:= Text: =
|—————————Node:field_expression Text: client->next
|——————————Node:identifier Text: client
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: next
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: free_all_blocked_clients(&ocb->rx.blocked_clients);
|——————Node:call_expression Text: free_all_blocked_clients(&ocb->rx.blocked_clients)
|———————Node:identifier Text: free_all_blocked_clients
|———————Node:argument_list Text: (&ocb->rx.blocked_clients)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.blocked_clients
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.blocked_clients
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: blocked_clients
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: pthread_mutex_unlock(&ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_unlock(&ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_unlock
|———————Node:argument_list Text: (&ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.mutex
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: pthread_mutex_lock(&ocb->rx.mutex);
|————Node:call_expression Text: pthread_mutex_lock(&ocb->rx.mutex)
|—————Node:identifier Text: pthread_mutex_lock
|—————Node:argument_list Text: (&ocb->rx.mutex)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.mutex
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.mutex
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: mutex
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pthread_mutex_destroy(&ocb->rx.mutex);
|————Node:call_expression Text: pthread_mutex_destroy(&ocb->rx.mutex)
|—————Node:identifier Text: pthread_mutex_destroy
|—————Node:argument_list Text: (&ocb->rx.mutex)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.mutex
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.mutex
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: mutex
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: pthread_cond_destroy(&ocb->rx.cond);
|————Node:call_expression Text: pthread_cond_destroy(&ocb->rx.cond)
|—————Node:identifier Text: pthread_cond_destroy
|—————Node:argument_list Text: (&ocb->rx.cond)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &ocb->rx.cond
|———————Node:& Text: &
|———————Node:field_expression Text: ocb->rx.cond
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: cond
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: ocb->rx.read_size = 0;
|————Node:assignment_expression Text: ocb->rx.read_size = 0
|—————Node:field_expression Text: ocb->rx.read_size
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: read_size
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:if_statement Text: if (ocb->rx.read_buffer) {
       free(ocb->rx.read_buffer);
       ocb->rx.read_buffer = NULL;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (ocb->rx.read_buffer)
|—————Node:( Text: (
|—————Node:field_expression Text: ocb->rx.read_buffer
|——————Node:field_expression Text: ocb->rx
|———————Node:identifier Text: ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: read_buffer
|—————Node:) Text: )
|————Node:compound_statement Text: {
       free(ocb->rx.read_buffer);
       ocb->rx.read_buffer = NULL;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: free(ocb->rx.read_buffer);
|——————Node:call_expression Text: free(ocb->rx.read_buffer)
|———————Node:identifier Text: free
|———————Node:argument_list Text: (ocb->rx.read_buffer)
|————————Node:( Text: (
|————————Node:field_expression Text: ocb->rx.read_buffer
|—————————Node:field_expression Text: ocb->rx
|——————————Node:identifier Text: ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rx
|—————————Node:. Text: .
|—————————Node:field_identifier Text: read_buffer
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: ocb->rx.read_buffer = NULL;
|——————Node:assignment_expression Text: ocb->rx.read_buffer = NULL
|———————Node:field_expression Text: ocb->rx.read_buffer
|————————Node:field_expression Text: ocb->rx
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_buffer
|———————Node:= Text: =
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: free(ocb);
|————Node:call_expression Text: free(ocb)
|—————Node:identifier Text: free
|—————Node:argument_list Text: (ocb)
|——————Node:( Text: (
|——————Node:identifier Text: ocb
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: // Notice we never unlocked the mutex, since we know the dequeue() is not
|———Node:comment Text: // waiting and we are in the process of destroying the session.
|———Node:comment Text: // No need: pthread_mutex_unlock(&ocb->rx.mutex);
|———Node:} Text: }
|—Node:function_definition Text: int msg_again_callback (message_context_t* ctp, int type, unsigned flags,
        void* handle)
{
    msg_again_t* msg_again = (msg_again_t*)ctp->msg;

    // function resmgr_msg_again() seems to modify the ctp->rcvid value
    // so let's save it and restore it afer the call
    int rcvid_save = ctp->rcvid;

    if (msg_again->rcvid != -1) {
        if (resmgr_msg_again(ctp, msg_again->rcvid) == -1) {
        }
    }

    ctp->rcvid = rcvid_save;

    MsgReply(ctp->rcvid, EOK, NULL, 0);
    return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: msg_again_callback (message_context_t* ctp, int type, unsigned flags,
        void* handle)
|———Node:identifier Text: msg_again_callback
|———Node:parameter_list Text: (message_context_t* ctp, int type, unsigned flags,
        void* handle)
|————Node:( Text: (
|————Node:parameter_declaration Text: message_context_t* ctp
|—————Node:type_identifier Text: message_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: int type
|—————Node:primitive_type Text: int
|—————Node:identifier Text: type
|————Node:, Text: ,
|————Node:parameter_declaration Text: unsigned flags
|—————Node:sized_type_specifier Text: unsigned
|——————Node:unsigned Text: unsigned
|—————Node:identifier Text: flags
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* handle
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * handle
|——————Node:* Text: *
|——————Node:identifier Text: handle
|————Node:) Text: )
|——Node:compound_statement Text: {
    msg_again_t* msg_again = (msg_again_t*)ctp->msg;

    // function resmgr_msg_again() seems to modify the ctp->rcvid value
    // so let's save it and restore it afer the call
    int rcvid_save = ctp->rcvid;

    if (msg_again->rcvid != -1) {
        if (resmgr_msg_again(ctp, msg_again->rcvid) == -1) {
        }
    }

    ctp->rcvid = rcvid_save;

    MsgReply(ctp->rcvid, EOK, NULL, 0);
    return 0;
}
|———Node:{ Text: {
|———Node:declaration Text: msg_again_t* msg_again = (msg_again_t*)ctp->msg;
|————Node:type_identifier Text: msg_again_t
|————Node:init_declarator Text: * msg_again = (msg_again_t*)ctp->msg
|—————Node:pointer_declarator Text: * msg_again
|——————Node:* Text: *
|——————Node:identifier Text: msg_again
|—————Node:= Text: =
|—————Node:cast_expression Text: (msg_again_t*)ctp->msg
|——————Node:( Text: (
|——————Node:type_descriptor Text: msg_again_t*
|———————Node:type_identifier Text: msg_again_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:field_expression Text: ctp->msg
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: msg
|————Node:; Text: ;
|———Node:comment Text: // function resmgr_msg_again() seems to modify the ctp->rcvid value
|———Node:comment Text: // so let's save it and restore it afer the call
|———Node:declaration Text: int rcvid_save = ctp->rcvid;
|————Node:primitive_type Text: int
|————Node:init_declarator Text: rcvid_save = ctp->rcvid
|—————Node:identifier Text: rcvid_save
|—————Node:= Text: =
|—————Node:field_expression Text: ctp->rcvid
|——————Node:identifier Text: ctp
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rcvid
|————Node:; Text: ;
|———Node:if_statement Text: if (msg_again->rcvid != -1) {
        if (resmgr_msg_again(ctp, msg_again->rcvid) == -1) {
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (msg_again->rcvid != -1)
|—————Node:( Text: (
|—————Node:binary_expression Text: msg_again->rcvid != -1
|——————Node:field_expression Text: msg_again->rcvid
|———————Node:identifier Text: msg_again
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rcvid
|——————Node:!= Text: !=
|——————Node:number_literal Text: -1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (resmgr_msg_again(ctp, msg_again->rcvid) == -1) {
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (resmgr_msg_again(ctp, msg_again->rcvid) == -1) {
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (resmgr_msg_again(ctp, msg_again->rcvid) == -1)
|———————Node:( Text: (
|———————Node:binary_expression Text: resmgr_msg_again(ctp, msg_again->rcvid) == -1
|————————Node:call_expression Text: resmgr_msg_again(ctp, msg_again->rcvid)
|—————————Node:identifier Text: resmgr_msg_again
|—————————Node:argument_list Text: (ctp, msg_again->rcvid)
|——————————Node:( Text: (
|——————————Node:identifier Text: ctp
|——————————Node:, Text: ,
|——————————Node:field_expression Text: msg_again->rcvid
|———————————Node:identifier Text: msg_again
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rcvid
|——————————Node:) Text: )
|————————Node:== Text: ==
|————————Node:number_literal Text: -1
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        }
|———————Node:{ Text: {
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:expression_statement Text: ctp->rcvid = rcvid_save;
|————Node:assignment_expression Text: ctp->rcvid = rcvid_save
|—————Node:field_expression Text: ctp->rcvid
|——————Node:identifier Text: ctp
|——————Node:-> Text: ->
|——————Node:field_identifier Text: rcvid
|—————Node:= Text: =
|—————Node:identifier Text: rcvid_save
|————Node:; Text: ;
|———Node:expression_statement Text: MsgReply(ctp->rcvid, EOK, NULL, 0);
|————Node:call_expression Text: MsgReply(ctp->rcvid, EOK, NULL, 0)
|—————Node:identifier Text: MsgReply
|—————Node:argument_list Text: (ctp->rcvid, EOK, NULL, 0)
|——————Node:( Text: (
|——————Node:field_expression Text: ctp->rcvid
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rcvid
|——————Node:, Text: ,
|——————Node:identifier Text: EOK
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void* rx_loop (void* arg) {
    struct can_ocb* ocb = (struct can_ocb*)arg;

    can_resmgr_t* resmgr = ocb->resmgr;

    int coid;
    msg_again_t msg_again = { .id = _IO_MAX + 1 };

    /* Connect to our channel */
    if ((coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )) == -1)
    {
        log_err("rx_loop exit: Unable to attach to channel.\n");

        pthread_exit(NULL);
    }

    while (1) {
        pthread_mutex_lock(&ocb->rx.mutex);

        while ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
        {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }

        pthread_mutex_unlock(&ocb->rx.mutex);

        if (resmgr->shutdown || (ocb->rx.queue == NULL)) {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }

        if (ocb->rx.blocked_clients != NULL) {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
    }

    return NULL;
}
|——Node:primitive_type Text: void
|——Node:pointer_declarator Text: * rx_loop (void* arg)
|———Node:* Text: *
|———Node:function_declarator Text: rx_loop (void* arg)
|————Node:identifier Text: rx_loop
|————Node:parameter_list Text: (void* arg)
|—————Node:( Text: (
|—————Node:parameter_declaration Text: void* arg
|——————Node:primitive_type Text: void
|——————Node:pointer_declarator Text: * arg
|———————Node:* Text: *
|———————Node:identifier Text: arg
|—————Node:) Text: )
|——Node:compound_statement Text: {
    struct can_ocb* ocb = (struct can_ocb*)arg;

    can_resmgr_t* resmgr = ocb->resmgr;

    int coid;
    msg_again_t msg_again = { .id = _IO_MAX + 1 };

    /* Connect to our channel */
    if ((coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )) == -1)
    {
        log_err("rx_loop exit: Unable to attach to channel.\n");

        pthread_exit(NULL);
    }

    while (1) {
        pthread_mutex_lock(&ocb->rx.mutex);

        while ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
        {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }

        pthread_mutex_unlock(&ocb->rx.mutex);

        if (resmgr->shutdown || (ocb->rx.queue == NULL)) {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }

        if (ocb->rx.blocked_clients != NULL) {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
    }

    return NULL;
}
|———Node:{ Text: {
|———Node:declaration Text: struct can_ocb* ocb = (struct can_ocb*)arg;
|————Node:struct_specifier Text: struct can_ocb
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_ocb
|————Node:init_declarator Text: * ocb = (struct can_ocb*)arg
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (struct can_ocb*)arg
|——————Node:( Text: (
|——————Node:type_descriptor Text: struct can_ocb*
|———————Node:struct_specifier Text: struct can_ocb
|————————Node:struct Text: struct
|————————Node:type_identifier Text: can_ocb
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: arg
|————Node:; Text: ;
|———Node:declaration Text: can_resmgr_t* resmgr = ocb->resmgr;
|————Node:type_identifier Text: can_resmgr_t
|————Node:init_declarator Text: * resmgr = ocb->resmgr
|—————Node:pointer_declarator Text: * resmgr
|——————Node:* Text: *
|——————Node:identifier Text: resmgr
|—————Node:= Text: =
|—————Node:field_expression Text: ocb->resmgr
|——————Node:identifier Text: ocb
|——————Node:-> Text: ->
|——————Node:field_identifier Text: resmgr
|————Node:; Text: ;
|———Node:declaration Text: int coid;
|————Node:primitive_type Text: int
|————Node:identifier Text: coid
|————Node:; Text: ;
|———Node:declaration Text: msg_again_t msg_again = { .id = _IO_MAX + 1 };
|————Node:type_identifier Text: msg_again_t
|————Node:init_declarator Text: msg_again = { .id = _IO_MAX + 1 }
|—————Node:identifier Text: msg_again
|—————Node:= Text: =
|—————Node:initializer_list Text: { .id = _IO_MAX + 1 }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .id = _IO_MAX + 1
|———————Node:field_designator Text: .id
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:binary_expression Text: _IO_MAX + 1
|————————Node:identifier Text: _IO_MAX
|————————Node:+ Text: +
|————————Node:number_literal Text: 1
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:comment Text: /* Connect to our channel */
|———Node:if_statement Text: if ((coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )) == -1)
    {
        log_err("rx_loop exit: Unable to attach to channel.\n");

        pthread_exit(NULL);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )) == -1)
|—————Node:( Text: (
|—————Node:binary_expression Text: (coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )) == -1
|——————Node:parenthesized_expression Text: (coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL ))
|———————Node:( Text: (
|———————Node:assignment_expression Text: coid = message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )
|————————Node:identifier Text: coid
|————————Node:= Text: =
|————————Node:call_expression Text: message_connect(
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )
|—————————Node:identifier Text: message_connect
|—————————Node:argument_list Text: (
                    ocb->resmgr->dispatch, MSG_FLAG_SIDE_CHANNEL )
|——————————Node:( Text: (
|——————————Node:field_expression Text: ocb->resmgr->dispatch
|———————————Node:field_expression Text: ocb->resmgr
|————————————Node:identifier Text: ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dispatch
|——————————Node:, Text: ,
|——————————Node:identifier Text: MSG_FLAG_SIDE_CHANNEL
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:== Text: ==
|——————Node:number_literal Text: -1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_err("rx_loop exit: Unable to attach to channel.\n");

        pthread_exit(NULL);
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_err("rx_loop exit: Unable to attach to channel.\n");
|——————Node:call_expression Text: log_err("rx_loop exit: Unable to attach to channel.\n")
|———————Node:identifier Text: log_err
|———————Node:argument_list Text: ("rx_loop exit: Unable to attach to channel.\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "rx_loop exit: Unable to attach to channel.\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: rx_loop exit: Unable to attach to channel.
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: pthread_exit(NULL);
|——————Node:call_expression Text: pthread_exit(NULL)
|———————Node:identifier Text: pthread_exit
|———————Node:argument_list Text: (NULL)
|————————Node:( Text: (
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:while_statement Text: while (1) {
        pthread_mutex_lock(&ocb->rx.mutex);

        while ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
        {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }

        pthread_mutex_unlock(&ocb->rx.mutex);

        if (resmgr->shutdown || (ocb->rx.queue == NULL)) {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }

        if (ocb->rx.blocked_clients != NULL) {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
    }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (1)
|—————Node:( Text: (
|—————Node:number_literal Text: 1
|—————Node:) Text: )
|————Node:compound_statement Text: {
        pthread_mutex_lock(&ocb->rx.mutex);

        while ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
        {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }

        pthread_mutex_unlock(&ocb->rx.mutex);

        if (resmgr->shutdown || (ocb->rx.queue == NULL)) {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }

        if (ocb->rx.blocked_clients != NULL) {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: pthread_mutex_lock(&ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_lock(&ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_lock
|———————Node:argument_list Text: (&ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.mutex
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:while_statement Text: while ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
        {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }
|——————Node:while Text: while
|——————Node:parenthesized_expression Text: ((!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL))
|———————Node:( Text: (
|———————Node:binary_expression Text: (!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
                && (ocb->rx.blocked_clients == NULL)
|————————Node:binary_expression Text: (!resmgr->shutdown)
                && (ocb->rx.queue != NULL)
|—————————Node:parenthesized_expression Text: (!resmgr->shutdown)
|——————————Node:( Text: (
|——————————Node:unary_expression Text: !resmgr->shutdown
|———————————Node:! Text: !
|———————————Node:field_expression Text: resmgr->shutdown
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: shutdown
|——————————Node:) Text: )
|—————————Node:&& Text: &&
|—————————Node:parenthesized_expression Text: (ocb->rx.queue != NULL)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: ocb->rx.queue != NULL
|———————————Node:field_expression Text: ocb->rx.queue
|————————————Node:field_expression Text: ocb->rx
|—————————————Node:identifier Text: ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: queue
|———————————Node:!= Text: !=
|———————————Node:null Text: NULL
|————————————Node:NULL Text: NULL
|——————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:parenthesized_expression Text: (ocb->rx.blocked_clients == NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ocb->rx.blocked_clients == NULL
|——————————Node:field_expression Text: ocb->rx.blocked_clients
|———————————Node:field_expression Text: ocb->rx
|————————————Node:identifier Text: ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: blocked_clients
|——————————Node:== Text: ==
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex);
|————————Node:call_expression Text: pthread_cond_wait(&ocb->rx.cond, &ocb->rx.mutex)
|—————————Node:identifier Text: pthread_cond_wait
|—————————Node:argument_list Text: (&ocb->rx.cond, &ocb->rx.mutex)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &ocb->rx.cond
|———————————Node:& Text: &
|———————————Node:field_expression Text: ocb->rx.cond
|————————————Node:field_expression Text: ocb->rx
|—————————————Node:identifier Text: ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: cond
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &ocb->rx.mutex
|———————————Node:& Text: &
|———————————Node:field_expression Text: ocb->rx.mutex
|————————————Node:field_expression Text: ocb->rx
|—————————————Node:identifier Text: ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mutex
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: pthread_mutex_unlock(&ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_unlock(&ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_unlock
|———————Node:argument_list Text: (&ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: ocb->rx.mutex
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (resmgr->shutdown || (ocb->rx.queue == NULL)) {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (resmgr->shutdown || (ocb->rx.queue == NULL))
|———————Node:( Text: (
|———————Node:binary_expression Text: resmgr->shutdown || (ocb->rx.queue == NULL)
|————————Node:field_expression Text: resmgr->shutdown
|—————————Node:identifier Text: resmgr
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: shutdown
|————————Node:|| Text: ||
|————————Node:parenthesized_expression Text: (ocb->rx.queue == NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: ocb->rx.queue == NULL
|——————————Node:field_expression Text: ocb->rx.queue
|———————————Node:field_expression Text: ocb->rx
|————————————Node:identifier Text: ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: queue
|——————————Node:== Text: ==
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            log_trace("rx_loop exit\n");

            ConnectDetach(coid);
            pthread_exit(NULL);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: log_trace("rx_loop exit\n");
|————————Node:call_expression Text: log_trace("rx_loop exit\n")
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("rx_loop exit\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "rx_loop exit\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: rx_loop exit
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: ConnectDetach(coid);
|————————Node:call_expression Text: ConnectDetach(coid)
|—————————Node:identifier Text: ConnectDetach
|—————————Node:argument_list Text: (coid)
|——————————Node:( Text: (
|——————————Node:identifier Text: coid
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: pthread_exit(NULL);
|————————Node:call_expression Text: pthread_exit(NULL)
|—————————Node:identifier Text: pthread_exit
|—————————Node:argument_list Text: (NULL)
|——————————Node:( Text: (
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (ocb->rx.blocked_clients != NULL) {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (ocb->rx.blocked_clients != NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: ocb->rx.blocked_clients != NULL
|————————Node:field_expression Text: ocb->rx.blocked_clients
|—————————Node:field_expression Text: ocb->rx
|——————————Node:identifier Text: ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rx
|—————————Node:. Text: .
|—————————Node:field_identifier Text: blocked_clients
|————————Node:!= Text: !=
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);

            if (canmsg == NULL) {
                continue;
            }

            blocked_client_t* client = ocb->rx.blocked_clients;

            while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
        }
|———————Node:{ Text: {
|———————Node:declaration Text: struct can_msg* canmsg = dequeue_peek(ocb->rx.queue);
|————————Node:struct_specifier Text: struct can_msg
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_msg
|————————Node:init_declarator Text: * canmsg = dequeue_peek(ocb->rx.queue)
|—————————Node:pointer_declarator Text: * canmsg
|——————————Node:* Text: *
|——————————Node:identifier Text: canmsg
|—————————Node:= Text: =
|—————————Node:call_expression Text: dequeue_peek(ocb->rx.queue)
|——————————Node:identifier Text: dequeue_peek
|——————————Node:argument_list Text: (ocb->rx.queue)
|———————————Node:( Text: (
|———————————Node:field_expression Text: ocb->rx.queue
|————————————Node:field_expression Text: ocb->rx
|—————————————Node:identifier Text: ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: queue
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (canmsg == NULL) {
                continue;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (canmsg == NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canmsg == NULL
|——————————Node:identifier Text: canmsg
|——————————Node:== Text: ==
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                continue;
            }
|—————————Node:{ Text: {
|—————————Node:continue_statement Text: continue;
|——————————Node:continue Text: continue
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:declaration Text: blocked_client_t* client = ocb->rx.blocked_clients;
|————————Node:type_identifier Text: blocked_client_t
|————————Node:init_declarator Text: * client = ocb->rx.blocked_clients
|—————————Node:pointer_declarator Text: * client
|——————————Node:* Text: *
|——————————Node:identifier Text: client
|—————————Node:= Text: =
|—————————Node:field_expression Text: ocb->rx.blocked_clients
|——————————Node:field_expression Text: ocb->rx
|———————————Node:identifier Text: ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: blocked_clients
|————————Node:; Text: ;
|———————Node:while_statement Text: while (client != NULL) {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
|————————Node:while Text: while
|————————Node:parenthesized_expression Text: (client != NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: client != NULL
|——————————Node:identifier Text: client
|——————————Node:!= Text: !=
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                pthread_mutex_lock(&ocb->rx.mutex);
                msg_again.rcvid = client->rcvid;
                pthread_mutex_unlock(&ocb->rx.mutex);

                if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }

                client = client->next;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: pthread_mutex_lock(&ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_lock(&ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_lock
|———————————Node:argument_list Text: (&ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: ocb->rx.mutex
|——————————————Node:field_expression Text: ocb->rx
|———————————————Node:identifier Text: ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: msg_again.rcvid = client->rcvid;
|——————————Node:assignment_expression Text: msg_again.rcvid = client->rcvid
|———————————Node:field_expression Text: msg_again.rcvid
|————————————Node:identifier Text: msg_again
|————————————Node:. Text: .
|————————————Node:field_identifier Text: rcvid
|———————————Node:= Text: =
|———————————Node:field_expression Text: client->rcvid
|————————————Node:identifier Text: client
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rcvid
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_mutex_unlock(&ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_unlock(&ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_unlock
|———————————Node:argument_list Text: (&ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: ocb->rx.mutex
|——————————————Node:field_expression Text: ocb->rx
|———————————————Node:identifier Text: ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:if_statement Text: if (ocb->rx.queue != NULL && msg_again.rcvid != -1) {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (ocb->rx.queue != NULL && msg_again.rcvid != -1)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: ocb->rx.queue != NULL && msg_again.rcvid != -1
|————————————Node:binary_expression Text: ocb->rx.queue != NULL
|—————————————Node:field_expression Text: ocb->rx.queue
|——————————————Node:field_expression Text: ocb->rx
|———————————————Node:identifier Text: ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: queue
|—————————————Node:!= Text: !=
|—————————————Node:null Text: NULL
|——————————————Node:NULL Text: NULL
|————————————Node:&& Text: &&
|————————————Node:binary_expression Text: msg_again.rcvid != -1
|—————————————Node:field_expression Text: msg_again.rcvid
|——————————————Node:identifier Text: msg_again
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: rcvid
|—————————————Node:!= Text: !=
|—————————————Node:number_literal Text: -1
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
                    if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
                }
|———————————Node:{ Text: {
|———————————Node:if_statement Text: if (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
                    {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
|————————————Node:if Text: if
|————————————Node:parenthesized_expression Text: (MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1)
|—————————————Node:( Text: (
|—————————————Node:binary_expression Text: MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
                            == -1
|——————————————Node:call_expression Text: MsgSend(coid, &msg_again, sizeof(msg_again_t), NULL, 0)
|———————————————Node:identifier Text: MsgSend
|———————————————Node:argument_list Text: (coid, &msg_again, sizeof(msg_again_t), NULL, 0)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: coid
|————————————————Node:, Text: ,
|————————————————Node:pointer_expression Text: &msg_again
|—————————————————Node:& Text: &
|—————————————————Node:identifier Text: msg_again
|————————————————Node:, Text: ,
|————————————————Node:sizeof_expression Text: sizeof(msg_again_t)
|—————————————————Node:sizeof Text: sizeof
|—————————————————Node:parenthesized_expression Text: (msg_again_t)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: msg_again_t
|——————————————————Node:) Text: )
|————————————————Node:, Text: ,
|————————————————Node:null Text: NULL
|—————————————————Node:NULL Text: NULL
|————————————————Node:, Text: ,
|————————————————Node:number_literal Text: 0
|————————————————Node:) Text: )
|——————————————Node:== Text: ==
|——————————————Node:number_literal Text: -1
|—————————————Node:) Text: )
|————————————Node:compound_statement Text: {
                        log_err("rx_loop MsgSend error: %s\n", strerror(errno));
                    }
|—————————————Node:{ Text: {
|—————————————Node:expression_statement Text: log_err("rx_loop MsgSend error: %s\n", strerror(errno));
|——————————————Node:call_expression Text: log_err("rx_loop MsgSend error: %s\n", strerror(errno))
|———————————————Node:identifier Text: log_err
|———————————————Node:argument_list Text: ("rx_loop MsgSend error: %s\n", strerror(errno))
|————————————————Node:( Text: (
|————————————————Node:string_literal Text: "rx_loop MsgSend error: %s\n"
|—————————————————Node:" Text: "
|—————————————————Node:string_content Text: rx_loop MsgSend error: %s
|—————————————————Node:escape_sequence Text: \n
|—————————————————Node:" Text: "
|————————————————Node:, Text: ,
|————————————————Node:call_expression Text: strerror(errno)
|—————————————————Node:identifier Text: strerror
|—————————————————Node:argument_list Text: (errno)
|——————————————————Node:( Text: (
|——————————————————Node:identifier Text: errno
|——————————————————Node:) Text: )
|————————————————Node:) Text: )
|——————————————Node:; Text: ;
|—————————————Node:} Text: }
|———————————Node:} Text: }
|—————————Node:expression_statement Text: client = client->next;
|——————————Node:assignment_expression Text: client = client->next
|———————————Node:identifier Text: client
|———————————Node:= Text: =
|———————————Node:field_expression Text: client->next
|————————————Node:identifier Text: client
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: next
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:return_statement Text: return NULL;
|————Node:return Text: return
|————Node:null Text: NULL
|—————Node:NULL Text: NULL
|————Node:; Text: ;
|———Node:} Text: }
|—Node:preproc_if Text: #if CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
/*
 * Resource Manager
 *
 * Message thread and callback functions for connection and IO
 */

void* dispatch_receive_loop (void* arg) {
    can_resmgr_t* resmgr = (can_resmgr_t*)arg;

    dispatch_context_t* ctp = resmgr->dispatch_context;

    /* Done! We can now go into our "receive loop" and wait
     * for messages. The dispatch_block() function is calling
     * MsgReceive() under the covers, and receives for us.
     * The dispatch_handler() function analyzes the message
     * for us and calls the appropriate callback function. */
    while (1) {
        if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
        /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
        dispatch_handler(ctp);
    }

    return NULL;
}
#endif
|——Node:#if Text: #if
|——Node:binary_expression Text: CONFIG_QNX_RESMGR_SINGLE_THREAD == 1
|———Node:identifier Text: CONFIG_QNX_RESMGR_SINGLE_THREAD
|———Node:== Text: ==
|———Node:number_literal Text: 1
|——Node:
 Text: 

|——Node:comment Text: /*
 * Resource Manager
 *
 * Message thread and callback functions for connection and IO
 */
|——Node:function_definition Text: void* dispatch_receive_loop (void* arg) {
    can_resmgr_t* resmgr = (can_resmgr_t*)arg;

    dispatch_context_t* ctp = resmgr->dispatch_context;

    /* Done! We can now go into our "receive loop" and wait
     * for messages. The dispatch_block() function is calling
     * MsgReceive() under the covers, and receives for us.
     * The dispatch_handler() function analyzes the message
     * for us and calls the appropriate callback function. */
    while (1) {
        if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
        /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
        dispatch_handler(ctp);
    }

    return NULL;
}
|———Node:primitive_type Text: void
|———Node:pointer_declarator Text: * dispatch_receive_loop (void* arg)
|————Node:* Text: *
|————Node:function_declarator Text: dispatch_receive_loop (void* arg)
|—————Node:identifier Text: dispatch_receive_loop
|—————Node:parameter_list Text: (void* arg)
|——————Node:( Text: (
|——————Node:parameter_declaration Text: void* arg
|———————Node:primitive_type Text: void
|———————Node:pointer_declarator Text: * arg
|————————Node:* Text: *
|————————Node:identifier Text: arg
|——————Node:) Text: )
|———Node:compound_statement Text: {
    can_resmgr_t* resmgr = (can_resmgr_t*)arg;

    dispatch_context_t* ctp = resmgr->dispatch_context;

    /* Done! We can now go into our "receive loop" and wait
     * for messages. The dispatch_block() function is calling
     * MsgReceive() under the covers, and receives for us.
     * The dispatch_handler() function analyzes the message
     * for us and calls the appropriate callback function. */
    while (1) {
        if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
        /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
        dispatch_handler(ctp);
    }

    return NULL;
}
|————Node:{ Text: {
|————Node:declaration Text: can_resmgr_t* resmgr = (can_resmgr_t*)arg;
|—————Node:type_identifier Text: can_resmgr_t
|—————Node:init_declarator Text: * resmgr = (can_resmgr_t*)arg
|——————Node:pointer_declarator Text: * resmgr
|———————Node:* Text: *
|———————Node:identifier Text: resmgr
|——————Node:= Text: =
|——————Node:cast_expression Text: (can_resmgr_t*)arg
|———————Node:( Text: (
|———————Node:type_descriptor Text: can_resmgr_t*
|————————Node:type_identifier Text: can_resmgr_t
|————————Node:abstract_pointer_declarator Text: *
|—————————Node:* Text: *
|———————Node:) Text: )
|———————Node:identifier Text: arg
|—————Node:; Text: ;
|————Node:declaration Text: dispatch_context_t* ctp = resmgr->dispatch_context;
|—————Node:type_identifier Text: dispatch_context_t
|—————Node:init_declarator Text: * ctp = resmgr->dispatch_context
|——————Node:pointer_declarator Text: * ctp
|———————Node:* Text: *
|———————Node:identifier Text: ctp
|——————Node:= Text: =
|——————Node:field_expression Text: resmgr->dispatch_context
|———————Node:identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: dispatch_context
|—————Node:; Text: ;
|————Node:comment Text: /* Done! We can now go into our "receive loop" and wait
     * for messages. The dispatch_block() function is calling
     * MsgReceive() under the covers, and receives for us.
     * The dispatch_handler() function analyzes the message
     * for us and calls the appropriate callback function. */
|————Node:while_statement Text: while (1) {
        if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
        /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
        dispatch_handler(ctp);
    }
|—————Node:while Text: while
|—————Node:parenthesized_expression Text: (1)
|——————Node:( Text: (
|——————Node:number_literal Text: 1
|——————Node:) Text: )
|—————Node:compound_statement Text: {
        if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
        /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
        dispatch_handler(ctp);
    }
|——————Node:{ Text: {
|——————Node:if_statement Text: if ((ctp = dispatch_block(ctp)) == NULL) {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: ((ctp = dispatch_block(ctp)) == NULL)
|————————Node:( Text: (
|————————Node:binary_expression Text: (ctp = dispatch_block(ctp)) == NULL
|—————————Node:parenthesized_expression Text: (ctp = dispatch_block(ctp))
|——————————Node:( Text: (
|——————————Node:assignment_expression Text: ctp = dispatch_block(ctp)
|———————————Node:identifier Text: ctp
|———————————Node:= Text: =
|———————————Node:call_expression Text: dispatch_block(ctp)
|————————————Node:identifier Text: dispatch_block
|————————————Node:argument_list Text: (ctp)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: ctp
|—————————————Node:) Text: )
|——————————Node:) Text: )
|—————————Node:== Text: ==
|—————————Node:null Text: NULL
|——————————Node:NULL Text: NULL
|————————Node:) Text: )
|———————Node:compound_statement Text: {
            if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }

            pthread_exit(NULL);
        }
|————————Node:{ Text: {
|————————Node:if_statement Text: if (!resmgr->shutdown) {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (!resmgr->shutdown)
|——————————Node:( Text: (
|——————————Node:unary_expression Text: !resmgr->shutdown
|———————————Node:! Text: !
|———————————Node:field_expression Text: resmgr->shutdown
|————————————Node:identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: shutdown
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                log_err("dispatch_block failed: %s\n", strerror(errno));
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: log_err("dispatch_block failed: %s\n", strerror(errno));
|———————————Node:call_expression Text: log_err("dispatch_block failed: %s\n", strerror(errno))
|————————————Node:identifier Text: log_err
|————————————Node:argument_list Text: ("dispatch_block failed: %s\n", strerror(errno))
|—————————————Node:( Text: (
|—————————————Node:string_literal Text: "dispatch_block failed: %s\n"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: dispatch_block failed: %s
|——————————————Node:escape_sequence Text: \n
|——————————————Node:" Text: "
|—————————————Node:, Text: ,
|—————————————Node:call_expression Text: strerror(errno)
|——————————————Node:identifier Text: strerror
|——————————————Node:argument_list Text: (errno)
|———————————————Node:( Text: (
|———————————————Node:identifier Text: errno
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:expression_statement Text: pthread_exit(NULL);
|—————————Node:call_expression Text: pthread_exit(NULL)
|——————————Node:identifier Text: pthread_exit
|——————————Node:argument_list Text: (NULL)
|———————————Node:( Text: (
|———————————Node:null Text: NULL
|————————————Node:NULL Text: NULL
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:comment Text: /* Call the correct callback function for the message
         * received. This is a single-threaded resource manager,
         * so the next request will be handled only when this
         * call returns. Consult our documentation if you want
         * to create a multi-threaded resource manager. */
|——————Node:expression_statement Text: dispatch_handler(ctp);
|———————Node:call_expression Text: dispatch_handler(ctp)
|————————Node:identifier Text: dispatch_handler
|————————Node:argument_list Text: (ctp)
|—————————Node:( Text: (
|—————————Node:identifier Text: ctp
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:return_statement Text: return NULL;
|—————Node:return Text: return
|—————Node:null Text: NULL
|——————Node:NULL Text: NULL
|—————Node:; Text: ;
|————Node:} Text: }
|——Node:#endif Text: #endif
|—Node:comment Text: /*
 *  io_open
 *
 * We are called here when the client does an open().
 * In this simple example, we just call the default routine
 * (which would be called anyway if we did not supply our own
 * callback), which creates an OCB (Open Context Block) for us.
 * In more complex resource managers, you will want to check if
 * the hardware is available, for example.
 */
|—Node:function_definition Text: int io_open (resmgr_context_t* ctp, io_open_t* msg,
        RESMGR_HANDLE_T* handle, void* extra)
{
    log_trace( "io_open -> (id: %d, rcvid: %d)\n",
            ctp->id, ctp->rcvid);

    return (iofunc_open_default (ctp, msg, handle, extra));
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_open (resmgr_context_t* ctp, io_open_t* msg,
        RESMGR_HANDLE_T* handle, void* extra)
|———Node:identifier Text: io_open
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_open_t* msg,
        RESMGR_HANDLE_T* handle, void* extra)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_open_t* msg
|—————Node:type_identifier Text: io_open_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_HANDLE_T* handle
|—————Node:type_identifier Text: RESMGR_HANDLE_T
|—————Node:pointer_declarator Text: * handle
|——————Node:* Text: *
|——————Node:identifier Text: handle
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* extra
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * extra
|——————Node:* Text: *
|——————Node:identifier Text: extra
|————Node:) Text: )
|——Node:compound_statement Text: {
    log_trace( "io_open -> (id: %d, rcvid: %d)\n",
            ctp->id, ctp->rcvid);

    return (iofunc_open_default (ctp, msg, handle, extra));
}
|———Node:{ Text: {
|———Node:expression_statement Text: log_trace( "io_open -> (id: %d, rcvid: %d)\n",
            ctp->id, ctp->rcvid);
|————Node:call_expression Text: log_trace( "io_open -> (id: %d, rcvid: %d)\n",
            ctp->id, ctp->rcvid)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ( "io_open -> (id: %d, rcvid: %d)\n",
            ctp->id, ctp->rcvid)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_open -> (id: %d, rcvid: %d)\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_open -> (id: %d, rcvid: %d)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->rcvid
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rcvid
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return (iofunc_open_default (ctp, msg, handle, extra));
|————Node:return Text: return
|————Node:parenthesized_expression Text: (iofunc_open_default (ctp, msg, handle, extra))
|—————Node:( Text: (
|—————Node:call_expression Text: iofunc_open_default (ctp, msg, handle, extra)
|——————Node:identifier Text: iofunc_open_default
|——————Node:argument_list Text: (ctp, msg, handle, extra)
|———————Node:( Text: (
|———————Node:identifier Text: ctp
|———————Node:, Text: ,
|———————Node:identifier Text: msg
|———————Node:, Text: ,
|———————Node:identifier Text: handle
|———————Node:, Text: ,
|———————Node:identifier Text: extra
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /* Why we don't have any close callback? Because the default
 * function, iofunc_close_ocb_default(), does all we need in this
 * case: Free the ocb, update the time stamps etc. See the docs
 * for more info.
 */
|—Node:function_definition Text: int io_close_ocb (resmgr_context_t* ctp, void* reserved, RESMGR_OCB_T* _ocb) {
    log_trace("io_close_ocb -> id: %d\n", ctp->id);

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    _ocb->rx.nbytes = 0;
    _ocb->rx.offset = 0;

    return iofunc_close_ocb_default(ctp, reserved, ocb);
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_close_ocb (resmgr_context_t* ctp, void* reserved, RESMGR_OCB_T* _ocb)
|———Node:identifier Text: io_close_ocb
|———Node:parameter_list Text: (resmgr_context_t* ctp, void* reserved, RESMGR_OCB_T* _ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: void* reserved
|—————Node:primitive_type Text: void
|—————Node:pointer_declarator Text: * reserved
|——————Node:* Text: *
|——————Node:identifier Text: reserved
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* _ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * _ocb
|——————Node:* Text: *
|——————Node:identifier Text: _ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    log_trace("io_close_ocb -> id: %d\n", ctp->id);

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    _ocb->rx.nbytes = 0;
    _ocb->rx.offset = 0;

    return iofunc_close_ocb_default(ctp, reserved, ocb);
}
|———Node:{ Text: {
|———Node:expression_statement Text: log_trace("io_close_ocb -> id: %d\n", ctp->id);
|————Node:call_expression Text: log_trace("io_close_ocb -> id: %d\n", ctp->id)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_close_ocb -> id: %d\n", ctp->id)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_close_ocb -> id: %d\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_close_ocb -> id: %d
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;
|————Node:type_identifier Text: iofunc_ocb_t
|————Node:init_declarator Text: * ocb = (iofunc_ocb_t*)_ocb
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (iofunc_ocb_t*)_ocb
|——————Node:( Text: (
|——————Node:type_descriptor Text: iofunc_ocb_t*
|———————Node:type_identifier Text: iofunc_ocb_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: _ocb
|————Node:; Text: ;
|———Node:expression_statement Text: _ocb->rx.nbytes = 0;
|————Node:assignment_expression Text: _ocb->rx.nbytes = 0
|—————Node:field_expression Text: _ocb->rx.nbytes
|——————Node:field_expression Text: _ocb->rx
|———————Node:identifier Text: _ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: nbytes
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: _ocb->rx.offset = 0;
|————Node:assignment_expression Text: _ocb->rx.offset = 0
|—————Node:field_expression Text: _ocb->rx.offset
|——————Node:field_expression Text: _ocb->rx
|———————Node:identifier Text: _ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: offset
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:return_statement Text: return iofunc_close_ocb_default(ctp, reserved, ocb);
|————Node:return Text: return
|————Node:call_expression Text: iofunc_close_ocb_default(ctp, reserved, ocb)
|—————Node:identifier Text: iofunc_close_ocb_default
|—————Node:argument_list Text: (ctp, reserved, ocb)
|——————Node:( Text: (
|——————Node:identifier Text: ctp
|——————Node:, Text: ,
|——————Node:identifier Text: reserved
|——————Node:, Text: ,
|——————Node:identifier Text: ocb
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 * io_read
 *
 * At this point, the client has called the library read() function, and
 * expects zero or more bytes.
 *
 * The message that we received can be accessed via the pointer *msg. A pointer
 * to the OCB that belongs to this read is the *ocb. The *ctp pointer points to
 * a context structure that is used by the resource manager framework to
 * determine whom to reply to, and more.
 */
|—Node:function_definition Text: int io_read (resmgr_context_t* ctp, io_read_t* msg, RESMGR_OCB_T* _ocb) {
    int     nparts;
    int     status;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    log_trace("io_read -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);

    /* Verify the client has the access rights needed to read from our device */
    if ((status = iofunc_read_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }

    /* Check if the read callback was called because of a pread() or a normal
     * read() call. If pread(), return with an error code indicating that it
     * isn't supported.
     */
    if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return ENOSYS;
    }

    if (_ocb->resmgr->channel_type == TX_CHANNEL) {
        return EIO; // Input/output error
    }

    if (_ocb->session->rx_queue.attr.size == 0) {
        _IO_SET_READ_NBYTES(ctp, 0);

        return (_RESMGR_NPARTS(0));
    }

    if (_ocb->rx.read_buffer == NULL
        || _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg))
    {
        if (_ocb->rx.read_buffer) {
            free(_ocb->rx.read_buffer);
        }

        _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg);
        _ocb->rx.read_buffer = malloc(_ocb->rx.read_size);

        if (_ocb->rx.read_buffer == NULL) {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
    }

    while (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        struct can_msg* canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue);

        if (canmsg == NULL) {
            break;
        }

        if (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
        {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
        else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
    }

    if (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        pthread_mutex_lock(&_ocb->rx.mutex);

        blocked_client_t *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);

        if (client == NULL) {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }

        pthread_cond_signal(&_ocb->rx.cond);
        pthread_mutex_unlock(&_ocb->rx.mutex);

        return _RESMGR_NOREPLY;
    }
    else {
        /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
        SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);

        /* Set up the number of bytes (returned by client's read()) */
        _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);

        nparts = 1;

        pthread_mutex_lock(&_ocb->rx.mutex);
        remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
        pthread_mutex_unlock(&_ocb->rx.mutex);
    }

    /* Mark the access time as invalid (we just accessed it) */
    if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_ATIME;
    }

    _ocb->rx.nbytes = 0;

    return (_RESMGR_NPARTS(nparts));
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_read (resmgr_context_t* ctp, io_read_t* msg, RESMGR_OCB_T* _ocb)
|———Node:identifier Text: io_read
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_read_t* msg, RESMGR_OCB_T* _ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_read_t* msg
|—————Node:type_identifier Text: io_read_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* _ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * _ocb
|——————Node:* Text: *
|——————Node:identifier Text: _ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    int     nparts;
    int     status;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    log_trace("io_read -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);

    /* Verify the client has the access rights needed to read from our device */
    if ((status = iofunc_read_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }

    /* Check if the read callback was called because of a pread() or a normal
     * read() call. If pread(), return with an error code indicating that it
     * isn't supported.
     */
    if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return ENOSYS;
    }

    if (_ocb->resmgr->channel_type == TX_CHANNEL) {
        return EIO; // Input/output error
    }

    if (_ocb->session->rx_queue.attr.size == 0) {
        _IO_SET_READ_NBYTES(ctp, 0);

        return (_RESMGR_NPARTS(0));
    }

    if (_ocb->rx.read_buffer == NULL
        || _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg))
    {
        if (_ocb->rx.read_buffer) {
            free(_ocb->rx.read_buffer);
        }

        _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg);
        _ocb->rx.read_buffer = malloc(_ocb->rx.read_size);

        if (_ocb->rx.read_buffer == NULL) {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
    }

    while (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        struct can_msg* canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue);

        if (canmsg == NULL) {
            break;
        }

        if (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
        {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
        else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
    }

    if (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        pthread_mutex_lock(&_ocb->rx.mutex);

        blocked_client_t *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);

        if (client == NULL) {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }

        pthread_cond_signal(&_ocb->rx.cond);
        pthread_mutex_unlock(&_ocb->rx.mutex);

        return _RESMGR_NOREPLY;
    }
    else {
        /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
        SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);

        /* Set up the number of bytes (returned by client's read()) */
        _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);

        nparts = 1;

        pthread_mutex_lock(&_ocb->rx.mutex);
        remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
        pthread_mutex_unlock(&_ocb->rx.mutex);
    }

    /* Mark the access time as invalid (we just accessed it) */
    if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_ATIME;
    }

    _ocb->rx.nbytes = 0;

    return (_RESMGR_NPARTS(nparts));
}
|———Node:{ Text: {
|———Node:declaration Text: int     nparts;
|————Node:primitive_type Text: int
|————Node:identifier Text: nparts
|————Node:; Text: ;
|———Node:declaration Text: int     status;
|————Node:primitive_type Text: int
|————Node:identifier Text: status
|————Node:; Text: ;
|———Node:declaration Text: iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;
|————Node:type_identifier Text: iofunc_ocb_t
|————Node:init_declarator Text: * ocb = (iofunc_ocb_t*)_ocb
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (iofunc_ocb_t*)_ocb
|——————Node:( Text: (
|——————Node:type_descriptor Text: iofunc_ocb_t*
|———————Node:type_identifier Text: iofunc_ocb_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: _ocb
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("io_read -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);
|————Node:call_expression Text: log_trace("io_read -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_read -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_read -> (id: %d, rcvid: %d)\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_read -> (id: %d, rcvid: %d)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->rcvid
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rcvid
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Verify the client has the access rights needed to read from our device */
|———Node:if_statement Text: if ((status = iofunc_read_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((status = iofunc_read_verify(ctp, msg, ocb, NULL)) != EOK)
|—————Node:( Text: (
|—————Node:binary_expression Text: (status = iofunc_read_verify(ctp, msg, ocb, NULL)) != EOK
|——————Node:parenthesized_expression Text: (status = iofunc_read_verify(ctp, msg, ocb, NULL))
|———————Node:( Text: (
|———————Node:assignment_expression Text: status = iofunc_read_verify(ctp, msg, ocb, NULL)
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:call_expression Text: iofunc_read_verify(ctp, msg, ocb, NULL)
|—————————Node:identifier Text: iofunc_read_verify
|—————————Node:argument_list Text: (ctp, msg, ocb, NULL)
|——————————Node:( Text: (
|——————————Node:identifier Text: ctp
|——————————Node:, Text: ,
|——————————Node:identifier Text: msg
|——————————Node:, Text: ,
|——————————Node:identifier Text: ocb
|——————————Node:, Text: ,
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: EOK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return (status);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return (status);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (status)
|———————Node:( Text: (
|———————Node:identifier Text: status
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Check if the read callback was called because of a pread() or a normal
     * read() call. If pread(), return with an error code indicating that it
     * isn't supported.
     */
|———Node:if_statement Text: if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return ENOSYS;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE)
|—————Node:( Text: (
|—————Node:binary_expression Text: (msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE
|——————Node:parenthesized_expression Text: (msg->i.xtype & _IO_XTYPE_MASK)
|———————Node:( Text: (
|———————Node:binary_expression Text: msg->i.xtype & _IO_XTYPE_MASK
|————————Node:field_expression Text: msg->i.xtype
|—————————Node:field_expression Text: msg->i
|——————————Node:identifier Text: msg
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: i
|—————————Node:. Text: .
|—————————Node:field_identifier Text: xtype
|————————Node:& Text: &
|————————Node:identifier Text: _IO_XTYPE_MASK
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: _IO_XTYPE_NONE
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return ENOSYS;
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return ENOSYS;
|——————Node:return Text: return
|——————Node:identifier Text: ENOSYS
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_ocb->resmgr->channel_type == TX_CHANNEL) {
        return EIO; // Input/output error
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == TX_CHANNEL)
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->resmgr->channel_type == TX_CHANNEL
|——————Node:field_expression Text: _ocb->resmgr->channel_type
|———————Node:field_expression Text: _ocb->resmgr
|————————Node:identifier Text: _ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: channel_type
|——————Node:== Text: ==
|——————Node:identifier Text: TX_CHANNEL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return EIO; // Input/output error
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return EIO;
|——————Node:return Text: return
|——————Node:identifier Text: EIO
|——————Node:; Text: ;
|—————Node:comment Text: // Input/output error
|—————Node:} Text: }
|———Node:if_statement Text: if (_ocb->session->rx_queue.attr.size == 0) {
        _IO_SET_READ_NBYTES(ctp, 0);

        return (_RESMGR_NPARTS(0));
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (_ocb->session->rx_queue.attr.size == 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->session->rx_queue.attr.size == 0
|——————Node:field_expression Text: _ocb->session->rx_queue.attr.size
|———————Node:field_expression Text: _ocb->session->rx_queue.attr
|————————Node:field_expression Text: _ocb->session->rx_queue
|—————————Node:field_expression Text: _ocb->session
|——————————Node:identifier Text: _ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: session
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx_queue
|————————Node:. Text: .
|————————Node:field_identifier Text: attr
|———————Node:. Text: .
|———————Node:field_identifier Text: size
|——————Node:== Text: ==
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        _IO_SET_READ_NBYTES(ctp, 0);

        return (_RESMGR_NPARTS(0));
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: _IO_SET_READ_NBYTES(ctp, 0);
|——————Node:call_expression Text: _IO_SET_READ_NBYTES(ctp, 0)
|———————Node:identifier Text: _IO_SET_READ_NBYTES
|———————Node:argument_list Text: (ctp, 0)
|————————Node:( Text: (
|————————Node:identifier Text: ctp
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return (_RESMGR_NPARTS(0));
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (_RESMGR_NPARTS(0))
|———————Node:( Text: (
|———————Node:call_expression Text: _RESMGR_NPARTS(0)
|————————Node:identifier Text: _RESMGR_NPARTS
|————————Node:argument_list Text: (0)
|—————————Node:( Text: (
|—————————Node:number_literal Text: 0
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_ocb->rx.read_buffer == NULL
        || _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg))
    {
        if (_ocb->rx.read_buffer) {
            free(_ocb->rx.read_buffer);
        }

        _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg);
        _ocb->rx.read_buffer = malloc(_ocb->rx.read_size);

        if (_ocb->rx.read_buffer == NULL) {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (_ocb->rx.read_buffer == NULL
        || _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg))
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->rx.read_buffer == NULL
        || _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg)
|——————Node:binary_expression Text: _ocb->rx.read_buffer == NULL
|———————Node:field_expression Text: _ocb->rx.read_buffer
|————————Node:field_expression Text: _ocb->rx
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_buffer
|———————Node:== Text: ==
|———————Node:null Text: NULL
|————————Node:NULL Text: NULL
|——————Node:|| Text: ||
|——————Node:binary_expression Text: _ocb->rx.read_size < _IO_READ_GET_NBYTES(msg)
|———————Node:field_expression Text: _ocb->rx.read_size
|————————Node:field_expression Text: _ocb->rx
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_size
|———————Node:< Text: <
|———————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|————————Node:identifier Text: _IO_READ_GET_NBYTES
|————————Node:argument_list Text: (msg)
|—————————Node:( Text: (
|—————————Node:identifier Text: msg
|—————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        if (_ocb->rx.read_buffer) {
            free(_ocb->rx.read_buffer);
        }

        _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg);
        _ocb->rx.read_buffer = malloc(_ocb->rx.read_size);

        if (_ocb->rx.read_buffer == NULL) {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
    }
|—————Node:{ Text: {
|—————Node:if_statement Text: if (_ocb->rx.read_buffer) {
            free(_ocb->rx.read_buffer);
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (_ocb->rx.read_buffer)
|———————Node:( Text: (
|———————Node:field_expression Text: _ocb->rx.read_buffer
|————————Node:field_expression Text: _ocb->rx
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_buffer
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            free(_ocb->rx.read_buffer);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: free(_ocb->rx.read_buffer);
|————————Node:call_expression Text: free(_ocb->rx.read_buffer)
|—————————Node:identifier Text: free
|—————————Node:argument_list Text: (_ocb->rx.read_buffer)
|——————————Node:( Text: (
|——————————Node:field_expression Text: _ocb->rx.read_buffer
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: read_buffer
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg);
|——————Node:assignment_expression Text: _ocb->rx.read_size += _IO_READ_GET_NBYTES(msg)
|———————Node:field_expression Text: _ocb->rx.read_size
|————————Node:field_expression Text: _ocb->rx
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_size
|———————Node:+= Text: +=
|———————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|————————Node:identifier Text: _IO_READ_GET_NBYTES
|————————Node:argument_list Text: (msg)
|—————————Node:( Text: (
|—————————Node:identifier Text: msg
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: _ocb->rx.read_buffer = malloc(_ocb->rx.read_size);
|——————Node:assignment_expression Text: _ocb->rx.read_buffer = malloc(_ocb->rx.read_size)
|———————Node:field_expression Text: _ocb->rx.read_buffer
|————————Node:field_expression Text: _ocb->rx
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: rx
|————————Node:. Text: .
|————————Node:field_identifier Text: read_buffer
|———————Node:= Text: =
|———————Node:call_expression Text: malloc(_ocb->rx.read_size)
|————————Node:identifier Text: malloc
|————————Node:argument_list Text: (_ocb->rx.read_size)
|—————————Node:( Text: (
|—————————Node:field_expression Text: _ocb->rx.read_size
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_size
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (_ocb->rx.read_buffer == NULL) {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (_ocb->rx.read_buffer == NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: _ocb->rx.read_buffer == NULL
|————————Node:field_expression Text: _ocb->rx.read_buffer
|—————————Node:field_expression Text: _ocb->rx
|——————————Node:identifier Text: _ocb
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rx
|—————————Node:. Text: .
|—————————Node:field_identifier Text: read_buffer
|————————Node:== Text: ==
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            _ocb->rx.read_buffer = NULL;
            _ocb->rx.read_size = 0;

            return ENOMEM; // Not enough memory
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: _ocb->rx.read_buffer = NULL;
|————————Node:assignment_expression Text: _ocb->rx.read_buffer = NULL
|—————————Node:field_expression Text: _ocb->rx.read_buffer
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_buffer
|—————————Node:= Text: =
|—————————Node:null Text: NULL
|——————————Node:NULL Text: NULL
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->rx.read_size = 0;
|————————Node:assignment_expression Text: _ocb->rx.read_size = 0
|—————————Node:field_expression Text: _ocb->rx.read_size
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_size
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:return_statement Text: return ENOMEM;
|————————Node:return Text: return
|————————Node:identifier Text: ENOMEM
|————————Node:; Text: ;
|———————Node:comment Text: // Not enough memory
|———————Node:} Text: }
|—————Node:} Text: }
|———Node:while_statement Text: while (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        struct can_msg* canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue);

        if (canmsg == NULL) {
            break;
        }

        if (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
        {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
        else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
    }
|————Node:while Text: while
|————Node:parenthesized_expression Text: (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg))
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)
|——————Node:field_expression Text: _ocb->rx.nbytes
|———————Node:field_expression Text: _ocb->rx
|————————Node:identifier Text: _ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: rx
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:< Text: <
|——————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|———————Node:identifier Text: _IO_READ_GET_NBYTES
|———————Node:argument_list Text: (msg)
|————————Node:( Text: (
|————————Node:identifier Text: msg
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        struct can_msg* canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue);

        if (canmsg == NULL) {
            break;
        }

        if (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
        {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
        else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
    }
|—————Node:{ Text: {
|—————Node:declaration Text: struct can_msg* canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue);
|——————Node:struct_specifier Text: struct can_msg
|———————Node:struct Text: struct
|———————Node:type_identifier Text: can_msg
|——————Node:init_declarator Text: * canmsg =
            dequeue_peek_noblock(&_ocb->session->rx_queue)
|———————Node:pointer_declarator Text: * canmsg
|————————Node:* Text: *
|————————Node:identifier Text: canmsg
|———————Node:= Text: =
|———————Node:call_expression Text: dequeue_peek_noblock(&_ocb->session->rx_queue)
|————————Node:identifier Text: dequeue_peek_noblock
|————————Node:argument_list Text: (&_ocb->session->rx_queue)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &_ocb->session->rx_queue
|——————————Node:& Text: &
|——————————Node:field_expression Text: _ocb->session->rx_queue
|———————————Node:field_expression Text: _ocb->session
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: session
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx_queue
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (canmsg == NULL) {
            break;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (canmsg == NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: canmsg == NULL
|————————Node:identifier Text: canmsg
|————————Node:== Text: ==
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            break;
        }
|———————Node:{ Text: {
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:if_statement Text: if (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
        {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
        else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (_ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg))
|———————Node:( Text: (
|———————Node:binary_expression Text: _ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
                <= _IO_READ_GET_NBYTES(msg)
|————————Node:binary_expression Text: _ocb->rx.nbytes + canmsg->len - _ocb->rx.offset
|—————————Node:binary_expression Text: _ocb->rx.nbytes + canmsg->len
|——————————Node:field_expression Text: _ocb->rx.nbytes
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: nbytes
|——————————Node:+ Text: +
|——————————Node:field_expression Text: canmsg->len
|———————————Node:identifier Text: canmsg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: len
|—————————Node:- Text: -
|—————————Node:field_expression Text: _ocb->rx.offset
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: offset
|————————Node:<= Text: <=
|————————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|—————————Node:identifier Text: _IO_READ_GET_NBYTES
|—————————Node:argument_list Text: (msg)
|——————————Node:( Text: (
|——————————Node:identifier Text: msg
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            size_t nbytes = canmsg->len - _ocb->rx.offset;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes += nbytes;
            _ocb->rx.offset = 0;

            dequeue_noblock(&_ocb->session->rx_queue, 0);
        }
|———————Node:{ Text: {
|———————Node:declaration Text: size_t nbytes = canmsg->len - _ocb->rx.offset;
|————————Node:primitive_type Text: size_t
|————————Node:init_declarator Text: nbytes = canmsg->len - _ocb->rx.offset
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:binary_expression Text: canmsg->len - _ocb->rx.offset
|——————————Node:field_expression Text: canmsg->len
|———————————Node:identifier Text: canmsg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: len
|——————————Node:- Text: -
|——————————Node:field_expression Text: _ocb->rx.offset
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: offset
|————————Node:; Text: ;
|———————Node:expression_statement Text: memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );
|————————Node:call_expression Text: memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes )
|—————————Node:identifier Text: memcpy
|—————————Node:argument_list Text: ( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes )
|——————————Node:( Text: (
|——————————Node:binary_expression Text: _ocb->rx.read_buffer + _ocb->rx.nbytes
|———————————Node:field_expression Text: _ocb->rx.read_buffer
|————————————Node:field_expression Text: _ocb->rx
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: read_buffer
|———————————Node:+ Text: +
|———————————Node:field_expression Text: _ocb->rx.nbytes
|————————————Node:field_expression Text: _ocb->rx
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: nbytes
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: canmsg->dat + _ocb->rx.offset
|———————————Node:field_expression Text: canmsg->dat
|————————————Node:identifier Text: canmsg
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dat
|———————————Node:+ Text: +
|———————————Node:field_expression Text: _ocb->rx.offset
|————————————Node:field_expression Text: _ocb->rx
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: offset
|——————————Node:, Text: ,
|——————————Node:identifier Text: nbytes
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->rx.nbytes += nbytes;
|————————Node:assignment_expression Text: _ocb->rx.nbytes += nbytes
|—————————Node:field_expression Text: _ocb->rx.nbytes
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:+= Text: +=
|—————————Node:identifier Text: nbytes
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->rx.offset = 0;
|————————Node:assignment_expression Text: _ocb->rx.offset = 0
|—————————Node:field_expression Text: _ocb->rx.offset
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: offset
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: dequeue_noblock(&_ocb->session->rx_queue, 0);
|————————Node:call_expression Text: dequeue_noblock(&_ocb->session->rx_queue, 0)
|—————————Node:identifier Text: dequeue_noblock
|—————————Node:argument_list Text: (&_ocb->session->rx_queue, 0)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &_ocb->session->rx_queue
|———————————Node:& Text: &
|———————————Node:field_expression Text: _ocb->session->rx_queue
|————————————Node:field_expression Text: _ocb->session
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: session
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx_queue
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
            size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;

            memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );

            _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
            _ocb->rx.offset += nbytes;
        }
|————————Node:{ Text: {
|————————Node:declaration Text: size_t nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes;
|—————————Node:primitive_type Text: size_t
|—————————Node:init_declarator Text: nbytes = _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes
|——————————Node:identifier Text: nbytes
|——————————Node:= Text: =
|——————————Node:binary_expression Text: _IO_READ_GET_NBYTES(msg) - _ocb->rx.nbytes
|———————————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|————————————Node:identifier Text: _IO_READ_GET_NBYTES
|————————————Node:argument_list Text: (msg)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: msg
|—————————————Node:) Text: )
|———————————Node:- Text: -
|———————————Node:field_expression Text: _ocb->rx.nbytes
|————————————Node:field_expression Text: _ocb->rx
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: nbytes
|—————————Node:; Text: ;
|————————Node:expression_statement Text: memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes );
|—————————Node:call_expression Text: memcpy( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes )
|——————————Node:identifier Text: memcpy
|——————————Node:argument_list Text: ( _ocb->rx.read_buffer + _ocb->rx.nbytes,
                    canmsg->dat + _ocb->rx.offset, nbytes )
|———————————Node:( Text: (
|———————————Node:binary_expression Text: _ocb->rx.read_buffer + _ocb->rx.nbytes
|————————————Node:field_expression Text: _ocb->rx.read_buffer
|—————————————Node:field_expression Text: _ocb->rx
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: rx
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: read_buffer
|————————————Node:+ Text: +
|————————————Node:field_expression Text: _ocb->rx.nbytes
|—————————————Node:field_expression Text: _ocb->rx
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: rx
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: nbytes
|———————————Node:, Text: ,
|———————————Node:binary_expression Text: canmsg->dat + _ocb->rx.offset
|————————————Node:field_expression Text: canmsg->dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dat
|————————————Node:+ Text: +
|————————————Node:field_expression Text: _ocb->rx.offset
|—————————————Node:field_expression Text: _ocb->rx
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: rx
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: offset
|———————————Node:, Text: ,
|———————————Node:identifier Text: nbytes
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg);
|—————————Node:assignment_expression Text: _ocb->rx.nbytes = _IO_READ_GET_NBYTES(msg)
|——————————Node:field_expression Text: _ocb->rx.nbytes
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: nbytes
|——————————Node:= Text: =
|——————————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|———————————Node:identifier Text: _IO_READ_GET_NBYTES
|———————————Node:argument_list Text: (msg)
|————————————Node:( Text: (
|————————————Node:identifier Text: msg
|————————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: _ocb->rx.offset += nbytes;
|—————————Node:assignment_expression Text: _ocb->rx.offset += nbytes
|——————————Node:field_expression Text: _ocb->rx.offset
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: offset
|——————————Node:+= Text: +=
|——————————Node:identifier Text: nbytes
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:} Text: }
|———Node:if_statement Text: if (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)) {
        pthread_mutex_lock(&_ocb->rx.mutex);

        blocked_client_t *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);

        if (client == NULL) {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }

        pthread_cond_signal(&_ocb->rx.cond);
        pthread_mutex_unlock(&_ocb->rx.mutex);

        return _RESMGR_NOREPLY;
    }
    else {
        /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
        SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);

        /* Set up the number of bytes (returned by client's read()) */
        _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);

        nparts = 1;

        pthread_mutex_lock(&_ocb->rx.mutex);
        remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
        pthread_mutex_unlock(&_ocb->rx.mutex);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (_ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg))
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->rx.nbytes < _IO_READ_GET_NBYTES(msg)
|——————Node:field_expression Text: _ocb->rx.nbytes
|———————Node:field_expression Text: _ocb->rx
|————————Node:identifier Text: _ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: rx
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:< Text: <
|——————Node:call_expression Text: _IO_READ_GET_NBYTES(msg)
|———————Node:identifier Text: _IO_READ_GET_NBYTES
|———————Node:argument_list Text: (msg)
|————————Node:( Text: (
|————————Node:identifier Text: msg
|————————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        pthread_mutex_lock(&_ocb->rx.mutex);

        blocked_client_t *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);

        if (client == NULL) {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }

        pthread_cond_signal(&_ocb->rx.cond);
        pthread_mutex_unlock(&_ocb->rx.mutex);

        return _RESMGR_NOREPLY;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_lock
|———————Node:argument_list Text: (&_ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: _ocb->rx.mutex
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: blocked_client_t *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
|——————Node:type_identifier Text: blocked_client_t
|——————Node:init_declarator Text: *client =
            get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid)
|———————Node:pointer_declarator Text: *client
|————————Node:* Text: *
|————————Node:identifier Text: client
|———————Node:= Text: =
|———————Node:call_expression Text: get_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid)
|————————Node:identifier Text: get_blocked_client
|————————Node:argument_list Text: (&_ocb->rx.blocked_clients, ctp->rcvid)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|——————————Node:& Text: &
|——————————Node:field_expression Text: _ocb->rx.blocked_clients
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: blocked_clients
|—————————Node:, Text: ,
|—————————Node:field_expression Text: ctp->rcvid
|——————————Node:identifier Text: ctp
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rcvid
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:if_statement Text: if (client == NULL) {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (client == NULL)
|———————Node:( Text: (
|———————Node:binary_expression Text: client == NULL
|————————Node:identifier Text: client
|————————Node:== Text: ==
|————————Node:null Text: NULL
|—————————Node:NULL Text: NULL
|———————Node:) Text: )
|——————Node:compound_statement Text: {
            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);
        }
|———————Node:{ Text: {
|———————Node:declaration Text: blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
|————————Node:type_identifier Text: blocked_client_t
|————————Node:init_declarator Text: * new_block = malloc(sizeof(blocked_client_t))
|—————————Node:pointer_declarator Text: * new_block
|——————————Node:* Text: *
|——————————Node:identifier Text: new_block
|—————————Node:= Text: =
|—————————Node:call_expression Text: malloc(sizeof(blocked_client_t))
|——————————Node:identifier Text: malloc
|——————————Node:argument_list Text: (sizeof(blocked_client_t))
|———————————Node:( Text: (
|———————————Node:sizeof_expression Text: sizeof(blocked_client_t)
|————————————Node:sizeof Text: sizeof
|————————————Node:parenthesized_expression Text: (blocked_client_t)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: blocked_client_t
|—————————————Node:) Text: )
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: new_block->prev = new_block->next = NULL;
|————————Node:assignment_expression Text: new_block->prev = new_block->next = NULL
|—————————Node:field_expression Text: new_block->prev
|——————————Node:identifier Text: new_block
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prev
|—————————Node:= Text: =
|—————————Node:assignment_expression Text: new_block->next = NULL
|——————————Node:field_expression Text: new_block->next
|———————————Node:identifier Text: new_block
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: next
|——————————Node:= Text: =
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|————————Node:; Text: ;
|———————Node:expression_statement Text: new_block->rcvid = ctp->rcvid;
|————————Node:assignment_expression Text: new_block->rcvid = ctp->rcvid
|—————————Node:field_expression Text: new_block->rcvid
|——————————Node:identifier Text: new_block
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rcvid
|—————————Node:= Text: =
|—————————Node:field_expression Text: ctp->rcvid
|——————————Node:identifier Text: ctp
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rcvid
|————————Node:; Text: ;
|———————Node:expression_statement Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block);
|————————Node:call_expression Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block)
|—————————Node:identifier Text: store_blocked_client
|—————————Node:argument_list Text: (&_ocb->rx.blocked_clients, new_block)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|———————————Node:& Text: &
|———————————Node:field_expression Text: _ocb->rx.blocked_clients
|————————————Node:field_expression Text: _ocb->rx
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx
|————————————Node:. Text: .
|————————————Node:field_identifier Text: blocked_clients
|——————————Node:, Text: ,
|——————————Node:identifier Text: new_block
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:expression_statement Text: pthread_cond_signal(&_ocb->rx.cond);
|——————Node:call_expression Text: pthread_cond_signal(&_ocb->rx.cond)
|———————Node:identifier Text: pthread_cond_signal
|———————Node:argument_list Text: (&_ocb->rx.cond)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &_ocb->rx.cond
|—————————Node:& Text: &
|—————————Node:field_expression Text: _ocb->rx.cond
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: cond
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|——————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|———————Node:identifier Text: pthread_mutex_unlock
|———————Node:argument_list Text: (&_ocb->rx.mutex)
|————————Node:( Text: (
|————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————Node:& Text: &
|—————————Node:field_expression Text: _ocb->rx.mutex
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mutex
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return _RESMGR_NOREPLY;
|——————Node:return Text: return
|——————Node:identifier Text: _RESMGR_NOREPLY
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else {
        /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
        SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);

        /* Set up the number of bytes (returned by client's read()) */
        _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);

        nparts = 1;

        pthread_mutex_lock(&_ocb->rx.mutex);
        remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
        pthread_mutex_unlock(&_ocb->rx.mutex);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
        SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);

        /* Set up the number of bytes (returned by client's read()) */
        _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);

        nparts = 1;

        pthread_mutex_lock(&_ocb->rx.mutex);
        remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
        pthread_mutex_unlock(&_ocb->rx.mutex);
    }
|——————Node:{ Text: {
|——————Node:comment Text: /* Set up the return data IOV.
         * This is used to tell the system how large the buffer is in which we
         * want to return the data for the read() call.
         */
|——————Node:expression_statement Text: SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes);
|———————Node:call_expression Text: SETIOV(ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes)
|————————Node:identifier Text: SETIOV
|————————Node:argument_list Text: (ctp->iov, _ocb->rx.read_buffer, _ocb->rx.nbytes)
|—————————Node:( Text: (
|—————————Node:field_expression Text: ctp->iov
|——————————Node:identifier Text: ctp
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: iov
|—————————Node:, Text: ,
|—————————Node:field_expression Text: _ocb->rx.read_buffer
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: read_buffer
|—————————Node:, Text: ,
|—————————Node:field_expression Text: _ocb->rx.nbytes
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:comment Text: /* Set up the number of bytes (returned by client's read()) */
|——————Node:expression_statement Text: _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes);
|———————Node:call_expression Text: _IO_SET_READ_NBYTES(ctp, _ocb->rx.nbytes)
|————————Node:identifier Text: _IO_SET_READ_NBYTES
|————————Node:argument_list Text: (ctp, _ocb->rx.nbytes)
|—————————Node:( Text: (
|—————————Node:identifier Text: ctp
|—————————Node:, Text: ,
|—————————Node:field_expression Text: _ocb->rx.nbytes
|——————————Node:field_expression Text: _ocb->rx
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: rx
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: nparts = 1;
|———————Node:assignment_expression Text: nparts = 1
|————————Node:identifier Text: nparts
|————————Node:= Text: =
|————————Node:number_literal Text: 1
|———————Node:; Text: ;
|——————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|———————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|————————Node:identifier Text: pthread_mutex_lock
|————————Node:argument_list Text: (&_ocb->rx.mutex)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &_ocb->rx.mutex
|——————————Node:& Text: &
|——————————Node:field_expression Text: _ocb->rx.mutex
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mutex
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
|———————Node:call_expression Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid)
|————————Node:identifier Text: remove_blocked_client
|————————Node:argument_list Text: (&_ocb->rx.blocked_clients, ctp->rcvid)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|——————————Node:& Text: &
|——————————Node:field_expression Text: _ocb->rx.blocked_clients
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: blocked_clients
|—————————Node:, Text: ,
|—————————Node:field_expression Text: ctp->rcvid
|——————————Node:identifier Text: ctp
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: rcvid
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|———————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|————————Node:identifier Text: pthread_mutex_unlock
|————————Node:argument_list Text: (&_ocb->rx.mutex)
|—————————Node:( Text: (
|—————————Node:pointer_expression Text: &_ocb->rx.mutex
|——————————Node:& Text: &
|——————————Node:field_expression Text: _ocb->rx.mutex
|———————————Node:field_expression Text: _ocb->rx
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: rx
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mutex
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:comment Text: /* Mark the access time as invalid (we just accessed it) */
|———Node:if_statement Text: if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_ATIME;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (msg->i.nbytes > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: msg->i.nbytes > 0
|——————Node:field_expression Text: msg->i.nbytes
|———————Node:field_expression Text: msg->i
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: i
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        ocb->attr->flags |= IOFUNC_ATTR_ATIME;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ocb->attr->flags |= IOFUNC_ATTR_ATIME;
|——————Node:assignment_expression Text: ocb->attr->flags |= IOFUNC_ATTR_ATIME
|———————Node:field_expression Text: ocb->attr->flags
|————————Node:field_expression Text: ocb->attr
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: attr
|————————Node:-> Text: ->
|————————Node:field_identifier Text: flags
|———————Node:|= Text: |=
|———————Node:identifier Text: IOFUNC_ATTR_ATIME
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: _ocb->rx.nbytes = 0;
|————Node:assignment_expression Text: _ocb->rx.nbytes = 0
|—————Node:field_expression Text: _ocb->rx.nbytes
|——————Node:field_expression Text: _ocb->rx
|———————Node:identifier Text: _ocb
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rx
|——————Node:. Text: .
|——————Node:field_identifier Text: nbytes
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:return_statement Text: return (_RESMGR_NPARTS(nparts));
|————Node:return Text: return
|————Node:parenthesized_expression Text: (_RESMGR_NPARTS(nparts))
|—————Node:( Text: (
|—————Node:call_expression Text: _RESMGR_NPARTS(nparts)
|——————Node:identifier Text: _RESMGR_NPARTS
|——————Node:argument_list Text: (nparts)
|———————Node:( Text: (
|———————Node:identifier Text: nparts
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment Text: /*
 *  io_write
 *
 *  At this point, the client has called the library write()
 *  function, and expects that our resource manager will write
 *  the number of bytes that have been specified to the device.
 */
|—Node:function_definition Text: int io_write (resmgr_context_t* ctp, io_write_t* msg, RESMGR_OCB_T* _ocb) {
    int status;
    char *buf;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    log_trace("io_write -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);

    /* Check the access permissions of the client */
    if ((status = iofunc_write_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }

    /* Check if pwrite() or normal write() */
    if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return (ENOSYS);
    }

    if (_ocb->resmgr->channel_type == RX_CHANNEL) {
        return EIO; // Input/output error
    }

    /* Set the number of bytes successfully written for the client. This
     * information will be passed to the client by the resource manager
     * framework upon reply.
     */
    _IO_SET_WRITE_NBYTES (ctp, msg -> i.nbytes);
    log_trace("io_write: got write of %d bytes, data:\n", msg->i.nbytes);

    struct can_msg canmsg = {
        .mid = _ocb->resmgr->mid,
        .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
    };

    /* First check if our message buffer was large enough to receive the whole
     * write at once. If yes, print data.
     */
    if ((msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)) &&
            (ctp->info.msglen < ctp->msg_max_size))
    {
        buf = (char *)(msg+1);

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
    }
    else {
        /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
        buf = malloc(msg->i.nbytes + 1);
        resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }

        free(buf);
    }

    /* Finally, if we received more than 0 bytes, we mark the file information
     * for the device to be updated: modification time and change of file status
     * time. To avoid constant update of the real file status information (which
     * would involve overhead getting the current time), we just set these
     * flags. The actual update is done upon closing, which is valid according
     * to POSIX. */
    if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
    }

    return (_RESMGR_NPARTS (0));
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_write (resmgr_context_t* ctp, io_write_t* msg, RESMGR_OCB_T* _ocb)
|———Node:identifier Text: io_write
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_write_t* msg, RESMGR_OCB_T* _ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_write_t* msg
|—————Node:type_identifier Text: io_write_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* _ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * _ocb
|——————Node:* Text: *
|——————Node:identifier Text: _ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    int status;
    char *buf;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    log_trace("io_write -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);

    /* Check the access permissions of the client */
    if ((status = iofunc_write_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }

    /* Check if pwrite() or normal write() */
    if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return (ENOSYS);
    }

    if (_ocb->resmgr->channel_type == RX_CHANNEL) {
        return EIO; // Input/output error
    }

    /* Set the number of bytes successfully written for the client. This
     * information will be passed to the client by the resource manager
     * framework upon reply.
     */
    _IO_SET_WRITE_NBYTES (ctp, msg -> i.nbytes);
    log_trace("io_write: got write of %d bytes, data:\n", msg->i.nbytes);

    struct can_msg canmsg = {
        .mid = _ocb->resmgr->mid,
        .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
    };

    /* First check if our message buffer was large enough to receive the whole
     * write at once. If yes, print data.
     */
    if ((msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)) &&
            (ctp->info.msglen < ctp->msg_max_size))
    {
        buf = (char *)(msg+1);

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
    }
    else {
        /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
        buf = malloc(msg->i.nbytes + 1);
        resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }

        free(buf);
    }

    /* Finally, if we received more than 0 bytes, we mark the file information
     * for the device to be updated: modification time and change of file status
     * time. To avoid constant update of the real file status information (which
     * would involve overhead getting the current time), we just set these
     * flags. The actual update is done upon closing, which is valid according
     * to POSIX. */
    if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
    }

    return (_RESMGR_NPARTS (0));
}
|———Node:{ Text: {
|———Node:declaration Text: int status;
|————Node:primitive_type Text: int
|————Node:identifier Text: status
|————Node:; Text: ;
|———Node:declaration Text: char *buf;
|————Node:primitive_type Text: char
|————Node:pointer_declarator Text: *buf
|—————Node:* Text: *
|—————Node:identifier Text: buf
|————Node:; Text: ;
|———Node:declaration Text: iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;
|————Node:type_identifier Text: iofunc_ocb_t
|————Node:init_declarator Text: * ocb = (iofunc_ocb_t*)_ocb
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (iofunc_ocb_t*)_ocb
|——————Node:( Text: (
|——————Node:type_descriptor Text: iofunc_ocb_t*
|———————Node:type_identifier Text: iofunc_ocb_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: _ocb
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("io_write -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid);
|————Node:call_expression Text: log_trace("io_write -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_write -> (id: %d, rcvid: %d)\n", ctp->id, ctp->rcvid)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_write -> (id: %d, rcvid: %d)\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_write -> (id: %d, rcvid: %d)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->rcvid
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: rcvid
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Check the access permissions of the client */
|———Node:if_statement Text: if ((status = iofunc_write_verify(ctp, msg, ocb, NULL)) != EOK) {
        return (status);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((status = iofunc_write_verify(ctp, msg, ocb, NULL)) != EOK)
|—————Node:( Text: (
|—————Node:binary_expression Text: (status = iofunc_write_verify(ctp, msg, ocb, NULL)) != EOK
|——————Node:parenthesized_expression Text: (status = iofunc_write_verify(ctp, msg, ocb, NULL))
|———————Node:( Text: (
|———————Node:assignment_expression Text: status = iofunc_write_verify(ctp, msg, ocb, NULL)
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:call_expression Text: iofunc_write_verify(ctp, msg, ocb, NULL)
|—————————Node:identifier Text: iofunc_write_verify
|—————————Node:argument_list Text: (ctp, msg, ocb, NULL)
|——————————Node:( Text: (
|——————————Node:identifier Text: ctp
|——————————Node:, Text: ,
|——————————Node:identifier Text: msg
|——————————Node:, Text: ,
|——————————Node:identifier Text: ocb
|——————————Node:, Text: ,
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: EOK
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return (status);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return (status);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (status)
|———————Node:( Text: (
|———————Node:identifier Text: status
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Check if pwrite() or normal write() */
|———Node:if_statement Text: if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE) {
        return (ENOSYS);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE)
|—————Node:( Text: (
|—————Node:binary_expression Text: (msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE
|——————Node:parenthesized_expression Text: (msg->i.xtype & _IO_XTYPE_MASK)
|———————Node:( Text: (
|———————Node:binary_expression Text: msg->i.xtype & _IO_XTYPE_MASK
|————————Node:field_expression Text: msg->i.xtype
|—————————Node:field_expression Text: msg->i
|——————————Node:identifier Text: msg
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: i
|—————————Node:. Text: .
|—————————Node:field_identifier Text: xtype
|————————Node:& Text: &
|————————Node:identifier Text: _IO_XTYPE_MASK
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: _IO_XTYPE_NONE
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return (ENOSYS);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return (ENOSYS);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (ENOSYS)
|———————Node:( Text: (
|———————Node:identifier Text: ENOSYS
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:if_statement Text: if (_ocb->resmgr->channel_type == RX_CHANNEL) {
        return EIO; // Input/output error
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == RX_CHANNEL)
|—————Node:( Text: (
|—————Node:binary_expression Text: _ocb->resmgr->channel_type == RX_CHANNEL
|——————Node:field_expression Text: _ocb->resmgr->channel_type
|———————Node:field_expression Text: _ocb->resmgr
|————————Node:identifier Text: _ocb
|————————Node:-> Text: ->
|————————Node:field_identifier Text: resmgr
|———————Node:-> Text: ->
|———————Node:field_identifier Text: channel_type
|——————Node:== Text: ==
|——————Node:identifier Text: RX_CHANNEL
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return EIO; // Input/output error
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return EIO;
|——————Node:return Text: return
|——————Node:identifier Text: EIO
|——————Node:; Text: ;
|—————Node:comment Text: // Input/output error
|—————Node:} Text: }
|———Node:comment Text: /* Set the number of bytes successfully written for the client. This
     * information will be passed to the client by the resource manager
     * framework upon reply.
     */
|———Node:expression_statement Text: _IO_SET_WRITE_NBYTES (ctp, msg -> i.nbytes);
|————Node:call_expression Text: _IO_SET_WRITE_NBYTES (ctp, msg -> i.nbytes)
|—————Node:identifier Text: _IO_SET_WRITE_NBYTES
|—————Node:argument_list Text: (ctp, msg -> i.nbytes)
|——————Node:( Text: (
|——————Node:identifier Text: ctp
|——————Node:, Text: ,
|——————Node:field_expression Text: msg -> i.nbytes
|———————Node:field_expression Text: msg -> i
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: i
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("io_write: got write of %d bytes, data:\n", msg->i.nbytes);
|————Node:call_expression Text: log_trace("io_write: got write of %d bytes, data:\n", msg->i.nbytes)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_write: got write of %d bytes, data:\n", msg->i.nbytes)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_write: got write of %d bytes, data:\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_write: got write of %d bytes, data:
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: msg->i.nbytes
|———————Node:field_expression Text: msg->i
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: i
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: struct can_msg canmsg = {
        .mid = _ocb->resmgr->mid,
        .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
    };
|————Node:struct_specifier Text: struct can_msg
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_msg
|————Node:init_declarator Text: canmsg = {
        .mid = _ocb->resmgr->mid,
        .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
    }
|—————Node:identifier Text: canmsg
|—————Node:= Text: =
|—————Node:initializer_list Text: {
        .mid = _ocb->resmgr->mid,
        .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
    }
|——————Node:{ Text: {
|——————Node:initializer_pair Text: .mid = _ocb->resmgr->mid
|———————Node:field_designator Text: .mid
|————————Node:. Text: .
|————————Node:field_identifier Text: mid
|———————Node:= Text: =
|———————Node:field_expression Text: _ocb->resmgr->mid
|————————Node:field_expression Text: _ocb->resmgr
|—————————Node:identifier Text: _ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: resmgr
|————————Node:-> Text: ->
|————————Node:field_identifier Text: mid
|——————Node:, Text: ,
|——————Node:initializer_pair Text: .ext = { .is_extended_mid = _ocb->resmgr->is_extended_mid }
|———————Node:field_designator Text: .ext
|————————Node:. Text: .
|————————Node:field_identifier Text: ext
|———————Node:= Text: =
|———————Node:initializer_list Text: { .is_extended_mid = _ocb->resmgr->is_extended_mid }
|————————Node:{ Text: {
|————————Node:initializer_pair Text: .is_extended_mid = _ocb->resmgr->is_extended_mid
|—————————Node:field_designator Text: .is_extended_mid
|——————————Node:. Text: .
|——————————Node:field_identifier Text: is_extended_mid
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->is_extended_mid
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: is_extended_mid
|————————Node:} Text: }
|——————Node:} Text: }
|————Node:; Text: ;
|———Node:comment Text: /* First check if our message buffer was large enough to receive the whole
     * write at once. If yes, print data.
     */
|———Node:if_statement Text: if ((msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)) &&
            (ctp->info.msglen < ctp->msg_max_size))
    {
        buf = (char *)(msg+1);

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
    }
    else {
        /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
        buf = malloc(msg->i.nbytes + 1);
        resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }

        free(buf);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)) &&
            (ctp->info.msglen < ctp->msg_max_size))
|—————Node:( Text: (
|—————Node:binary_expression Text: (msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)) &&
            (ctp->info.msglen < ctp->msg_max_size)
|——————Node:parenthesized_expression Text: (msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i))
|———————Node:( Text: (
|———————Node:binary_expression Text: msg->i.nbytes <= ctp->info.msglen - ctp->offset - sizeof(msg->i)
|————————Node:field_expression Text: msg->i.nbytes
|—————————Node:field_expression Text: msg->i
|——————————Node:identifier Text: msg
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: i
|—————————Node:. Text: .
|—————————Node:field_identifier Text: nbytes
|————————Node:<= Text: <=
|————————Node:binary_expression Text: ctp->info.msglen - ctp->offset - sizeof(msg->i)
|—————————Node:binary_expression Text: ctp->info.msglen - ctp->offset
|——————————Node:field_expression Text: ctp->info.msglen
|———————————Node:field_expression Text: ctp->info
|————————————Node:identifier Text: ctp
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: info
|———————————Node:. Text: .
|———————————Node:field_identifier Text: msglen
|——————————Node:- Text: -
|——————————Node:field_expression Text: ctp->offset
|———————————Node:identifier Text: ctp
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: offset
|—————————Node:- Text: -
|—————————Node:sizeof_expression Text: sizeof(msg->i)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (msg->i)
|———————————Node:( Text: (
|———————————Node:field_expression Text: msg->i
|————————————Node:identifier Text: msg
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: i
|———————————Node:) Text: )
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:parenthesized_expression Text: (ctp->info.msglen < ctp->msg_max_size)
|———————Node:( Text: (
|———————Node:binary_expression Text: ctp->info.msglen < ctp->msg_max_size
|————————Node:field_expression Text: ctp->info.msglen
|—————————Node:field_expression Text: ctp->info
|——————————Node:identifier Text: ctp
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: info
|—————————Node:. Text: .
|—————————Node:field_identifier Text: msglen
|————————Node:< Text: <
|————————Node:field_expression Text: ctp->msg_max_size
|—————————Node:identifier Text: ctp
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: msg_max_size
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:compound_statement Text: {
        buf = (char *)(msg+1);

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: buf = (char *)(msg+1);
|——————Node:assignment_expression Text: buf = (char *)(msg+1)
|———————Node:identifier Text: buf
|———————Node:= Text: =
|———————Node:cast_expression Text: (char *)(msg+1)
|————————Node:( Text: (
|————————Node:type_descriptor Text: char *
|—————————Node:primitive_type Text: char
|—————————Node:abstract_pointer_declarator Text: *
|——————————Node:* Text: *
|————————Node:) Text: )
|————————Node:parenthesized_expression Text: (msg+1)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: msg+1
|——————————Node:identifier Text: msg
|——————————Node:+ Text: +
|——————————Node:number_literal Text: 1
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: buf[msg->i.nbytes] = '\0';
|——————Node:assignment_expression Text: buf[msg->i.nbytes] = '\0'
|———————Node:subscript_expression Text: buf[msg->i.nbytes]
|————————Node:identifier Text: buf
|————————Node:[ Text: [
|————————Node:field_expression Text: msg->i.nbytes
|—————————Node:field_expression Text: msg->i
|——————————Node:identifier Text: msg
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: i
|—————————Node:. Text: .
|—————————Node:field_identifier Text: nbytes
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:char_literal Text: '\0'
|————————Node:' Text: '
|————————Node:escape_sequence Text: \0
|————————Node:' Text: '
|——————Node:; Text: ;
|—————Node:expression_statement Text: log_trace("io_write: buf: %s\n", buf);
|——————Node:call_expression Text: log_trace("io_write: buf: %s\n", buf)
|———————Node:identifier Text: log_trace
|———————Node:argument_list Text: ("io_write: buf: %s\n", buf)
|————————Node:( Text: (
|————————Node:string_literal Text: "io_write: buf: %s\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: io_write: buf: %s
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: buf
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);
|——————Node:primitive_type Text: int
|——————Node:init_declarator Text: n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0)
|———————Node:identifier Text: n
|———————Node:= Text: =
|———————Node:binary_expression Text: msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0)
|————————Node:binary_expression Text: msg->i.nbytes/8
|—————————Node:field_expression Text: msg->i.nbytes
|——————————Node:field_expression Text: msg->i
|———————————Node:identifier Text: msg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: i
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:/ Text: /
|—————————Node:number_literal Text: 8
|————————Node:+ Text: +
|————————Node:parenthesized_expression Text: (msg->i.nbytes%8 ? 1 : 0)
|—————————Node:( Text: (
|—————————Node:conditional_expression Text: msg->i.nbytes%8 ? 1 : 0
|——————————Node:binary_expression Text: msg->i.nbytes%8
|———————————Node:field_expression Text: msg->i.nbytes
|————————————Node:field_expression Text: msg->i
|—————————————Node:identifier Text: msg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: i
|————————————Node:. Text: .
|————————————Node:field_identifier Text: nbytes
|———————————Node:% Text: %
|———————————Node:number_literal Text: 8
|——————————Node:? Text: ?
|——————————Node:number_literal Text: 1
|——————————Node:: Text: :
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:declaration Text: int i;
|——————Node:primitive_type Text: int
|——————Node:identifier Text: i
|——————Node:; Text: ;
|—————Node:for_statement Text: for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
|——————Node:for Text: for
|——————Node:( Text: (
|——————Node:assignment_expression Text: i = 0
|———————Node:identifier Text: i
|———————Node:= Text: =
|———————Node:number_literal Text: 0
|——————Node:; Text: ;
|——————Node:binary_expression Text: i < n
|———————Node:identifier Text: i
|———————Node:< Text: <
|———————Node:identifier Text: n
|——————Node:; Text: ;
|——————Node:update_expression Text: ++i
|———————Node:++ Text: ++
|———————Node:identifier Text: i
|——————Node:) Text: )
|——————Node:compound_statement Text: {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
|———————Node:{ Text: {
|———————Node:expression_statement Text: canmsg.len = msg->i.nbytes - 8*i;
|————————Node:assignment_expression Text: canmsg.len = msg->i.nbytes - 8*i
|—————————Node:field_expression Text: canmsg.len
|——————————Node:identifier Text: canmsg
|——————————Node:. Text: .
|——————————Node:field_identifier Text: len
|—————————Node:= Text: =
|—————————Node:binary_expression Text: msg->i.nbytes - 8*i
|——————————Node:field_expression Text: msg->i.nbytes
|———————————Node:field_expression Text: msg->i
|————————————Node:identifier Text: msg
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: i
|———————————Node:. Text: .
|———————————Node:field_identifier Text: nbytes
|——————————Node:- Text: -
|——————————Node:binary_expression Text: 8*i
|———————————Node:number_literal Text: 8
|———————————Node:* Text: *
|———————————Node:identifier Text: i
|————————Node:; Text: ;
|———————Node:if_statement Text: if (canmsg.len > 8) {
                canmsg.len = 8;
            }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (canmsg.len > 8)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canmsg.len > 8
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:> Text: >
|——————————Node:number_literal Text: 8
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
                canmsg.len = 8;
            }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: canmsg.len = 8;
|——————————Node:assignment_expression Text: canmsg.len = 8
|———————————Node:field_expression Text: canmsg.len
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: len
|———————————Node:= Text: =
|———————————Node:number_literal Text: 8
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: memcpy(canmsg.dat, buf+8*i, canmsg.len);
|————————Node:call_expression Text: memcpy(canmsg.dat, buf+8*i, canmsg.len)
|—————————Node:identifier Text: memcpy
|—————————Node:argument_list Text: (canmsg.dat, buf+8*i, canmsg.len)
|——————————Node:( Text: (
|——————————Node:field_expression Text: canmsg.dat
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: dat
|——————————Node:, Text: ,
|——————————Node:binary_expression Text: buf+8*i
|———————————Node:identifier Text: buf
|———————————Node:+ Text: +
|———————————Node:binary_expression Text: 8*i
|————————————Node:number_literal Text: 8
|————————————Node:* Text: *
|————————————Node:identifier Text: i
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);
|————————Node:call_expression Text: log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7])
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7])
|——————————Node:( Text: (
|——————————Node:concatenated_string Text: "io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|———————————Node:string_literal Text: "io_write; %s TS: %ums [%s] %X [%d] "
|————————————Node:" Text: "
|————————————Node:string_content Text: io_write; %s TS: %ums [%s] %X [%d] 
|————————————Node:" Text: "
|———————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->name
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.ext.timestamp
|———————————Node:field_expression Text: canmsg.ext
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: ext
|———————————Node:. Text: .
|———————————Node:field_identifier Text: timestamp
|——————————Node:, Text: ,
|——————————Node:conditional_expression Text: canmsg.ext.is_extended_mid ? "EFF" : "SFF"
|———————————Node:field_expression Text: canmsg.ext.is_extended_mid
|————————————Node:field_expression Text: canmsg.ext
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: ext
|————————————Node:. Text: .
|————————————Node:field_identifier Text: is_extended_mid
|———————————Node:? Text: ?
|———————————Node:string_literal Text: "EFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: EFF
|————————————Node:" Text: "
|———————————Node:: Text: :
|———————————Node:string_literal Text: "SFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: SFF
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.mid
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mid
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[0]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 0
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[1]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[2]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 2
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[3]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 3
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[4]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 4
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[5]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 5
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[6]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 6
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[7]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 7
|———————————Node:] Text: ]
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
|————————Node:call_expression Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg)
|—————————Node:identifier Text: enqueue
|—————————Node:argument_list Text: (&_ocb->resmgr->device_session->tx_queue, &canmsg)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &_ocb->resmgr->device_session->tx_queue
|———————————Node:& Text: &
|———————————Node:field_expression Text: _ocb->resmgr->device_session->tx_queue
|————————————Node:field_expression Text: _ocb->resmgr->device_session
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: device_session
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: tx_queue
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &canmsg
|———————————Node:& Text: &
|———————————Node:identifier Text: canmsg
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:} Text: }
|————Node:else_clause Text: else {
        /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
        buf = malloc(msg->i.nbytes + 1);
        resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }

        free(buf);
    }
|—————Node:else Text: else
|—————Node:compound_statement Text: {
        /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
        buf = malloc(msg->i.nbytes + 1);
        resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));

        buf[msg->i.nbytes] = '\0';
        log_trace("io_write: buf: %s\n", buf);

        int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);

        int i;
        for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }

        free(buf);
    }
|——————Node:{ Text: {
|——————Node:comment Text: /* If we did not receive the whole message because the client wanted to
         * send more than we could receive, we allocate memory for all the data
         * and use resmgr_msgread() to read all the data at once. Although we
         * did not receive the data completely first, because our buffer was not
         * big enough, the data is still fully available on the client side,
         * because its write() call blocks until we return from this callback.
         */
|——————Node:expression_statement Text: buf = malloc(msg->i.nbytes + 1);
|———————Node:assignment_expression Text: buf = malloc(msg->i.nbytes + 1)
|————————Node:identifier Text: buf
|————————Node:= Text: =
|————————Node:call_expression Text: malloc(msg->i.nbytes + 1)
|—————————Node:identifier Text: malloc
|—————————Node:argument_list Text: (msg->i.nbytes + 1)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: msg->i.nbytes + 1
|———————————Node:field_expression Text: msg->i.nbytes
|————————————Node:field_expression Text: msg->i
|—————————————Node:identifier Text: msg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: i
|————————————Node:. Text: .
|————————————Node:field_identifier Text: nbytes
|———————————Node:+ Text: +
|———————————Node:number_literal Text: 1
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i));
|———————Node:call_expression Text: resmgr_msgread(ctp, buf, msg->i.nbytes, sizeof(msg->i))
|————————Node:identifier Text: resmgr_msgread
|————————Node:argument_list Text: (ctp, buf, msg->i.nbytes, sizeof(msg->i))
|—————————Node:( Text: (
|—————————Node:identifier Text: ctp
|—————————Node:, Text: ,
|—————————Node:identifier Text: buf
|—————————Node:, Text: ,
|—————————Node:field_expression Text: msg->i.nbytes
|——————————Node:field_expression Text: msg->i
|———————————Node:identifier Text: msg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: i
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:, Text: ,
|—————————Node:sizeof_expression Text: sizeof(msg->i)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (msg->i)
|———————————Node:( Text: (
|———————————Node:field_expression Text: msg->i
|————————————Node:identifier Text: msg
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: i
|———————————Node:) Text: )
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:expression_statement Text: buf[msg->i.nbytes] = '\0';
|———————Node:assignment_expression Text: buf[msg->i.nbytes] = '\0'
|————————Node:subscript_expression Text: buf[msg->i.nbytes]
|—————————Node:identifier Text: buf
|—————————Node:[ Text: [
|—————————Node:field_expression Text: msg->i.nbytes
|——————————Node:field_expression Text: msg->i
|———————————Node:identifier Text: msg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: i
|——————————Node:. Text: .
|——————————Node:field_identifier Text: nbytes
|—————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:char_literal Text: '\0'
|—————————Node:' Text: '
|—————————Node:escape_sequence Text: \0
|—————————Node:' Text: '
|———————Node:; Text: ;
|——————Node:expression_statement Text: log_trace("io_write: buf: %s\n", buf);
|———————Node:call_expression Text: log_trace("io_write: buf: %s\n", buf)
|————————Node:identifier Text: log_trace
|————————Node:argument_list Text: ("io_write: buf: %s\n", buf)
|—————————Node:( Text: (
|—————————Node:string_literal Text: "io_write: buf: %s\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: io_write: buf: %s
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:identifier Text: buf
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:declaration Text: int n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0);
|———————Node:primitive_type Text: int
|———————Node:init_declarator Text: n = msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0)
|————————Node:identifier Text: n
|————————Node:= Text: =
|————————Node:binary_expression Text: msg->i.nbytes/8 + (msg->i.nbytes%8 ? 1 : 0)
|—————————Node:binary_expression Text: msg->i.nbytes/8
|——————————Node:field_expression Text: msg->i.nbytes
|———————————Node:field_expression Text: msg->i
|————————————Node:identifier Text: msg
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: i
|———————————Node:. Text: .
|———————————Node:field_identifier Text: nbytes
|——————————Node:/ Text: /
|——————————Node:number_literal Text: 8
|—————————Node:+ Text: +
|—————————Node:parenthesized_expression Text: (msg->i.nbytes%8 ? 1 : 0)
|——————————Node:( Text: (
|——————————Node:conditional_expression Text: msg->i.nbytes%8 ? 1 : 0
|———————————Node:binary_expression Text: msg->i.nbytes%8
|————————————Node:field_expression Text: msg->i.nbytes
|—————————————Node:field_expression Text: msg->i
|——————————————Node:identifier Text: msg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: i
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: nbytes
|————————————Node:% Text: %
|————————————Node:number_literal Text: 8
|———————————Node:? Text: ?
|———————————Node:number_literal Text: 1
|———————————Node:: Text: :
|———————————Node:number_literal Text: 0
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:declaration Text: int i;
|———————Node:primitive_type Text: int
|———————Node:identifier Text: i
|———————Node:; Text: ;
|——————Node:for_statement Text: for (i = 0; i < n; ++i) {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
|———————Node:for Text: for
|———————Node:( Text: (
|———————Node:assignment_expression Text: i = 0
|————————Node:identifier Text: i
|————————Node:= Text: =
|————————Node:number_literal Text: 0
|———————Node:; Text: ;
|———————Node:binary_expression Text: i < n
|————————Node:identifier Text: i
|————————Node:< Text: <
|————————Node:identifier Text: n
|———————Node:; Text: ;
|———————Node:update_expression Text: ++i
|————————Node:++ Text: ++
|————————Node:identifier Text: i
|———————Node:) Text: )
|———————Node:compound_statement Text: {
            canmsg.len = msg->i.nbytes - 8*i;

            if (canmsg.len > 8) {
                canmsg.len = 8;
            }

            memcpy(canmsg.dat, buf+8*i, canmsg.len);

            log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);

            enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
        }
|————————Node:{ Text: {
|————————Node:expression_statement Text: canmsg.len = msg->i.nbytes - 8*i;
|—————————Node:assignment_expression Text: canmsg.len = msg->i.nbytes - 8*i
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:= Text: =
|——————————Node:binary_expression Text: msg->i.nbytes - 8*i
|———————————Node:field_expression Text: msg->i.nbytes
|————————————Node:field_expression Text: msg->i
|—————————————Node:identifier Text: msg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: i
|————————————Node:. Text: .
|————————————Node:field_identifier Text: nbytes
|———————————Node:- Text: -
|———————————Node:binary_expression Text: 8*i
|————————————Node:number_literal Text: 8
|————————————Node:* Text: *
|————————————Node:identifier Text: i
|—————————Node:; Text: ;
|————————Node:if_statement Text: if (canmsg.len > 8) {
                canmsg.len = 8;
            }
|—————————Node:if Text: if
|—————————Node:parenthesized_expression Text: (canmsg.len > 8)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: canmsg.len > 8
|———————————Node:field_expression Text: canmsg.len
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: len
|———————————Node:> Text: >
|———————————Node:number_literal Text: 8
|——————————Node:) Text: )
|—————————Node:compound_statement Text: {
                canmsg.len = 8;
            }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: canmsg.len = 8;
|———————————Node:assignment_expression Text: canmsg.len = 8
|————————————Node:field_expression Text: canmsg.len
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: len
|————————————Node:= Text: =
|————————————Node:number_literal Text: 8
|———————————Node:; Text: ;
|——————————Node:} Text: }
|————————Node:expression_statement Text: memcpy(canmsg.dat, buf+8*i, canmsg.len);
|—————————Node:call_expression Text: memcpy(canmsg.dat, buf+8*i, canmsg.len)
|——————————Node:identifier Text: memcpy
|——————————Node:argument_list Text: (canmsg.dat, buf+8*i, canmsg.len)
|———————————Node:( Text: (
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:, Text: ,
|———————————Node:binary_expression Text: buf+8*i
|————————————Node:identifier Text: buf
|————————————Node:+ Text: +
|————————————Node:binary_expression Text: 8*i
|—————————————Node:number_literal Text: 8
|—————————————Node:* Text: *
|—————————————Node:identifier Text: i
|———————————Node:, Text: ,
|———————————Node:field_expression Text: canmsg.len
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: len
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7]);
|—————————Node:call_expression Text: log_trace("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7])
|——————————Node:identifier Text: log_trace
|——————————Node:argument_list Text: ("io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg.ext.timestamp,
                    canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg.mid,
                    canmsg.len,
                    canmsg.dat[0],
                    canmsg.dat[1],
                    canmsg.dat[2],
                    canmsg.dat[3],
                    canmsg.dat[4],
                    canmsg.dat[5],
                    canmsg.dat[6],
                    canmsg.dat[7])
|———————————Node:( Text: (
|———————————Node:concatenated_string Text: "io_write; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|————————————Node:string_literal Text: "io_write; %s TS: %ums [%s] %X [%d] "
|—————————————Node:" Text: "
|—————————————Node:string_content Text: io_write; %s TS: %ums [%s] %X [%d] 
|—————————————Node:" Text: "
|————————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|———————————Node:, Text: ,
|———————————Node:field_expression Text: _ocb->resmgr->name
|————————————Node:field_expression Text: _ocb->resmgr
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: name
|———————————Node:, Text: ,
|———————————Node:field_expression Text: canmsg.ext.timestamp
|————————————Node:field_expression Text: canmsg.ext
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: ext
|————————————Node:. Text: .
|————————————Node:field_identifier Text: timestamp
|———————————Node:, Text: ,
|———————————Node:conditional_expression Text: canmsg.ext.is_extended_mid ? "EFF" : "SFF"
|————————————Node:field_expression Text: canmsg.ext.is_extended_mid
|—————————————Node:field_expression Text: canmsg.ext
|——————————————Node:identifier Text: canmsg
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: ext
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: is_extended_mid
|————————————Node:? Text: ?
|————————————Node:string_literal Text: "EFF"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: EFF
|—————————————Node:" Text: "
|————————————Node:: Text: :
|————————————Node:string_literal Text: "SFF"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: SFF
|—————————————Node:" Text: "
|———————————Node:, Text: ,
|———————————Node:field_expression Text: canmsg.mid
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mid
|———————————Node:, Text: ,
|———————————Node:field_expression Text: canmsg.len
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: len
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[0]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 0
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[1]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 1
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[2]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 2
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[3]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 3
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[4]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 4
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[5]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 5
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[6]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 6
|————————————Node:] Text: ]
|———————————Node:, Text: ,
|———————————Node:subscript_expression Text: canmsg.dat[7]
|————————————Node:field_expression Text: canmsg.dat
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dat
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 7
|————————————Node:] Text: ]
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:expression_statement Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
|—————————Node:call_expression Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg)
|——————————Node:identifier Text: enqueue
|——————————Node:argument_list Text: (&_ocb->resmgr->device_session->tx_queue, &canmsg)
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &_ocb->resmgr->device_session->tx_queue
|————————————Node:& Text: &
|————————————Node:field_expression Text: _ocb->resmgr->device_session->tx_queue
|—————————————Node:field_expression Text: _ocb->resmgr->device_session
|——————————————Node:field_expression Text: _ocb->resmgr
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: resmgr
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: device_session
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: tx_queue
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &canmsg
|————————————Node:& Text: &
|————————————Node:identifier Text: canmsg
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:expression_statement Text: free(buf);
|———————Node:call_expression Text: free(buf)
|————————Node:identifier Text: free
|————————Node:argument_list Text: (buf)
|—————————Node:( Text: (
|—————————Node:identifier Text: buf
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:comment Text: /* Finally, if we received more than 0 bytes, we mark the file information
     * for the device to be updated: modification time and change of file status
     * time. To avoid constant update of the real file status information (which
     * would involve overhead getting the current time), we just set these
     * flags. The actual update is done upon closing, which is valid according
     * to POSIX. */
|———Node:if_statement Text: if (msg->i.nbytes > 0) {
        ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: (msg->i.nbytes > 0)
|—————Node:( Text: (
|—————Node:binary_expression Text: msg->i.nbytes > 0
|——————Node:field_expression Text: msg->i.nbytes
|———————Node:field_expression Text: msg->i
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: i
|———————Node:. Text: .
|———————Node:field_identifier Text: nbytes
|——————Node:> Text: >
|——————Node:number_literal Text: 0
|—————Node:) Text: )
|————Node:compound_statement Text: {
        ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
|——————Node:assignment_expression Text: ocb->attr->flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME
|———————Node:field_expression Text: ocb->attr->flags
|————————Node:field_expression Text: ocb->attr
|—————————Node:identifier Text: ocb
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: attr
|————————Node:-> Text: ->
|————————Node:field_identifier Text: flags
|———————Node:|= Text: |=
|———————Node:binary_expression Text: IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME
|————————Node:identifier Text: IOFUNC_ATTR_MTIME
|————————Node:| Text: |
|————————Node:identifier Text: IOFUNC_ATTR_CTIME
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return (_RESMGR_NPARTS (0));
|————Node:return Text: return
|————Node:parenthesized_expression Text: (_RESMGR_NPARTS (0))
|—————Node:( Text: (
|—————Node:call_expression Text: _RESMGR_NPARTS (0)
|——————Node:identifier Text: _RESMGR_NPARTS
|——————Node:argument_list Text: (0)
|———————Node:( Text: (
|———————Node:number_literal Text: 0
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: int io_unblock (resmgr_context_t* ctp, io_pulse_t* msg, RESMGR_OCB_T* _ocb) {
    log_trace("io_unblock -> id: %d\n", ctp->id);

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    int status;
    if((status = iofunc_unblock_default(ctp, msg, ocb)) != _RESMGR_DEFAULT) {
        log_dbg("iofunc_unblock_default: No client connection was found.\n");

        return status;
    }

    return 0;
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_unblock (resmgr_context_t* ctp, io_pulse_t* msg, RESMGR_OCB_T* _ocb)
|———Node:identifier Text: io_unblock
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_pulse_t* msg, RESMGR_OCB_T* _ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_pulse_t* msg
|—————Node:type_identifier Text: io_pulse_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* _ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * _ocb
|——————Node:* Text: *
|——————Node:identifier Text: _ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    log_trace("io_unblock -> id: %d\n", ctp->id);

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    int status;
    if((status = iofunc_unblock_default(ctp, msg, ocb)) != _RESMGR_DEFAULT) {
        log_dbg("iofunc_unblock_default: No client connection was found.\n");

        return status;
    }

    return 0;
}
|———Node:{ Text: {
|———Node:expression_statement Text: log_trace("io_unblock -> id: %d\n", ctp->id);
|————Node:call_expression Text: log_trace("io_unblock -> id: %d\n", ctp->id)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_unblock -> id: %d\n", ctp->id)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_unblock -> id: %d\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_unblock -> id: %d
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:declaration Text: iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;
|————Node:type_identifier Text: iofunc_ocb_t
|————Node:init_declarator Text: * ocb = (iofunc_ocb_t*)_ocb
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (iofunc_ocb_t*)_ocb
|——————Node:( Text: (
|——————Node:type_descriptor Text: iofunc_ocb_t*
|———————Node:type_identifier Text: iofunc_ocb_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: _ocb
|————Node:; Text: ;
|———Node:declaration Text: int status;
|————Node:primitive_type Text: int
|————Node:identifier Text: status
|————Node:; Text: ;
|———Node:if_statement Text: if((status = iofunc_unblock_default(ctp, msg, ocb)) != _RESMGR_DEFAULT) {
        log_dbg("iofunc_unblock_default: No client connection was found.\n");

        return status;
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((status = iofunc_unblock_default(ctp, msg, ocb)) != _RESMGR_DEFAULT)
|—————Node:( Text: (
|—————Node:binary_expression Text: (status = iofunc_unblock_default(ctp, msg, ocb)) != _RESMGR_DEFAULT
|——————Node:parenthesized_expression Text: (status = iofunc_unblock_default(ctp, msg, ocb))
|———————Node:( Text: (
|———————Node:assignment_expression Text: status = iofunc_unblock_default(ctp, msg, ocb)
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:call_expression Text: iofunc_unblock_default(ctp, msg, ocb)
|—————————Node:identifier Text: iofunc_unblock_default
|—————————Node:argument_list Text: (ctp, msg, ocb)
|——————————Node:( Text: (
|——————————Node:identifier Text: ctp
|——————————Node:, Text: ,
|——————————Node:identifier Text: msg
|——————————Node:, Text: ,
|——————————Node:identifier Text: ocb
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: _RESMGR_DEFAULT
|—————Node:) Text: )
|————Node:compound_statement Text: {
        log_dbg("iofunc_unblock_default: No client connection was found.\n");

        return status;
    }
|—————Node:{ Text: {
|—————Node:expression_statement Text: log_dbg("iofunc_unblock_default: No client connection was found.\n");
|——————Node:call_expression Text: log_dbg("iofunc_unblock_default: No client connection was found.\n")
|———————Node:identifier Text: log_dbg
|———————Node:argument_list Text: ("iofunc_unblock_default: No client connection was found.\n")
|————————Node:( Text: (
|————————Node:string_literal Text: "iofunc_unblock_default: No client connection was found.\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: iofunc_unblock_default: No client connection was found.
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:return_statement Text: return status;
|——————Node:return Text: return
|——————Node:identifier Text: status
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return 0;
|————Node:return Text: return
|————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: int io_devctl (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* _ocb) {
    int nbytes, status;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    union data_t {
        uint32_t    latency_limit;
        uint32_t    bitrate;
        uint32_t    info2;

        DCMD_DATA   dcmd;
    } *data;

    log_trace("io_devctl -> id: %d\n", ctp->id);

    /*
     Let common code handle DCMD_ALL_* cases.
     You can do this before or after you intercept devctls, depending
     on your intentions.  Here we aren't using any predefined values,
     so let the system ones be handled first. See note 2.
    */
    if ((status = iofunc_devctl_default(ctp, msg, ocb)) !=
         _RESMGR_DEFAULT) {
        return(status);
    }
    status = nbytes = 0;

    /* Get the data from the message. See Note 3. */
    data = _DEVCTL_DATA(msg->i);

    /*
     * Where applicable an associated canctl, candump or cansend tool usage
     * example is given as comments in each case below.
     */
    switch (msg->i.dcmd) {
    /*
     * Extended devctl() commands; these are in addition to the standard
     * QNX dev-can-* driver protocol commands
     */
    case EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS:
    {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
    /*
     * Standard QNX dev-can-* driver protocol commands
     */
    case CAN_DEVCTL_GET_MID: // e.g. canctl -u1,rx0 -M
    {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
    case CAN_DEVCTL_SET_MID: // e.g. canctl -u1,rx1 -m 0x11CC0000
    {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
    case CAN_DEVCTL_GET_MFILTER: // e.g. #canctl -u0,tx0 -F
    {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
    case CAN_DEVCTL_SET_MFILTER: // e.g. canctl -u0,tx0 -f 0x11CC0000
    {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
    case CAN_DEVCTL_GET_PRIO: // canctl -u1,tx1 -P
    {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_SET_PRIO: // e.g. canctl -u1,tx1 -p 5
    {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_GET_TIMESTAMP: // e.g. canctl -u1 -T
    {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
    case CAN_DEVCTL_SET_TIMESTAMP: // e.g. canctl -u1 -t 0xAAAAAA
    {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
    case CAN_DEVCTL_READ_CANMSG_EXT: // e.g. canctl -u0,rx0 -r
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
    case CAN_DEVCTL_WRITE_CANMSG_EXT: // e.g. canctl -u0,rx0 -w0x22,1,0x55
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    case CAN_DEVCTL_ERROR: // e.g. canctl -u0,rx0 -e
    {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO2: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
    case CAN_DEVCTL_GET_STATS: // e.g. canctl -s
    {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
    case CAN_DEVCTL_GET_INFO: // e.g. canctl -u0,rx0 -i
    {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
    case CAN_DEVCTL_SET_TIMING: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
                                // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
                                // e.g. canctl -u0,rx0 -c 0,1,3,2,1
                                //          reference clock don't change if '0'
    {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
    case CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK:
    case CAN_DEVCTL_RX_FRAME_RAW_BLOCK: // e.g. candump -u0,rx0
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
    case CAN_DEVCTL_TX_FRAME_RAW: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    default:
        log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);

        return(ENOSYS);
    }

    /* Clear the return message. Note that we saved our data past
       this location in the message. */
    memset(&msg->o, 0, sizeof(msg->o));

    /*
     If you wanted to pass something different to the return
     field of the devctl() you could do it through this member.
     See note 5.
    */
    msg->o.ret_val = status;

    /* Indicate the number of bytes and return the message */
    msg->o.nbytes = nbytes;
    return(_RESMGR_PTR(ctp, &msg->o, sizeof(msg->o) + nbytes));
}
|——Node:primitive_type Text: int
|——Node:function_declarator Text: io_devctl (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* _ocb)
|———Node:identifier Text: io_devctl
|———Node:parameter_list Text: (resmgr_context_t* ctp, io_devctl_t* msg, RESMGR_OCB_T* _ocb)
|————Node:( Text: (
|————Node:parameter_declaration Text: resmgr_context_t* ctp
|—————Node:type_identifier Text: resmgr_context_t
|—————Node:pointer_declarator Text: * ctp
|——————Node:* Text: *
|——————Node:identifier Text: ctp
|————Node:, Text: ,
|————Node:parameter_declaration Text: io_devctl_t* msg
|—————Node:type_identifier Text: io_devctl_t
|—————Node:pointer_declarator Text: * msg
|——————Node:* Text: *
|——————Node:identifier Text: msg
|————Node:, Text: ,
|————Node:parameter_declaration Text: RESMGR_OCB_T* _ocb
|—————Node:type_identifier Text: RESMGR_OCB_T
|—————Node:pointer_declarator Text: * _ocb
|——————Node:* Text: *
|——————Node:identifier Text: _ocb
|————Node:) Text: )
|——Node:compound_statement Text: {
    int nbytes, status;

    iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;

    union data_t {
        uint32_t    latency_limit;
        uint32_t    bitrate;
        uint32_t    info2;

        DCMD_DATA   dcmd;
    } *data;

    log_trace("io_devctl -> id: %d\n", ctp->id);

    /*
     Let common code handle DCMD_ALL_* cases.
     You can do this before or after you intercept devctls, depending
     on your intentions.  Here we aren't using any predefined values,
     so let the system ones be handled first. See note 2.
    */
    if ((status = iofunc_devctl_default(ctp, msg, ocb)) !=
         _RESMGR_DEFAULT) {
        return(status);
    }
    status = nbytes = 0;

    /* Get the data from the message. See Note 3. */
    data = _DEVCTL_DATA(msg->i);

    /*
     * Where applicable an associated canctl, candump or cansend tool usage
     * example is given as comments in each case below.
     */
    switch (msg->i.dcmd) {
    /*
     * Extended devctl() commands; these are in addition to the standard
     * QNX dev-can-* driver protocol commands
     */
    case EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS:
    {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
    /*
     * Standard QNX dev-can-* driver protocol commands
     */
    case CAN_DEVCTL_GET_MID: // e.g. canctl -u1,rx0 -M
    {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
    case CAN_DEVCTL_SET_MID: // e.g. canctl -u1,rx1 -m 0x11CC0000
    {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
    case CAN_DEVCTL_GET_MFILTER: // e.g. #canctl -u0,tx0 -F
    {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
    case CAN_DEVCTL_SET_MFILTER: // e.g. canctl -u0,tx0 -f 0x11CC0000
    {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
    case CAN_DEVCTL_GET_PRIO: // canctl -u1,tx1 -P
    {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_SET_PRIO: // e.g. canctl -u1,tx1 -p 5
    {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_GET_TIMESTAMP: // e.g. canctl -u1 -T
    {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
    case CAN_DEVCTL_SET_TIMESTAMP: // e.g. canctl -u1 -t 0xAAAAAA
    {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
    case CAN_DEVCTL_READ_CANMSG_EXT: // e.g. canctl -u0,rx0 -r
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
    case CAN_DEVCTL_WRITE_CANMSG_EXT: // e.g. canctl -u0,rx0 -w0x22,1,0x55
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    case CAN_DEVCTL_ERROR: // e.g. canctl -u0,rx0 -e
    {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO2: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
    case CAN_DEVCTL_GET_STATS: // e.g. canctl -s
    {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
    case CAN_DEVCTL_GET_INFO: // e.g. canctl -u0,rx0 -i
    {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
    case CAN_DEVCTL_SET_TIMING: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
                                // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
                                // e.g. canctl -u0,rx0 -c 0,1,3,2,1
                                //          reference clock don't change if '0'
    {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
    case CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK:
    case CAN_DEVCTL_RX_FRAME_RAW_BLOCK: // e.g. candump -u0,rx0
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
    case CAN_DEVCTL_TX_FRAME_RAW: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    default:
        log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);

        return(ENOSYS);
    }

    /* Clear the return message. Note that we saved our data past
       this location in the message. */
    memset(&msg->o, 0, sizeof(msg->o));

    /*
     If you wanted to pass something different to the return
     field of the devctl() you could do it through this member.
     See note 5.
    */
    msg->o.ret_val = status;

    /* Indicate the number of bytes and return the message */
    msg->o.nbytes = nbytes;
    return(_RESMGR_PTR(ctp, &msg->o, sizeof(msg->o) + nbytes));
}
|———Node:{ Text: {
|———Node:declaration Text: int nbytes, status;
|————Node:primitive_type Text: int
|————Node:identifier Text: nbytes
|————Node:, Text: ,
|————Node:identifier Text: status
|————Node:; Text: ;
|———Node:declaration Text: iofunc_ocb_t* ocb = (iofunc_ocb_t*)_ocb;
|————Node:type_identifier Text: iofunc_ocb_t
|————Node:init_declarator Text: * ocb = (iofunc_ocb_t*)_ocb
|—————Node:pointer_declarator Text: * ocb
|——————Node:* Text: *
|——————Node:identifier Text: ocb
|—————Node:= Text: =
|—————Node:cast_expression Text: (iofunc_ocb_t*)_ocb
|——————Node:( Text: (
|——————Node:type_descriptor Text: iofunc_ocb_t*
|———————Node:type_identifier Text: iofunc_ocb_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:identifier Text: _ocb
|————Node:; Text: ;
|———Node:declaration Text: union data_t {
        uint32_t    latency_limit;
        uint32_t    bitrate;
        uint32_t    info2;

        DCMD_DATA   dcmd;
    } *data;
|————Node:union_specifier Text: union data_t {
        uint32_t    latency_limit;
        uint32_t    bitrate;
        uint32_t    info2;

        DCMD_DATA   dcmd;
    }
|—————Node:union Text: union
|—————Node:type_identifier Text: data_t
|—————Node:field_declaration_list Text: {
        uint32_t    latency_limit;
        uint32_t    bitrate;
        uint32_t    info2;

        DCMD_DATA   dcmd;
    }
|——————Node:{ Text: {
|——————Node:field_declaration Text: uint32_t    latency_limit;
|———————Node:primitive_type Text: uint32_t
|———————Node:field_identifier Text: latency_limit
|———————Node:; Text: ;
|——————Node:field_declaration Text: uint32_t    bitrate;
|———————Node:primitive_type Text: uint32_t
|———————Node:field_identifier Text: bitrate
|———————Node:; Text: ;
|——————Node:field_declaration Text: uint32_t    info2;
|———————Node:primitive_type Text: uint32_t
|———————Node:field_identifier Text: info2
|———————Node:; Text: ;
|——————Node:field_declaration Text: DCMD_DATA   dcmd;
|———————Node:type_identifier Text: DCMD_DATA
|———————Node:field_identifier Text: dcmd
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:pointer_declarator Text: *data
|—————Node:* Text: *
|—————Node:identifier Text: data
|————Node:; Text: ;
|———Node:expression_statement Text: log_trace("io_devctl -> id: %d\n", ctp->id);
|————Node:call_expression Text: log_trace("io_devctl -> id: %d\n", ctp->id)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("io_devctl -> id: %d\n", ctp->id)
|——————Node:( Text: (
|——————Node:string_literal Text: "io_devctl -> id: %d\n"
|———————Node:" Text: "
|———————Node:string_content Text: io_devctl -> id: %d
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: ctp->id
|———————Node:identifier Text: ctp
|———————Node:-> Text: ->
|———————Node:field_identifier Text: id
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*
     Let common code handle DCMD_ALL_* cases.
     You can do this before or after you intercept devctls, depending
     on your intentions.  Here we aren't using any predefined values,
     so let the system ones be handled first. See note 2.
    */
|———Node:if_statement Text: if ((status = iofunc_devctl_default(ctp, msg, ocb)) !=
         _RESMGR_DEFAULT) {
        return(status);
    }
|————Node:if Text: if
|————Node:parenthesized_expression Text: ((status = iofunc_devctl_default(ctp, msg, ocb)) !=
         _RESMGR_DEFAULT)
|—————Node:( Text: (
|—————Node:binary_expression Text: (status = iofunc_devctl_default(ctp, msg, ocb)) !=
         _RESMGR_DEFAULT
|——————Node:parenthesized_expression Text: (status = iofunc_devctl_default(ctp, msg, ocb))
|———————Node:( Text: (
|———————Node:assignment_expression Text: status = iofunc_devctl_default(ctp, msg, ocb)
|————————Node:identifier Text: status
|————————Node:= Text: =
|————————Node:call_expression Text: iofunc_devctl_default(ctp, msg, ocb)
|—————————Node:identifier Text: iofunc_devctl_default
|—————————Node:argument_list Text: (ctp, msg, ocb)
|——————————Node:( Text: (
|——————————Node:identifier Text: ctp
|——————————Node:, Text: ,
|——————————Node:identifier Text: msg
|——————————Node:, Text: ,
|——————————Node:identifier Text: ocb
|——————————Node:) Text: )
|———————Node:) Text: )
|——————Node:!= Text: !=
|——————Node:identifier Text: _RESMGR_DEFAULT
|—————Node:) Text: )
|————Node:compound_statement Text: {
        return(status);
    }
|—————Node:{ Text: {
|—————Node:return_statement Text: return(status);
|——————Node:return Text: return
|——————Node:parenthesized_expression Text: (status)
|———————Node:( Text: (
|———————Node:identifier Text: status
|———————Node:) Text: )
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: status = nbytes = 0;
|————Node:assignment_expression Text: status = nbytes = 0
|—————Node:identifier Text: status
|—————Node:= Text: =
|—————Node:assignment_expression Text: nbytes = 0
|——————Node:identifier Text: nbytes
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:comment Text: /* Get the data from the message. See Note 3. */
|———Node:expression_statement Text: data = _DEVCTL_DATA(msg->i);
|————Node:assignment_expression Text: data = _DEVCTL_DATA(msg->i)
|—————Node:identifier Text: data
|—————Node:= Text: =
|—————Node:call_expression Text: _DEVCTL_DATA(msg->i)
|——————Node:identifier Text: _DEVCTL_DATA
|——————Node:argument_list Text: (msg->i)
|———————Node:( Text: (
|———————Node:field_expression Text: msg->i
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: i
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*
     * Where applicable an associated canctl, candump or cansend tool usage
     * example is given as comments in each case below.
     */
|———Node:switch_statement Text: switch (msg->i.dcmd) {
    /*
     * Extended devctl() commands; these are in addition to the standard
     * QNX dev-can-* driver protocol commands
     */
    case EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS:
    {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
    /*
     * Standard QNX dev-can-* driver protocol commands
     */
    case CAN_DEVCTL_GET_MID: // e.g. canctl -u1,rx0 -M
    {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
    case CAN_DEVCTL_SET_MID: // e.g. canctl -u1,rx1 -m 0x11CC0000
    {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
    case CAN_DEVCTL_GET_MFILTER: // e.g. #canctl -u0,tx0 -F
    {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
    case CAN_DEVCTL_SET_MFILTER: // e.g. canctl -u0,tx0 -f 0x11CC0000
    {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
    case CAN_DEVCTL_GET_PRIO: // canctl -u1,tx1 -P
    {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_SET_PRIO: // e.g. canctl -u1,tx1 -p 5
    {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_GET_TIMESTAMP: // e.g. canctl -u1 -T
    {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
    case CAN_DEVCTL_SET_TIMESTAMP: // e.g. canctl -u1 -t 0xAAAAAA
    {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
    case CAN_DEVCTL_READ_CANMSG_EXT: // e.g. canctl -u0,rx0 -r
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
    case CAN_DEVCTL_WRITE_CANMSG_EXT: // e.g. canctl -u0,rx0 -w0x22,1,0x55
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    case CAN_DEVCTL_ERROR: // e.g. canctl -u0,rx0 -e
    {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO2: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
    case CAN_DEVCTL_GET_STATS: // e.g. canctl -s
    {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
    case CAN_DEVCTL_GET_INFO: // e.g. canctl -u0,rx0 -i
    {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
    case CAN_DEVCTL_SET_TIMING: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
                                // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
                                // e.g. canctl -u0,rx0 -c 0,1,3,2,1
                                //          reference clock don't change if '0'
    {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
    case CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK:
    case CAN_DEVCTL_RX_FRAME_RAW_BLOCK: // e.g. candump -u0,rx0
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
    case CAN_DEVCTL_TX_FRAME_RAW: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    default:
        log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);

        return(ENOSYS);
    }
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (msg->i.dcmd)
|—————Node:( Text: (
|—————Node:field_expression Text: msg->i.dcmd
|——————Node:field_expression Text: msg->i
|———————Node:identifier Text: msg
|———————Node:-> Text: ->
|———————Node:field_identifier Text: i
|——————Node:. Text: .
|——————Node:field_identifier Text: dcmd
|—————Node:) Text: )
|————Node:compound_statement Text: {
    /*
     * Extended devctl() commands; these are in addition to the standard
     * QNX dev-can-* driver protocol commands
     */
    case EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS:
    {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
    /*
     * Standard QNX dev-can-* driver protocol commands
     */
    case CAN_DEVCTL_GET_MID: // e.g. canctl -u1,rx0 -M
    {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
    case CAN_DEVCTL_SET_MID: // e.g. canctl -u1,rx1 -m 0x11CC0000
    {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
    case CAN_DEVCTL_GET_MFILTER: // e.g. #canctl -u0,tx0 -F
    {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
    case CAN_DEVCTL_SET_MFILTER: // e.g. canctl -u0,tx0 -f 0x11CC0000
    {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
    case CAN_DEVCTL_GET_PRIO: // canctl -u1,tx1 -P
    {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_SET_PRIO: // e.g. canctl -u1,tx1 -p 5
    {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
    case CAN_DEVCTL_GET_TIMESTAMP: // e.g. canctl -u1 -T
    {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
    case CAN_DEVCTL_SET_TIMESTAMP: // e.g. canctl -u1 -t 0xAAAAAA
    {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
    case CAN_DEVCTL_READ_CANMSG_EXT: // e.g. canctl -u0,rx0 -r
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
    case CAN_DEVCTL_WRITE_CANMSG_EXT: // e.g. canctl -u0,rx0 -w0x22,1,0x55
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    case CAN_DEVCTL_ERROR: // e.g. canctl -u0,rx0 -e
    {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
    case CAN_DEVCTL_DEBUG_INFO2: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
    case CAN_DEVCTL_GET_STATS: // e.g. canctl -s
    {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
    case CAN_DEVCTL_GET_INFO: // e.g. canctl -u0,rx0 -i
    {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
    case CAN_DEVCTL_SET_TIMING: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
                                // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
                                // e.g. canctl -u0,rx0 -c 0,1,3,2,1
                                //          reference clock don't change if '0'
    {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
    case CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK:
    case CAN_DEVCTL_RX_FRAME_RAW_BLOCK: // e.g. candump -u0,rx0
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
    case CAN_DEVCTL_TX_FRAME_RAW: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
    default:
        log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);

        return(ENOSYS);
    }
|—————Node:{ Text: {
|—————Node:comment Text: /*
     * Extended devctl() commands; these are in addition to the standard
     * QNX dev-can-* driver protocol commands
     */
|—————Node:case_statement Text: case EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS:
    {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS
|——————Node:: Text: :
|——————Node:compound_statement Text: {
        uint32_t can_latency_limit = data->latency_limit;
        nbytes = 0;

        _ocb->resmgr->latency_limit_ms = can_latency_limit;

        log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);

        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t can_latency_limit = data->latency_limit;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: can_latency_limit = data->latency_limit
|—————————Node:identifier Text: can_latency_limit
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->latency_limit
|——————————Node:identifier Text: data
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: latency_limit
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->resmgr->latency_limit_ms = can_latency_limit;
|————————Node:assignment_expression Text: _ocb->resmgr->latency_limit_ms = can_latency_limit
|—————————Node:field_expression Text: _ocb->resmgr->latency_limit_ms
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: latency_limit_ms
|—————————Node:= Text: =
|—————————Node:identifier Text: can_latency_limit
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name);
|————————Node:call_expression Text: log_trace("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n",
                can_latency_limit,
                _ocb->resmgr->name)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: EXT_CAN_DEVCTL_SET_LATENCY_LIMIT_MS: %dms (%s)
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: can_latency_limit
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->name
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment Text: /*
     * Standard QNX dev-can-* driver protocol commands
     */
|—————Node:case_statement Text: case CAN_DEVCTL_GET_MID: // e.g. canctl -u1,rx0 -M
    {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_MID
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u1,rx0 -M
|——————Node:compound_statement Text: {
        data->dcmd.mid = _ocb->resmgr->mid; // <- set MID
        nbytes = sizeof(data->dcmd.mid);

        log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: data->dcmd.mid = _ocb->resmgr->mid;
|————————Node:assignment_expression Text: data->dcmd.mid = _ocb->resmgr->mid
|—————————Node:field_expression Text: data->dcmd.mid
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mid
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->mid
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mid
|————————Node:; Text: ;
|———————Node:comment Text: // <- set MID
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.mid);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.mid)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.mid)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.mid)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.mid
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mid
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_MID: %x\n", data->dcmd.mid)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_MID: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_MID: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.mid
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mid
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_SET_MID: // e.g. canctl -u1,rx1 -m 0x11CC0000
    {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_SET_MID
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u1,rx1 -m 0x11CC0000
|——————Node:compound_statement Text: {
        uint32_t mid = data->dcmd.mid;
        nbytes = 0;

        _ocb->resmgr->mid = mid;

        log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t mid = data->dcmd.mid;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: mid = data->dcmd.mid
|—————————Node:identifier Text: mid
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.mid
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mid
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->resmgr->mid = mid;
|————————Node:assignment_expression Text: _ocb->resmgr->mid = mid
|—————————Node:field_expression Text: _ocb->resmgr->mid
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mid
|—————————Node:= Text: =
|—————————Node:identifier Text: mid
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_SET_MID: %x\n", mid);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_SET_MID: %x\n", mid)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_SET_MID: %x\n", mid)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_SET_MID: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_SET_MID: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: mid
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_GET_MFILTER: // e.g. #canctl -u0,tx0 -F
    {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_MFILTER
|——————Node:: Text: :
|——————Node:comment Text: // e.g. #canctl -u0,tx0 -F
|——————Node:compound_statement Text: {
        data->dcmd.mfilter = _ocb->resmgr->mfilter; // set MFILTER
        nbytes = sizeof(data->dcmd.mfilter);

        log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: data->dcmd.mfilter = _ocb->resmgr->mfilter;
|————————Node:assignment_expression Text: data->dcmd.mfilter = _ocb->resmgr->mfilter
|—————————Node:field_expression Text: data->dcmd.mfilter
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mfilter
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->mfilter
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mfilter
|————————Node:; Text: ;
|———————Node:comment Text: // set MFILTER
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.mfilter);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.mfilter)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.mfilter)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.mfilter)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.mfilter
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: mfilter
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_MFILTER: %x\n", data->dcmd.mfilter)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_MFILTER: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_MFILTER: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.mfilter
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mfilter
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_SET_MFILTER: // e.g. canctl -u0,tx0 -f 0x11CC0000
    {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_SET_MFILTER
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,tx0 -f 0x11CC0000
|——————Node:compound_statement Text: {
        uint32_t mfilter = data->dcmd.mfilter;
        nbytes = 0;

        _ocb->resmgr->mfilter = mfilter;

        log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t mfilter = data->dcmd.mfilter;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: mfilter = data->dcmd.mfilter
|—————————Node:identifier Text: mfilter
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.mfilter
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mfilter
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->resmgr->mfilter = mfilter;
|————————Node:assignment_expression Text: _ocb->resmgr->mfilter = mfilter
|—————————Node:field_expression Text: _ocb->resmgr->mfilter
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: mfilter
|—————————Node:= Text: =
|—————————Node:identifier Text: mfilter
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_SET_MFILTER: %x\n", mfilter)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_SET_MFILTER: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_SET_MFILTER: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: mfilter
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_GET_PRIO: // canctl -u1,tx1 -P
    {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_PRIO
|——————Node:: Text: :
|——————Node:comment Text: // canctl -u1,tx1 -P
|——————Node:compound_statement Text: {
        data->dcmd.prio = _ocb->resmgr->prio; // set PRIO
        nbytes = sizeof(data->dcmd.prio);

        log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);

        return ENOTSUP; // Not supported
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: data->dcmd.prio = _ocb->resmgr->prio;
|————————Node:assignment_expression Text: data->dcmd.prio = _ocb->resmgr->prio
|—————————Node:field_expression Text: data->dcmd.prio
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: prio
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->prio
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prio
|————————Node:; Text: ;
|———————Node:comment Text: // set PRIO
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.prio);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.prio)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.prio)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.prio)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.prio
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: prio
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_PRIO: %x\n", data->dcmd.prio)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_PRIO: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_PRIO: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.prio
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: prio
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return ENOTSUP;
|————————Node:return Text: return
|————————Node:identifier Text: ENOTSUP
|————————Node:; Text: ;
|———————Node:comment Text: // Not supported
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_SET_PRIO: // e.g. canctl -u1,tx1 -p 5
    {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_SET_PRIO
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u1,tx1 -p 5
|——————Node:compound_statement Text: {
        uint32_t prio = data->dcmd.prio;
        nbytes = 0;

        _ocb->resmgr->prio = prio;

        log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);

        return ENOTSUP; // Not supported
    }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t prio = data->dcmd.prio;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: prio = data->dcmd.prio
|—————————Node:identifier Text: prio
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.prio
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: prio
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: _ocb->resmgr->prio = prio;
|————————Node:assignment_expression Text: _ocb->resmgr->prio = prio
|—————————Node:field_expression Text: _ocb->resmgr->prio
|——————————Node:field_expression Text: _ocb->resmgr
|———————————Node:identifier Text: _ocb
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: resmgr
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: prio
|—————————Node:= Text: =
|—————————Node:identifier Text: prio
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_SET_PRIO: %x\n", prio)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_SET_PRIO: %x\n", prio)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_SET_PRIO: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_SET_PRIO: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: prio
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:return_statement Text: return ENOTSUP;
|————————Node:return Text: return
|————————Node:identifier Text: ENOTSUP
|————————Node:; Text: ;
|———————Node:comment Text: // Not supported
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_GET_TIMESTAMP: // e.g. canctl -u1 -T
    {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_TIMESTAMP
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u1 -T
|——————Node:compound_statement Text: {
        nbytes = sizeof(data->dcmd.timestamp);

        // set TIMESTAMP
        if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }

        log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.timestamp);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.timestamp)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.timestamp)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.timestamp)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.timestamp
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: timestamp
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: // set TIMESTAMP
|———————Node:if_statement Text: if (optt) {
            data->dcmd.timestamp = user_timestamp;
        }
        else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (optt)
|—————————Node:( Text: (
|—————————Node:identifier Text: optt
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            data->dcmd.timestamp = user_timestamp;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: data->dcmd.timestamp = user_timestamp;
|——————————Node:assignment_expression Text: data->dcmd.timestamp = user_timestamp
|———————————Node:field_expression Text: data->dcmd.timestamp
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: timestamp
|———————————Node:= Text: =
|———————————Node:identifier Text: user_timestamp
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (user_timestamp_time != 0) {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
        else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (user_timestamp_time != 0)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: user_timestamp_time != 0
|————————————Node:identifier Text: user_timestamp_time
|————————————Node:!= Text: !=
|————————————Node:number_literal Text: 0
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
            data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
        }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time;
|————————————Node:assignment_expression Text: data->dcmd.timestamp =
                user_timestamp + get_clock_time_us()/1000 - user_timestamp_time
|—————————————Node:field_expression Text: data->dcmd.timestamp
|——————————————Node:field_expression Text: data->dcmd
|———————————————Node:identifier Text: data
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: dcmd
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: timestamp
|—————————————Node:= Text: =
|—————————————Node:binary_expression Text: user_timestamp + get_clock_time_us()/1000 - user_timestamp_time
|——————————————Node:binary_expression Text: user_timestamp + get_clock_time_us()/1000
|———————————————Node:identifier Text: user_timestamp
|———————————————Node:+ Text: +
|———————————————Node:binary_expression Text: get_clock_time_us()/1000
|————————————————Node:call_expression Text: get_clock_time_us()
|—————————————————Node:identifier Text: get_clock_time_us
|—————————————————Node:argument_list Text: ()
|——————————————————Node:( Text: (
|——————————————————Node:) Text: )
|————————————————Node:/ Text: /
|————————————————Node:number_literal Text: 1000
|——————————————Node:- Text: -
|——————————————Node:identifier Text: user_timestamp_time
|————————————Node:; Text: ;
|———————————Node:} Text: }
|——————————Node:else_clause Text: else {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: {
            data->dcmd.timestamp = get_clock_time_us()/1000;
        }
|————————————Node:{ Text: {
|————————————Node:expression_statement Text: data->dcmd.timestamp = get_clock_time_us()/1000;
|—————————————Node:assignment_expression Text: data->dcmd.timestamp = get_clock_time_us()/1000
|——————————————Node:field_expression Text: data->dcmd.timestamp
|———————————————Node:field_expression Text: data->dcmd
|————————————————Node:identifier Text: data
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: dcmd
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: timestamp
|——————————————Node:= Text: =
|——————————————Node:binary_expression Text: get_clock_time_us()/1000
|———————————————Node:call_expression Text: get_clock_time_us()
|————————————————Node:identifier Text: get_clock_time_us
|————————————————Node:argument_list Text: ()
|—————————————————Node:( Text: (
|—————————————————Node:) Text: )
|———————————————Node:/ Text: /
|———————————————Node:number_literal Text: 1000
|—————————————Node:; Text: ;
|————————————Node:} Text: }
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_TIMESTAMP: %x\n", data->dcmd.timestamp)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_TIMESTAMP: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_TIMESTAMP: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.timestamp
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: timestamp
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_SET_TIMESTAMP: // e.g. canctl -u1 -t 0xAAAAAA
    {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_SET_TIMESTAMP
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u1 -t 0xAAAAAA
|——————Node:compound_statement Text: {
        uint32_t ts = data->dcmd.timestamp;
        nbytes = 0;

        user_timestamp = ts;
        user_timestamp_time = get_clock_time_us()/1000;

        log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: uint32_t ts = data->dcmd.timestamp;
|————————Node:primitive_type Text: uint32_t
|————————Node:init_declarator Text: ts = data->dcmd.timestamp
|—————————Node:identifier Text: ts
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.timestamp
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: timestamp
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: user_timestamp = ts;
|————————Node:assignment_expression Text: user_timestamp = ts
|—————————Node:identifier Text: user_timestamp
|—————————Node:= Text: =
|—————————Node:identifier Text: ts
|————————Node:; Text: ;
|———————Node:expression_statement Text: user_timestamp_time = get_clock_time_us()/1000;
|————————Node:assignment_expression Text: user_timestamp_time = get_clock_time_us()/1000
|—————————Node:identifier Text: user_timestamp_time
|—————————Node:= Text: =
|—————————Node:binary_expression Text: get_clock_time_us()/1000
|——————————Node:call_expression Text: get_clock_time_us()
|———————————Node:identifier Text: get_clock_time_us
|———————————Node:argument_list Text: ()
|————————————Node:( Text: (
|————————————Node:) Text: )
|——————————Node:/ Text: /
|——————————Node:number_literal Text: 1000
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_SET_TIMESTAMP: %x\n", ts)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_SET_TIMESTAMP: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_SET_TIMESTAMP: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: ts
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_READ_CANMSG_EXT: // e.g. canctl -u0,rx0 -r
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_READ_CANMSG_EXT
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,rx0 -r
|——————Node:compound_statement Text: {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }

        break;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == TX_CHANNEL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: _ocb->resmgr->channel_type == TX_CHANNEL
|——————————Node:field_expression Text: _ocb->resmgr->channel_type
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: channel_type
|——————————Node:== Text: ==
|——————————Node:identifier Text: TX_CHANNEL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            return EIO; // Input/output error
        }
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return EIO;
|——————————Node:return Text: return
|——————————Node:identifier Text: EIO
|——————————Node:; Text: ;
|—————————Node:comment Text: // Input/output error
|—————————Node:} Text: }
|———————Node:declaration Text: struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );
|————————Node:struct_specifier Text: struct can_msg
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_msg
|————————Node:init_declarator Text: * canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|—————————Node:pointer_declarator Text: * canmsg
|——————————Node:* Text: *
|——————————Node:identifier Text: canmsg
|—————————Node:= Text: =
|—————————Node:call_expression Text: dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|——————————Node:identifier Text: dequeue_noblock
|——————————Node:argument_list Text: ( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &_ocb->session->rx_queue
|————————————Node:& Text: &
|————————————Node:field_expression Text: _ocb->session->rx_queue
|—————————————Node:field_expression Text: _ocb->session
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: session
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx_queue
|———————————Node:, Text: ,
|———————————Node:field_expression Text: _ocb->resmgr->latency_limit_ms
|————————————Node:field_expression Text: _ocb->resmgr
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: latency_limit_ms
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (canmsg != NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canmsg != NULL
|——————————Node:identifier Text: canmsg
|——————————Node:!= Text: !=
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Could be a zero size rx queue, i.e. a tx queue
|—————————Node:expression_statement Text: data->dcmd.canmsg = *canmsg;
|——————————Node:assignment_expression Text: data->dcmd.canmsg = *canmsg
|———————————Node:field_expression Text: data->dcmd.canmsg
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: canmsg
|———————————Node:= Text: =
|———————————Node:pointer_expression Text: *canmsg
|————————————Node:* Text: *
|————————————Node:identifier Text: canmsg
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: nbytes = sizeof(data->dcmd.canmsg);
|——————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.canmsg)
|———————————Node:identifier Text: nbytes
|———————————Node:= Text: =
|———————————Node:sizeof_expression Text: sizeof(data->dcmd.canmsg)
|————————————Node:sizeof Text: sizeof
|————————————Node:parenthesized_expression Text: (data->dcmd.canmsg)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: data->dcmd.canmsg
|——————————————Node:field_expression Text: data->dcmd
|———————————————Node:identifier Text: data
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: dcmd
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: canmsg
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);
|——————————Node:call_expression Text: log_trace("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7])
|———————————Node:identifier Text: log_trace
|———————————Node:argument_list Text: ("CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7])
|————————————Node:( Text: (
|————————————Node:concatenated_string Text: "CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|—————————————Node:string_literal Text: "CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] "
|——————————————Node:" Text: "
|——————————————Node:string_content Text: CAN_DEVCTL_READ_CANMSG_EXT; %s TS: %ums [%s] %X [%d] 
|——————————————Node:" Text: "
|—————————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|——————————————Node:escape_sequence Text: \n
|——————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:field_expression Text: _ocb->resmgr->name
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: name
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->ext.timestamp
|—————————————Node:field_expression Text: canmsg->ext
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: ext
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: timestamp
|————————————Node:, Text: ,
|————————————Node:conditional_expression Text: canmsg->ext.is_extended_mid ? "EFF" : "SFF"
|—————————————Node:field_expression Text: canmsg->ext.is_extended_mid
|——————————————Node:field_expression Text: canmsg->ext
|———————————————Node:identifier Text: canmsg
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: ext
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: is_extended_mid
|—————————————Node:? Text: ?
|—————————————Node:string_literal Text: "EFF"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: EFF
|——————————————Node:" Text: "
|—————————————Node:: Text: :
|—————————————Node:string_literal Text: "SFF"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: SFF
|——————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->mid
|—————————————Node:identifier Text: canmsg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: mid
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->len
|—————————————Node:identifier Text: canmsg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: len
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[0]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 0
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[1]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[2]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 2
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[3]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 3
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[4]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 4
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[5]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 5
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[6]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 6
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[7]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 7
|—————————————Node:] Text: ]
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_lock
|———————————Node:argument_list Text: (&_ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.mutex
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
|——————————Node:call_expression Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid)
|———————————Node:identifier Text: remove_blocked_client
|———————————Node:argument_list Text: (&_ocb->rx.blocked_clients, ctp->rcvid)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.blocked_clients
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: blocked_clients
|————————————Node:, Text: ,
|————————————Node:field_expression Text: ctp->rcvid
|—————————————Node:identifier Text: ctp
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rcvid
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_unlock
|———————————Node:argument_list Text: (&_ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.mutex
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }
|—————————Node:else Text: else
|—————————Node:compound_statement Text: {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY;
        }
|——————————Node:{ Text: {
|——————————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|———————————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|————————————Node:identifier Text: pthread_mutex_lock
|————————————Node:argument_list Text: (&_ocb->rx.mutex)
|—————————————Node:( Text: (
|—————————————Node:pointer_expression Text: &_ocb->rx.mutex
|——————————————Node:& Text: &
|——————————————Node:field_expression Text: _ocb->rx.mutex
|———————————————Node:field_expression Text: _ocb->rx
|————————————————Node:identifier Text: _ocb
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: rx
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: mutex
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:declaration Text: blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
|———————————Node:type_identifier Text: blocked_client_t
|———————————Node:init_declarator Text: * new_block = malloc(sizeof(blocked_client_t))
|————————————Node:pointer_declarator Text: * new_block
|—————————————Node:* Text: *
|—————————————Node:identifier Text: new_block
|————————————Node:= Text: =
|————————————Node:call_expression Text: malloc(sizeof(blocked_client_t))
|—————————————Node:identifier Text: malloc
|—————————————Node:argument_list Text: (sizeof(blocked_client_t))
|——————————————Node:( Text: (
|——————————————Node:sizeof_expression Text: sizeof(blocked_client_t)
|———————————————Node:sizeof Text: sizeof
|———————————————Node:parenthesized_expression Text: (blocked_client_t)
|————————————————Node:( Text: (
|————————————————Node:identifier Text: blocked_client_t
|————————————————Node:) Text: )
|——————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: new_block->prev = new_block->next = NULL;
|———————————Node:assignment_expression Text: new_block->prev = new_block->next = NULL
|————————————Node:field_expression Text: new_block->prev
|—————————————Node:identifier Text: new_block
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: prev
|————————————Node:= Text: =
|————————————Node:assignment_expression Text: new_block->next = NULL
|—————————————Node:field_expression Text: new_block->next
|——————————————Node:identifier Text: new_block
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: next
|—————————————Node:= Text: =
|—————————————Node:null Text: NULL
|——————————————Node:NULL Text: NULL
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: new_block->rcvid = ctp->rcvid;
|———————————Node:assignment_expression Text: new_block->rcvid = ctp->rcvid
|————————————Node:field_expression Text: new_block->rcvid
|—————————————Node:identifier Text: new_block
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rcvid
|————————————Node:= Text: =
|————————————Node:field_expression Text: ctp->rcvid
|—————————————Node:identifier Text: ctp
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rcvid
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block);
|———————————Node:call_expression Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block)
|————————————Node:identifier Text: store_blocked_client
|————————————Node:argument_list Text: (&_ocb->rx.blocked_clients, new_block)
|—————————————Node:( Text: (
|—————————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|——————————————Node:& Text: &
|——————————————Node:field_expression Text: _ocb->rx.blocked_clients
|———————————————Node:field_expression Text: _ocb->rx
|————————————————Node:identifier Text: _ocb
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: rx
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: blocked_clients
|—————————————Node:, Text: ,
|—————————————Node:identifier Text: new_block
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: pthread_cond_signal(&_ocb->rx.cond);
|———————————Node:call_expression Text: pthread_cond_signal(&_ocb->rx.cond)
|————————————Node:identifier Text: pthread_cond_signal
|————————————Node:argument_list Text: (&_ocb->rx.cond)
|—————————————Node:( Text: (
|—————————————Node:pointer_expression Text: &_ocb->rx.cond
|——————————————Node:& Text: &
|——————————————Node:field_expression Text: _ocb->rx.cond
|———————————————Node:field_expression Text: _ocb->rx
|————————————————Node:identifier Text: _ocb
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: rx
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: cond
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|———————————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|————————————Node:identifier Text: pthread_mutex_unlock
|————————————Node:argument_list Text: (&_ocb->rx.mutex)
|—————————————Node:( Text: (
|—————————————Node:pointer_expression Text: &_ocb->rx.mutex
|——————————————Node:& Text: &
|——————————————Node:field_expression Text: _ocb->rx.mutex
|———————————————Node:field_expression Text: _ocb->rx
|————————————————Node:identifier Text: _ocb
|————————————————Node:-> Text: ->
|————————————————Node:field_identifier Text: rx
|———————————————Node:. Text: .
|———————————————Node:field_identifier Text: mutex
|—————————————Node:) Text: )
|———————————Node:; Text: ;
|——————————Node:return_statement Text: return _RESMGR_NOREPLY;
|———————————Node:return Text: return
|———————————Node:identifier Text: _RESMGR_NOREPLY
|———————————Node:; Text: ;
|——————————Node:} Text: }
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_WRITE_CANMSG_EXT: // e.g. canctl -u0,rx0 -w0x22,1,0x55
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_WRITE_CANMSG_EXT
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,rx0 -w0x22,1,0x55
|——————Node:compound_statement Text: {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == RX_CHANNEL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: _ocb->resmgr->channel_type == RX_CHANNEL
|——————————Node:field_expression Text: _ocb->resmgr->channel_type
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: channel_type
|——————————Node:== Text: ==
|——————————Node:identifier Text: RX_CHANNEL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            return EIO; // Input/output error
        }
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return EIO;
|——————————Node:return Text: return
|——————————Node:identifier Text: EIO
|——————————Node:; Text: ;
|—————————Node:comment Text: // Input/output error
|—————————Node:} Text: }
|———————Node:declaration Text: struct can_msg canmsg = data->dcmd.canmsg;
|————————Node:struct_specifier Text: struct can_msg
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_msg
|————————Node:init_declarator Text: canmsg = data->dcmd.canmsg
|—————————Node:identifier Text: canmsg
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.canmsg
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: canmsg
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
|————————Node:call_expression Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg)
|—————————Node:identifier Text: enqueue
|—————————Node:argument_list Text: (&_ocb->resmgr->device_session->tx_queue, &canmsg)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &_ocb->resmgr->device_session->tx_queue
|———————————Node:& Text: &
|———————————Node:field_expression Text: _ocb->resmgr->device_session->tx_queue
|————————————Node:field_expression Text: _ocb->resmgr->device_session
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: device_session
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: tx_queue
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &canmsg
|———————————Node:& Text: &
|———————————Node:identifier Text: canmsg
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7])
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7])
|——————————Node:( Text: (
|——————————Node:concatenated_string Text: "CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|———————————Node:string_literal Text: "CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] "
|————————————Node:" Text: "
|————————————Node:string_content Text: CAN_DEVCTL_WRITE_CANMSG_EXT; %s TS: %ums [%s] %X [%d] 
|————————————Node:" Text: "
|———————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->name
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.ext.timestamp
|———————————Node:field_expression Text: canmsg.ext
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: ext
|———————————Node:. Text: .
|———————————Node:field_identifier Text: timestamp
|——————————Node:, Text: ,
|——————————Node:conditional_expression Text: canmsg.ext.is_extended_mid ? "EFF" : "SFF"
|———————————Node:field_expression Text: canmsg.ext.is_extended_mid
|————————————Node:field_expression Text: canmsg.ext
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: ext
|————————————Node:. Text: .
|————————————Node:field_identifier Text: is_extended_mid
|———————————Node:? Text: ?
|———————————Node:string_literal Text: "EFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: EFF
|————————————Node:" Text: "
|———————————Node:: Text: :
|———————————Node:string_literal Text: "SFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: SFF
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.mid
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mid
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[0]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 0
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[1]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[2]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 2
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[3]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 3
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[4]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 4
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[5]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 5
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[6]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 6
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[7]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 7
|———————————Node:] Text: ]
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_ERROR: // e.g. canctl -u0,rx0 -e
    {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_ERROR
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,rx0 -e
|——————Node:compound_statement Text: {
        data->dcmd.error.drvr1 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr2 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr3 = 0x0; // set DRIVER ERROR 1
        data->dcmd.error.drvr4 = 0x0; // set DRIVER ERROR 1
        nbytes = sizeof(data->dcmd.error);

        log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: data->dcmd.error.drvr1 = 0x0;
|————————Node:assignment_expression Text: data->dcmd.error.drvr1 = 0x0
|—————————Node:field_expression Text: data->dcmd.error.drvr1
|——————————Node:field_expression Text: data->dcmd.error
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: error
|——————————Node:. Text: .
|——————————Node:field_identifier Text: drvr1
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0x0
|————————Node:; Text: ;
|———————Node:comment Text: // set DRIVER ERROR 1
|———————Node:expression_statement Text: data->dcmd.error.drvr2 = 0x0;
|————————Node:assignment_expression Text: data->dcmd.error.drvr2 = 0x0
|—————————Node:field_expression Text: data->dcmd.error.drvr2
|——————————Node:field_expression Text: data->dcmd.error
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: error
|——————————Node:. Text: .
|——————————Node:field_identifier Text: drvr2
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0x0
|————————Node:; Text: ;
|———————Node:comment Text: // set DRIVER ERROR 1
|———————Node:expression_statement Text: data->dcmd.error.drvr3 = 0x0;
|————————Node:assignment_expression Text: data->dcmd.error.drvr3 = 0x0
|—————————Node:field_expression Text: data->dcmd.error.drvr3
|——————————Node:field_expression Text: data->dcmd.error
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: error
|——————————Node:. Text: .
|——————————Node:field_identifier Text: drvr3
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0x0
|————————Node:; Text: ;
|———————Node:comment Text: // set DRIVER ERROR 1
|———————Node:expression_statement Text: data->dcmd.error.drvr4 = 0x0;
|————————Node:assignment_expression Text: data->dcmd.error.drvr4 = 0x0
|—————————Node:field_expression Text: data->dcmd.error.drvr4
|——————————Node:field_expression Text: data->dcmd.error
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: error
|——————————Node:. Text: .
|——————————Node:field_identifier Text: drvr4
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0x0
|————————Node:; Text: ;
|———————Node:comment Text: // set DRIVER ERROR 1
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.error);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.error)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.error)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.error)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.error
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: error
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_ERROR: %x %x %x %x\n",
                data->dcmd.error.drvr1,
                data->dcmd.error.drvr2,
                data->dcmd.error.drvr3,
                data->dcmd.error.drvr4)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_ERROR: %x %x %x %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_ERROR: %x %x %x %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.error.drvr1
|———————————Node:field_expression Text: data->dcmd.error
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: error
|———————————Node:. Text: .
|———————————Node:field_identifier Text: drvr1
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.error.drvr2
|———————————Node:field_expression Text: data->dcmd.error
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: error
|———————————Node:. Text: .
|———————————Node:field_identifier Text: drvr2
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.error.drvr3
|———————————Node:field_expression Text: data->dcmd.error
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: error
|———————————Node:. Text: .
|———————————Node:field_identifier Text: drvr3
|——————————Node:, Text: ,
|——————————Node:field_expression Text: data->dcmd.error.drvr4
|———————————Node:field_expression Text: data->dcmd.error
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: error
|———————————Node:. Text: .
|———————————Node:field_identifier Text: drvr4
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_DEBUG_INFO: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_DEBUG_INFO
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
|——————Node:compound_statement Text: {
        nbytes = 0;

        log_err("Some debug info to stderr (& syslog)\n");
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_err("Some debug info to stderr (& syslog)\n");
|————————Node:call_expression Text: log_err("Some debug info to stderr (& syslog)\n")
|—————————Node:identifier Text: log_err
|—————————Node:argument_list Text: ("Some debug info to stderr (& syslog)\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "Some debug info to stderr (& syslog)\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: Some debug info to stderr (& syslog)
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_DEBUG_INFO2: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
    {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_DEBUG_INFO2
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -d # Some strange behaviour INFO vs INFO2
|——————Node:compound_statement Text: {
        u32 debug = data->info2;
        nbytes = 0;

        log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: u32 debug = data->info2;
|————————Node:type_identifier Text: u32
|————————Node:init_declarator Text: debug = data->info2
|—————————Node:identifier Text: debug
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->info2
|——————————Node:identifier Text: data
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: info2
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug)
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_DEBUG_INFO2: %x\n", debug)
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_DEBUG_INFO2: %x\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_DEBUG_INFO2: %x
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:identifier Text: debug
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_GET_STATS: // e.g. canctl -s
    {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_STATS
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -s
|——————Node:compound_statement Text: {
        nbytes = sizeof(data->dcmd.stats);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct sja1000_priv* priv = netdev_priv(device);

        data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
        data->dcmd.stats.received_frames = device->stats.rx_packets;
        data->dcmd.stats.missing_ack = device->stats.tx_dropped;

        /* Bus errors */
        data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;

        /* Arbitration lost errors */
        data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;

        data->dcmd.stats.form_errors = 0;
        data->dcmd.stats.dom_bit_recess_errors = 0;
        data->dcmd.stats.recess_bit_dom_errors = 0;
        data->dcmd.stats.parity_errors = 0;
        data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
        data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
        data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;

        /* Changes to error warning state */
        data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;

        /* Changes to error passive state */
        data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;

        /* Changes to bus off state */
        data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;

        data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;

        /* CAN controller re-starts */
        data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;

        data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
        data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
        data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;

        // TODO: These may need to be incremented on resmgr side:
        // device->stats.rx_bytes;
        // device->stats.tx_bytes;
        // device->stats.rx_dropped;
        // device->stats.tx_dropped;
        // device->stats.multicast;
        // device->stats.collisions;
        // device->stats.rx_length_errors;
        // device->stats.rx_frame_errors;
        // device->stats.rx_fifo_errors;
        // device->stats.rx_missed_errors;
        // device->stats.tx_aborted_errors;
        // device->stats.tx_carrier_errors;
        // device->stats.tx_fifo_errors;
        // device->stats.tx_heartbeat_errors;
        // device->stats.tx_window_errors;
        // device->stats.rx_compressed;
        // device->stats.tx_compressed;

        log_trace("CAN_DEVCTL_GET_STATS\n");
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.stats);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.stats)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.stats)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.stats)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.stats
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: stats
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: struct net_device* device = _ocb->resmgr->device_session->device;
|————————Node:struct_specifier Text: struct net_device
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: net_device
|————————Node:init_declarator Text: * device = _ocb->resmgr->device_session->device
|—————————Node:pointer_declarator Text: * device
|——————————Node:* Text: *
|——————————Node:identifier Text: device
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->device_session->device
|——————————Node:field_expression Text: _ocb->resmgr->device_session
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: device_session
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: device
|————————Node:; Text: ;
|———————Node:declaration Text: struct sja1000_priv* priv = netdev_priv(device);
|————————Node:struct_specifier Text: struct sja1000_priv
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: sja1000_priv
|————————Node:init_declarator Text: * priv = netdev_priv(device)
|—————————Node:pointer_declarator Text: * priv
|——————————Node:* Text: *
|——————————Node:identifier Text: priv
|—————————Node:= Text: =
|—————————Node:call_expression Text: netdev_priv(device)
|——————————Node:identifier Text: netdev_priv
|——————————Node:argument_list Text: (device)
|———————————Node:( Text: (
|———————————Node:identifier Text: device
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.transmitted_frames = device->stats.tx_packets;
|————————Node:assignment_expression Text: data->dcmd.stats.transmitted_frames = device->stats.tx_packets
|—————————Node:field_expression Text: data->dcmd.stats.transmitted_frames
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: transmitted_frames
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.tx_packets
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tx_packets
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.received_frames = device->stats.rx_packets;
|————————Node:assignment_expression Text: data->dcmd.stats.received_frames = device->stats.rx_packets
|—————————Node:field_expression Text: data->dcmd.stats.received_frames
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: received_frames
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.rx_packets
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_packets
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.missing_ack = device->stats.tx_dropped;
|————————Node:assignment_expression Text: data->dcmd.stats.missing_ack = device->stats.tx_dropped
|—————————Node:field_expression Text: data->dcmd.stats.missing_ack
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: missing_ack
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.tx_dropped
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tx_dropped
|————————Node:; Text: ;
|———————Node:comment Text: /* Bus errors */
|———————Node:expression_statement Text: data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.total_frame_errors =
            device->stats.rx_errors + device->stats.tx_errors
|—————————Node:field_expression Text: data->dcmd.stats.total_frame_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: total_frame_errors
|—————————Node:= Text: =
|—————————Node:binary_expression Text: device->stats.rx_errors + device->stats.tx_errors
|——————————Node:field_expression Text: device->stats.rx_errors
|———————————Node:field_expression Text: device->stats
|————————————Node:identifier Text: device
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: rx_errors
|——————————Node:+ Text: +
|——————————Node:field_expression Text: device->stats.tx_errors
|———————————Node:field_expression Text: device->stats
|————————————Node:identifier Text: device
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tx_errors
|————————Node:; Text: ;
|———————Node:comment Text: /* Arbitration lost errors */
|———————Node:expression_statement Text: data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost;
|————————Node:assignment_expression Text: data->dcmd.stats.stuff_errors = priv->can.can_stats.arbitration_lost
|—————————Node:field_expression Text: data->dcmd.stats.stuff_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: stuff_errors
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->can.can_stats.arbitration_lost
|——————————Node:field_expression Text: priv->can.can_stats
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: can_stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: arbitration_lost
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.form_errors = 0;
|————————Node:assignment_expression Text: data->dcmd.stats.form_errors = 0
|—————————Node:field_expression Text: data->dcmd.stats.form_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: form_errors
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.dom_bit_recess_errors = 0;
|————————Node:assignment_expression Text: data->dcmd.stats.dom_bit_recess_errors = 0
|—————————Node:field_expression Text: data->dcmd.stats.dom_bit_recess_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: dom_bit_recess_errors
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.recess_bit_dom_errors = 0;
|————————Node:assignment_expression Text: data->dcmd.stats.recess_bit_dom_errors = 0
|—————————Node:field_expression Text: data->dcmd.stats.recess_bit_dom_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: recess_bit_dom_errors
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.parity_errors = 0;
|————————Node:assignment_expression Text: data->dcmd.stats.parity_errors = 0
|—————————Node:field_expression Text: data->dcmd.stats.parity_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: parity_errors
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.crc_errors = device->stats.rx_crc_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.crc_errors = device->stats.rx_crc_errors
|—————————Node:field_expression Text: data->dcmd.stats.crc_errors
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: crc_errors
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.rx_crc_errors
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_crc_errors
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.hw_receive_overflows = device->stats.rx_over_errors
|—————————Node:field_expression Text: data->dcmd.stats.hw_receive_overflows
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: hw_receive_overflows
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.rx_over_errors
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_over_errors
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped;
|————————Node:assignment_expression Text: data->dcmd.stats.sw_receive_q_full = device->stats.rx_dropped
|—————————Node:field_expression Text: data->dcmd.stats.sw_receive_q_full
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sw_receive_q_full
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.rx_dropped
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_dropped
|————————Node:; Text: ;
|———————Node:comment Text: /* Changes to error warning state */
|———————Node:expression_statement Text: data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning;
|————————Node:assignment_expression Text: data->dcmd.stats.error_warning_state_count =
            priv->can.can_stats.error_warning
|—————————Node:field_expression Text: data->dcmd.stats.error_warning_state_count
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: error_warning_state_count
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->can.can_stats.error_warning
|——————————Node:field_expression Text: priv->can.can_stats
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: can_stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: error_warning
|————————Node:; Text: ;
|———————Node:comment Text: /* Changes to error passive state */
|———————Node:expression_statement Text: data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive;
|————————Node:assignment_expression Text: data->dcmd.stats.error_passive_state_count =
            priv->can.can_stats.error_passive
|—————————Node:field_expression Text: data->dcmd.stats.error_passive_state_count
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: error_passive_state_count
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->can.can_stats.error_passive
|——————————Node:field_expression Text: priv->can.can_stats
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: can_stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: error_passive
|————————Node:; Text: ;
|———————Node:comment Text: /* Changes to bus off state */
|———————Node:expression_statement Text: data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off;
|————————Node:assignment_expression Text: data->dcmd.stats.bus_off_state_count = priv->can.can_stats.bus_off
|—————————Node:field_expression Text: data->dcmd.stats.bus_off_state_count
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bus_off_state_count
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->can.can_stats.bus_off
|——————————Node:field_expression Text: priv->can.can_stats
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: can_stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bus_off
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error;
|————————Node:assignment_expression Text: data->dcmd.stats.bus_idle_count = priv->can.can_stats.bus_error
|—————————Node:field_expression Text: data->dcmd.stats.bus_idle_count
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bus_idle_count
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->can.can_stats.bus_error
|——————————Node:field_expression Text: priv->can.can_stats
|———————————Node:field_expression Text: priv->can
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: can
|———————————Node:. Text: .
|———————————Node:field_identifier Text: can_stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bus_error
|————————Node:; Text: ;
|———————Node:comment Text: /* CAN controller re-starts */
|———————Node:expression_statement Text: data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts;
|————————Node:assignment_expression Text: data->dcmd.stats.power_down_count =
            data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts
|—————————Node:field_expression Text: data->dcmd.stats.power_down_count
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: power_down_count
|—————————Node:= Text: =
|—————————Node:assignment_expression Text: data->dcmd.stats.wake_up_count = priv->can.can_stats.restarts
|——————————Node:field_expression Text: data->dcmd.stats.wake_up_count
|———————————Node:field_expression Text: data->dcmd.stats
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: wake_up_count
|——————————Node:= Text: =
|——————————Node:field_expression Text: priv->can.can_stats.restarts
|———————————Node:field_expression Text: priv->can.can_stats
|————————————Node:field_expression Text: priv->can
|—————————————Node:identifier Text: priv
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: can
|————————————Node:. Text: .
|————————————Node:field_identifier Text: can_stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: restarts
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.rx_interrupts = device->stats.rx_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.rx_interrupts = device->stats.rx_errors
|—————————Node:field_expression Text: data->dcmd.stats.rx_interrupts
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_interrupts
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.rx_errors
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: rx_errors
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.tx_interrupts = device->stats.tx_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.tx_interrupts = device->stats.tx_errors
|—————————Node:field_expression Text: data->dcmd.stats.tx_interrupts
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tx_interrupts
|—————————Node:= Text: =
|—————————Node:field_expression Text: device->stats.tx_errors
|——————————Node:field_expression Text: device->stats
|———————————Node:identifier Text: device
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: tx_errors
|————————Node:; Text: ;
|———————Node:expression_statement Text: data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors;
|————————Node:assignment_expression Text: data->dcmd.stats.total_interrupts =
            device->stats.rx_errors + device->stats.tx_errors
|—————————Node:field_expression Text: data->dcmd.stats.total_interrupts
|——————————Node:field_expression Text: data->dcmd.stats
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: stats
|——————————Node:. Text: .
|——————————Node:field_identifier Text: total_interrupts
|—————————Node:= Text: =
|—————————Node:binary_expression Text: device->stats.rx_errors + device->stats.tx_errors
|——————————Node:field_expression Text: device->stats.rx_errors
|———————————Node:field_expression Text: device->stats
|————————————Node:identifier Text: device
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: rx_errors
|——————————Node:+ Text: +
|——————————Node:field_expression Text: device->stats.tx_errors
|———————————Node:field_expression Text: device->stats
|————————————Node:identifier Text: device
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: stats
|———————————Node:. Text: .
|———————————Node:field_identifier Text: tx_errors
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: These may need to be incremented on resmgr side:
|———————Node:comment Text: // device->stats.rx_bytes;
|———————Node:comment Text: // device->stats.tx_bytes;
|———————Node:comment Text: // device->stats.rx_dropped;
|———————Node:comment Text: // device->stats.tx_dropped;
|———————Node:comment Text: // device->stats.multicast;
|———————Node:comment Text: // device->stats.collisions;
|———————Node:comment Text: // device->stats.rx_length_errors;
|———————Node:comment Text: // device->stats.rx_frame_errors;
|———————Node:comment Text: // device->stats.rx_fifo_errors;
|———————Node:comment Text: // device->stats.rx_missed_errors;
|———————Node:comment Text: // device->stats.tx_aborted_errors;
|———————Node:comment Text: // device->stats.tx_carrier_errors;
|———————Node:comment Text: // device->stats.tx_fifo_errors;
|———————Node:comment Text: // device->stats.tx_heartbeat_errors;
|———————Node:comment Text: // device->stats.tx_window_errors;
|———————Node:comment Text: // device->stats.rx_compressed;
|———————Node:comment Text: // device->stats.tx_compressed;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_STATS\n");
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_STATS\n")
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_STATS\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_STATS\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_STATS
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_GET_INFO: // e.g. canctl -u0,rx0 -i
    {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_GET_INFO
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,rx0 -i
|——————Node:compound_statement Text: {
        nbytes = sizeof(data->dcmd.info);

        struct net_device* device = _ocb->resmgr->device_session->device;
        struct can_priv* priv = netdev_priv(device);

        /* CAN device description */
        snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );

        /* Number of message queue objects */
        data->dcmd.info.msgq_size = 0; // TODO: set msgq_size

        /* Number of client wait queue objects */
        data->dcmd.info.waitq_size = 0; // TODO: set waitq_size

        /* CAN driver mode - I/O or raw frames */
        data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;

        /* Bit rate */
        data->dcmd.info.bit_rate = priv->bittiming.bitrate;

        /* Bit rate prescaler */
        data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;

        /* Time quantum Sync Jump Width */
        data->dcmd.info.sync_jump_width = priv->bittiming.sjw;

        /* Time quantum Time Segment 1 */
        data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;

        /* Time quantum Time Segment 2 */
        data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;

        /* Number of TX Mailboxes */
        data->dcmd.info.num_tx_mboxes = 0; // TODO: set num_tx_mboxes

        /* Number of RX Mailboxes */
        data->dcmd.info.num_rx_mboxes = 0; // TODO: set num_rx_mboxes

        /* External loopback is enabled */
        data->dcmd.info.loopback_external = 0; // TODO: set loopback_external

        /* Internal loopback is enabled */
        data->dcmd.info.loopback_internal = optE; // TODO: check meaning of this

        /* Auto timed bus on after bus off */
        data->dcmd.info.autobus_on = 0; // TODO: set autobus_on

        /* Receiver only, no ack generation */
        data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);

        log_trace("CAN_DEVCTL_GET_INFO\n");
        break;
    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: nbytes = sizeof(data->dcmd.info);
|————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.info)
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:sizeof_expression Text: sizeof(data->dcmd.info)
|——————————Node:sizeof Text: sizeof
|——————————Node:parenthesized_expression Text: (data->dcmd.info)
|———————————Node:( Text: (
|———————————Node:field_expression Text: data->dcmd.info
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: info
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: struct net_device* device = _ocb->resmgr->device_session->device;
|————————Node:struct_specifier Text: struct net_device
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: net_device
|————————Node:init_declarator Text: * device = _ocb->resmgr->device_session->device
|—————————Node:pointer_declarator Text: * device
|——————————Node:* Text: *
|——————————Node:identifier Text: device
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->device_session->device
|——————————Node:field_expression Text: _ocb->resmgr->device_session
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: device_session
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: device
|————————Node:; Text: ;
|———————Node:declaration Text: struct can_priv* priv = netdev_priv(device);
|————————Node:struct_specifier Text: struct can_priv
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_priv
|————————Node:init_declarator Text: * priv = netdev_priv(device)
|—————————Node:pointer_declarator Text: * priv
|——————————Node:* Text: *
|——————————Node:identifier Text: priv
|—————————Node:= Text: =
|—————————Node:call_expression Text: netdev_priv(device)
|——————————Node:identifier Text: netdev_priv
|——————————Node:argument_list Text: (device)
|———————————Node:( Text: (
|———————————Node:identifier Text: device
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: /* CAN device description */
|———————Node:expression_statement Text: snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name );
|————————Node:call_expression Text: snprintf( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name )
|—————————Node:identifier Text: snprintf
|—————————Node:argument_list Text: ( data->dcmd.info.description, 64,
                "dev-can-linux dev: %s, driver: %s",
                _ocb->resmgr->name,
                _ocb->resmgr->driver_selection->driver->name )
|——————————Node:( Text: (
|——————————Node:field_expression Text: data->dcmd.info.description
|———————————Node:field_expression Text: data->dcmd.info
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: info
|———————————Node:. Text: .
|———————————Node:field_identifier Text: description
|——————————Node:, Text: ,
|——————————Node:number_literal Text: 64
|——————————Node:, Text: ,
|——————————Node:string_literal Text: "dev-can-linux dev: %s, driver: %s"
|———————————Node:" Text: "
|———————————Node:string_content Text: dev-can-linux dev: %s, driver: %s
|———————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->name
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->driver_selection->driver->name
|———————————Node:field_expression Text: _ocb->resmgr->driver_selection->driver
|————————————Node:field_expression Text: _ocb->resmgr->driver_selection
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: driver_selection
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: driver
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:comment Text: /* Number of message queue objects */
|———————Node:expression_statement Text: data->dcmd.info.msgq_size = 0;
|————————Node:assignment_expression Text: data->dcmd.info.msgq_size = 0
|—————————Node:field_expression Text: data->dcmd.info.msgq_size
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: msgq_size
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set msgq_size
|———————Node:comment Text: /* Number of client wait queue objects */
|———————Node:expression_statement Text: data->dcmd.info.waitq_size = 0;
|————————Node:assignment_expression Text: data->dcmd.info.waitq_size = 0
|—————————Node:field_expression Text: data->dcmd.info.waitq_size
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: waitq_size
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set waitq_size
|———————Node:comment Text: /* CAN driver mode - I/O or raw frames */
|———————Node:expression_statement Text: data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME;
|————————Node:assignment_expression Text: data->dcmd.info.mode = CANDEV_MODE_RAW_FRAME
|—————————Node:field_expression Text: data->dcmd.info.mode
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: mode
|—————————Node:= Text: =
|—————————Node:identifier Text: CANDEV_MODE_RAW_FRAME
|————————Node:; Text: ;
|———————Node:comment Text: /* Bit rate */
|———————Node:expression_statement Text: data->dcmd.info.bit_rate = priv->bittiming.bitrate;
|————————Node:assignment_expression Text: data->dcmd.info.bit_rate = priv->bittiming.bitrate
|—————————Node:field_expression Text: data->dcmd.info.bit_rate
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bit_rate
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->bittiming.bitrate
|——————————Node:field_expression Text: priv->bittiming
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bittiming
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitrate
|————————Node:; Text: ;
|———————Node:comment Text: /* Bit rate prescaler */
|———————Node:expression_statement Text: data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp;
|————————Node:assignment_expression Text: data->dcmd.info.bit_rate_prescaler = priv->bittiming.brp
|—————————Node:field_expression Text: data->dcmd.info.bit_rate_prescaler
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bit_rate_prescaler
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->bittiming.brp
|——————————Node:field_expression Text: priv->bittiming
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bittiming
|——————————Node:. Text: .
|——————————Node:field_identifier Text: brp
|————————Node:; Text: ;
|———————Node:comment Text: /* Time quantum Sync Jump Width */
|———————Node:expression_statement Text: data->dcmd.info.sync_jump_width = priv->bittiming.sjw;
|————————Node:assignment_expression Text: data->dcmd.info.sync_jump_width = priv->bittiming.sjw
|—————————Node:field_expression Text: data->dcmd.info.sync_jump_width
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sync_jump_width
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->bittiming.sjw
|——————————Node:field_expression Text: priv->bittiming
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bittiming
|——————————Node:. Text: .
|——————————Node:field_identifier Text: sjw
|————————Node:; Text: ;
|———————Node:comment Text: /* Time quantum Time Segment 1 */
|———————Node:expression_statement Text: data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1;
|————————Node:assignment_expression Text: data->dcmd.info.time_segment_1 = priv->bittiming.phase_seg1
|—————————Node:field_expression Text: data->dcmd.info.time_segment_1
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: time_segment_1
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->bittiming.phase_seg1
|——————————Node:field_expression Text: priv->bittiming
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bittiming
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg1
|————————Node:; Text: ;
|———————Node:comment Text: /* Time quantum Time Segment 2 */
|———————Node:expression_statement Text: data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2;
|————————Node:assignment_expression Text: data->dcmd.info.time_segment_2 = priv->bittiming.phase_seg2
|—————————Node:field_expression Text: data->dcmd.info.time_segment_2
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: time_segment_2
|—————————Node:= Text: =
|—————————Node:field_expression Text: priv->bittiming.phase_seg2
|——————————Node:field_expression Text: priv->bittiming
|———————————Node:identifier Text: priv
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: bittiming
|——————————Node:. Text: .
|——————————Node:field_identifier Text: phase_seg2
|————————Node:; Text: ;
|———————Node:comment Text: /* Number of TX Mailboxes */
|———————Node:expression_statement Text: data->dcmd.info.num_tx_mboxes = 0;
|————————Node:assignment_expression Text: data->dcmd.info.num_tx_mboxes = 0
|—————————Node:field_expression Text: data->dcmd.info.num_tx_mboxes
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: num_tx_mboxes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set num_tx_mboxes
|———————Node:comment Text: /* Number of RX Mailboxes */
|———————Node:expression_statement Text: data->dcmd.info.num_rx_mboxes = 0;
|————————Node:assignment_expression Text: data->dcmd.info.num_rx_mboxes = 0
|—————————Node:field_expression Text: data->dcmd.info.num_rx_mboxes
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: num_rx_mboxes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set num_rx_mboxes
|———————Node:comment Text: /* External loopback is enabled */
|———————Node:expression_statement Text: data->dcmd.info.loopback_external = 0;
|————————Node:assignment_expression Text: data->dcmd.info.loopback_external = 0
|—————————Node:field_expression Text: data->dcmd.info.loopback_external
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: loopback_external
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set loopback_external
|———————Node:comment Text: /* Internal loopback is enabled */
|———————Node:expression_statement Text: data->dcmd.info.loopback_internal = optE;
|————————Node:assignment_expression Text: data->dcmd.info.loopback_internal = optE
|—————————Node:field_expression Text: data->dcmd.info.loopback_internal
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: loopback_internal
|—————————Node:= Text: =
|—————————Node:identifier Text: optE
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: check meaning of this
|———————Node:comment Text: /* Auto timed bus on after bus off */
|———————Node:expression_statement Text: data->dcmd.info.autobus_on = 0;
|————————Node:assignment_expression Text: data->dcmd.info.autobus_on = 0
|—————————Node:field_expression Text: data->dcmd.info.autobus_on
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: autobus_on
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:comment Text: // TODO: set autobus_on
|———————Node:comment Text: /* Receiver only, no ack generation */
|———————Node:expression_statement Text: data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0);
|————————Node:assignment_expression Text: data->dcmd.info.silent =
            (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0)
|—————————Node:field_expression Text: data->dcmd.info.silent
|——————————Node:field_expression Text: data->dcmd.info
|———————————Node:field_expression Text: data->dcmd
|————————————Node:identifier Text: data
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: dcmd
|———————————Node:. Text: .
|———————————Node:field_identifier Text: info
|——————————Node:. Text: .
|——————————Node:field_identifier Text: silent
|—————————Node:= Text: =
|—————————Node:parenthesized_expression Text: (priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0)
|——————————Node:( Text: (
|——————————Node:conditional_expression Text: priv->ctrlmode & CAN_CTRLMODE_LISTENONLY ? 1 : 0
|———————————Node:binary_expression Text: priv->ctrlmode & CAN_CTRLMODE_LISTENONLY
|————————————Node:field_expression Text: priv->ctrlmode
|—————————————Node:identifier Text: priv
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: ctrlmode
|————————————Node:& Text: &
|————————————Node:identifier Text: CAN_CTRLMODE_LISTENONLY
|———————————Node:? Text: ?
|———————————Node:number_literal Text: 1
|———————————Node:: Text: :
|———————————Node:number_literal Text: 0
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_GET_INFO\n");
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_GET_INFO\n")
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_GET_INFO\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_GET_INFO\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_GET_INFO
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_SET_TIMING: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
                                // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
                                // e.g. canctl -u0,rx0 -c 0,1,3,2,1
                                //          reference clock don't change if '0'
    {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_SET_TIMING
|——————Node:: Text: :
|——————Node:comment Text: // e.g. canctl -u0,rx0 -c 250k,2,7,2,1
|——————Node:comment Text: // e.g. canctl -u0,rx0 -c 1M,1,3,2,1
|——————Node:comment Text: // e.g. canctl -u0,rx0 -c 0,1,3,2,1
|——————Node:comment Text: //          reference clock don't change if '0'
|——————Node:compound_statement Text: {
        struct can_devctl_timing timing = data->dcmd.timing;
        nbytes = 0;

        struct net_device* device = _ocb->resmgr->device_session->device;

        struct can_priv* priv = netdev_priv(device);

        if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }

        struct user_dev_setup user;
        create_user_dev_setup(&timing, priv->clock.freq, &user);

        int err;

        device->flags &= ~IFF_UP;

        if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }

        device->flags |= IFF_UP;

        log_trace("CAN_DEVCTL_SET_TIMING: success\n");
        log_trace_bittiming_info(device);

        break;
    }
|———————Node:{ Text: {
|———————Node:declaration Text: struct can_devctl_timing timing = data->dcmd.timing;
|————————Node:struct_specifier Text: struct can_devctl_timing
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_devctl_timing
|————————Node:init_declarator Text: timing = data->dcmd.timing
|—————————Node:identifier Text: timing
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.timing
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: timing
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:declaration Text: struct net_device* device = _ocb->resmgr->device_session->device;
|————————Node:struct_specifier Text: struct net_device
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: net_device
|————————Node:init_declarator Text: * device = _ocb->resmgr->device_session->device
|—————————Node:pointer_declarator Text: * device
|——————————Node:* Text: *
|——————————Node:identifier Text: device
|—————————Node:= Text: =
|—————————Node:field_expression Text: _ocb->resmgr->device_session->device
|——————————Node:field_expression Text: _ocb->resmgr->device_session
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: device_session
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: device
|————————Node:; Text: ;
|———————Node:declaration Text: struct can_priv* priv = netdev_priv(device);
|————————Node:struct_specifier Text: struct can_priv
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_priv
|————————Node:init_declarator Text: * priv = netdev_priv(device)
|—————————Node:pointer_declarator Text: * priv
|——————————Node:* Text: *
|——————————Node:identifier Text: priv
|—————————Node:= Text: =
|—————————Node:call_expression Text: netdev_priv(device)
|——————————Node:identifier Text: netdev_priv
|——————————Node:argument_list Text: (device)
|———————————Node:( Text: (
|———————————Node:identifier Text: device
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (!timing.ref_clock_freq) {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (!timing.ref_clock_freq)
|—————————Node:( Text: (
|—————————Node:unary_expression Text: !timing.ref_clock_freq
|——————————Node:! Text: !
|——————————Node:field_expression Text: timing.ref_clock_freq
|———————————Node:identifier Text: timing
|———————————Node:. Text: .
|———————————Node:field_identifier Text: ref_clock_freq
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            timing.ref_clock_freq = priv->bittiming.bitrate;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: timing.ref_clock_freq = priv->bittiming.bitrate;
|——————————Node:assignment_expression Text: timing.ref_clock_freq = priv->bittiming.bitrate
|———————————Node:field_expression Text: timing.ref_clock_freq
|————————————Node:identifier Text: timing
|————————————Node:. Text: .
|————————————Node:field_identifier Text: ref_clock_freq
|———————————Node:= Text: =
|———————————Node:field_expression Text: priv->bittiming.bitrate
|————————————Node:field_expression Text: priv->bittiming
|—————————————Node:identifier Text: priv
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: bittiming
|————————————Node:. Text: .
|————————————Node:field_identifier Text: bitrate
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:declaration Text: struct user_dev_setup user;
|————————Node:struct_specifier Text: struct user_dev_setup
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: user_dev_setup
|————————Node:identifier Text: user
|————————Node:; Text: ;
|———————Node:expression_statement Text: create_user_dev_setup(&timing, priv->clock.freq, &user);
|————————Node:call_expression Text: create_user_dev_setup(&timing, priv->clock.freq, &user)
|—————————Node:identifier Text: create_user_dev_setup
|—————————Node:argument_list Text: (&timing, priv->clock.freq, &user)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &timing
|———————————Node:& Text: &
|———————————Node:identifier Text: timing
|——————————Node:, Text: ,
|——————————Node:field_expression Text: priv->clock.freq
|———————————Node:field_expression Text: priv->clock
|————————————Node:identifier Text: priv
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: clock
|———————————Node:. Text: .
|———————————Node:field_identifier Text: freq
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &user
|———————————Node:& Text: &
|———————————Node:identifier Text: user
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:declaration Text: int err;
|————————Node:primitive_type Text: int
|————————Node:identifier Text: err
|————————Node:; Text: ;
|———————Node:expression_statement Text: device->flags &= ~IFF_UP;
|————————Node:assignment_expression Text: device->flags &= ~IFF_UP
|—————————Node:field_expression Text: device->flags
|——————————Node:identifier Text: device
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: flags
|—————————Node:&= Text: &=
|—————————Node:unary_expression Text: ~IFF_UP
|——————————Node:~ Text: ~
|——————————Node:identifier Text: IFF_UP
|————————Node:; Text: ;
|———————Node:if_statement Text: if ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0) {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: ((err = device->resmgr_ops->changelink(device, &user, NULL)) != 0)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: (err = device->resmgr_ops->changelink(device, &user, NULL)) != 0
|——————————Node:parenthesized_expression Text: (err = device->resmgr_ops->changelink(device, &user, NULL))
|———————————Node:( Text: (
|———————————Node:assignment_expression Text: err = device->resmgr_ops->changelink(device, &user, NULL)
|————————————Node:identifier Text: err
|————————————Node:= Text: =
|————————————Node:call_expression Text: device->resmgr_ops->changelink(device, &user, NULL)
|—————————————Node:field_expression Text: device->resmgr_ops->changelink
|——————————————Node:field_expression Text: device->resmgr_ops
|———————————————Node:identifier Text: device
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: resmgr_ops
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: changelink
|—————————————Node:argument_list Text: (device, &user, NULL)
|——————————————Node:( Text: (
|——————————————Node:identifier Text: device
|——————————————Node:, Text: ,
|——————————————Node:pointer_expression Text: &user
|———————————————Node:& Text: &
|———————————————Node:identifier Text: user
|——————————————Node:, Text: ,
|——————————————Node:null Text: NULL
|———————————————Node:NULL Text: NULL
|——————————————Node:) Text: )
|———————————Node:) Text: )
|——————————Node:!= Text: !=
|——————————Node:number_literal Text: 0
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));

            device->flags |= IFF_UP;
            return -err;
        }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err));
|——————————Node:call_expression Text: log_err("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err))
|———————————Node:identifier Text: log_err
|———————————Node:argument_list Text: ("CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n",
                    -err, strerror(-err))
|————————————Node:( Text: (
|————————————Node:string_literal Text: "CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: CAN_DEVCTL_SET_TIMING: changelink failed: (%d) %s
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:unary_expression Text: -err
|—————————————Node:- Text: -
|—————————————Node:identifier Text: err
|————————————Node:, Text: ,
|————————————Node:call_expression Text: strerror(-err)
|—————————————Node:identifier Text: strerror
|—————————————Node:argument_list Text: (-err)
|——————————————Node:( Text: (
|——————————————Node:unary_expression Text: -err
|———————————————Node:- Text: -
|———————————————Node:identifier Text: err
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: device->flags |= IFF_UP;
|——————————Node:assignment_expression Text: device->flags |= IFF_UP
|———————————Node:field_expression Text: device->flags
|————————————Node:identifier Text: device
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: flags
|———————————Node:|= Text: |=
|———————————Node:identifier Text: IFF_UP
|——————————Node:; Text: ;
|—————————Node:return_statement Text: return -err;
|——————————Node:return Text: return
|——————————Node:unary_expression Text: -err
|———————————Node:- Text: -
|———————————Node:identifier Text: err
|——————————Node:; Text: ;
|—————————Node:} Text: }
|———————Node:expression_statement Text: device->flags |= IFF_UP;
|————————Node:assignment_expression Text: device->flags |= IFF_UP
|—————————Node:field_expression Text: device->flags
|——————————Node:identifier Text: device
|——————————Node:-> Text: ->
|——————————Node:field_identifier Text: flags
|—————————Node:|= Text: |=
|—————————Node:identifier Text: IFF_UP
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_SET_TIMING: success\n");
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_SET_TIMING: success\n")
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_SET_TIMING: success\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "CAN_DEVCTL_SET_TIMING: success\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: CAN_DEVCTL_SET_TIMING: success
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace_bittiming_info(device);
|————————Node:call_expression Text: log_trace_bittiming_info(device)
|—————————Node:identifier Text: log_trace_bittiming_info
|—————————Node:argument_list Text: (device)
|——————————Node:( Text: (
|——————————Node:identifier Text: device
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK:
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
|——————Node:: Text: :
|—————Node:case_statement Text: case CAN_DEVCTL_RX_FRAME_RAW_BLOCK: // e.g. candump -u0,rx0
    {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|——————Node:: Text: :
|——————Node:comment Text: // e.g. candump -u0,rx0
|——————Node:compound_statement Text: {
        if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );

        if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }

        break;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (_ocb->resmgr->channel_type == TX_CHANNEL) {
            return EIO; // Input/output error
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == TX_CHANNEL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: _ocb->resmgr->channel_type == TX_CHANNEL
|——————————Node:field_expression Text: _ocb->resmgr->channel_type
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: channel_type
|——————————Node:== Text: ==
|——————————Node:identifier Text: TX_CHANNEL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            return EIO; // Input/output error
        }
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return EIO;
|——————————Node:return Text: return
|——————————Node:identifier Text: EIO
|——————————Node:; Text: ;
|—————————Node:comment Text: // Input/output error
|—————————Node:} Text: }
|———————Node:declaration Text: struct can_msg* canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms );
|————————Node:struct_specifier Text: struct can_msg
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_msg
|————————Node:init_declarator Text: * canmsg =
            dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|—————————Node:pointer_declarator Text: * canmsg
|——————————Node:* Text: *
|——————————Node:identifier Text: canmsg
|—————————Node:= Text: =
|—————————Node:call_expression Text: dequeue_noblock( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|——————————Node:identifier Text: dequeue_noblock
|——————————Node:argument_list Text: ( &_ocb->session->rx_queue,
                    _ocb->resmgr->latency_limit_ms )
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &_ocb->session->rx_queue
|————————————Node:& Text: &
|————————————Node:field_expression Text: _ocb->session->rx_queue
|—————————————Node:field_expression Text: _ocb->session
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: session
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rx_queue
|———————————Node:, Text: ,
|———————————Node:field_expression Text: _ocb->resmgr->latency_limit_ms
|————————————Node:field_expression Text: _ocb->resmgr
|—————————————Node:identifier Text: _ocb
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: resmgr
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: latency_limit_ms
|———————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:if_statement Text: if (canmsg != NULL) { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
        else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (canmsg != NULL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: canmsg != NULL
|——————————Node:identifier Text: canmsg
|——————————Node:!= Text: !=
|——————————Node:null Text: NULL
|———————————Node:NULL Text: NULL
|—————————Node:) Text: )
|————————Node:compound_statement Text: { // Could be a zero size rx queue, i.e. a tx queue
            data->dcmd.canmsg = *canmsg;

            nbytes = sizeof(data->dcmd.canmsg);

            log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);

            pthread_mutex_lock(&_ocb->rx.mutex);
            remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
            pthread_mutex_unlock(&_ocb->rx.mutex);
        }
|—————————Node:{ Text: {
|—————————Node:comment Text: // Could be a zero size rx queue, i.e. a tx queue
|—————————Node:expression_statement Text: data->dcmd.canmsg = *canmsg;
|——————————Node:assignment_expression Text: data->dcmd.canmsg = *canmsg
|———————————Node:field_expression Text: data->dcmd.canmsg
|————————————Node:field_expression Text: data->dcmd
|—————————————Node:identifier Text: data
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: dcmd
|————————————Node:. Text: .
|————————————Node:field_identifier Text: canmsg
|———————————Node:= Text: =
|———————————Node:pointer_expression Text: *canmsg
|————————————Node:* Text: *
|————————————Node:identifier Text: canmsg
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: nbytes = sizeof(data->dcmd.canmsg);
|——————————Node:assignment_expression Text: nbytes = sizeof(data->dcmd.canmsg)
|———————————Node:identifier Text: nbytes
|———————————Node:= Text: =
|———————————Node:sizeof_expression Text: sizeof(data->dcmd.canmsg)
|————————————Node:sizeof Text: sizeof
|————————————Node:parenthesized_expression Text: (data->dcmd.canmsg)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: data->dcmd.canmsg
|——————————————Node:field_expression Text: data->dcmd
|———————————————Node:identifier Text: data
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: dcmd
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: canmsg
|—————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7]);
|——————————Node:call_expression Text: log_trace("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7])
|———————————Node:identifier Text: log_trace
|———————————Node:argument_list Text: ("%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                    (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"),
                    _ocb->resmgr->name,
                    canmsg->ext.timestamp,
                    canmsg->ext.is_extended_mid ? "EFF" : "SFF",
                    canmsg->mid,
                    canmsg->len,
                    canmsg->dat[0],
                    canmsg->dat[1],
                    canmsg->dat[2],
                    canmsg->dat[3],
                    canmsg->dat[4],
                    canmsg->dat[5],
                    canmsg->dat[6],
                    canmsg->dat[7])
|————————————Node:( Text: (
|————————————Node:concatenated_string Text: "%s; %s TS: %ums [%s] %X [%d] " \
                      "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|—————————————Node:string_literal Text: "%s; %s TS: %ums [%s] %X [%d] "
|——————————————Node:" Text: "
|——————————————Node:string_content Text: %s; %s TS: %ums [%s] %X [%d] 
|——————————————Node:" Text: "
|—————————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|——————————————Node:escape_sequence Text: \n
|——————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:parenthesized_expression Text: (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK")
|—————————————Node:( Text: (
|—————————————Node:conditional_expression Text: msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
                        ? "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
                        : "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"
|——————————————Node:binary_expression Text: msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|———————————————Node:field_expression Text: msg->i.dcmd
|————————————————Node:field_expression Text: msg->i
|—————————————————Node:identifier Text: msg
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: i
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: dcmd
|———————————————Node:== Text: ==
|———————————————Node:identifier Text: CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|——————————————Node:? Text: ?
|——————————————Node:string_literal Text: "CAN_DEVCTL_RX_FRAME_RAW_BLOCK"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|———————————————Node:" Text: "
|——————————————Node:: Text: :
|——————————————Node:string_literal Text: "CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK"
|———————————————Node:" Text: "
|———————————————Node:string_content Text: CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
|———————————————Node:" Text: "
|—————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:field_expression Text: _ocb->resmgr->name
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: name
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->ext.timestamp
|—————————————Node:field_expression Text: canmsg->ext
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: ext
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: timestamp
|————————————Node:, Text: ,
|————————————Node:conditional_expression Text: canmsg->ext.is_extended_mid ? "EFF" : "SFF"
|—————————————Node:field_expression Text: canmsg->ext.is_extended_mid
|——————————————Node:field_expression Text: canmsg->ext
|———————————————Node:identifier Text: canmsg
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: ext
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: is_extended_mid
|—————————————Node:? Text: ?
|—————————————Node:string_literal Text: "EFF"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: EFF
|——————————————Node:" Text: "
|—————————————Node:: Text: :
|—————————————Node:string_literal Text: "SFF"
|——————————————Node:" Text: "
|——————————————Node:string_content Text: SFF
|——————————————Node:" Text: "
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->mid
|—————————————Node:identifier Text: canmsg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: mid
|————————————Node:, Text: ,
|————————————Node:field_expression Text: canmsg->len
|—————————————Node:identifier Text: canmsg
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: len
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[0]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 0
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[1]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[2]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 2
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[3]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 3
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[4]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 4
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[5]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 5
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[6]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 6
|—————————————Node:] Text: ]
|————————————Node:, Text: ,
|————————————Node:subscript_expression Text: canmsg->dat[7]
|—————————————Node:field_expression Text: canmsg->dat
|——————————————Node:identifier Text: canmsg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: dat
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 7
|—————————————Node:] Text: ]
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_lock
|———————————Node:argument_list Text: (&_ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.mutex
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid);
|——————————Node:call_expression Text: remove_blocked_client(&_ocb->rx.blocked_clients, ctp->rcvid)
|———————————Node:identifier Text: remove_blocked_client
|———————————Node:argument_list Text: (&_ocb->rx.blocked_clients, ctp->rcvid)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.blocked_clients
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: blocked_clients
|————————————Node:, Text: ,
|————————————Node:field_expression Text: ctp->rcvid
|—————————————Node:identifier Text: ctp
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: rcvid
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|——————————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|———————————Node:identifier Text: pthread_mutex_unlock
|———————————Node:argument_list Text: (&_ocb->rx.mutex)
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: &_ocb->rx.mutex
|—————————————Node:& Text: &
|—————————————Node:field_expression Text: _ocb->rx.mutex
|——————————————Node:field_expression Text: _ocb->rx
|———————————————Node:identifier Text: _ocb
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: rx
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: mutex
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|————————Node:else_clause Text: else if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }
|—————————Node:else Text: else
|—————————Node:if_statement Text: if (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK) {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
        else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }
|——————————Node:if Text: if
|——————————Node:parenthesized_expression Text: (msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: msg->i.dcmd == CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|————————————Node:field_expression Text: msg->i.dcmd
|—————————————Node:field_expression Text: msg->i
|——————————————Node:identifier Text: msg
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: i
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: dcmd
|————————————Node:== Text: ==
|————————————Node:identifier Text: CAN_DEVCTL_RX_FRAME_RAW_BLOCK
|———————————Node:) Text: )
|——————————Node:compound_statement Text: {
            pthread_mutex_lock(&_ocb->rx.mutex);

            blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
            new_block->prev = new_block->next = NULL;
            new_block->rcvid = ctp->rcvid;

            store_blocked_client(&_ocb->rx.blocked_clients, new_block);

            pthread_cond_signal(&_ocb->rx.cond);
            pthread_mutex_unlock(&_ocb->rx.mutex);

            return _RESMGR_NOREPLY; /* put the client in block state */
        }
|———————————Node:{ Text: {
|———————————Node:expression_statement Text: pthread_mutex_lock(&_ocb->rx.mutex);
|————————————Node:call_expression Text: pthread_mutex_lock(&_ocb->rx.mutex)
|—————————————Node:identifier Text: pthread_mutex_lock
|—————————————Node:argument_list Text: (&_ocb->rx.mutex)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &_ocb->rx.mutex
|———————————————Node:& Text: &
|———————————————Node:field_expression Text: _ocb->rx.mutex
|————————————————Node:field_expression Text: _ocb->rx
|—————————————————Node:identifier Text: _ocb
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: rx
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: mutex
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:declaration Text: blocked_client_t* new_block = malloc(sizeof(blocked_client_t));
|————————————Node:type_identifier Text: blocked_client_t
|————————————Node:init_declarator Text: * new_block = malloc(sizeof(blocked_client_t))
|—————————————Node:pointer_declarator Text: * new_block
|——————————————Node:* Text: *
|——————————————Node:identifier Text: new_block
|—————————————Node:= Text: =
|—————————————Node:call_expression Text: malloc(sizeof(blocked_client_t))
|——————————————Node:identifier Text: malloc
|——————————————Node:argument_list Text: (sizeof(blocked_client_t))
|———————————————Node:( Text: (
|———————————————Node:sizeof_expression Text: sizeof(blocked_client_t)
|————————————————Node:sizeof Text: sizeof
|————————————————Node:parenthesized_expression Text: (blocked_client_t)
|—————————————————Node:( Text: (
|—————————————————Node:identifier Text: blocked_client_t
|—————————————————Node:) Text: )
|———————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: new_block->prev = new_block->next = NULL;
|————————————Node:assignment_expression Text: new_block->prev = new_block->next = NULL
|—————————————Node:field_expression Text: new_block->prev
|——————————————Node:identifier Text: new_block
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: prev
|—————————————Node:= Text: =
|—————————————Node:assignment_expression Text: new_block->next = NULL
|——————————————Node:field_expression Text: new_block->next
|———————————————Node:identifier Text: new_block
|———————————————Node:-> Text: ->
|———————————————Node:field_identifier Text: next
|——————————————Node:= Text: =
|——————————————Node:null Text: NULL
|———————————————Node:NULL Text: NULL
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: new_block->rcvid = ctp->rcvid;
|————————————Node:assignment_expression Text: new_block->rcvid = ctp->rcvid
|—————————————Node:field_expression Text: new_block->rcvid
|——————————————Node:identifier Text: new_block
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: rcvid
|—————————————Node:= Text: =
|—————————————Node:field_expression Text: ctp->rcvid
|——————————————Node:identifier Text: ctp
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: rcvid
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block);
|————————————Node:call_expression Text: store_blocked_client(&_ocb->rx.blocked_clients, new_block)
|—————————————Node:identifier Text: store_blocked_client
|—————————————Node:argument_list Text: (&_ocb->rx.blocked_clients, new_block)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &_ocb->rx.blocked_clients
|———————————————Node:& Text: &
|———————————————Node:field_expression Text: _ocb->rx.blocked_clients
|————————————————Node:field_expression Text: _ocb->rx
|—————————————————Node:identifier Text: _ocb
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: rx
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: blocked_clients
|——————————————Node:, Text: ,
|——————————————Node:identifier Text: new_block
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pthread_cond_signal(&_ocb->rx.cond);
|————————————Node:call_expression Text: pthread_cond_signal(&_ocb->rx.cond)
|—————————————Node:identifier Text: pthread_cond_signal
|—————————————Node:argument_list Text: (&_ocb->rx.cond)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &_ocb->rx.cond
|———————————————Node:& Text: &
|———————————————Node:field_expression Text: _ocb->rx.cond
|————————————————Node:field_expression Text: _ocb->rx
|—————————————————Node:identifier Text: _ocb
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: rx
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: cond
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:expression_statement Text: pthread_mutex_unlock(&_ocb->rx.mutex);
|————————————Node:call_expression Text: pthread_mutex_unlock(&_ocb->rx.mutex)
|—————————————Node:identifier Text: pthread_mutex_unlock
|—————————————Node:argument_list Text: (&_ocb->rx.mutex)
|——————————————Node:( Text: (
|——————————————Node:pointer_expression Text: &_ocb->rx.mutex
|———————————————Node:& Text: &
|———————————————Node:field_expression Text: _ocb->rx.mutex
|————————————————Node:field_expression Text: _ocb->rx
|—————————————————Node:identifier Text: _ocb
|—————————————————Node:-> Text: ->
|—————————————————Node:field_identifier Text: rx
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: mutex
|——————————————Node:) Text: )
|————————————Node:; Text: ;
|———————————Node:return_statement Text: return _RESMGR_NOREPLY;
|————————————Node:return Text: return
|————————————Node:identifier Text: _RESMGR_NOREPLY
|————————————Node:; Text: ;
|———————————Node:comment Text: /* put the client in block state */
|———————————Node:} Text: }
|——————————Node:else_clause Text: else { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }
|———————————Node:else Text: else
|———————————Node:compound_statement Text: { // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
            return EAGAIN; /* There are no messages in the queue. */
        }
|————————————Node:{ Text: {
|————————————Node:comment Text: // CAN_DEVCTL_RX_FRAME_RAW_NOBLOCK
|————————————Node:return_statement Text: return EAGAIN;
|—————————————Node:return Text: return
|—————————————Node:identifier Text: EAGAIN
|—————————————Node:; Text: ;
|————————————Node:comment Text: /* There are no messages in the queue. */
|————————————Node:} Text: }
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: case CAN_DEVCTL_TX_FRAME_RAW: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
    {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
|——————Node:case Text: case
|——————Node:identifier Text: CAN_DEVCTL_TX_FRAME_RAW
|——————Node:: Text: :
|——————Node:comment Text: // e.g. cansend -u0,tx0 -w0x1234,1,0xABCD
|——————Node:compound_statement Text: {
        if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }

        struct can_msg canmsg = data->dcmd.canmsg;
        nbytes = 0;

        enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);

        log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);

        break;
    }
|———————Node:{ Text: {
|———————Node:if_statement Text: if (_ocb->resmgr->channel_type == RX_CHANNEL) {
            return EIO; // Input/output error
        }
|————————Node:if Text: if
|————————Node:parenthesized_expression Text: (_ocb->resmgr->channel_type == RX_CHANNEL)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: _ocb->resmgr->channel_type == RX_CHANNEL
|——————————Node:field_expression Text: _ocb->resmgr->channel_type
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: channel_type
|——————————Node:== Text: ==
|——————————Node:identifier Text: RX_CHANNEL
|—————————Node:) Text: )
|————————Node:compound_statement Text: {
            return EIO; // Input/output error
        }
|—————————Node:{ Text: {
|—————————Node:return_statement Text: return EIO;
|——————————Node:return Text: return
|——————————Node:identifier Text: EIO
|——————————Node:; Text: ;
|—————————Node:comment Text: // Input/output error
|—————————Node:} Text: }
|———————Node:declaration Text: struct can_msg canmsg = data->dcmd.canmsg;
|————————Node:struct_specifier Text: struct can_msg
|—————————Node:struct Text: struct
|—————————Node:type_identifier Text: can_msg
|————————Node:init_declarator Text: canmsg = data->dcmd.canmsg
|—————————Node:identifier Text: canmsg
|—————————Node:= Text: =
|—————————Node:field_expression Text: data->dcmd.canmsg
|——————————Node:field_expression Text: data->dcmd
|———————————Node:identifier Text: data
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: dcmd
|——————————Node:. Text: .
|——————————Node:field_identifier Text: canmsg
|————————Node:; Text: ;
|———————Node:expression_statement Text: nbytes = 0;
|————————Node:assignment_expression Text: nbytes = 0
|—————————Node:identifier Text: nbytes
|—————————Node:= Text: =
|—————————Node:number_literal Text: 0
|————————Node:; Text: ;
|———————Node:expression_statement Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg);
|————————Node:call_expression Text: enqueue(&_ocb->resmgr->device_session->tx_queue, &canmsg)
|—————————Node:identifier Text: enqueue
|—————————Node:argument_list Text: (&_ocb->resmgr->device_session->tx_queue, &canmsg)
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &_ocb->resmgr->device_session->tx_queue
|———————————Node:& Text: &
|———————————Node:field_expression Text: _ocb->resmgr->device_session->tx_queue
|————————————Node:field_expression Text: _ocb->resmgr->device_session
|—————————————Node:field_expression Text: _ocb->resmgr
|——————————————Node:identifier Text: _ocb
|——————————————Node:-> Text: ->
|——————————————Node:field_identifier Text: resmgr
|—————————————Node:-> Text: ->
|—————————————Node:field_identifier Text: device_session
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: tx_queue
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &canmsg
|———————————Node:& Text: &
|———————————Node:identifier Text: canmsg
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:expression_statement Text: log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7]);
|————————Node:call_expression Text: log_trace("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7])
|—————————Node:identifier Text: log_trace
|—————————Node:argument_list Text: ("CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n",
                _ocb->resmgr->name,
                canmsg.ext.timestamp,
                canmsg.ext.is_extended_mid ? "EFF" : "SFF",
                canmsg.mid,
                canmsg.len,
                canmsg.dat[0],
                canmsg.dat[1],
                canmsg.dat[2],
                canmsg.dat[3],
                canmsg.dat[4],
                canmsg.dat[5],
                canmsg.dat[6],
                canmsg.dat[7])
|——————————Node:( Text: (
|——————————Node:concatenated_string Text: "CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] " \
                  "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|———————————Node:string_literal Text: "CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] "
|————————————Node:" Text: "
|————————————Node:string_content Text: CAN_DEVCTL_TX_FRAME_RAW; %s TS: %ums [%s] %X [%d] 
|————————————Node:" Text: "
|———————————Node:string_literal Text: "%02X %02X %02X %02X %02X %02X %02X %02X\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: %02X %02X %02X %02X %02X %02X %02X %02X
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: _ocb->resmgr->name
|———————————Node:field_expression Text: _ocb->resmgr
|————————————Node:identifier Text: _ocb
|————————————Node:-> Text: ->
|————————————Node:field_identifier Text: resmgr
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: name
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.ext.timestamp
|———————————Node:field_expression Text: canmsg.ext
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: ext
|———————————Node:. Text: .
|———————————Node:field_identifier Text: timestamp
|——————————Node:, Text: ,
|——————————Node:conditional_expression Text: canmsg.ext.is_extended_mid ? "EFF" : "SFF"
|———————————Node:field_expression Text: canmsg.ext.is_extended_mid
|————————————Node:field_expression Text: canmsg.ext
|—————————————Node:identifier Text: canmsg
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: ext
|————————————Node:. Text: .
|————————————Node:field_identifier Text: is_extended_mid
|———————————Node:? Text: ?
|———————————Node:string_literal Text: "EFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: EFF
|————————————Node:" Text: "
|———————————Node:: Text: :
|———————————Node:string_literal Text: "SFF"
|————————————Node:" Text: "
|————————————Node:string_content Text: SFF
|————————————Node:" Text: "
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.mid
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: mid
|——————————Node:, Text: ,
|——————————Node:field_expression Text: canmsg.len
|———————————Node:identifier Text: canmsg
|———————————Node:. Text: .
|———————————Node:field_identifier Text: len
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[0]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 0
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[1]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 1
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[2]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 2
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[3]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 3
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[4]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 4
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[5]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 5
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[6]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 6
|———————————Node:] Text: ]
|——————————Node:, Text: ,
|——————————Node:subscript_expression Text: canmsg.dat[7]
|———————————Node:field_expression Text: canmsg.dat
|————————————Node:identifier Text: canmsg
|————————————Node:. Text: .
|————————————Node:field_identifier Text: dat
|———————————Node:[ Text: [
|———————————Node:number_literal Text: 7
|———————————Node:] Text: ]
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:break_statement Text: break;
|————————Node:break Text: break
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:case_statement Text: default:
        log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);

        return(ENOSYS);
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: log_trace("io_devctl unknown command: %d\n", msg->i.dcmd);
|———————Node:call_expression Text: log_trace("io_devctl unknown command: %d\n", msg->i.dcmd)
|————————Node:identifier Text: log_trace
|————————Node:argument_list Text: ("io_devctl unknown command: %d\n", msg->i.dcmd)
|—————————Node:( Text: (
|—————————Node:string_literal Text: "io_devctl unknown command: %d\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: io_devctl unknown command: %d
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:field_expression Text: msg->i.dcmd
|——————————Node:field_expression Text: msg->i
|———————————Node:identifier Text: msg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: i
|——————————Node:. Text: .
|——————————Node:field_identifier Text: dcmd
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:return_statement Text: return(ENOSYS);
|———————Node:return Text: return
|———————Node:parenthesized_expression Text: (ENOSYS)
|————————Node:( Text: (
|————————Node:identifier Text: ENOSYS
|————————Node:) Text: )
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:comment Text: /* Clear the return message. Note that we saved our data past
       this location in the message. */
|———Node:expression_statement Text: memset(&msg->o, 0, sizeof(msg->o));
|————Node:call_expression Text: memset(&msg->o, 0, sizeof(msg->o))
|—————Node:identifier Text: memset
|—————Node:argument_list Text: (&msg->o, 0, sizeof(msg->o))
|——————Node:( Text: (
|——————Node:pointer_expression Text: &msg->o
|———————Node:& Text: &
|———————Node:field_expression Text: msg->o
|————————Node:identifier Text: msg
|————————Node:-> Text: ->
|————————Node:field_identifier Text: o
|——————Node:, Text: ,
|——————Node:number_literal Text: 0
|——————Node:, Text: ,
|——————Node:sizeof_expression Text: sizeof(msg->o)
|———————Node:sizeof Text: sizeof
|———————Node:parenthesized_expression Text: (msg->o)
|————————Node:( Text: (
|————————Node:field_expression Text: msg->o
|—————————Node:identifier Text: msg
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: o
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /*
     If you wanted to pass something different to the return
     field of the devctl() you could do it through this member.
     See note 5.
    */
|———Node:expression_statement Text: msg->o.ret_val = status;
|————Node:assignment_expression Text: msg->o.ret_val = status
|—————Node:field_expression Text: msg->o.ret_val
|——————Node:field_expression Text: msg->o
|———————Node:identifier Text: msg
|———————Node:-> Text: ->
|———————Node:field_identifier Text: o
|——————Node:. Text: .
|——————Node:field_identifier Text: ret_val
|—————Node:= Text: =
|—————Node:identifier Text: status
|————Node:; Text: ;
|———Node:comment Text: /* Indicate the number of bytes and return the message */
|———Node:expression_statement Text: msg->o.nbytes = nbytes;
|————Node:assignment_expression Text: msg->o.nbytes = nbytes
|—————Node:field_expression Text: msg->o.nbytes
|——————Node:field_expression Text: msg->o
|———————Node:identifier Text: msg
|———————Node:-> Text: ->
|———————Node:field_identifier Text: o
|——————Node:. Text: .
|——————Node:field_identifier Text: nbytes
|—————Node:= Text: =
|—————Node:identifier Text: nbytes
|————Node:; Text: ;
|———Node:return_statement Text: return(_RESMGR_PTR(ctp, &msg->o, sizeof(msg->o) + nbytes));
|————Node:return Text: return
|————Node:parenthesized_expression Text: (_RESMGR_PTR(ctp, &msg->o, sizeof(msg->o) + nbytes))
|—————Node:( Text: (
|—————Node:call_expression Text: _RESMGR_PTR(ctp, &msg->o, sizeof(msg->o) + nbytes)
|——————Node:identifier Text: _RESMGR_PTR
|——————Node:argument_list Text: (ctp, &msg->o, sizeof(msg->o) + nbytes)
|———————Node:( Text: (
|———————Node:identifier Text: ctp
|———————Node:, Text: ,
|———————Node:pointer_expression Text: &msg->o
|————————Node:& Text: &
|————————Node:field_expression Text: msg->o
|—————————Node:identifier Text: msg
|—————————Node:-> Text: ->
|—————————Node:field_identifier Text: o
|———————Node:, Text: ,
|———————Node:binary_expression Text: sizeof(msg->o) + nbytes
|————————Node:sizeof_expression Text: sizeof(msg->o)
|—————————Node:sizeof Text: sizeof
|—————————Node:parenthesized_expression Text: (msg->o)
|——————————Node:( Text: (
|——————————Node:field_expression Text: msg->o
|———————————Node:identifier Text: msg
|———————————Node:-> Text: ->
|———————————Node:field_identifier Text: o
|——————————Node:) Text: )
|————————Node:+ Text: +
|————————Node:identifier Text: nbytes
|———————Node:) Text: )
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:function_definition Text: void log_trace_bittiming_info (struct net_device* device) {
    struct can_priv* priv = netdev_priv(device);

    /* Clock frequency */
    log_trace("  clock: %uHz\n", priv->clock.freq);

    /* Bit-rate in bits/second */
    log_trace("  bitrate: %ubits/second\n", priv->bittiming.bitrate);

    /* Sample point in one-tenth of a percent */
    log_trace("  sample_point: %u (1/10 of percent)\n",
            priv->bittiming.sample_point);

    /* Time quanta (TQ) in nanoseconds */
    log_trace("  tq: %uns (TQ)\n", priv->bittiming.tq);

    /* Propagation segment in TQs */
    log_trace("  prop_seg: %u\n", priv->bittiming.prop_seg);

    /* Phase buffer segment 1 in TQs */
    log_trace("  phase_seg1: %uTQ\n", priv->bittiming.phase_seg1);

    /* Phase buffer segment 2 in TQs */
    log_trace("  phase_seg2: %uTQ\n", priv->bittiming.phase_seg2);

    /* Synchronisation jump width in TQs */
    log_trace("  sjw: %uTQ\n", priv->bittiming.sjw);

    /* Bit-rate prescaler */
    log_trace("  brp: %u\n", priv->bittiming.brp);
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: log_trace_bittiming_info (struct net_device* device)
|———Node:identifier Text: log_trace_bittiming_info
|———Node:parameter_list Text: (struct net_device* device)
|————Node:( Text: (
|————Node:parameter_declaration Text: struct net_device* device
|—————Node:struct_specifier Text: struct net_device
|——————Node:struct Text: struct
|——————Node:type_identifier Text: net_device
|—————Node:pointer_declarator Text: * device
|——————Node:* Text: *
|——————Node:identifier Text: device
|————Node:) Text: )
|——Node:compound_statement Text: {
    struct can_priv* priv = netdev_priv(device);

    /* Clock frequency */
    log_trace("  clock: %uHz\n", priv->clock.freq);

    /* Bit-rate in bits/second */
    log_trace("  bitrate: %ubits/second\n", priv->bittiming.bitrate);

    /* Sample point in one-tenth of a percent */
    log_trace("  sample_point: %u (1/10 of percent)\n",
            priv->bittiming.sample_point);

    /* Time quanta (TQ) in nanoseconds */
    log_trace("  tq: %uns (TQ)\n", priv->bittiming.tq);

    /* Propagation segment in TQs */
    log_trace("  prop_seg: %u\n", priv->bittiming.prop_seg);

    /* Phase buffer segment 1 in TQs */
    log_trace("  phase_seg1: %uTQ\n", priv->bittiming.phase_seg1);

    /* Phase buffer segment 2 in TQs */
    log_trace("  phase_seg2: %uTQ\n", priv->bittiming.phase_seg2);

    /* Synchronisation jump width in TQs */
    log_trace("  sjw: %uTQ\n", priv->bittiming.sjw);

    /* Bit-rate prescaler */
    log_trace("  brp: %u\n", priv->bittiming.brp);
}
|———Node:{ Text: {
|———Node:declaration Text: struct can_priv* priv = netdev_priv(device);
|————Node:struct_specifier Text: struct can_priv
|—————Node:struct Text: struct
|—————Node:type_identifier Text: can_priv
|————Node:init_declarator Text: * priv = netdev_priv(device)
|—————Node:pointer_declarator Text: * priv
|——————Node:* Text: *
|——————Node:identifier Text: priv
|—————Node:= Text: =
|—————Node:call_expression Text: netdev_priv(device)
|——————Node:identifier Text: netdev_priv
|——————Node:argument_list Text: (device)
|———————Node:( Text: (
|———————Node:identifier Text: device
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Clock frequency */
|———Node:expression_statement Text: log_trace("  clock: %uHz\n", priv->clock.freq);
|————Node:call_expression Text: log_trace("  clock: %uHz\n", priv->clock.freq)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  clock: %uHz\n", priv->clock.freq)
|——————Node:( Text: (
|——————Node:string_literal Text: "  clock: %uHz\n"
|———————Node:" Text: "
|———————Node:string_content Text:   clock: %uHz
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->clock.freq
|———————Node:field_expression Text: priv->clock
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: clock
|———————Node:. Text: .
|———————Node:field_identifier Text: freq
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Bit-rate in bits/second */
|———Node:expression_statement Text: log_trace("  bitrate: %ubits/second\n", priv->bittiming.bitrate);
|————Node:call_expression Text: log_trace("  bitrate: %ubits/second\n", priv->bittiming.bitrate)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  bitrate: %ubits/second\n", priv->bittiming.bitrate)
|——————Node:( Text: (
|——————Node:string_literal Text: "  bitrate: %ubits/second\n"
|———————Node:" Text: "
|———————Node:string_content Text:   bitrate: %ubits/second
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.bitrate
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: bitrate
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Sample point in one-tenth of a percent */
|———Node:expression_statement Text: log_trace("  sample_point: %u (1/10 of percent)\n",
            priv->bittiming.sample_point);
|————Node:call_expression Text: log_trace("  sample_point: %u (1/10 of percent)\n",
            priv->bittiming.sample_point)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  sample_point: %u (1/10 of percent)\n",
            priv->bittiming.sample_point)
|——————Node:( Text: (
|——————Node:string_literal Text: "  sample_point: %u (1/10 of percent)\n"
|———————Node:" Text: "
|———————Node:string_content Text:   sample_point: %u (1/10 of percent)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.sample_point
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: sample_point
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Time quanta (TQ) in nanoseconds */
|———Node:expression_statement Text: log_trace("  tq: %uns (TQ)\n", priv->bittiming.tq);
|————Node:call_expression Text: log_trace("  tq: %uns (TQ)\n", priv->bittiming.tq)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  tq: %uns (TQ)\n", priv->bittiming.tq)
|——————Node:( Text: (
|——————Node:string_literal Text: "  tq: %uns (TQ)\n"
|———————Node:" Text: "
|———————Node:string_content Text:   tq: %uns (TQ)
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.tq
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: tq
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Propagation segment in TQs */
|———Node:expression_statement Text: log_trace("  prop_seg: %u\n", priv->bittiming.prop_seg);
|————Node:call_expression Text: log_trace("  prop_seg: %u\n", priv->bittiming.prop_seg)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  prop_seg: %u\n", priv->bittiming.prop_seg)
|——————Node:( Text: (
|——————Node:string_literal Text: "  prop_seg: %u\n"
|———————Node:" Text: "
|———————Node:string_content Text:   prop_seg: %u
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.prop_seg
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: prop_seg
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Phase buffer segment 1 in TQs */
|———Node:expression_statement Text: log_trace("  phase_seg1: %uTQ\n", priv->bittiming.phase_seg1);
|————Node:call_expression Text: log_trace("  phase_seg1: %uTQ\n", priv->bittiming.phase_seg1)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  phase_seg1: %uTQ\n", priv->bittiming.phase_seg1)
|——————Node:( Text: (
|——————Node:string_literal Text: "  phase_seg1: %uTQ\n"
|———————Node:" Text: "
|———————Node:string_content Text:   phase_seg1: %uTQ
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.phase_seg1
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: phase_seg1
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Phase buffer segment 2 in TQs */
|———Node:expression_statement Text: log_trace("  phase_seg2: %uTQ\n", priv->bittiming.phase_seg2);
|————Node:call_expression Text: log_trace("  phase_seg2: %uTQ\n", priv->bittiming.phase_seg2)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  phase_seg2: %uTQ\n", priv->bittiming.phase_seg2)
|——————Node:( Text: (
|——————Node:string_literal Text: "  phase_seg2: %uTQ\n"
|———————Node:" Text: "
|———————Node:string_content Text:   phase_seg2: %uTQ
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.phase_seg2
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: phase_seg2
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Synchronisation jump width in TQs */
|———Node:expression_statement Text: log_trace("  sjw: %uTQ\n", priv->bittiming.sjw);
|————Node:call_expression Text: log_trace("  sjw: %uTQ\n", priv->bittiming.sjw)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  sjw: %uTQ\n", priv->bittiming.sjw)
|——————Node:( Text: (
|——————Node:string_literal Text: "  sjw: %uTQ\n"
|———————Node:" Text: "
|———————Node:string_content Text:   sjw: %uTQ
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.sjw
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: sjw
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment Text: /* Bit-rate prescaler */
|———Node:expression_statement Text: log_trace("  brp: %u\n", priv->bittiming.brp);
|————Node:call_expression Text: log_trace("  brp: %u\n", priv->bittiming.brp)
|—————Node:identifier Text: log_trace
|—————Node:argument_list Text: ("  brp: %u\n", priv->bittiming.brp)
|——————Node:( Text: (
|——————Node:string_literal Text: "  brp: %u\n"
|———————Node:" Text: "
|———————Node:string_content Text:   brp: %u
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:field_expression Text: priv->bittiming.brp
|———————Node:field_expression Text: priv->bittiming
|————————Node:identifier Text: priv
|————————Node:-> Text: ->
|————————Node:field_identifier Text: bittiming
|———————Node:. Text: .
|———————Node:field_identifier Text: brp
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
