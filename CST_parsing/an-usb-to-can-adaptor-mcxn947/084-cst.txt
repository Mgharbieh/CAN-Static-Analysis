an-usb-to-can-adaptor-mcxn947-source\can_interface.c

|Node:translation_unit
|—Node:comment
|—Node:comment
|—Node:preproc_include Text: #include "fsl_debug_console.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "fsl_debug_console.h"
|———Node:" Text: "
|———Node:string_content Text: fsl_debug_console.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "fsl_flexcan.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "fsl_flexcan.h"
|———Node:" Text: "
|———Node:string_content Text: fsl_flexcan.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "can_interface.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "can_interface.h"
|———Node:" Text: "
|———Node:string_content Text: can_interface.h
|———Node:" Text: "
|—Node:preproc_include Text: #include "usb_to_can.h"

|——Node:#include Text: #include
|——Node:string_literal Text: "usb_to_can.h"
|———Node:" Text: "
|———Node:string_content Text: usb_to_can.h
|———Node:" Text: "
|—Node:comment
|—Node:preproc_def Text: #define EXAMPLE_CAN                CAN0

|——Node:#define Text: #define
|——Node:identifier Text: EXAMPLE_CAN
|——Node:preproc_arg Text: CAN0
|—Node:preproc_def Text: #define EXAMPLE_FLEXCAN_IRQn       CAN0_IRQn

|——Node:#define Text: #define
|——Node:identifier Text: EXAMPLE_FLEXCAN_IRQn
|——Node:preproc_arg Text: CAN0_IRQn
|—Node:preproc_def Text: #define EXAMPLE_FLEXCAN_IRQHandler CAN0_IRQHandler

|——Node:#define Text: #define
|——Node:identifier Text: EXAMPLE_FLEXCAN_IRQHandler
|——Node:preproc_arg Text: CAN0_IRQHandler
|—Node:preproc_def Text: #define RX_MESSAGE_BUFFER_NUM      (0)

|——Node:#define Text: #define
|——Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|——Node:preproc_arg Text: (0)
|—Node:preproc_def Text: #define TX_MESSAGE_BUFFER_NUM      (1)

|——Node:#define Text: #define
|——Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|——Node:preproc_arg Text: (1)
|—Node:preproc_def Text: #define RX_IDENTIFIER              (0x000)

|——Node:#define Text: #define
|——Node:identifier Text: RX_IDENTIFIER
|——Node:preproc_arg Text: (0x000)
|—Node:comment
|—Node:preproc_def Text: #define EXAMPLE_CAN_CLK_FREQ CLOCK_GetFlexcanClkFreq(0U)

|——Node:#define Text: #define
|——Node:identifier Text: EXAMPLE_CAN_CLK_FREQ
|——Node:preproc_arg Text: CLOCK_GetFlexcanClkFreq(0U)
|—Node:comment
|—Node:preproc_def Text: #define USE_IMPROVED_TIMING_CONFIG (1U)

|——Node:#define Text: #define
|——Node:identifier Text: USE_IMPROVED_TIMING_CONFIG
|——Node:preproc_arg Text: (1U)
|—Node:comment
|—Node:preproc_def Text: #define LOG_INFO (void)PRINTF

|——Node:#define Text: #define
|——Node:identifier Text: LOG_INFO
|——Node:preproc_arg Text: (void)PRINTF
|—Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
/*
 *    DWORD_IN_MB    DLC    BYTES_IN_MB             Maximum MBs
 *    2              8      kFLEXCAN_8BperMB        64
 *    4              10     kFLEXCAN_16BperMB       42
 *    8              13     kFLEXCAN_32BperMB       25
 *    16             15     kFLEXCAN_64BperMB       14
 *
 * Dword in each message buffer, Length of data in bytes, Payload size must align,
 * and the Message Buffers are limited corresponding to each payload configuration:
 */
#define DWORD_IN_MB (16)
#define DLC         (15)
#define BYTES_IN_MB kFLEXCAN_64BperMB
#else
#define DLC (8)
#endif
|——Node:#if Text: #if
|——Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|———Node:( Text: (
|———Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|————Node:preproc_defined Text: defined(USE_CANFD)
|—————Node:defined Text: defined
|—————Node:( Text: (
|—————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:&& Text: &&
|————Node:identifier Text: USE_CANFD
|———Node:) Text: )
|——Node:
 Text: 

|——Node:comment
|——Node:preproc_def Text: #define DWORD_IN_MB (16)

|———Node:#define Text: #define
|———Node:identifier Text: DWORD_IN_MB
|———Node:preproc_arg Text: (16)
|——Node:preproc_def Text: #define DLC         (15)

|———Node:#define Text: #define
|———Node:identifier Text: DLC
|———Node:preproc_arg Text: (15)
|——Node:preproc_def Text: #define BYTES_IN_MB kFLEXCAN_64BperMB

|———Node:#define Text: #define
|———Node:identifier Text: BYTES_IN_MB
|———Node:preproc_arg Text: kFLEXCAN_64BperMB
|——Node:preproc_else Text: #else
#define DLC (8)

|———Node:#else Text: #else
|———Node:preproc_def Text: #define DLC (8)

|————Node:#define Text: #define
|————Node:identifier Text: DLC
|————Node:preproc_arg Text: (8)
|——Node:#endif Text: #endif
|—Node:comment
|—Node:declaration Text: flexcan_handle_t flexcanHandle;
|——Node:type_identifier Text: flexcan_handle_t
|——Node:identifier Text: flexcanHandle
|——Node:; Text: ;
|—Node:declaration Text: volatile bool txComplete = false;
|——Node:type_qualifier Text: volatile
|———Node:volatile Text: volatile
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: txComplete = false
|———Node:identifier Text: txComplete
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: volatile bool rxComplete = false;
|——Node:type_qualifier Text: volatile
|———Node:volatile Text: volatile
|——Node:primitive_type Text: bool
|——Node:init_declarator Text: rxComplete = false
|———Node:identifier Text: rxComplete
|———Node:= Text: =
|———Node:false Text: false
|——Node:; Text: ;
|—Node:declaration Text: flexcan_mb_transfer_t txXfer;
|——Node:type_identifier Text: flexcan_mb_transfer_t
|——Node:identifier Text: txXfer
|——Node:; Text: ;
|—Node:declaration Text: flexcan_mb_transfer_t rxXfer;
|——Node:type_identifier Text: flexcan_mb_transfer_t
|——Node:identifier Text: rxXfer
|——Node:; Text: ;
|—Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
flexcan_fd_frame_t txFrame, rxFrame;
#else
flexcan_frame_t txFrame, rxFrame;
#endif
|——Node:#if Text: #if
|——Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|———Node:( Text: (
|———Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|————Node:preproc_defined Text: defined(USE_CANFD)
|—————Node:defined Text: defined
|—————Node:( Text: (
|—————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:&& Text: &&
|————Node:identifier Text: USE_CANFD
|———Node:) Text: )
|——Node:
 Text: 

|——Node:declaration Text: flexcan_fd_frame_t txFrame, rxFrame;
|———Node:type_identifier Text: flexcan_fd_frame_t
|———Node:identifier Text: txFrame
|———Node:, Text: ,
|———Node:identifier Text: rxFrame
|———Node:; Text: ;
|——Node:preproc_else Text: #else
flexcan_frame_t txFrame, rxFrame;
|———Node:#else Text: #else
|———Node:declaration Text: flexcan_frame_t txFrame, rxFrame;
|————Node:type_identifier Text: flexcan_frame_t
|————Node:identifier Text: txFrame
|————Node:, Text: ,
|————Node:identifier Text: rxFrame
|————Node:; Text: ;
|——Node:#endif Text: #endif
|—Node:preproc_if Text: #if (defined(FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER)) && (FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER > 0)
    uint64_t flag = 1U;
#else
    uint32_t flag = 1U;
#endif
|——Node:#if Text: #if
|——Node:binary_expression Text: (defined(FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER)) && (FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER > 0)
|———Node:parenthesized_expression Text: (defined(FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER))
|————Node:( Text: (
|————Node:preproc_defined Text: defined(FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER)
|—————Node:defined Text: defined
|—————Node:( Text: (
|—————Node:identifier Text: FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER
|—————Node:) Text: )
|————Node:) Text: )
|———Node:&& Text: &&
|———Node:parenthesized_expression Text: (FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER > 0)
|————Node:( Text: (
|————Node:binary_expression Text: FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER > 0
|—————Node:identifier Text: FSL_FEATURE_FLEXCAN_HAS_EXTENDED_FLAG_REGISTER
|—————Node:> Text: >
|—————Node:number_literal Text: 0
|————Node:) Text: )
|——Node:
 Text: 

|——Node:declaration Text: uint64_t flag = 1U;
|———Node:primitive_type Text: uint64_t
|———Node:init_declarator Text: flag = 1U
|————Node:identifier Text: flag
|————Node:= Text: =
|————Node:number_literal Text: 1U
|———Node:; Text: ;
|——Node:preproc_else Text: #else
    uint32_t flag = 1U;
|———Node:#else Text: #else
|———Node:declaration Text: uint32_t flag = 1U;
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: flag = 1U
|—————Node:identifier Text: flag
|—————Node:= Text: =
|—————Node:number_literal Text: 1U
|————Node:; Text: ;
|——Node:#endif Text: #endif
|—Node:declaration Text: uint8_t swapRxData[64];
|——Node:primitive_type Text: uint8_t
|——Node:array_declarator Text: swapRxData[64]
|———Node:identifier Text: swapRxData
|———Node:[ Text: [
|———Node:number_literal Text: 64
|———Node:] Text: ]
|——Node:; Text: ;
|—Node:comment
|—Node:declaration Text: uint32_t fdBitrate = 2000000U;
|——Node:primitive_type Text: uint32_t
|——Node:init_declarator Text: fdBitrate = 2000000U
|———Node:identifier Text: fdBitrate
|———Node:= Text: =
|———Node:number_literal Text: 2000000U
|——Node:; Text: ;
|—Node:declaration Text: uint32_t bitrate = 1000000U;
|——Node:primitive_type Text: uint32_t
|——Node:init_declarator Text: bitrate = 1000000U
|———Node:identifier Text: bitrate
|———Node:= Text: =
|———Node:number_literal Text: 1000000U
|——Node:; Text: ;
|—Node:comment
|—Node:function_definition Text: uint8_t CANFD_DLC_TO_BYTE(uint8_t dlc)
{
  uint8_t byteSize;
  
  switch(dlc)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      byteSize = dlc;
      break;
    case 9:
    case 10:
    case 11:
    case 12:
      byteSize = ((dlc-8)*4)+8;
      break;
    case 13:
      byteSize = 32;
      break;
    case 14:
      byteSize = 48;
      break;
    case 15:
      byteSize = 64;
      break;      
  }
  
  return(byteSize);
}
|——Node:primitive_type Text: uint8_t
|——Node:function_declarator Text: CANFD_DLC_TO_BYTE(uint8_t dlc)
|———Node:identifier Text: CANFD_DLC_TO_BYTE
|———Node:parameter_list Text: (uint8_t dlc)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t dlc
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: dlc
|————Node:) Text: )
|——Node:compound_statement Text: {
  uint8_t byteSize;
  
  switch(dlc)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      byteSize = dlc;
      break;
    case 9:
    case 10:
    case 11:
    case 12:
      byteSize = ((dlc-8)*4)+8;
      break;
    case 13:
      byteSize = 32;
      break;
    case 14:
      byteSize = 48;
      break;
    case 15:
      byteSize = 64;
      break;      
  }
  
  return(byteSize);
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t byteSize;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: byteSize
|————Node:; Text: ;
|———Node:switch_statement Text: switch(dlc)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      byteSize = dlc;
      break;
    case 9:
    case 10:
    case 11:
    case 12:
      byteSize = ((dlc-8)*4)+8;
      break;
    case 13:
      byteSize = 32;
      break;
    case 14:
      byteSize = 48;
      break;
    case 15:
      byteSize = 64;
      break;      
  }
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (dlc)
|—————Node:( Text: (
|—————Node:identifier Text: dlc
|—————Node:) Text: )
|————Node:compound_statement Text: {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      byteSize = dlc;
      break;
    case 9:
    case 10:
    case 11:
    case 12:
      byteSize = ((dlc-8)*4)+8;
      break;
    case 13:
      byteSize = 32;
      break;
    case 14:
      byteSize = 48;
      break;
    case 15:
      byteSize = 64;
      break;      
  }
|—————Node:{ Text: {
|—————Node:case_statement Text: case 1:
|——————Node:case Text: case
|——————Node:number_literal Text: 1
|——————Node:: Text: :
|—————Node:case_statement Text: case 2:
|——————Node:case Text: case
|——————Node:number_literal Text: 2
|——————Node:: Text: :
|—————Node:case_statement Text: case 3:
|——————Node:case Text: case
|——————Node:number_literal Text: 3
|——————Node:: Text: :
|—————Node:case_statement Text: case 4:
|——————Node:case Text: case
|——————Node:number_literal Text: 4
|——————Node:: Text: :
|—————Node:case_statement Text: case 5:
|——————Node:case Text: case
|——————Node:number_literal Text: 5
|——————Node:: Text: :
|—————Node:case_statement Text: case 6:
|——————Node:case Text: case
|——————Node:number_literal Text: 6
|——————Node:: Text: :
|—————Node:case_statement Text: case 7:
|——————Node:case Text: case
|——————Node:number_literal Text: 7
|——————Node:: Text: :
|—————Node:case_statement Text: case 8:
      byteSize = dlc;
      break;
|——————Node:case Text: case
|——————Node:number_literal Text: 8
|——————Node:: Text: :
|——————Node:expression_statement Text: byteSize = dlc;
|———————Node:assignment_expression Text: byteSize = dlc
|————————Node:identifier Text: byteSize
|————————Node:= Text: =
|————————Node:identifier Text: dlc
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 9:
|——————Node:case Text: case
|——————Node:number_literal Text: 9
|——————Node:: Text: :
|—————Node:case_statement Text: case 10:
|——————Node:case Text: case
|——————Node:number_literal Text: 10
|——————Node:: Text: :
|—————Node:case_statement Text: case 11:
|——————Node:case Text: case
|——————Node:number_literal Text: 11
|——————Node:: Text: :
|—————Node:case_statement Text: case 12:
      byteSize = ((dlc-8)*4)+8;
      break;
|——————Node:case Text: case
|——————Node:number_literal Text: 12
|——————Node:: Text: :
|——————Node:expression_statement Text: byteSize = ((dlc-8)*4)+8;
|———————Node:assignment_expression Text: byteSize = ((dlc-8)*4)+8
|————————Node:identifier Text: byteSize
|————————Node:= Text: =
|————————Node:binary_expression Text: ((dlc-8)*4)+8
|—————————Node:parenthesized_expression Text: ((dlc-8)*4)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: (dlc-8)*4
|———————————Node:parenthesized_expression Text: (dlc-8)
|————————————Node:( Text: (
|————————————Node:binary_expression Text: dlc-8
|—————————————Node:identifier Text: dlc
|—————————————Node:- Text: -
|—————————————Node:number_literal Text: 8
|————————————Node:) Text: )
|———————————Node:* Text: *
|———————————Node:number_literal Text: 4
|——————————Node:) Text: )
|—————————Node:+ Text: +
|—————————Node:number_literal Text: 8
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 13:
      byteSize = 32;
      break;
|——————Node:case Text: case
|——————Node:number_literal Text: 13
|——————Node:: Text: :
|——————Node:expression_statement Text: byteSize = 32;
|———————Node:assignment_expression Text: byteSize = 32
|————————Node:identifier Text: byteSize
|————————Node:= Text: =
|————————Node:number_literal Text: 32
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 14:
      byteSize = 48;
      break;
|——————Node:case Text: case
|——————Node:number_literal Text: 14
|——————Node:: Text: :
|——————Node:expression_statement Text: byteSize = 48;
|———————Node:assignment_expression Text: byteSize = 48
|————————Node:identifier Text: byteSize
|————————Node:= Text: =
|————————Node:number_literal Text: 48
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case 15:
      byteSize = 64;
      break;
|——————Node:case Text: case
|——————Node:number_literal Text: 15
|——————Node:: Text: :
|——————Node:expression_statement Text: byteSize = 64;
|———————Node:assignment_expression Text: byteSize = 64
|————————Node:identifier Text: byteSize
|————————Node:= Text: =
|————————Node:number_literal Text: 64
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:return_statement Text: return(byteSize);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (byteSize)
|—————Node:( Text: (
|—————Node:identifier Text: byteSize
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: static FLEXCAN_CALLBACK(flexcan_callback)
{
    switch (status)
    {
        case kStatus_FLEXCAN_RxIdle:
            if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
            break;

        case kStatus_FLEXCAN_TxIdle:
            if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
            break;

        default:
            break;
    }
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:type_identifier Text: FLEXCAN_CALLBACK
|——Node:parenthesized_declarator Text: (flexcan_callback)
|———Node:( Text: (
|———Node:identifier Text: flexcan_callback
|———Node:) Text: )
|——Node:compound_statement Text: {
    switch (status)
    {
        case kStatus_FLEXCAN_RxIdle:
            if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
            break;

        case kStatus_FLEXCAN_TxIdle:
            if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
            break;

        default:
            break;
    }
}
|———Node:{ Text: {
|———Node:switch_statement Text: switch (status)
    {
        case kStatus_FLEXCAN_RxIdle:
            if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
            break;

        case kStatus_FLEXCAN_TxIdle:
            if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
            break;

        default:
            break;
    }
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (status)
|—————Node:( Text: (
|—————Node:identifier Text: status
|—————Node:) Text: )
|————Node:compound_statement Text: {
        case kStatus_FLEXCAN_RxIdle:
            if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
            break;

        case kStatus_FLEXCAN_TxIdle:
            if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
            break;

        default:
            break;
    }
|—————Node:{ Text: {
|—————Node:case_statement Text: case kStatus_FLEXCAN_RxIdle:
            if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
            break;
|——————Node:case Text: case
|——————Node:identifier Text: kStatus_FLEXCAN_RxIdle
|——————Node:: Text: :
|——————Node:if_statement Text: if (RX_MESSAGE_BUFFER_NUM == result)
            {
                /* Set Complete Flag */
                rxComplete = true;
            }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (RX_MESSAGE_BUFFER_NUM == result)
|————————Node:( Text: (
|————————Node:binary_expression Text: RX_MESSAGE_BUFFER_NUM == result
|—————————Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|—————————Node:== Text: ==
|—————————Node:identifier Text: result
|————————Node:) Text: )
|———————Node:compound_statement Text: {
                /* Set Complete Flag */
                rxComplete = true;
            }
|————————Node:{ Text: {
|————————Node:comment
|————————Node:expression_statement Text: rxComplete = true;
|—————————Node:assignment_expression Text: rxComplete = true
|——————————Node:identifier Text: rxComplete
|——————————Node:= Text: =
|——————————Node:true Text: true
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case kStatus_FLEXCAN_TxIdle:
            if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
            break;
|——————Node:case Text: case
|——————Node:identifier Text: kStatus_FLEXCAN_TxIdle
|——————Node:: Text: :
|——————Node:if_statement Text: if (TX_MESSAGE_BUFFER_NUM == result)
            {
               /* Set Complete Flag */
               txComplete = true;
            }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (TX_MESSAGE_BUFFER_NUM == result)
|————————Node:( Text: (
|————————Node:binary_expression Text: TX_MESSAGE_BUFFER_NUM == result
|—————————Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|—————————Node:== Text: ==
|—————————Node:identifier Text: result
|————————Node:) Text: )
|———————Node:compound_statement Text: {
               /* Set Complete Flag */
               txComplete = true;
            }
|————————Node:{ Text: {
|————————Node:comment
|————————Node:expression_statement Text: txComplete = true;
|—————————Node:assignment_expression Text: txComplete = true
|——————————Node:identifier Text: txComplete
|——————————Node:= Text: =
|——————————Node:true Text: true
|—————————Node:; Text: ;
|————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
            break;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: void APPCanStart(uint8_t *param)
{
	flexcan_timing_config_t newTimingConfig;


	char fdBitFrame;

	if(param[9] == '0')
	{
		fdBitFrame = param[12];
	}
	else
	{
		fdBitFrame = param[11];
	}

	switch(param[3])
	{
		case '1':
			if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
			break;
		case '2':
			bitrate = 250000U;
			break;
		case '5':
			bitrate = 500000U;
			break;
		case '8':
			bitrate = 800000U;
			break;
		default:
			bitrate = 1000000U;
			break;
	}

	switch(fdBitFrame)
	{
		case '1':
			fdBitrate = 1000000U;
			break;
		case '2':
			fdBitrate = 2000000U;
			break;
		case '4':
			fdBitrate = 4000000U;
			break;
		case '5':
			fdBitrate = 5000000U;
			break;
	}

	FLEXCAN_Deinit(EXAMPLE_CAN);
	APPCanInit();


    /* Start receive data */
#if (defined(USE_CANFD) && USE_CANFD)
    rxXfer.framefd = &rxFrame;
    (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
     rxXfer.frame = &rxFrame;
     (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif
     rxComplete = false;

}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: APPCanStart(uint8_t *param)
|———Node:identifier Text: APPCanStart
|———Node:parameter_list Text: (uint8_t *param)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t *param
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: *param
|——————Node:* Text: *
|——————Node:identifier Text: param
|————Node:) Text: )
|——Node:compound_statement Text: {
	flexcan_timing_config_t newTimingConfig;


	char fdBitFrame;

	if(param[9] == '0')
	{
		fdBitFrame = param[12];
	}
	else
	{
		fdBitFrame = param[11];
	}

	switch(param[3])
	{
		case '1':
			if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
			break;
		case '2':
			bitrate = 250000U;
			break;
		case '5':
			bitrate = 500000U;
			break;
		case '8':
			bitrate = 800000U;
			break;
		default:
			bitrate = 1000000U;
			break;
	}

	switch(fdBitFrame)
	{
		case '1':
			fdBitrate = 1000000U;
			break;
		case '2':
			fdBitrate = 2000000U;
			break;
		case '4':
			fdBitrate = 4000000U;
			break;
		case '5':
			fdBitrate = 5000000U;
			break;
	}

	FLEXCAN_Deinit(EXAMPLE_CAN);
	APPCanInit();


    /* Start receive data */
#if (defined(USE_CANFD) && USE_CANFD)
    rxXfer.framefd = &rxFrame;
    (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
     rxXfer.frame = &rxFrame;
     (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif
     rxComplete = false;

}
|———Node:{ Text: {
|———Node:declaration Text: flexcan_timing_config_t newTimingConfig;
|————Node:type_identifier Text: flexcan_timing_config_t
|————Node:identifier Text: newTimingConfig
|————Node:; Text: ;
|———Node:declaration Text: char fdBitFrame;
|————Node:primitive_type Text: char
|————Node:identifier Text: fdBitFrame
|————Node:; Text: ;
|———Node:if_statement Text: if(param[9] == '0')
	{
		fdBitFrame = param[12];
	}
	else
	{
		fdBitFrame = param[11];
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (param[9] == '0')
|—————Node:( Text: (
|—————Node:binary_expression Text: param[9] == '0'
|——————Node:subscript_expression Text: param[9]
|———————Node:identifier Text: param
|———————Node:[ Text: [
|———————Node:number_literal Text: 9
|———————Node:] Text: ]
|——————Node:== Text: ==
|——————Node:char_literal Text: '0'
|———————Node:' Text: '
|———————Node:character Text: 0
|———————Node:' Text: '
|—————Node:) Text: )
|————Node:compound_statement Text: {
		fdBitFrame = param[12];
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: fdBitFrame = param[12];
|——————Node:assignment_expression Text: fdBitFrame = param[12]
|———————Node:identifier Text: fdBitFrame
|———————Node:= Text: =
|———————Node:subscript_expression Text: param[12]
|————————Node:identifier Text: param
|————————Node:[ Text: [
|————————Node:number_literal Text: 12
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:} Text: }
|————Node:else_clause Text: else
	{
		fdBitFrame = param[11];
	}
|—————Node:else Text: else
|—————Node:compound_statement Text: {
		fdBitFrame = param[11];
	}
|——————Node:{ Text: {
|——————Node:expression_statement Text: fdBitFrame = param[11];
|———————Node:assignment_expression Text: fdBitFrame = param[11]
|————————Node:identifier Text: fdBitFrame
|————————Node:= Text: =
|————————Node:subscript_expression Text: param[11]
|—————————Node:identifier Text: param
|—————————Node:[ Text: [
|—————————Node:number_literal Text: 11
|—————————Node:] Text: ]
|———————Node:; Text: ;
|——————Node:} Text: }
|———Node:switch_statement Text: switch(param[3])
	{
		case '1':
			if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
			break;
		case '2':
			bitrate = 250000U;
			break;
		case '5':
			bitrate = 500000U;
			break;
		case '8':
			bitrate = 800000U;
			break;
		default:
			bitrate = 1000000U;
			break;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (param[3])
|—————Node:( Text: (
|—————Node:subscript_expression Text: param[3]
|——————Node:identifier Text: param
|——————Node:[ Text: [
|——————Node:number_literal Text: 3
|——————Node:] Text: ]
|—————Node:) Text: )
|————Node:compound_statement Text: {
		case '1':
			if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
			break;
		case '2':
			bitrate = 250000U;
			break;
		case '5':
			bitrate = 500000U;
			break;
		case '8':
			bitrate = 800000U;
			break;
		default:
			bitrate = 1000000U;
			break;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case '1':
			if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '1'
|———————Node:' Text: '
|———————Node:character Text: 1
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:if_statement Text: if(param[9] == '0')
			{
				bitrate = 1000000U;
			}
			else
			{
				bitrate = 100000U;
			}
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (param[9] == '0')
|————————Node:( Text: (
|————————Node:binary_expression Text: param[9] == '0'
|—————————Node:subscript_expression Text: param[9]
|——————————Node:identifier Text: param
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 9
|——————————Node:] Text: ]
|—————————Node:== Text: ==
|—————————Node:char_literal Text: '0'
|——————————Node:' Text: '
|——————————Node:character Text: 0
|——————————Node:' Text: '
|————————Node:) Text: )
|———————Node:compound_statement Text: {
				bitrate = 1000000U;
			}
|————————Node:{ Text: {
|————————Node:expression_statement Text: bitrate = 1000000U;
|—————————Node:assignment_expression Text: bitrate = 1000000U
|——————————Node:identifier Text: bitrate
|——————————Node:= Text: =
|——————————Node:number_literal Text: 1000000U
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
			{
				bitrate = 100000U;
			}
|————————Node:else Text: else
|————————Node:compound_statement Text: {
				bitrate = 100000U;
			}
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: bitrate = 100000U;
|——————————Node:assignment_expression Text: bitrate = 100000U
|———————————Node:identifier Text: bitrate
|———————————Node:= Text: =
|———————————Node:number_literal Text: 100000U
|——————————Node:; Text: ;
|—————————Node:} Text: }
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '2':
			bitrate = 250000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '2'
|———————Node:' Text: '
|———————Node:character Text: 2
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: bitrate = 250000U;
|———————Node:assignment_expression Text: bitrate = 250000U
|————————Node:identifier Text: bitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 250000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '5':
			bitrate = 500000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '5'
|———————Node:' Text: '
|———————Node:character Text: 5
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: bitrate = 500000U;
|———————Node:assignment_expression Text: bitrate = 500000U
|————————Node:identifier Text: bitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 500000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '8':
			bitrate = 800000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '8'
|———————Node:' Text: '
|———————Node:character Text: 8
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: bitrate = 800000U;
|———————Node:assignment_expression Text: bitrate = 800000U
|————————Node:identifier Text: bitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 800000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: default:
			bitrate = 1000000U;
			break;
|——————Node:default Text: default
|——————Node:: Text: :
|——————Node:expression_statement Text: bitrate = 1000000U;
|———————Node:assignment_expression Text: bitrate = 1000000U
|————————Node:identifier Text: bitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 1000000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:switch_statement Text: switch(fdBitFrame)
	{
		case '1':
			fdBitrate = 1000000U;
			break;
		case '2':
			fdBitrate = 2000000U;
			break;
		case '4':
			fdBitrate = 4000000U;
			break;
		case '5':
			fdBitrate = 5000000U;
			break;
	}
|————Node:switch Text: switch
|————Node:parenthesized_expression Text: (fdBitFrame)
|—————Node:( Text: (
|—————Node:identifier Text: fdBitFrame
|—————Node:) Text: )
|————Node:compound_statement Text: {
		case '1':
			fdBitrate = 1000000U;
			break;
		case '2':
			fdBitrate = 2000000U;
			break;
		case '4':
			fdBitrate = 4000000U;
			break;
		case '5':
			fdBitrate = 5000000U;
			break;
	}
|—————Node:{ Text: {
|—————Node:case_statement Text: case '1':
			fdBitrate = 1000000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '1'
|———————Node:' Text: '
|———————Node:character Text: 1
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: fdBitrate = 1000000U;
|———————Node:assignment_expression Text: fdBitrate = 1000000U
|————————Node:identifier Text: fdBitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 1000000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '2':
			fdBitrate = 2000000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '2'
|———————Node:' Text: '
|———————Node:character Text: 2
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: fdBitrate = 2000000U;
|———————Node:assignment_expression Text: fdBitrate = 2000000U
|————————Node:identifier Text: fdBitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 2000000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '4':
			fdBitrate = 4000000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '4'
|———————Node:' Text: '
|———————Node:character Text: 4
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: fdBitrate = 4000000U;
|———————Node:assignment_expression Text: fdBitrate = 4000000U
|————————Node:identifier Text: fdBitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 4000000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:case_statement Text: case '5':
			fdBitrate = 5000000U;
			break;
|——————Node:case Text: case
|——————Node:char_literal Text: '5'
|———————Node:' Text: '
|———————Node:character Text: 5
|———————Node:' Text: '
|——————Node:: Text: :
|——————Node:expression_statement Text: fdBitrate = 5000000U;
|———————Node:assignment_expression Text: fdBitrate = 5000000U
|————————Node:identifier Text: fdBitrate
|————————Node:= Text: =
|————————Node:number_literal Text: 5000000U
|———————Node:; Text: ;
|——————Node:break_statement Text: break;
|———————Node:break Text: break
|———————Node:; Text: ;
|—————Node:} Text: }
|———Node:expression_statement Text: FLEXCAN_Deinit(EXAMPLE_CAN);
|————Node:call_expression Text: FLEXCAN_Deinit(EXAMPLE_CAN)
|—————Node:identifier Text: FLEXCAN_Deinit
|—————Node:argument_list Text: (EXAMPLE_CAN)
|——————Node:( Text: (
|——————Node:identifier Text: EXAMPLE_CAN
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: APPCanInit();
|————Node:call_expression Text: APPCanInit()
|—————Node:identifier Text: APPCanInit
|—————Node:argument_list Text: ()
|——————Node:( Text: (
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    rxXfer.framefd = &rxFrame;
    (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
     rxXfer.frame = &rxFrame;
     (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: rxXfer.framefd = &rxFrame;
|—————Node:assignment_expression Text: rxXfer.framefd = &rxFrame
|——————Node:field_expression Text: rxXfer.framefd
|———————Node:identifier Text: rxXfer
|———————Node:. Text: .
|———————Node:field_identifier Text: framefd
|——————Node:= Text: =
|——————Node:pointer_expression Text: &rxFrame
|———————Node:& Text: &
|———————Node:identifier Text: rxFrame
|—————Node:; Text: ;
|————Node:expression_statement Text: (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|—————Node:cast_expression Text: (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|——————Node:( Text: (
|——————Node:type_descriptor Text: void
|———————Node:primitive_type Text: void
|——————Node:) Text: )
|——————Node:call_expression Text: FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|———————Node:identifier Text: FLEXCAN_TransferFDReceiveNonBlocking
|———————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|————————Node:( Text: (
|————————Node:identifier Text: EXAMPLE_CAN
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &flexcanHandle
|—————————Node:& Text: &
|—————————Node:identifier Text: flexcanHandle
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &rxXfer
|—————————Node:& Text: &
|—————————Node:identifier Text: rxXfer
|————————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
     rxXfer.frame = &rxFrame;
     (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: rxXfer.frame = &rxFrame;
|——————Node:assignment_expression Text: rxXfer.frame = &rxFrame
|———————Node:field_expression Text: rxXfer.frame
|————————Node:identifier Text: rxXfer
|————————Node:. Text: .
|————————Node:field_identifier Text: frame
|———————Node:= Text: =
|———————Node:pointer_expression Text: &rxFrame
|————————Node:& Text: &
|————————Node:identifier Text: rxFrame
|——————Node:; Text: ;
|—————Node:expression_statement Text: (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|——————Node:cast_expression Text: (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|———————Node:( Text: (
|———————Node:type_descriptor Text: void
|————————Node:primitive_type Text: void
|———————Node:) Text: )
|———————Node:call_expression Text: FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|————————Node:identifier Text: FLEXCAN_TransferReceiveNonBlocking
|————————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|—————————Node:( Text: (
|—————————Node:identifier Text: EXAMPLE_CAN
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &flexcanHandle
|——————————Node:& Text: &
|——————————Node:identifier Text: flexcanHandle
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &rxXfer
|——————————Node:& Text: &
|——————————Node:identifier Text: rxXfer
|—————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:expression_statement Text: rxComplete = false;
|————Node:assignment_expression Text: rxComplete = false
|—————Node:identifier Text: rxComplete
|—————Node:= Text: =
|—————Node:false Text: false
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: void APPCanInit(void)
{
    flexcan_config_t flexcanConfig;
    flexcan_rx_mb_config_t mbConfig;

  
      /* attach FRO HF to FLEXCAN0 */
    CLOCK_SetClkDiv(kCLOCK_DivFlexcan0Clk, 1u);
    CLOCK_AttachClk(kFRO_HF_to_FLEXCAN0);
    
    LOG_INFO("\r\n== USB Adapter Example -- Start.==\r\n\r\n");

    /* Get FlexCAN module default Configuration. */
    /*
     * flexcanConfig.clkSrc                 = kFLEXCAN_ClkSrc0;
     * flexcanConfig.bitRate                = 1000000U;
     * flexcanConfig.bitRateFD              = 2000000U;
     * flexcanConfig.maxMbNum               = 16;
     * flexcanConfig.enableLoopBack         = false;
     * flexcanConfig.enableSelfWakeup       = false;
     * flexcanConfig.enableIndividMask      = false;
     * flexcanConfig.disableSelfReception   = false;
     * flexcanConfig.enableListenOnlyMode   = false;
     * flexcanConfig.enableDoze             = false;
     */
    FLEXCAN_GetDefaultConfig(&flexcanConfig);
    flexcanConfig.bitRate                = bitrate;
    flexcanConfig.bitRateFD              = fdBitrate;

#if defined(EXAMPLE_CAN_CLK_SOURCE)
    flexcanConfig.clkSrc = EXAMPLE_CAN_CLK_SOURCE;
#endif

/* If special quantum setting is needed, set the timing parameters. */
#if (defined(SET_CAN_QUANTUM) && SET_CAN_QUANTUM)
    flexcanConfig.timingConfig.phaseSeg1 = PSEG1;
    flexcanConfig.timingConfig.phaseSeg2 = PSEG2;
    flexcanConfig.timingConfig.propSeg   = PROPSEG;
#if (defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
    flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1;
    flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2;
    flexcanConfig.timingConfig.fpropSeg   = FPROPSEG;
#endif
#endif    
    
    
#if (defined(USE_IMPROVED_TIMING_CONFIG) && USE_IMPROVED_TIMING_CONFIG)
    flexcan_timing_config_t timing_config;
    memset(&timing_config, 0, sizeof(flexcan_timing_config_t));
#if (defined(USE_CANFD) && USE_CANFD)
    if (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#else
    if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#endif
#endif

#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_FDInit(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true);
#else
    FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ);
#endif

    /* Create FlexCAN handle structure and set call back function. */
    FLEXCAN_TransferCreateHandle(EXAMPLE_CAN, &flexcanHandle, flexcan_callback, NULL);

    /* Set Rx Masking mechanism. */
    FLEXCAN_SetRxMbGlobalMask(EXAMPLE_CAN, FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0));
           
    /* Setup Rx Message Buffer. */
    mbConfig.format = kFLEXCAN_FrameFormatStandard;
    mbConfig.type   = kFLEXCAN_FrameTypeData;
    mbConfig.id     = FLEXCAN_ID_STD(RX_IDENTIFIER);
#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#else
    FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#endif

/* Setup Tx Message Buffer. */
#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#else
    FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#endif
    
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: APPCanInit(void)
|———Node:identifier Text: APPCanInit
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {
    flexcan_config_t flexcanConfig;
    flexcan_rx_mb_config_t mbConfig;

  
      /* attach FRO HF to FLEXCAN0 */
    CLOCK_SetClkDiv(kCLOCK_DivFlexcan0Clk, 1u);
    CLOCK_AttachClk(kFRO_HF_to_FLEXCAN0);
    
    LOG_INFO("\r\n== USB Adapter Example -- Start.==\r\n\r\n");

    /* Get FlexCAN module default Configuration. */
    /*
     * flexcanConfig.clkSrc                 = kFLEXCAN_ClkSrc0;
     * flexcanConfig.bitRate                = 1000000U;
     * flexcanConfig.bitRateFD              = 2000000U;
     * flexcanConfig.maxMbNum               = 16;
     * flexcanConfig.enableLoopBack         = false;
     * flexcanConfig.enableSelfWakeup       = false;
     * flexcanConfig.enableIndividMask      = false;
     * flexcanConfig.disableSelfReception   = false;
     * flexcanConfig.enableListenOnlyMode   = false;
     * flexcanConfig.enableDoze             = false;
     */
    FLEXCAN_GetDefaultConfig(&flexcanConfig);
    flexcanConfig.bitRate                = bitrate;
    flexcanConfig.bitRateFD              = fdBitrate;

#if defined(EXAMPLE_CAN_CLK_SOURCE)
    flexcanConfig.clkSrc = EXAMPLE_CAN_CLK_SOURCE;
#endif

/* If special quantum setting is needed, set the timing parameters. */
#if (defined(SET_CAN_QUANTUM) && SET_CAN_QUANTUM)
    flexcanConfig.timingConfig.phaseSeg1 = PSEG1;
    flexcanConfig.timingConfig.phaseSeg2 = PSEG2;
    flexcanConfig.timingConfig.propSeg   = PROPSEG;
#if (defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
    flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1;
    flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2;
    flexcanConfig.timingConfig.fpropSeg   = FPROPSEG;
#endif
#endif    
    
    
#if (defined(USE_IMPROVED_TIMING_CONFIG) && USE_IMPROVED_TIMING_CONFIG)
    flexcan_timing_config_t timing_config;
    memset(&timing_config, 0, sizeof(flexcan_timing_config_t));
#if (defined(USE_CANFD) && USE_CANFD)
    if (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#else
    if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#endif
#endif

#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_FDInit(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true);
#else
    FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ);
#endif

    /* Create FlexCAN handle structure and set call back function. */
    FLEXCAN_TransferCreateHandle(EXAMPLE_CAN, &flexcanHandle, flexcan_callback, NULL);

    /* Set Rx Masking mechanism. */
    FLEXCAN_SetRxMbGlobalMask(EXAMPLE_CAN, FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0));
           
    /* Setup Rx Message Buffer. */
    mbConfig.format = kFLEXCAN_FrameFormatStandard;
    mbConfig.type   = kFLEXCAN_FrameTypeData;
    mbConfig.id     = FLEXCAN_ID_STD(RX_IDENTIFIER);
#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#else
    FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#endif

/* Setup Tx Message Buffer. */
#if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#else
    FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#endif
    
}
|———Node:{ Text: {
|———Node:declaration Text: flexcan_config_t flexcanConfig;
|————Node:type_identifier Text: flexcan_config_t
|————Node:identifier Text: flexcanConfig
|————Node:; Text: ;
|———Node:declaration Text: flexcan_rx_mb_config_t mbConfig;
|————Node:type_identifier Text: flexcan_rx_mb_config_t
|————Node:identifier Text: mbConfig
|————Node:; Text: ;
|———Node:comment
|———Node:expression_statement Text: CLOCK_SetClkDiv(kCLOCK_DivFlexcan0Clk, 1u);
|————Node:call_expression Text: CLOCK_SetClkDiv(kCLOCK_DivFlexcan0Clk, 1u)
|—————Node:identifier Text: CLOCK_SetClkDiv
|—————Node:argument_list Text: (kCLOCK_DivFlexcan0Clk, 1u)
|——————Node:( Text: (
|——————Node:identifier Text: kCLOCK_DivFlexcan0Clk
|——————Node:, Text: ,
|——————Node:number_literal Text: 1u
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: CLOCK_AttachClk(kFRO_HF_to_FLEXCAN0);
|————Node:call_expression Text: CLOCK_AttachClk(kFRO_HF_to_FLEXCAN0)
|—————Node:identifier Text: CLOCK_AttachClk
|—————Node:argument_list Text: (kFRO_HF_to_FLEXCAN0)
|——————Node:( Text: (
|——————Node:identifier Text: kFRO_HF_to_FLEXCAN0
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: LOG_INFO("\r\n== USB Adapter Example -- Start.==\r\n\r\n");
|————Node:call_expression Text: LOG_INFO("\r\n== USB Adapter Example -- Start.==\r\n\r\n")
|—————Node:identifier Text: LOG_INFO
|—————Node:argument_list Text: ("\r\n== USB Adapter Example -- Start.==\r\n\r\n")
|——————Node:( Text: (
|——————Node:string_literal Text: "\r\n== USB Adapter Example -- Start.==\r\n\r\n"
|———————Node:" Text: "
|———————Node:escape_sequence Text: \r
|———————Node:escape_sequence Text: \n
|———————Node:string_content Text: == USB Adapter Example -- Start.==
|———————Node:escape_sequence Text: \r
|———————Node:escape_sequence Text: \n
|———————Node:escape_sequence Text: \r
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment
|———Node:comment
|———Node:expression_statement Text: FLEXCAN_GetDefaultConfig(&flexcanConfig);
|————Node:call_expression Text: FLEXCAN_GetDefaultConfig(&flexcanConfig)
|—————Node:identifier Text: FLEXCAN_GetDefaultConfig
|—————Node:argument_list Text: (&flexcanConfig)
|——————Node:( Text: (
|——————Node:pointer_expression Text: &flexcanConfig
|———————Node:& Text: &
|———————Node:identifier Text: flexcanConfig
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: flexcanConfig.bitRate                = bitrate;
|————Node:assignment_expression Text: flexcanConfig.bitRate                = bitrate
|—————Node:field_expression Text: flexcanConfig.bitRate
|——————Node:identifier Text: flexcanConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: bitRate
|—————Node:= Text: =
|—————Node:identifier Text: bitrate
|————Node:; Text: ;
|———Node:expression_statement Text: flexcanConfig.bitRateFD              = fdBitrate;
|————Node:assignment_expression Text: flexcanConfig.bitRateFD              = fdBitrate
|—————Node:field_expression Text: flexcanConfig.bitRateFD
|——————Node:identifier Text: flexcanConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: bitRateFD
|—————Node:= Text: =
|—————Node:identifier Text: fdBitrate
|————Node:; Text: ;
|———Node:preproc_if Text: #if defined(EXAMPLE_CAN_CLK_SOURCE)
    flexcanConfig.clkSrc = EXAMPLE_CAN_CLK_SOURCE;
#endif
|————Node:#if Text: #if
|————Node:preproc_defined Text: defined(EXAMPLE_CAN_CLK_SOURCE)
|—————Node:defined Text: defined
|—————Node:( Text: (
|—————Node:identifier Text: EXAMPLE_CAN_CLK_SOURCE
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: flexcanConfig.clkSrc = EXAMPLE_CAN_CLK_SOURCE;
|—————Node:assignment_expression Text: flexcanConfig.clkSrc = EXAMPLE_CAN_CLK_SOURCE
|——————Node:field_expression Text: flexcanConfig.clkSrc
|———————Node:identifier Text: flexcanConfig
|———————Node:. Text: .
|———————Node:field_identifier Text: clkSrc
|——————Node:= Text: =
|——————Node:identifier Text: EXAMPLE_CAN_CLK_SOURCE
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:comment
|———Node:preproc_if Text: #if (defined(SET_CAN_QUANTUM) && SET_CAN_QUANTUM)
    flexcanConfig.timingConfig.phaseSeg1 = PSEG1;
    flexcanConfig.timingConfig.phaseSeg2 = PSEG2;
    flexcanConfig.timingConfig.propSeg   = PROPSEG;
#if (defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
    flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1;
    flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2;
    flexcanConfig.timingConfig.fpropSeg   = FPROPSEG;
#endif
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(SET_CAN_QUANTUM) && SET_CAN_QUANTUM)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(SET_CAN_QUANTUM) && SET_CAN_QUANTUM
|——————Node:preproc_defined Text: defined(SET_CAN_QUANTUM)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: SET_CAN_QUANTUM
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: SET_CAN_QUANTUM
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: flexcanConfig.timingConfig.phaseSeg1 = PSEG1;
|—————Node:assignment_expression Text: flexcanConfig.timingConfig.phaseSeg1 = PSEG1
|——————Node:field_expression Text: flexcanConfig.timingConfig.phaseSeg1
|———————Node:field_expression Text: flexcanConfig.timingConfig
|————————Node:identifier Text: flexcanConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: timingConfig
|———————Node:. Text: .
|———————Node:field_identifier Text: phaseSeg1
|——————Node:= Text: =
|——————Node:identifier Text: PSEG1
|—————Node:; Text: ;
|————Node:expression_statement Text: flexcanConfig.timingConfig.phaseSeg2 = PSEG2;
|—————Node:assignment_expression Text: flexcanConfig.timingConfig.phaseSeg2 = PSEG2
|——————Node:field_expression Text: flexcanConfig.timingConfig.phaseSeg2
|———————Node:field_expression Text: flexcanConfig.timingConfig
|————————Node:identifier Text: flexcanConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: timingConfig
|———————Node:. Text: .
|———————Node:field_identifier Text: phaseSeg2
|——————Node:= Text: =
|——————Node:identifier Text: PSEG2
|—————Node:; Text: ;
|————Node:expression_statement Text: flexcanConfig.timingConfig.propSeg   = PROPSEG;
|—————Node:assignment_expression Text: flexcanConfig.timingConfig.propSeg   = PROPSEG
|——————Node:field_expression Text: flexcanConfig.timingConfig.propSeg
|———————Node:field_expression Text: flexcanConfig.timingConfig
|————————Node:identifier Text: flexcanConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: timingConfig
|———————Node:. Text: .
|———————Node:field_identifier Text: propSeg
|——————Node:= Text: =
|——————Node:identifier Text: PROPSEG
|—————Node:; Text: ;
|————Node:preproc_if Text: #if (defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
    flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1;
    flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2;
    flexcanConfig.timingConfig.fpropSeg   = FPROPSEG;
#endif
|—————Node:#if Text: #if
|—————Node:parenthesized_expression Text: (defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
|——————Node:( Text: (
|——————Node:binary_expression Text: defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE) && FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE
|———————Node:preproc_defined Text: defined(FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE)
|————————Node:defined Text: defined
|————————Node:( Text: (
|————————Node:identifier Text: FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE
|————————Node:) Text: )
|———————Node:&& Text: &&
|———————Node:identifier Text: FSL_FEATURE_FLEXCAN_HAS_FLEXIBLE_DATA_RATE
|——————Node:) Text: )
|—————Node:
 Text: 

|—————Node:expression_statement Text: flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1;
|——————Node:assignment_expression Text: flexcanConfig.timingConfig.fphaseSeg1 = FPSEG1
|———————Node:field_expression Text: flexcanConfig.timingConfig.fphaseSeg1
|————————Node:field_expression Text: flexcanConfig.timingConfig
|—————————Node:identifier Text: flexcanConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: timingConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: fphaseSeg1
|———————Node:= Text: =
|———————Node:identifier Text: FPSEG1
|——————Node:; Text: ;
|—————Node:expression_statement Text: flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2;
|——————Node:assignment_expression Text: flexcanConfig.timingConfig.fphaseSeg2 = FPSEG2
|———————Node:field_expression Text: flexcanConfig.timingConfig.fphaseSeg2
|————————Node:field_expression Text: flexcanConfig.timingConfig
|—————————Node:identifier Text: flexcanConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: timingConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: fphaseSeg2
|———————Node:= Text: =
|———————Node:identifier Text: FPSEG2
|——————Node:; Text: ;
|—————Node:expression_statement Text: flexcanConfig.timingConfig.fpropSeg   = FPROPSEG;
|——————Node:assignment_expression Text: flexcanConfig.timingConfig.fpropSeg   = FPROPSEG
|———————Node:field_expression Text: flexcanConfig.timingConfig.fpropSeg
|————————Node:field_expression Text: flexcanConfig.timingConfig
|—————————Node:identifier Text: flexcanConfig
|—————————Node:. Text: .
|—————————Node:field_identifier Text: timingConfig
|————————Node:. Text: .
|————————Node:field_identifier Text: fpropSeg
|———————Node:= Text: =
|———————Node:identifier Text: FPROPSEG
|——————Node:; Text: ;
|—————Node:#endif Text: #endif
|————Node:#endif Text: #endif
|———Node:preproc_if Text: #if (defined(USE_IMPROVED_TIMING_CONFIG) && USE_IMPROVED_TIMING_CONFIG)
    flexcan_timing_config_t timing_config;
    memset(&timing_config, 0, sizeof(flexcan_timing_config_t));
#if (defined(USE_CANFD) && USE_CANFD)
    if (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#else
    if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#endif
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_IMPROVED_TIMING_CONFIG) && USE_IMPROVED_TIMING_CONFIG)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_IMPROVED_TIMING_CONFIG) && USE_IMPROVED_TIMING_CONFIG
|——————Node:preproc_defined Text: defined(USE_IMPROVED_TIMING_CONFIG)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_IMPROVED_TIMING_CONFIG
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_IMPROVED_TIMING_CONFIG
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:declaration Text: flexcan_timing_config_t timing_config;
|—————Node:type_identifier Text: flexcan_timing_config_t
|—————Node:identifier Text: timing_config
|—————Node:; Text: ;
|————Node:expression_statement Text: memset(&timing_config, 0, sizeof(flexcan_timing_config_t));
|—————Node:call_expression Text: memset(&timing_config, 0, sizeof(flexcan_timing_config_t))
|——————Node:identifier Text: memset
|——————Node:argument_list Text: (&timing_config, 0, sizeof(flexcan_timing_config_t))
|———————Node:( Text: (
|———————Node:pointer_expression Text: &timing_config
|————————Node:& Text: &
|————————Node:identifier Text: timing_config
|———————Node:, Text: ,
|———————Node:number_literal Text: 0
|———————Node:, Text: ,
|———————Node:sizeof_expression Text: sizeof(flexcan_timing_config_t)
|————————Node:sizeof Text: sizeof
|————————Node:parenthesized_expression Text: (flexcan_timing_config_t)
|—————————Node:( Text: (
|—————————Node:identifier Text: flexcan_timing_config_t
|—————————Node:) Text: )
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    if (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#else
    if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
#endif
|—————Node:#if Text: #if
|—————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|——————Node:( Text: (
|——————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|———————Node:preproc_defined Text: defined(USE_CANFD)
|————————Node:defined Text: defined
|————————Node:( Text: (
|————————Node:identifier Text: USE_CANFD
|————————Node:) Text: )
|———————Node:&& Text: &&
|———————Node:identifier Text: USE_CANFD
|——————Node:) Text: )
|—————Node:
 Text: 

|—————Node:if_statement Text: if (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config))
|———————Node:( Text: (
|———————Node:call_expression Text: FLEXCAN_FDCalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config)
|————————Node:identifier Text: FLEXCAN_FDCalculateImprovedTimingValues
|————————Node:argument_list Text: (EXAMPLE_CAN, flexcanConfig.bitRate, flexcanConfig.bitRateFD,
                                                EXAMPLE_CAN_CLK_FREQ, &timing_config)
|—————————Node:( Text: (
|—————————Node:identifier Text: EXAMPLE_CAN
|—————————Node:, Text: ,
|—————————Node:field_expression Text: flexcanConfig.bitRate
|——————————Node:identifier Text: flexcanConfig
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitRate
|—————————Node:, Text: ,
|—————————Node:field_expression Text: flexcanConfig.bitRateFD
|——————————Node:identifier Text: flexcanConfig
|——————————Node:. Text: .
|——————————Node:field_identifier Text: bitRateFD
|—————————Node:, Text: ,
|—————————Node:identifier Text: EXAMPLE_CAN_CLK_FREQ
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &timing_config
|——————————Node:& Text: &
|——————————Node:identifier Text: timing_config
|—————————Node:) Text: )
|———————Node:) Text: )
|——————Node:compound_statement Text: {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
|———————Node:{ Text: {
|———————Node:comment
|———————Node:expression_statement Text: memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
|————————Node:call_expression Text: memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t))
|—————————Node:identifier Text: memcpy
|—————————Node:argument_list Text: (&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t))
|——————————Node:( Text: (
|——————————Node:pointer_expression Text: &(flexcanConfig.timingConfig)
|———————————Node:& Text: &
|———————————Node:parenthesized_expression Text: (flexcanConfig.timingConfig)
|————————————Node:( Text: (
|————————————Node:field_expression Text: flexcanConfig.timingConfig
|—————————————Node:identifier Text: flexcanConfig
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: timingConfig
|————————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &timing_config
|———————————Node:& Text: &
|———————————Node:identifier Text: timing_config
|——————————Node:, Text: ,
|——————————Node:sizeof_expression Text: sizeof(flexcan_timing_config_t)
|———————————Node:sizeof Text: sizeof
|———————————Node:parenthesized_expression Text: (flexcan_timing_config_t)
|————————————Node:( Text: (
|————————————Node:identifier Text: flexcan_timing_config_t
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|——————Node:else_clause Text: else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|———————Node:else Text: else
|———————Node:compound_statement Text: {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|————————Node:{ Text: {
|————————Node:expression_statement Text: LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
|—————————Node:call_expression Text: LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n")
|——————————Node:identifier Text: LOG_INFO
|——————————Node:argument_list Text: ("No found Improved Timing Configuration. Just used default configuration\r\n\r\n")
|———————————Node:( Text: (
|———————————Node:string_literal Text: "No found Improved Timing Configuration. Just used default configuration\r\n\r\n"
|————————————Node:" Text: "
|————————————Node:string_content Text: No found Improved Timing Configuration. Just used default configuration
|————————————Node:escape_sequence Text: \r
|————————————Node:escape_sequence Text: \n
|————————————Node:escape_sequence Text: \r
|————————————Node:escape_sequence Text: \n
|————————————Node:" Text: "
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|—————Node:preproc_else Text: #else
    if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|——————Node:#else Text: #else
|——————Node:if_statement Text: if (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
    {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
    else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|———————Node:if Text: if
|———————Node:parenthesized_expression Text: (FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config))
|————————Node:( Text: (
|————————Node:call_expression Text: FLEXCAN_CalculateImprovedTimingValues(EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config)
|—————————Node:identifier Text: FLEXCAN_CalculateImprovedTimingValues
|—————————Node:argument_list Text: (EXAMPLE_CAN, flexcanConfig.bitRate, EXAMPLE_CAN_CLK_FREQ, &timing_config)
|——————————Node:( Text: (
|——————————Node:identifier Text: EXAMPLE_CAN
|——————————Node:, Text: ,
|——————————Node:field_expression Text: flexcanConfig.bitRate
|———————————Node:identifier Text: flexcanConfig
|———————————Node:. Text: .
|———————————Node:field_identifier Text: bitRate
|——————————Node:, Text: ,
|——————————Node:identifier Text: EXAMPLE_CAN_CLK_FREQ
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &timing_config
|———————————Node:& Text: &
|———————————Node:identifier Text: timing_config
|——————————Node:) Text: )
|————————Node:) Text: )
|———————Node:compound_statement Text: {
        /* Update the improved timing configuration*/
        memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
    }
|————————Node:{ Text: {
|————————Node:comment
|————————Node:expression_statement Text: memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t));
|—————————Node:call_expression Text: memcpy(&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t))
|——————————Node:identifier Text: memcpy
|——————————Node:argument_list Text: (&(flexcanConfig.timingConfig), &timing_config, sizeof(flexcan_timing_config_t))
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: &(flexcanConfig.timingConfig)
|————————————Node:& Text: &
|————————————Node:parenthesized_expression Text: (flexcanConfig.timingConfig)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: flexcanConfig.timingConfig
|——————————————Node:identifier Text: flexcanConfig
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: timingConfig
|—————————————Node:) Text: )
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &timing_config
|————————————Node:& Text: &
|————————————Node:identifier Text: timing_config
|———————————Node:, Text: ,
|———————————Node:sizeof_expression Text: sizeof(flexcan_timing_config_t)
|————————————Node:sizeof Text: sizeof
|————————————Node:parenthesized_expression Text: (flexcan_timing_config_t)
|—————————————Node:( Text: (
|—————————————Node:identifier Text: flexcan_timing_config_t
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:} Text: }
|———————Node:else_clause Text: else
    {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|————————Node:else Text: else
|————————Node:compound_statement Text: {
        LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
    }
|—————————Node:{ Text: {
|—————————Node:expression_statement Text: LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n");
|——————————Node:call_expression Text: LOG_INFO("No found Improved Timing Configuration. Just used default configuration\r\n\r\n")
|———————————Node:identifier Text: LOG_INFO
|———————————Node:argument_list Text: ("No found Improved Timing Configuration. Just used default configuration\r\n\r\n")
|————————————Node:( Text: (
|————————————Node:string_literal Text: "No found Improved Timing Configuration. Just used default configuration\r\n\r\n"
|—————————————Node:" Text: "
|—————————————Node:string_content Text: No found Improved Timing Configuration. Just used default configuration
|—————————————Node:escape_sequence Text: \r
|—————————————Node:escape_sequence Text: \n
|—————————————Node:escape_sequence Text: \r
|—————————————Node:escape_sequence Text: \n
|—————————————Node:" Text: "
|————————————Node:) Text: )
|——————————Node:; Text: ;
|—————————Node:} Text: }
|—————Node:#endif Text: #endif
|————Node:#endif Text: #endif
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_FDInit(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true);
#else
    FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: FLEXCAN_FDInit(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true);
|—————Node:call_expression Text: FLEXCAN_FDInit(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true)
|——————Node:identifier Text: FLEXCAN_FDInit
|——————Node:argument_list Text: (EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ, BYTES_IN_MB, true)
|———————Node:( Text: (
|———————Node:identifier Text: EXAMPLE_CAN
|———————Node:, Text: ,
|———————Node:pointer_expression Text: &flexcanConfig
|————————Node:& Text: &
|————————Node:identifier Text: flexcanConfig
|———————Node:, Text: ,
|———————Node:identifier Text: EXAMPLE_CAN_CLK_FREQ
|———————Node:, Text: ,
|———————Node:identifier Text: BYTES_IN_MB
|———————Node:, Text: ,
|———————Node:true Text: true
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ);
|——————Node:call_expression Text: FLEXCAN_Init(EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ)
|———————Node:identifier Text: FLEXCAN_Init
|———————Node:argument_list Text: (EXAMPLE_CAN, &flexcanConfig, EXAMPLE_CAN_CLK_FREQ)
|————————Node:( Text: (
|————————Node:identifier Text: EXAMPLE_CAN
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &flexcanConfig
|—————————Node:& Text: &
|—————————Node:identifier Text: flexcanConfig
|————————Node:, Text: ,
|————————Node:identifier Text: EXAMPLE_CAN_CLK_FREQ
|————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:comment
|———Node:expression_statement Text: FLEXCAN_TransferCreateHandle(EXAMPLE_CAN, &flexcanHandle, flexcan_callback, NULL);
|————Node:call_expression Text: FLEXCAN_TransferCreateHandle(EXAMPLE_CAN, &flexcanHandle, flexcan_callback, NULL)
|—————Node:identifier Text: FLEXCAN_TransferCreateHandle
|—————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, flexcan_callback, NULL)
|——————Node:( Text: (
|——————Node:identifier Text: EXAMPLE_CAN
|——————Node:, Text: ,
|——————Node:pointer_expression Text: &flexcanHandle
|———————Node:& Text: &
|———————Node:identifier Text: flexcanHandle
|——————Node:, Text: ,
|——————Node:identifier Text: flexcan_callback
|——————Node:, Text: ,
|——————Node:null Text: NULL
|———————Node:NULL Text: NULL
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment
|———Node:expression_statement Text: FLEXCAN_SetRxMbGlobalMask(EXAMPLE_CAN, FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0));
|————Node:call_expression Text: FLEXCAN_SetRxMbGlobalMask(EXAMPLE_CAN, FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0))
|—————Node:identifier Text: FLEXCAN_SetRxMbGlobalMask
|—————Node:argument_list Text: (EXAMPLE_CAN, FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0))
|——————Node:( Text: (
|——————Node:identifier Text: EXAMPLE_CAN
|——————Node:, Text: ,
|——————Node:call_expression Text: FLEXCAN_RX_MB_STD_MASK(RX_IDENTIFIER, 0, 0)
|———————Node:identifier Text: FLEXCAN_RX_MB_STD_MASK
|———————Node:argument_list Text: (RX_IDENTIFIER, 0, 0)
|————————Node:( Text: (
|————————Node:identifier Text: RX_IDENTIFIER
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:, Text: ,
|————————Node:number_literal Text: 0
|————————Node:) Text: )
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:comment
|———Node:expression_statement Text: mbConfig.format = kFLEXCAN_FrameFormatStandard;
|————Node:assignment_expression Text: mbConfig.format = kFLEXCAN_FrameFormatStandard
|—————Node:field_expression Text: mbConfig.format
|——————Node:identifier Text: mbConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: format
|—————Node:= Text: =
|—————Node:identifier Text: kFLEXCAN_FrameFormatStandard
|————Node:; Text: ;
|———Node:expression_statement Text: mbConfig.type   = kFLEXCAN_FrameTypeData;
|————Node:assignment_expression Text: mbConfig.type   = kFLEXCAN_FrameTypeData
|—————Node:field_expression Text: mbConfig.type
|——————Node:identifier Text: mbConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: type
|—————Node:= Text: =
|—————Node:identifier Text: kFLEXCAN_FrameTypeData
|————Node:; Text: ;
|———Node:expression_statement Text: mbConfig.id     = FLEXCAN_ID_STD(RX_IDENTIFIER);
|————Node:assignment_expression Text: mbConfig.id     = FLEXCAN_ID_STD(RX_IDENTIFIER)
|—————Node:field_expression Text: mbConfig.id
|——————Node:identifier Text: mbConfig
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|—————Node:= Text: =
|—————Node:call_expression Text: FLEXCAN_ID_STD(RX_IDENTIFIER)
|——————Node:identifier Text: FLEXCAN_ID_STD
|——————Node:argument_list Text: (RX_IDENTIFIER)
|———————Node:( Text: (
|———————Node:identifier Text: RX_IDENTIFIER
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#else
    FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: FLEXCAN_SetFDRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
|—————Node:call_expression Text: FLEXCAN_SetFDRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true)
|——————Node:identifier Text: FLEXCAN_SetFDRxMbConfig
|——————Node:argument_list Text: (EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true)
|———————Node:( Text: (
|———————Node:identifier Text: EXAMPLE_CAN
|———————Node:, Text: ,
|———————Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|———————Node:, Text: ,
|———————Node:pointer_expression Text: &mbConfig
|————————Node:& Text: &
|————————Node:identifier Text: mbConfig
|———————Node:, Text: ,
|———————Node:true Text: true
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true);
|——————Node:call_expression Text: FLEXCAN_SetRxMbConfig(EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true)
|———————Node:identifier Text: FLEXCAN_SetRxMbConfig
|———————Node:argument_list Text: (EXAMPLE_CAN, RX_MESSAGE_BUFFER_NUM, &mbConfig, true)
|————————Node:( Text: (
|————————Node:identifier Text: EXAMPLE_CAN
|————————Node:, Text: ,
|————————Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|————————Node:, Text: ,
|————————Node:pointer_expression Text: &mbConfig
|—————————Node:& Text: &
|—————————Node:identifier Text: mbConfig
|————————Node:, Text: ,
|————————Node:true Text: true
|————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:comment
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    FLEXCAN_SetFDTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#else
    FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: FLEXCAN_SetFDTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
|—————Node:call_expression Text: FLEXCAN_SetFDTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true)
|——————Node:identifier Text: FLEXCAN_SetFDTxMbConfig
|——————Node:argument_list Text: (EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true)
|———————Node:( Text: (
|———————Node:identifier Text: EXAMPLE_CAN
|———————Node:, Text: ,
|———————Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|———————Node:, Text: ,
|———————Node:true Text: true
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true);
|——————Node:call_expression Text: FLEXCAN_SetTxMbConfig(EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true)
|———————Node:identifier Text: FLEXCAN_SetTxMbConfig
|———————Node:argument_list Text: (EXAMPLE_CAN, TX_MESSAGE_BUFFER_NUM, true)
|————————Node:( Text: (
|————————Node:identifier Text: EXAMPLE_CAN
|————————Node:, Text: ,
|————————Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|————————Node:, Text: ,
|————————Node:true Text: true
|————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: uint32_t APPCanSend(uint32_t id, uint8_t *buff, uint32_t len)
{
    uint32_t txStatus;
    uint8_t i;

    /* Prepare Tx Frame for sending. */
    txFrame.format = (uint8_t)kFLEXCAN_FrameFormatStandard;
    txFrame.type   = (uint8_t)kFLEXCAN_FrameTypeData;
    txFrame.id     = FLEXCAN_ID_STD(id);
    txFrame.length = (uint8_t)len;
#if (defined(USE_CANFD) && USE_CANFD)
    txFrame.brs = 1U;
#endif
    
#if(defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
      txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
    }
#else
    /* Copy the message doing byte swap */
    txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)));
    txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))));
#endif
    
    LOG_INFO("Send message from MB%d to MB%d\r\n", TX_MESSAGE_BUFFER_NUM, RX_MESSAGE_BUFFER_NUM);


#if (defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
        LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
    }
#else
    LOG_INFO("tx ID = 0x%x\r\n", id);
    LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0);
    LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1);
#endif
    /* Start frame transmission */
    txXfer.mbIdx = (uint8_t)TX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
    txXfer.framefd = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#else
    txXfer.frame = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#endif
   
    return txStatus;
}
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: APPCanSend(uint32_t id, uint8_t *buff, uint32_t len)
|———Node:identifier Text: APPCanSend
|———Node:parameter_list Text: (uint32_t id, uint8_t *buff, uint32_t len)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t *buff
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: *buff
|——————Node:* Text: *
|——————Node:identifier Text: buff
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t len
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: len
|————Node:) Text: )
|——Node:compound_statement Text: {
    uint32_t txStatus;
    uint8_t i;

    /* Prepare Tx Frame for sending. */
    txFrame.format = (uint8_t)kFLEXCAN_FrameFormatStandard;
    txFrame.type   = (uint8_t)kFLEXCAN_FrameTypeData;
    txFrame.id     = FLEXCAN_ID_STD(id);
    txFrame.length = (uint8_t)len;
#if (defined(USE_CANFD) && USE_CANFD)
    txFrame.brs = 1U;
#endif
    
#if(defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
      txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
    }
#else
    /* Copy the message doing byte swap */
    txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)));
    txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))));
#endif
    
    LOG_INFO("Send message from MB%d to MB%d\r\n", TX_MESSAGE_BUFFER_NUM, RX_MESSAGE_BUFFER_NUM);


#if (defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
        LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
    }
#else
    LOG_INFO("tx ID = 0x%x\r\n", id);
    LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0);
    LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1);
#endif
    /* Start frame transmission */
    txXfer.mbIdx = (uint8_t)TX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
    txXfer.framefd = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#else
    txXfer.frame = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#endif
   
    return txStatus;
}
|———Node:{ Text: {
|———Node:declaration Text: uint32_t txStatus;
|————Node:primitive_type Text: uint32_t
|————Node:identifier Text: txStatus
|————Node:; Text: ;
|———Node:declaration Text: uint8_t i;
|————Node:primitive_type Text: uint8_t
|————Node:identifier Text: i
|————Node:; Text: ;
|———Node:comment
|———Node:expression_statement Text: txFrame.format = (uint8_t)kFLEXCAN_FrameFormatStandard;
|————Node:assignment_expression Text: txFrame.format = (uint8_t)kFLEXCAN_FrameFormatStandard
|—————Node:field_expression Text: txFrame.format
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: format
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint8_t)kFLEXCAN_FrameFormatStandard
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint8_t
|———————Node:primitive_type Text: uint8_t
|——————Node:) Text: )
|——————Node:identifier Text: kFLEXCAN_FrameFormatStandard
|————Node:; Text: ;
|———Node:expression_statement Text: txFrame.type   = (uint8_t)kFLEXCAN_FrameTypeData;
|————Node:assignment_expression Text: txFrame.type   = (uint8_t)kFLEXCAN_FrameTypeData
|—————Node:field_expression Text: txFrame.type
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: type
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint8_t)kFLEXCAN_FrameTypeData
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint8_t
|———————Node:primitive_type Text: uint8_t
|——————Node:) Text: )
|——————Node:identifier Text: kFLEXCAN_FrameTypeData
|————Node:; Text: ;
|———Node:expression_statement Text: txFrame.id     = FLEXCAN_ID_STD(id);
|————Node:assignment_expression Text: txFrame.id     = FLEXCAN_ID_STD(id)
|—————Node:field_expression Text: txFrame.id
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: id
|—————Node:= Text: =
|—————Node:call_expression Text: FLEXCAN_ID_STD(id)
|——————Node:identifier Text: FLEXCAN_ID_STD
|——————Node:argument_list Text: (id)
|———————Node:( Text: (
|———————Node:identifier Text: id
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:expression_statement Text: txFrame.length = (uint8_t)len;
|————Node:assignment_expression Text: txFrame.length = (uint8_t)len
|—————Node:field_expression Text: txFrame.length
|——————Node:identifier Text: txFrame
|——————Node:. Text: .
|——————Node:field_identifier Text: length
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint8_t)len
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint8_t
|———————Node:primitive_type Text: uint8_t
|——————Node:) Text: )
|——————Node:identifier Text: len
|————Node:; Text: ;
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    txFrame.brs = 1U;
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: txFrame.brs = 1U;
|—————Node:assignment_expression Text: txFrame.brs = 1U
|——————Node:field_expression Text: txFrame.brs
|———————Node:identifier Text: txFrame
|———————Node:. Text: .
|———————Node:field_identifier Text: brs
|——————Node:= Text: =
|——————Node:number_literal Text: 1U
|—————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:preproc_if Text: #if(defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
      txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
    }
#else
    /* Copy the message doing byte swap */
    txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)));
    txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))));
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:for_statement Text: for (i = 0; i < DWORD_IN_MB; i++)
    {
      txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
    }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:assignment_expression Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|—————Node:binary_expression Text: i < DWORD_IN_MB
|——————Node:identifier Text: i
|——————Node:< Text: <
|——————Node:identifier Text: DWORD_IN_MB
|—————Node:; Text: ;
|—————Node:update_expression Text: i++
|——————Node:identifier Text: i
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
      txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)));
|———————Node:assignment_expression Text: txFrame.dataWord[i] = endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)))
|————————Node:subscript_expression Text: txFrame.dataWord[i]
|—————————Node:field_expression Text: txFrame.dataWord
|——————————Node:identifier Text: txFrame
|——————————Node:. Text: .
|——————————Node:field_identifier Text: dataWord
|—————————Node:[ Text: [
|—————————Node:identifier Text: i
|—————————Node:] Text: ]
|————————Node:= Text: =
|————————Node:call_expression Text: endianSwap4bytes((uint32_t)(*((uint32_t *)buff + i)))
|—————————Node:identifier Text: endianSwap4bytes
|—————————Node:argument_list Text: ((uint32_t)(*((uint32_t *)buff + i)))
|——————————Node:( Text: (
|——————————Node:cast_expression Text: (uint32_t)(*((uint32_t *)buff + i))
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: uint32_t
|————————————Node:primitive_type Text: uint32_t
|———————————Node:) Text: )
|———————————Node:parenthesized_expression Text: (*((uint32_t *)buff + i))
|————————————Node:( Text: (
|————————————Node:pointer_expression Text: *((uint32_t *)buff + i)
|—————————————Node:* Text: *
|—————————————Node:parenthesized_expression Text: ((uint32_t *)buff + i)
|——————————————Node:( Text: (
|——————————————Node:binary_expression Text: (uint32_t *)buff + i
|———————————————Node:cast_expression Text: (uint32_t *)buff
|————————————————Node:( Text: (
|————————————————Node:type_descriptor Text: uint32_t *
|—————————————————Node:primitive_type Text: uint32_t
|—————————————————Node:abstract_pointer_declarator Text: *
|——————————————————Node:* Text: *
|————————————————Node:) Text: )
|————————————————Node:identifier Text: buff
|———————————————Node:+ Text: +
|———————————————Node:identifier Text: i
|——————————————Node:) Text: )
|————————————Node:) Text: )
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:preproc_else Text: #else
    /* Copy the message doing byte swap */
    txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)));
    txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))));
|—————Node:#else Text: #else
|—————Node:comment
|—————Node:expression_statement Text: txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)));
|——————Node:assignment_expression Text: txFrame.dataWord0 = endianSwap4bytes((uint32_t)(*((uint32_t *)buff)))
|———————Node:field_expression Text: txFrame.dataWord0
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: dataWord0
|———————Node:= Text: =
|———————Node:call_expression Text: endianSwap4bytes((uint32_t)(*((uint32_t *)buff)))
|————————Node:identifier Text: endianSwap4bytes
|————————Node:argument_list Text: ((uint32_t)(*((uint32_t *)buff)))
|—————————Node:( Text: (
|—————————Node:cast_expression Text: (uint32_t)(*((uint32_t *)buff))
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: uint32_t
|———————————Node:primitive_type Text: uint32_t
|——————————Node:) Text: )
|——————————Node:parenthesized_expression Text: (*((uint32_t *)buff))
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: *((uint32_t *)buff)
|————————————Node:* Text: *
|————————————Node:parenthesized_expression Text: ((uint32_t *)buff)
|—————————————Node:( Text: (
|—————————————Node:cast_expression Text: (uint32_t *)buff
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: uint32_t *
|———————————————Node:primitive_type Text: uint32_t
|———————————————Node:abstract_pointer_declarator Text: *
|————————————————Node:* Text: *
|——————————————Node:) Text: )
|——————————————Node:identifier Text: buff
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))));
|——————Node:assignment_expression Text: txFrame.dataWord1 = endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))))
|———————Node:field_expression Text: txFrame.dataWord1
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: dataWord1
|———————Node:= Text: =
|———————Node:call_expression Text: endianSwap4bytes((uint32_t)(*((uint32_t *)(buff + 4))))
|————————Node:identifier Text: endianSwap4bytes
|————————Node:argument_list Text: ((uint32_t)(*((uint32_t *)(buff + 4))))
|—————————Node:( Text: (
|—————————Node:cast_expression Text: (uint32_t)(*((uint32_t *)(buff + 4)))
|——————————Node:( Text: (
|——————————Node:type_descriptor Text: uint32_t
|———————————Node:primitive_type Text: uint32_t
|——————————Node:) Text: )
|——————————Node:parenthesized_expression Text: (*((uint32_t *)(buff + 4)))
|———————————Node:( Text: (
|———————————Node:pointer_expression Text: *((uint32_t *)(buff + 4))
|————————————Node:* Text: *
|————————————Node:parenthesized_expression Text: ((uint32_t *)(buff + 4))
|—————————————Node:( Text: (
|—————————————Node:cast_expression Text: (uint32_t *)(buff + 4)
|——————————————Node:( Text: (
|——————————————Node:type_descriptor Text: uint32_t *
|———————————————Node:primitive_type Text: uint32_t
|———————————————Node:abstract_pointer_declarator Text: *
|————————————————Node:* Text: *
|——————————————Node:) Text: )
|——————————————Node:parenthesized_expression Text: (buff + 4)
|———————————————Node:( Text: (
|———————————————Node:binary_expression Text: buff + 4
|————————————————Node:identifier Text: buff
|————————————————Node:+ Text: +
|————————————————Node:number_literal Text: 4
|———————————————Node:) Text: )
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:expression_statement Text: LOG_INFO("Send message from MB%d to MB%d\r\n", TX_MESSAGE_BUFFER_NUM, RX_MESSAGE_BUFFER_NUM);
|————Node:call_expression Text: LOG_INFO("Send message from MB%d to MB%d\r\n", TX_MESSAGE_BUFFER_NUM, RX_MESSAGE_BUFFER_NUM)
|—————Node:identifier Text: LOG_INFO
|—————Node:argument_list Text: ("Send message from MB%d to MB%d\r\n", TX_MESSAGE_BUFFER_NUM, RX_MESSAGE_BUFFER_NUM)
|——————Node:( Text: (
|——————Node:string_literal Text: "Send message from MB%d to MB%d\r\n"
|———————Node:" Text: "
|———————Node:string_content Text: Send message from MB%d to MB%d
|———————Node:escape_sequence Text: \r
|———————Node:escape_sequence Text: \n
|———————Node:" Text: "
|——————Node:, Text: ,
|——————Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|——————Node:, Text: ,
|——————Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|——————Node:) Text: )
|————Node:; Text: ;
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    for (i = 0; i < DWORD_IN_MB; i++)
    {
        LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
    }
#else
    LOG_INFO("tx ID = 0x%x\r\n", id);
    LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0);
    LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:for_statement Text: for (i = 0; i < DWORD_IN_MB; i++)
    {
        LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
    }
|—————Node:for Text: for
|—————Node:( Text: (
|—————Node:assignment_expression Text: i = 0
|——————Node:identifier Text: i
|——————Node:= Text: =
|——————Node:number_literal Text: 0
|—————Node:; Text: ;
|—————Node:binary_expression Text: i < DWORD_IN_MB
|——————Node:identifier Text: i
|——————Node:< Text: <
|——————Node:identifier Text: DWORD_IN_MB
|—————Node:; Text: ;
|—————Node:update_expression Text: i++
|——————Node:identifier Text: i
|——————Node:++ Text: ++
|—————Node:) Text: )
|—————Node:compound_statement Text: {
        LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
    }
|——————Node:{ Text: {
|——————Node:expression_statement Text: LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i]);
|———————Node:call_expression Text: LOG_INFO("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i])
|————————Node:identifier Text: LOG_INFO
|————————Node:argument_list Text: ("tx word%d = 0x%x\r\n", i, txFrame.dataWord[i])
|—————————Node:( Text: (
|—————————Node:string_literal Text: "tx word%d = 0x%x\r\n"
|——————————Node:" Text: "
|——————————Node:string_content Text: tx word%d = 0x%x
|——————————Node:escape_sequence Text: \r
|——————————Node:escape_sequence Text: \n
|——————————Node:" Text: "
|—————————Node:, Text: ,
|—————————Node:identifier Text: i
|—————————Node:, Text: ,
|—————————Node:subscript_expression Text: txFrame.dataWord[i]
|——————————Node:field_expression Text: txFrame.dataWord
|———————————Node:identifier Text: txFrame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: dataWord
|——————————Node:[ Text: [
|——————————Node:identifier Text: i
|——————————Node:] Text: ]
|—————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:} Text: }
|————Node:preproc_else Text: #else
    LOG_INFO("tx ID = 0x%x\r\n", id);
    LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0);
    LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: LOG_INFO("tx ID = 0x%x\r\n", id);
|——————Node:call_expression Text: LOG_INFO("tx ID = 0x%x\r\n", id)
|———————Node:identifier Text: LOG_INFO
|———————Node:argument_list Text: ("tx ID = 0x%x\r\n", id)
|————————Node:( Text: (
|————————Node:string_literal Text: "tx ID = 0x%x\r\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: tx ID = 0x%x
|—————————Node:escape_sequence Text: \r
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:identifier Text: id
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0);
|——————Node:call_expression Text: LOG_INFO("tx word0 = 0x%x\r\n", txFrame.dataWord0)
|———————Node:identifier Text: LOG_INFO
|———————Node:argument_list Text: ("tx word0 = 0x%x\r\n", txFrame.dataWord0)
|————————Node:( Text: (
|————————Node:string_literal Text: "tx word0 = 0x%x\r\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: tx word0 = 0x%x
|—————————Node:escape_sequence Text: \r
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:field_expression Text: txFrame.dataWord0
|—————————Node:identifier Text: txFrame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: dataWord0
|————————Node:) Text: )
|——————Node:; Text: ;
|—————Node:expression_statement Text: LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1);
|——————Node:call_expression Text: LOG_INFO("tx word1 = 0x%x\r\n", txFrame.dataWord1)
|———————Node:identifier Text: LOG_INFO
|———————Node:argument_list Text: ("tx word1 = 0x%x\r\n", txFrame.dataWord1)
|————————Node:( Text: (
|————————Node:string_literal Text: "tx word1 = 0x%x\r\n"
|—————————Node:" Text: "
|—————————Node:string_content Text: tx word1 = 0x%x
|—————————Node:escape_sequence Text: \r
|—————————Node:escape_sequence Text: \n
|—————————Node:" Text: "
|————————Node:, Text: ,
|————————Node:field_expression Text: txFrame.dataWord1
|—————————Node:identifier Text: txFrame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: dataWord1
|————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:comment
|———Node:expression_statement Text: txXfer.mbIdx = (uint8_t)TX_MESSAGE_BUFFER_NUM;
|————Node:assignment_expression Text: txXfer.mbIdx = (uint8_t)TX_MESSAGE_BUFFER_NUM
|—————Node:field_expression Text: txXfer.mbIdx
|——————Node:identifier Text: txXfer
|——————Node:. Text: .
|——————Node:field_identifier Text: mbIdx
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint8_t)TX_MESSAGE_BUFFER_NUM
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint8_t
|———————Node:primitive_type Text: uint8_t
|——————Node:) Text: )
|——————Node:identifier Text: TX_MESSAGE_BUFFER_NUM
|————Node:; Text: ;
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
    txXfer.framefd = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#else
    txXfer.frame = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: txXfer.framefd = &txFrame;
|—————Node:assignment_expression Text: txXfer.framefd = &txFrame
|——————Node:field_expression Text: txXfer.framefd
|———————Node:identifier Text: txXfer
|———————Node:. Text: .
|———————Node:field_identifier Text: framefd
|——————Node:= Text: =
|——————Node:pointer_expression Text: &txFrame
|———————Node:& Text: &
|———————Node:identifier Text: txFrame
|—————Node:; Text: ;
|————Node:expression_statement Text: txStatus = (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
|—————Node:assignment_expression Text: txStatus = (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|——————Node:identifier Text: txStatus
|——————Node:= Text: =
|——————Node:cast_expression Text: (uint32_t)FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|———————Node:( Text: (
|———————Node:type_descriptor Text: uint32_t
|————————Node:primitive_type Text: uint32_t
|———————Node:) Text: )
|———————Node:call_expression Text: FLEXCAN_TransferFDSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|————————Node:identifier Text: FLEXCAN_TransferFDSendNonBlocking
|————————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &txXfer)
|—————————Node:( Text: (
|—————————Node:identifier Text: EXAMPLE_CAN
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &flexcanHandle
|——————————Node:& Text: &
|——————————Node:identifier Text: flexcanHandle
|—————————Node:, Text: ,
|—————————Node:pointer_expression Text: &txXfer
|——————————Node:& Text: &
|——————————Node:identifier Text: txXfer
|—————————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
    txXfer.frame = &txFrame;
    txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: txXfer.frame = &txFrame;
|——————Node:assignment_expression Text: txXfer.frame = &txFrame
|———————Node:field_expression Text: txXfer.frame
|————————Node:identifier Text: txXfer
|————————Node:. Text: .
|————————Node:field_identifier Text: frame
|———————Node:= Text: =
|———————Node:pointer_expression Text: &txFrame
|————————Node:& Text: &
|————————Node:identifier Text: txFrame
|——————Node:; Text: ;
|—————Node:expression_statement Text: txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer);
|——————Node:assignment_expression Text: txStatus = (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|———————Node:identifier Text: txStatus
|———————Node:= Text: =
|———————Node:cast_expression Text: (uint32_t)FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint32_t
|—————————Node:primitive_type Text: uint32_t
|————————Node:) Text: )
|————————Node:call_expression Text: FLEXCAN_TransferSendNonBlocking(EXAMPLE_CAN, &flexcanHandle, &txXfer)
|—————————Node:identifier Text: FLEXCAN_TransferSendNonBlocking
|—————————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &txXfer)
|——————————Node:( Text: (
|——————————Node:identifier Text: EXAMPLE_CAN
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &flexcanHandle
|———————————Node:& Text: &
|———————————Node:identifier Text: flexcanHandle
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &txXfer
|———————————Node:& Text: &
|———————————Node:identifier Text: txXfer
|——————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:return_statement Text: return txStatus;
|————Node:return Text: return
|————Node:identifier Text: txStatus
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: static uint32_t endianSwap4bytes(uint32_t var)
{

  uint8_t *bytePtr = (uint8_t*)&var;
  uint32_t swappedVar = (uint32_t)((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]));
  
  return (swappedVar);
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: uint32_t
|——Node:function_declarator Text: endianSwap4bytes(uint32_t var)
|———Node:identifier Text: endianSwap4bytes
|———Node:parameter_list Text: (uint32_t var)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t var
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: var
|————Node:) Text: )
|——Node:compound_statement Text: {

  uint8_t *bytePtr = (uint8_t*)&var;
  uint32_t swappedVar = (uint32_t)((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]));
  
  return (swappedVar);
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t *bytePtr = (uint8_t*)&var;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: *bytePtr = (uint8_t*)&var
|—————Node:pointer_declarator Text: *bytePtr
|——————Node:* Text: *
|——————Node:identifier Text: bytePtr
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint8_t*)&var
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint8_t*
|———————Node:primitive_type Text: uint8_t
|———————Node:abstract_pointer_declarator Text: *
|————————Node:* Text: *
|——————Node:) Text: )
|——————Node:pointer_expression Text: &var
|———————Node:& Text: &
|———————Node:identifier Text: var
|————Node:; Text: ;
|———Node:declaration Text: uint32_t swappedVar = (uint32_t)((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]));
|————Node:primitive_type Text: uint32_t
|————Node:init_declarator Text: swappedVar = (uint32_t)((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]))
|—————Node:identifier Text: swappedVar
|—————Node:= Text: =
|—————Node:cast_expression Text: (uint32_t)((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]))
|——————Node:( Text: (
|——————Node:type_descriptor Text: uint32_t
|———————Node:primitive_type Text: uint32_t
|——————Node:) Text: )
|——————Node:parenthesized_expression Text: ((bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3]))
|———————Node:( Text: (
|———————Node:binary_expression Text: (bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8) | 
                                   (bytePtr[3])
|————————Node:binary_expression Text: (bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16) | 
                                   (bytePtr[2] << 8)
|—————————Node:binary_expression Text: (bytePtr[0] << 24) | 
                                   (bytePtr[1] << 16)
|——————————Node:parenthesized_expression Text: (bytePtr[0] << 24)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: bytePtr[0] << 24
|————————————Node:subscript_expression Text: bytePtr[0]
|—————————————Node:identifier Text: bytePtr
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 0
|—————————————Node:] Text: ]
|————————————Node:<< Text: <<
|————————————Node:number_literal Text: 24
|———————————Node:) Text: )
|——————————Node:| Text: |
|——————————Node:parenthesized_expression Text: (bytePtr[1] << 16)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: bytePtr[1] << 16
|————————————Node:subscript_expression Text: bytePtr[1]
|—————————————Node:identifier Text: bytePtr
|—————————————Node:[ Text: [
|—————————————Node:number_literal Text: 1
|—————————————Node:] Text: ]
|————————————Node:<< Text: <<
|————————————Node:number_literal Text: 16
|———————————Node:) Text: )
|—————————Node:| Text: |
|—————————Node:parenthesized_expression Text: (bytePtr[2] << 8)
|——————————Node:( Text: (
|——————————Node:binary_expression Text: bytePtr[2] << 8
|———————————Node:subscript_expression Text: bytePtr[2]
|————————————Node:identifier Text: bytePtr
|————————————Node:[ Text: [
|————————————Node:number_literal Text: 2
|————————————Node:] Text: ]
|———————————Node:<< Text: <<
|———————————Node:number_literal Text: 8
|——————————Node:) Text: )
|————————Node:| Text: |
|————————Node:parenthesized_expression Text: (bytePtr[3])
|—————————Node:( Text: (
|—————————Node:subscript_expression Text: bytePtr[3]
|——————————Node:identifier Text: bytePtr
|——————————Node:[ Text: [
|——————————Node:number_literal Text: 3
|——————————Node:] Text: ]
|—————————Node:) Text: )
|———————Node:) Text: )
|————Node:; Text: ;
|———Node:return_statement Text: return (swappedVar);
|————Node:return Text: return
|————Node:parenthesized_expression Text: (swappedVar)
|—————Node:( Text: (
|—————Node:identifier Text: swappedVar
|—————Node:) Text: )
|————Node:; Text: ;
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: static void endianSwapBuffer(uint8_t * dBuff, uint8_t * sBuff, uint8_t length)
{
  uint8_t ctr = 0;
  uint8_t byteCtr = 0;
  length = length / 4;
  
  for(ctr = 0; ctr < length; ctr++)
  {
    dBuff[0 + byteCtr] = sBuff[3 + byteCtr];
    dBuff[1 + byteCtr] = sBuff[2 + byteCtr];
    dBuff[2 + byteCtr] = sBuff[1 + byteCtr];
    dBuff[3 + byteCtr] = sBuff[0 + byteCtr]; 
    byteCtr = byteCtr + 4;
  }
  
}
|——Node:storage_class_specifier Text: static
|———Node:static Text: static
|——Node:primitive_type Text: void
|——Node:function_declarator Text: endianSwapBuffer(uint8_t * dBuff, uint8_t * sBuff, uint8_t length)
|———Node:identifier Text: endianSwapBuffer
|———Node:parameter_list Text: (uint8_t * dBuff, uint8_t * sBuff, uint8_t length)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint8_t * dBuff
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: * dBuff
|——————Node:* Text: *
|——————Node:identifier Text: dBuff
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t * sBuff
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: * sBuff
|——————Node:* Text: *
|——————Node:identifier Text: sBuff
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t length
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: length
|————Node:) Text: )
|——Node:compound_statement Text: {
  uint8_t ctr = 0;
  uint8_t byteCtr = 0;
  length = length / 4;
  
  for(ctr = 0; ctr < length; ctr++)
  {
    dBuff[0 + byteCtr] = sBuff[3 + byteCtr];
    dBuff[1 + byteCtr] = sBuff[2 + byteCtr];
    dBuff[2 + byteCtr] = sBuff[1 + byteCtr];
    dBuff[3 + byteCtr] = sBuff[0 + byteCtr]; 
    byteCtr = byteCtr + 4;
  }
  
}
|———Node:{ Text: {
|———Node:declaration Text: uint8_t ctr = 0;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: ctr = 0
|—————Node:identifier Text: ctr
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:declaration Text: uint8_t byteCtr = 0;
|————Node:primitive_type Text: uint8_t
|————Node:init_declarator Text: byteCtr = 0
|—————Node:identifier Text: byteCtr
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|———Node:expression_statement Text: length = length / 4;
|————Node:assignment_expression Text: length = length / 4
|—————Node:identifier Text: length
|—————Node:= Text: =
|—————Node:binary_expression Text: length / 4
|——————Node:identifier Text: length
|——————Node:/ Text: /
|——————Node:number_literal Text: 4
|————Node:; Text: ;
|———Node:for_statement Text: for(ctr = 0; ctr < length; ctr++)
  {
    dBuff[0 + byteCtr] = sBuff[3 + byteCtr];
    dBuff[1 + byteCtr] = sBuff[2 + byteCtr];
    dBuff[2 + byteCtr] = sBuff[1 + byteCtr];
    dBuff[3 + byteCtr] = sBuff[0 + byteCtr]; 
    byteCtr = byteCtr + 4;
  }
|————Node:for Text: for
|————Node:( Text: (
|————Node:assignment_expression Text: ctr = 0
|—————Node:identifier Text: ctr
|—————Node:= Text: =
|—————Node:number_literal Text: 0
|————Node:; Text: ;
|————Node:binary_expression Text: ctr < length
|—————Node:identifier Text: ctr
|—————Node:< Text: <
|—————Node:identifier Text: length
|————Node:; Text: ;
|————Node:update_expression Text: ctr++
|—————Node:identifier Text: ctr
|—————Node:++ Text: ++
|————Node:) Text: )
|————Node:compound_statement Text: {
    dBuff[0 + byteCtr] = sBuff[3 + byteCtr];
    dBuff[1 + byteCtr] = sBuff[2 + byteCtr];
    dBuff[2 + byteCtr] = sBuff[1 + byteCtr];
    dBuff[3 + byteCtr] = sBuff[0 + byteCtr]; 
    byteCtr = byteCtr + 4;
  }
|—————Node:{ Text: {
|—————Node:expression_statement Text: dBuff[0 + byteCtr] = sBuff[3 + byteCtr];
|——————Node:assignment_expression Text: dBuff[0 + byteCtr] = sBuff[3 + byteCtr]
|———————Node:subscript_expression Text: dBuff[0 + byteCtr]
|————————Node:identifier Text: dBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 0 + byteCtr
|—————————Node:number_literal Text: 0
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: sBuff[3 + byteCtr]
|————————Node:identifier Text: sBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 3 + byteCtr
|—————————Node:number_literal Text: 3
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: dBuff[1 + byteCtr] = sBuff[2 + byteCtr];
|——————Node:assignment_expression Text: dBuff[1 + byteCtr] = sBuff[2 + byteCtr]
|———————Node:subscript_expression Text: dBuff[1 + byteCtr]
|————————Node:identifier Text: dBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 1 + byteCtr
|—————————Node:number_literal Text: 1
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: sBuff[2 + byteCtr]
|————————Node:identifier Text: sBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 2 + byteCtr
|—————————Node:number_literal Text: 2
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: dBuff[2 + byteCtr] = sBuff[1 + byteCtr];
|——————Node:assignment_expression Text: dBuff[2 + byteCtr] = sBuff[1 + byteCtr]
|———————Node:subscript_expression Text: dBuff[2 + byteCtr]
|————————Node:identifier Text: dBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 2 + byteCtr
|—————————Node:number_literal Text: 2
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: sBuff[1 + byteCtr]
|————————Node:identifier Text: sBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 1 + byteCtr
|—————————Node:number_literal Text: 1
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: dBuff[3 + byteCtr] = sBuff[0 + byteCtr];
|——————Node:assignment_expression Text: dBuff[3 + byteCtr] = sBuff[0 + byteCtr]
|———————Node:subscript_expression Text: dBuff[3 + byteCtr]
|————————Node:identifier Text: dBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 3 + byteCtr
|—————————Node:number_literal Text: 3
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|———————Node:= Text: =
|———————Node:subscript_expression Text: sBuff[0 + byteCtr]
|————————Node:identifier Text: sBuff
|————————Node:[ Text: [
|————————Node:binary_expression Text: 0 + byteCtr
|—————————Node:number_literal Text: 0
|—————————Node:+ Text: +
|—————————Node:identifier Text: byteCtr
|————————Node:] Text: ]
|——————Node:; Text: ;
|—————Node:expression_statement Text: byteCtr = byteCtr + 4;
|——————Node:assignment_expression Text: byteCtr = byteCtr + 4
|———————Node:identifier Text: byteCtr
|———————Node:= Text: =
|———————Node:binary_expression Text: byteCtr + 4
|————————Node:identifier Text: byteCtr
|————————Node:+ Text: +
|————————Node:number_literal Text: 4
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
|—Node:comment
|—Node:function_definition Text: void APPUSBTinCanRxCallback(uint32_t id, uint8_t extId, uint8_t *buf, 
                            uint8_t dlc, uint32_t lenInBytes)
{
#if (defined(USE_CANFD) && USE_CANFD)
	usb_to_can_fd_interfacez(id, extId, buf, dlc, lenInBytes);
#else
  usb_to_can_interfacez(id, extId, buf, dlc);
#endif
  
  
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: APPUSBTinCanRxCallback(uint32_t id, uint8_t extId, uint8_t *buf, 
                            uint8_t dlc, uint32_t lenInBytes)
|———Node:identifier Text: APPUSBTinCanRxCallback
|———Node:parameter_list Text: (uint32_t id, uint8_t extId, uint8_t *buf, 
                            uint8_t dlc, uint32_t lenInBytes)
|————Node:( Text: (
|————Node:parameter_declaration Text: uint32_t id
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: id
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t extId
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: extId
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t *buf
|—————Node:primitive_type Text: uint8_t
|—————Node:pointer_declarator Text: *buf
|——————Node:* Text: *
|——————Node:identifier Text: buf
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint8_t dlc
|—————Node:primitive_type Text: uint8_t
|—————Node:identifier Text: dlc
|————Node:, Text: ,
|————Node:parameter_declaration Text: uint32_t lenInBytes
|—————Node:primitive_type Text: uint32_t
|—————Node:identifier Text: lenInBytes
|————Node:) Text: )
|——Node:compound_statement Text: {
#if (defined(USE_CANFD) && USE_CANFD)
	usb_to_can_fd_interfacez(id, extId, buf, dlc, lenInBytes);
#else
  usb_to_can_interfacez(id, extId, buf, dlc);
#endif
  
  
}
|———Node:{ Text: {
|———Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
	usb_to_can_fd_interfacez(id, extId, buf, dlc, lenInBytes);
#else
  usb_to_can_interfacez(id, extId, buf, dlc);
#endif
|————Node:#if Text: #if
|————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————Node:( Text: (
|—————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————Node:preproc_defined Text: defined(USE_CANFD)
|———————Node:defined Text: defined
|———————Node:( Text: (
|———————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:&& Text: &&
|——————Node:identifier Text: USE_CANFD
|—————Node:) Text: )
|————Node:
 Text: 

|————Node:expression_statement Text: usb_to_can_fd_interfacez(id, extId, buf, dlc, lenInBytes);
|—————Node:call_expression Text: usb_to_can_fd_interfacez(id, extId, buf, dlc, lenInBytes)
|——————Node:identifier Text: usb_to_can_fd_interfacez
|——————Node:argument_list Text: (id, extId, buf, dlc, lenInBytes)
|———————Node:( Text: (
|———————Node:identifier Text: id
|———————Node:, Text: ,
|———————Node:identifier Text: extId
|———————Node:, Text: ,
|———————Node:identifier Text: buf
|———————Node:, Text: ,
|———————Node:identifier Text: dlc
|———————Node:, Text: ,
|———————Node:identifier Text: lenInBytes
|———————Node:) Text: )
|—————Node:; Text: ;
|————Node:preproc_else Text: #else
  usb_to_can_interfacez(id, extId, buf, dlc);
|—————Node:#else Text: #else
|—————Node:expression_statement Text: usb_to_can_interfacez(id, extId, buf, dlc);
|——————Node:call_expression Text: usb_to_can_interfacez(id, extId, buf, dlc)
|———————Node:identifier Text: usb_to_can_interfacez
|———————Node:argument_list Text: (id, extId, buf, dlc)
|————————Node:( Text: (
|————————Node:identifier Text: id
|————————Node:, Text: ,
|————————Node:identifier Text: extId
|————————Node:, Text: ,
|————————Node:identifier Text: buf
|————————Node:, Text: ,
|————————Node:identifier Text: dlc
|————————Node:) Text: )
|——————Node:; Text: ;
|————Node:#endif Text: #endif
|———Node:} Text: }
|—Node:function_definition Text: void AppCANRequestRxTask(void)
{

	if(rxComplete == true)
	{
	    rxComplete = false;

	    /* Since the adapter does not have an active CAN ID any transmission will also be detected as a reception
	     * the next condition will help to filter messages sent by it self and do not reflect it on the GUI. */
	    if(txFrame.id != rxFrame.id)
	    {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }

		/* Start receive data through Rx Message Buffer. */
		rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
		rxXfer.framefd = &rxFrame;
		(void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif

		txFrame.id = 0x000;
	}
}
|——Node:primitive_type Text: void
|——Node:function_declarator Text: AppCANRequestRxTask(void)
|———Node:identifier Text: AppCANRequestRxTask
|———Node:parameter_list Text: (void)
|————Node:( Text: (
|————Node:parameter_declaration Text: void
|—————Node:primitive_type Text: void
|————Node:) Text: )
|——Node:compound_statement Text: {

	if(rxComplete == true)
	{
	    rxComplete = false;

	    /* Since the adapter does not have an active CAN ID any transmission will also be detected as a reception
	     * the next condition will help to filter messages sent by it self and do not reflect it on the GUI. */
	    if(txFrame.id != rxFrame.id)
	    {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }

		/* Start receive data through Rx Message Buffer. */
		rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
		rxXfer.framefd = &rxFrame;
		(void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif

		txFrame.id = 0x000;
	}
}
|———Node:{ Text: {
|———Node:if_statement Text: if(rxComplete == true)
	{
	    rxComplete = false;

	    /* Since the adapter does not have an active CAN ID any transmission will also be detected as a reception
	     * the next condition will help to filter messages sent by it self and do not reflect it on the GUI. */
	    if(txFrame.id != rxFrame.id)
	    {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }

		/* Start receive data through Rx Message Buffer. */
		rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
		rxXfer.framefd = &rxFrame;
		(void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif

		txFrame.id = 0x000;
	}
|————Node:if Text: if
|————Node:parenthesized_expression Text: (rxComplete == true)
|—————Node:( Text: (
|—————Node:binary_expression Text: rxComplete == true
|——————Node:identifier Text: rxComplete
|——————Node:== Text: ==
|——————Node:true Text: true
|—————Node:) Text: )
|————Node:compound_statement Text: {
	    rxComplete = false;

	    /* Since the adapter does not have an active CAN ID any transmission will also be detected as a reception
	     * the next condition will help to filter messages sent by it self and do not reflect it on the GUI. */
	    if(txFrame.id != rxFrame.id)
	    {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }

		/* Start receive data through Rx Message Buffer. */
		rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM;
#if (defined(USE_CANFD) && USE_CANFD)
		rxXfer.framefd = &rxFrame;
		(void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif

		txFrame.id = 0x000;
	}
|—————Node:{ Text: {
|—————Node:expression_statement Text: rxComplete = false;
|——————Node:assignment_expression Text: rxComplete = false
|———————Node:identifier Text: rxComplete
|———————Node:= Text: =
|———————Node:false Text: false
|——————Node:; Text: ;
|—————Node:comment
|—————Node:if_statement Text: if(txFrame.id != rxFrame.id)
	    {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }
|——————Node:if Text: if
|——————Node:parenthesized_expression Text: (txFrame.id != rxFrame.id)
|———————Node:( Text: (
|———————Node:binary_expression Text: txFrame.id != rxFrame.id
|————————Node:field_expression Text: txFrame.id
|—————————Node:identifier Text: txFrame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: id
|————————Node:!= Text: !=
|————————Node:field_expression Text: rxFrame.id
|—————————Node:identifier Text: rxFrame
|—————————Node:. Text: .
|—————————Node:field_identifier Text: id
|———————Node:) Text: )
|——————Node:compound_statement Text: {

			PRINTF("Reception complete!\r\n\r\n");
#if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif

			/* Call USBTin function to process the message  */
			APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
	    }
|———————Node:{ Text: {
|———————Node:expression_statement Text: PRINTF("Reception complete!\r\n\r\n");
|————————Node:call_expression Text: PRINTF("Reception complete!\r\n\r\n")
|—————————Node:identifier Text: PRINTF
|—————————Node:argument_list Text: ("Reception complete!\r\n\r\n")
|——————————Node:( Text: (
|——————————Node:string_literal Text: "Reception complete!\r\n\r\n"
|———————————Node:" Text: "
|———————————Node:string_content Text: Reception complete!
|———————————Node:escape_sequence Text: \r
|———————————Node:escape_sequence Text: \n
|———————————Node:escape_sequence Text: \r
|———————————Node:escape_sequence Text: \n
|———————————Node:" Text: "
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
#else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
#endif
|————————Node:#if Text: #if
|————————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|—————————Node:( Text: (
|—————————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|——————————Node:preproc_defined Text: defined(USE_CANFD)
|———————————Node:defined Text: defined
|———————————Node:( Text: (
|———————————Node:identifier Text: USE_CANFD
|———————————Node:) Text: )
|——————————Node:&& Text: &&
|——————————Node:identifier Text: USE_CANFD
|—————————Node:) Text: )
|————————Node:
 Text: 

|————————Node:comment
|————————Node:expression_statement Text: endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length));
|—————————Node:call_expression Text: endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length))
|——————————Node:identifier Text: endianSwapBuffer
|——————————Node:argument_list Text: ((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord[0]), CANFD_DLC_TO_BYTE(rxFrame.length))
|———————————Node:( Text: (
|———————————Node:cast_expression Text: (uint8_t *)swapRxData
|————————————Node:( Text: (
|————————————Node:type_descriptor Text: uint8_t *
|—————————————Node:primitive_type Text: uint8_t
|—————————————Node:abstract_pointer_declarator Text: *
|——————————————Node:* Text: *
|————————————Node:) Text: )
|————————————Node:identifier Text: swapRxData
|———————————Node:, Text: ,
|———————————Node:cast_expression Text: (uint8_t *)&(rxFrame.dataWord[0])
|————————————Node:( Text: (
|————————————Node:type_descriptor Text: uint8_t *
|—————————————Node:primitive_type Text: uint8_t
|—————————————Node:abstract_pointer_declarator Text: *
|——————————————Node:* Text: *
|————————————Node:) Text: )
|————————————Node:pointer_expression Text: &(rxFrame.dataWord[0])
|—————————————Node:& Text: &
|—————————————Node:parenthesized_expression Text: (rxFrame.dataWord[0])
|——————————————Node:( Text: (
|——————————————Node:subscript_expression Text: rxFrame.dataWord[0]
|———————————————Node:field_expression Text: rxFrame.dataWord
|————————————————Node:identifier Text: rxFrame
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: dataWord
|———————————————Node:[ Text: [
|———————————————Node:number_literal Text: 0
|———————————————Node:] Text: ]
|——————————————Node:) Text: )
|———————————Node:, Text: ,
|———————————Node:call_expression Text: CANFD_DLC_TO_BYTE(rxFrame.length)
|————————————Node:identifier Text: CANFD_DLC_TO_BYTE
|————————————Node:argument_list Text: (rxFrame.length)
|—————————————Node:( Text: (
|—————————————Node:field_expression Text: rxFrame.length
|——————————————Node:identifier Text: rxFrame
|——————————————Node:. Text: .
|——————————————Node:field_identifier Text: length
|—————————————Node:) Text: )
|———————————Node:) Text: )
|—————————Node:; Text: ;
|————————Node:preproc_else Text: #else
			/* Copy the received message doing a 8byte swap to fix endiness */
			endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
|—————————Node:#else Text: #else
|—————————Node:comment
|—————————Node:expression_statement Text: endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length);
|——————————Node:call_expression Text: endianSwapBuffer((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length)
|———————————Node:identifier Text: endianSwapBuffer
|———————————Node:argument_list Text: ((uint8_t *)swapRxData, (uint8_t *)&(rxFrame.dataWord0), rxFrame.length)
|————————————Node:( Text: (
|————————————Node:cast_expression Text: (uint8_t *)swapRxData
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: uint8_t *
|——————————————Node:primitive_type Text: uint8_t
|——————————————Node:abstract_pointer_declarator Text: *
|———————————————Node:* Text: *
|—————————————Node:) Text: )
|—————————————Node:identifier Text: swapRxData
|————————————Node:, Text: ,
|————————————Node:cast_expression Text: (uint8_t *)&(rxFrame.dataWord0)
|—————————————Node:( Text: (
|—————————————Node:type_descriptor Text: uint8_t *
|——————————————Node:primitive_type Text: uint8_t
|——————————————Node:abstract_pointer_declarator Text: *
|———————————————Node:* Text: *
|—————————————Node:) Text: )
|—————————————Node:pointer_expression Text: &(rxFrame.dataWord0)
|——————————————Node:& Text: &
|——————————————Node:parenthesized_expression Text: (rxFrame.dataWord0)
|———————————————Node:( Text: (
|———————————————Node:field_expression Text: rxFrame.dataWord0
|————————————————Node:identifier Text: rxFrame
|————————————————Node:. Text: .
|————————————————Node:field_identifier Text: dataWord0
|———————————————Node:) Text: )
|————————————Node:, Text: ,
|————————————Node:field_expression Text: rxFrame.length
|—————————————Node:identifier Text: rxFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: length
|————————————Node:) Text: )
|——————————Node:; Text: ;
|————————Node:#endif Text: #endif
|———————Node:comment
|———————Node:expression_statement Text: APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length));
|————————Node:call_expression Text: APPUSBTinCanRxCallback((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length))
|—————————Node:identifier Text: APPUSBTinCanRxCallback
|—————————Node:argument_list Text: ((rxFrame.id >> CAN_ID_STD_SHIFT), rxFrame.format, (uint8_t *)swapRxData, rxFrame.length, CANFD_DLC_TO_BYTE(rxFrame.length))
|——————————Node:( Text: (
|——————————Node:parenthesized_expression Text: (rxFrame.id >> CAN_ID_STD_SHIFT)
|———————————Node:( Text: (
|———————————Node:binary_expression Text: rxFrame.id >> CAN_ID_STD_SHIFT
|————————————Node:field_expression Text: rxFrame.id
|—————————————Node:identifier Text: rxFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: id
|————————————Node:>> Text: >>
|————————————Node:identifier Text: CAN_ID_STD_SHIFT
|———————————Node:) Text: )
|——————————Node:, Text: ,
|——————————Node:field_expression Text: rxFrame.format
|———————————Node:identifier Text: rxFrame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: format
|——————————Node:, Text: ,
|——————————Node:cast_expression Text: (uint8_t *)swapRxData
|———————————Node:( Text: (
|———————————Node:type_descriptor Text: uint8_t *
|————————————Node:primitive_type Text: uint8_t
|————————————Node:abstract_pointer_declarator Text: *
|—————————————Node:* Text: *
|———————————Node:) Text: )
|———————————Node:identifier Text: swapRxData
|——————————Node:, Text: ,
|——————————Node:field_expression Text: rxFrame.length
|———————————Node:identifier Text: rxFrame
|———————————Node:. Text: .
|———————————Node:field_identifier Text: length
|——————————Node:, Text: ,
|——————————Node:call_expression Text: CANFD_DLC_TO_BYTE(rxFrame.length)
|———————————Node:identifier Text: CANFD_DLC_TO_BYTE
|———————————Node:argument_list Text: (rxFrame.length)
|————————————Node:( Text: (
|————————————Node:field_expression Text: rxFrame.length
|—————————————Node:identifier Text: rxFrame
|—————————————Node:. Text: .
|—————————————Node:field_identifier Text: length
|————————————Node:) Text: )
|——————————Node:) Text: )
|————————Node:; Text: ;
|———————Node:} Text: }
|—————Node:comment
|—————Node:expression_statement Text: rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM;
|——————Node:assignment_expression Text: rxXfer.mbIdx = (uint8_t)RX_MESSAGE_BUFFER_NUM
|———————Node:field_expression Text: rxXfer.mbIdx
|————————Node:identifier Text: rxXfer
|————————Node:. Text: .
|————————Node:field_identifier Text: mbIdx
|———————Node:= Text: =
|———————Node:cast_expression Text: (uint8_t)RX_MESSAGE_BUFFER_NUM
|————————Node:( Text: (
|————————Node:type_descriptor Text: uint8_t
|—————————Node:primitive_type Text: uint8_t
|————————Node:) Text: )
|————————Node:identifier Text: RX_MESSAGE_BUFFER_NUM
|——————Node:; Text: ;
|—————Node:preproc_if Text: #if (defined(USE_CANFD) && USE_CANFD)
		rxXfer.framefd = &rxFrame;
		(void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
#endif
|——————Node:#if Text: #if
|——————Node:parenthesized_expression Text: (defined(USE_CANFD) && USE_CANFD)
|———————Node:( Text: (
|———————Node:binary_expression Text: defined(USE_CANFD) && USE_CANFD
|————————Node:preproc_defined Text: defined(USE_CANFD)
|—————————Node:defined Text: defined
|—————————Node:( Text: (
|—————————Node:identifier Text: USE_CANFD
|—————————Node:) Text: )
|————————Node:&& Text: &&
|————————Node:identifier Text: USE_CANFD
|———————Node:) Text: )
|——————Node:
 Text: 

|——————Node:expression_statement Text: rxXfer.framefd = &rxFrame;
|———————Node:assignment_expression Text: rxXfer.framefd = &rxFrame
|————————Node:field_expression Text: rxXfer.framefd
|—————————Node:identifier Text: rxXfer
|—————————Node:. Text: .
|—————————Node:field_identifier Text: framefd
|————————Node:= Text: =
|————————Node:pointer_expression Text: &rxFrame
|—————————Node:& Text: &
|—————————Node:identifier Text: rxFrame
|———————Node:; Text: ;
|——————Node:expression_statement Text: (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|———————Node:cast_expression Text: (void)FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|————————Node:( Text: (
|————————Node:type_descriptor Text: void
|—————————Node:primitive_type Text: void
|————————Node:) Text: )
|————————Node:call_expression Text: FLEXCAN_TransferFDReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|—————————Node:identifier Text: FLEXCAN_TransferFDReceiveNonBlocking
|—————————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|——————————Node:( Text: (
|——————————Node:identifier Text: EXAMPLE_CAN
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &flexcanHandle
|———————————Node:& Text: &
|———————————Node:identifier Text: flexcanHandle
|——————————Node:, Text: ,
|——————————Node:pointer_expression Text: &rxXfer
|———————————Node:& Text: &
|———————————Node:identifier Text: rxXfer
|——————————Node:) Text: )
|———————Node:; Text: ;
|——————Node:preproc_else Text: #else
		rxXfer.frame = &rxFrame;
		(void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|———————Node:#else Text: #else
|———————Node:expression_statement Text: rxXfer.frame = &rxFrame;
|————————Node:assignment_expression Text: rxXfer.frame = &rxFrame
|—————————Node:field_expression Text: rxXfer.frame
|——————————Node:identifier Text: rxXfer
|——————————Node:. Text: .
|——————————Node:field_identifier Text: frame
|—————————Node:= Text: =
|—————————Node:pointer_expression Text: &rxFrame
|——————————Node:& Text: &
|——————————Node:identifier Text: rxFrame
|————————Node:; Text: ;
|———————Node:expression_statement Text: (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer);
|————————Node:cast_expression Text: (void)FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|—————————Node:( Text: (
|—————————Node:type_descriptor Text: void
|——————————Node:primitive_type Text: void
|—————————Node:) Text: )
|—————————Node:call_expression Text: FLEXCAN_TransferReceiveNonBlocking(EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|——————————Node:identifier Text: FLEXCAN_TransferReceiveNonBlocking
|——————————Node:argument_list Text: (EXAMPLE_CAN, &flexcanHandle, &rxXfer)
|———————————Node:( Text: (
|———————————Node:identifier Text: EXAMPLE_CAN
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &flexcanHandle
|————————————Node:& Text: &
|————————————Node:identifier Text: flexcanHandle
|———————————Node:, Text: ,
|———————————Node:pointer_expression Text: &rxXfer
|————————————Node:& Text: &
|————————————Node:identifier Text: rxXfer
|———————————Node:) Text: )
|————————Node:; Text: ;
|——————Node:#endif Text: #endif
|—————Node:expression_statement Text: txFrame.id = 0x000;
|——————Node:assignment_expression Text: txFrame.id = 0x000
|———————Node:field_expression Text: txFrame.id
|————————Node:identifier Text: txFrame
|————————Node:. Text: .
|————————Node:field_identifier Text: id
|———————Node:= Text: =
|———————Node:number_literal Text: 0x000
|——————Node:; Text: ;
|—————Node:} Text: }
|———Node:} Text: }
